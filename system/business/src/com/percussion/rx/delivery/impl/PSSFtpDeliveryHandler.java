/*
 *     Percussion CMS
 *     Copyright (C) 1999-2020 Percussion Software, Inc.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU Affero General Public License for more details.
 *
 *     Mailing Address:
 *
 *      Percussion Software, Inc.
 *      PO Box 767
 *      Burlington, MA 01803, USA
 *      +01-781-438-9900
 *      support@percussion.com
 *      https://www.percusssion.com
 *
 *     You should have received a copy of the GNU Affero General Public License along with this program.  If not, see <https://www.gnu.org/licenses/>
 */
package com.percussion.rx.delivery.impl;

import com.jcraft.jsch.ChannelSftp;
import com.jcraft.jsch.JSchException;
import com.jcraft.jsch.SftpATTRS;
import com.jcraft.jsch.SftpException;
import com.percussion.rx.delivery.IPSDeliveryResult;
import com.percussion.rx.delivery.IPSDeliveryResult.Outcome;
import com.percussion.rx.delivery.PSDeliveryException;
import com.percussion.rx.delivery.data.PSDeliveryResult;
import com.percussion.server.PSServer;
import com.percussion.services.pubserver.IPSPubServer;
import com.percussion.services.sitemgr.IPSSite;

import java.io.File;
import java.io.InputStream;
import java.util.Collection;
import java.util.Vector;

import org.apache.commons.lang.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * Deliver files via SFtp, a secure transfer mechanism. This borrows some 
 * common code from the ftp handler.
 * 
 * @author dougrand
 */
public class PSSFtpDeliveryHandler extends PSBaseFtpDeliveryHandler
{
   /**
    * Logger.
    */
   private static Log ms_log = LogFactory.getLog(PSSFtpDeliveryHandler.class);

   /**
    * See {@link #getTimeout()}
    */
   private int m_timeout = -1;

   /**
    * See {@link #getPrivateKeyFilePath()}
    */
   private String m_privKeyFilePath;
   
   /**
    * Holds the per thread SFTP client. Initialized in {@link #commit(long)} and
    * used in <code>doDelivery</code> and <code>doRemoval</code>
    */
   protected ThreadLocal<PSSFtpClientJSch> ms_sftp = new ThreadLocal<PSSFtpClientJSch>();

   /**
    * Sets the socket timeout in milliseconds for the underlying provider.
    * @param timeout the timeout in milliseconds.
    */
   public void setTimeout(int timeout)
   {
      m_timeout = timeout;
   }
   
   /**
    * Gets the socket timeout in milliseconds for the underlying provider.
    * Defaults to <code>-1</code> if not defined.
    */
   public int getTimeout()
   {
      return m_timeout;
   }

   /**
    * Returns absolute path of the private key file generated by ssh-keygen
    * for example "/home/user/.ssh/id_dsa. 
    *
    * See http://en.wikipedia.org/wiki/Ssh-keygen for detail.
    * 
    * @return the key file path. It may be <code>null</code> if the handler
    * uses user-name / password pair to connect to SFTP server; otherwise
    * the handler uses user-name / private-key pair to connect to SFTP server.  
    */
   public String getPrivateKeyFilePath()
   {
      return m_privKeyFilePath;
   }

   /**
    * Sets the absolute path of the private key file, which is generated by ssh-keygen.
    *
    * @param privKeyFilePath - fully qualified path for private key file.
    * 
    * @see #getPrivateKeyFilePath()
    */
   public void setPrivateKeyFilePath(String privKeyFilePath)
   {
      m_privKeyFilePath = privKeyFilePath;
   }

    public static final String OPENSSH_CONFIG_FILE="config";

   /**
    * It returns the complete path to the directory
    * where the ssh keys are stored. It includes a File separator
    * 
    * @return the full path to the ssh keys directory. Never <code>null</code>
    *         or empty.
    */
   public static String getSshKeysDir()
   {
      return PSServer.getBaseConfigDir() + File.separator + "ssh-keys" + File.separator;
   }
   
   /**
    * Opens a connection and log in with the given SSH client for the 
    * supplied job ID.
    * 
    * @param ssh the SSH client, assumed not <code>null</code>.
    * @param jobId the job ID.
    * @param failAll if <code>true</code>, then all items for the current
    * job will be marked as failed if the login was unsuccessful, otherwise,
    * a {@link PSDeliveryException} will be thrown in the event of a failed
    * connection, login, or if the ftp server could not be set to binary
    * mode.
    * 
    * @return error result if there is any. It is <code>null</code> if there is
    *    no error.
    *    
    * @throws PSDeliveryException if <code>failAll</code> is
    * <code>false</code> and a connection could not be established.   
    */
   private Collection<IPSDeliveryResult> login(PSSFtpClientJSch ssh, long jobId, 
         boolean failAll, Integer timeout, Integer retries)
         throws PSDeliveryException
   {
     
      // Open connection
       synchronized (m_jobData) {
           JobData data = m_jobData.get(jobId);
           IPSSite site = data.m_site;

           SFTPLoginInfo info = new SFTPLoginInfo(m_jobData.get(jobId));

           try {

               logDebugInformation();

               // first try with the Delivery handler key
               if (!StringUtils.isBlank(getPrivateKeyFilePath())) {
                   return sshLogin(ssh, getPrivateKeyFilePath(), true, site, info, jobId, failAll, timeout, retries);
               }

               // Second, try with the site key, if any
               else if (!StringUtils.isBlank(info.privateKey)) {
                   //String filePath = PSServer.SSH_PRIVATE_KEYS_DIR;
                   String keyFilePath = getSshKeysDir() + info.privateKey;

                   return sshLogin(ssh, keyFilePath, false, site, info, jobId, failAll, timeout, retries);
               }

               // no key, we go with the password
               else {
                   ssh.login(info.ipAddress, info.port, info.userName,
                           info.password, timeout, retries);
               }

               if (m_umask != null)
                   ssh.setUmask(m_umask);
           } catch (Exception e) {
               String errorMsg = "Problem connecting to server, host="
                       + site.getIpAddress() + ", port=" + site.getPort()
                       + ", user=" + site.getUserId() + ". The underlying error is: ";

               // repeat the logic to see the cause of the failure
               if (!StringUtils.isBlank(getPrivateKeyFilePath())) {
                   errorMsg += "Failure with the private key of the Delivery Handler. \n " + e.getLocalizedMessage();
               }
               else if(!StringUtils.isBlank(site.getPrivateKey()))
               {
                   errorMsg += "Failure with the private key of the Site. \n " + e.getLocalizedMessage();
               }
               else
               {
                   errorMsg += "Failure with the password provided. \n " + e.getLocalizedMessage();
               }

               return handleLoginError(jobId, errorMsg, failAll);
           }
       }
      return null;
   }

   private Collection<IPSDeliveryResult> handleFailLoginException(long jobId,
         boolean failAll, IPSSite site, Exception e) throws PSDeliveryException
   {
      String errorMsg = "Problem connecting to server, host="
            + site.getIpAddress() + ", port=" + site.getPort()
            + ", user=" + site.getUserId() + ". The underline error is: "; 
      
      // repeat the logic to see the cause of the failure
      if (!StringUtils.isBlank(getPrivateKeyFilePath())) {
         errorMsg += "Failure with the private key of the Delivery Handler. \n " + e.getLocalizedMessage();
      }
      else if(!StringUtils.isBlank(site.getPrivateKey()))
      {
         errorMsg += "Failure with the private key of the Site. \n " + e.getLocalizedMessage();
      }
      else 
      {
         errorMsg += "Failure with the password provided. \n " + e.getLocalizedMessage();
      }

      return handleLoginError(jobId, errorMsg, failAll);
   }
   
   private Collection<IPSDeliveryResult> sshLogin(PSSFtpClientJSch ssh, String keyFilePath,
         boolean keyFromDeliveryHandler, IPSSite site, SFTPLoginInfo info, long jobId,
         boolean failAll, Integer timeout, Integer retries) throws PSDeliveryException, JSchException
   {
      if (timeout == null) {
         timeout = m_timeout;
      }
    
      // check if the file exists
      File keyFile = new File(keyFilePath);
      if(keyFile.exists())
      {
         ssh.loginKeyExchange(info.ipAddress, info.port, info.userName,
               keyFilePath, timeout, retries);
         
         return null;
      }
      else
      {
         String errorMsg = (keyFromDeliveryHandler)
               ? "Problem connecting to server, host=" + info.ipAddress
                     + ", port=" + info.port + ", user="
                     + info.userName
                     + ". The underline error is: The key file '" + keyFilePath
                     + "' from the Delivery Handler instance does not exist."
               : "Problem connecting to server, host=" + info.ipAddress
                     + ", port=" + info.port + ", user="
                     + info.userName
                     + ". The underline error is: The key file '" + keyFilePath
                     + "' from the site '" + site.getName()
                     + "' does not exist.";
         return handleLoginError(jobId, errorMsg, failAll);
      }
   }
   
   /**
    * Logout the FTP client and closing the given SSH client.
    * @param ssh the SSH client, assumed not <code>null</code>.
    */
   private void logout(PSSFtpClientJSch ssh)
   {
      try
      {
         if (ssh.isAlive())
            ssh.logoff();
      }
      catch (Exception e)
      {
         ms_log.warn("Failed logoff: ", e);
      }
      finally
      {
         ms_sftp.remove();
      }
   }
   
   /*
    * (non-Javadoc)
    * @see com.percussion.rx.delivery.impl.PSBaseDeliveryHandler#beginCommit(long)
    */
   protected Collection<IPSDeliveryResult> prepareForDelivery(long jobId) throws PSDeliveryException
   {
      // initialize data 
      getSFtpClient();
      
      return super.prepareForDelivery(jobId);
   }

   /**
    * Search up the paths until we find one and start creating the directories.
    * 
    * @param sftp the SFTP client, assumed never <code>null</code>.
    * @param dir the directory, assumed never <code>null</code>.
    * 
    * @throws RuntimeException if an error occurs.
    */
   private void makeDirectories(PSSFtpClientJSch sftp, File dir)
   {
      String path = canonicalPath(dir.toString());
      try
      {
      if (! sftp.mkdirs(path))
      {
         String errMsg = "Unable to create directory: " + path;
         ms_log.error(errMsg); 
         throw new RuntimeException(errMsg);
      }
      }
      catch (Exception e)
      {
         String errMsg = "Unable to create directory: " + path;
         ms_log.error(errMsg, e);
         errMsg = errMsg + ". The underlying error is: " + e.getMessage();
         throw new RuntimeException(errMsg);
      }
   }

   @Override
   protected IPSDeliveryResult removeFileOrDir(Item item, long jobId, String location, boolean isFile)
   {
      PSSFtpClientJSch sftp = ms_sftp.get();

      String cwd = null;
      try
      {
         cwd = getRootLocation(jobId, sftp);

         // Put location in Unix path format
         File file = new File(cwd, location);
         String filePath = canonicalPath(file.getAbsolutePath());
         
         SftpATTRS attrs = sftp.getFileAttrs(filePath);
         if (attrs == null)
         {
            // File doesn't exist
            return isFile ? getItemResult(Outcome.DELIVERED, item, jobId, null) : null;
         }
         
         sftp.cd(canonicalPath(file.getParent()));
         if (isFile)
         {
            sftp.rm(file.getName());
         }
         else
         {
            if (isEmptyDirectory(file.getName(), sftp))
               sftp.rmdir(file.getName());
         }

         return isFile ? getItemResult(Outcome.DELIVERED, item, jobId, location) : null;            
      }
      catch (Exception e)
      {
         ms_log.error("Error remove " + (isFile ? "file" : "directory") + ": \"" + location + "\"", e);
         return isFile ? getItemResult(Outcome.FAILED, item, jobId, e.getLocalizedMessage()) : null;
      }
      finally
      {
         if(!publishToAbsolutePath(m_jobData.get(jobId)))
         {
            changeDirectory(sftp, cwd);
         }
      }
   }

   /**
    * Determines if the specified directory is empty.
    * 
    * @param dir the directory in question, assumed not blank.
    * @param sftp the SFTP handler, assumed not <code>null</code>.
    * 
    * @return <code>true</code> if the directory is empty.
    * 
    * @throws SftpException if an error occurs.
    */
   @SuppressWarnings("unchecked")
   private boolean isEmptyDirectory(String dir, PSSFtpClientJSch sftp) throws SftpException
   {
      Vector<ChannelSftp.LsEntry> list = sftp.ls(dir);
      if (list.isEmpty())
         return true;
      
      // expecting "ls" command for unix returns:
      //   "."  - for current directory.
      //   ".." - for parent directory.
      if (list.size() != 2)
         return false;
      
      for (ChannelSftp.LsEntry entry : list)
      {
         SftpATTRS attrs = entry.getAttrs();
         if (!attrs.isDir())
            return false;
         
         String filename = entry.getFilename();
         if (! (filename.equals(".") || filename.equals("..")))
            return false;
      }
      return true; 
   }
   
   /**
    * Changes current directory to the specified location.
    * @param sftp the handler, assumed not <code>null</code>.
    * @param cwd the directory to change to, assumed not blank.
    */
   private void changeDirectory(PSSFtpClientJSch sftp, String cwd)
   {
      try
      {
         if (StringUtils.isNotBlank(cwd))
            sftp.cd(cwd);
      }
      catch (Exception e)
      {
         ms_log.error("Could not restore current working directory: " + cwd, e);
      }
   }
   
   /**
    * The m_umask property. It is default to <code>null</code> as undefined.
    * see {@link #getUmask()} for detail.
    */
   private String m_umask = null;
   
   /**
    * Gets the umask property. The umask property is used to control the
    * permission of the created files and directories. If the umask is
    * undefined, then the created file and directory permissions are controlled
    * by the configuration of the login user ID (of the SSH server). If the 
    * umask is defined, then the created file and directory permissions will be
    * modified by this delivery handler according to the specified umask.
    * See http://www.psc.edu/general/unix/umask.html for more info.
    * 
    * @return the umask property, a 3-character string of octal digits. It may
    * be <code>null</code> if undefined.
    */
   public String getUmask()
   {
      return m_umask;
   }
   
   /**
    * Sets the umask property.
    * 
    * @param umask the new umask property, must be a 3-character string of 
    *    octal digits.
    */
   public void setUmask(String umask)
   {
      if (umask != null)
         umask = umask.trim();
      
      if (! isValidUmask(umask))
      {
         ms_log.error("Failed to set umask property: \"" + umask + "\". " +
               "A valid umask property is 3-character string of octal digits." +
               "umask is undefined.");
         m_umask = null;
      }
      else
      {
         m_umask = umask;
      }
   }
   
   /**
    * Checks if the given umask is valid or not.
    * 
    * @param umask the umask in question. It must be a 3-character string of 
    *    octal digits.
    *    
    * @return <code>true</code> if the umask is valid.
    */
   public static boolean isValidUmask(String umask)
   {
      if (StringUtils.isBlank(umask) || (umask.length() != 3))
      {
         return false;
      }
      // make sure umask contains 3 octal digits
      try
      {
         Integer.parseInt(umask, 8);
      }
      catch (NumberFormatException e)
      {
         return false;
      }
      
      return true;
   }

   @Override
   protected IPSDeliveryResult deliverItem(Item item, InputStream inputStream,
         long jobId, String location)
   {
      PSSFtpClientJSch sftp = getSFtpClient();

      String cwd = null;
      try
      {
         if (!sftp.isAlive())
         {
            // sftp client is not logged in, let's try
            login(sftp, jobId, false, null, null);
         }
         
         cwd = getRootLocation(jobId, sftp);
         
         File file = new File(cwd, location);
         makeDirectories(sftp, file.getParentFile());
         String path = canonicalPath(file.getParent());
         sftp.cd(path);
         sftp.put(inputStream, file.getName());
         return new PSDeliveryResult(Outcome.DELIVERED, null, item.getId(),
               jobId, item.getReferenceId(), location.getBytes("UTF8"));
      }
      catch (Exception e)
      {
         return getItemResult(
               Outcome.FAILED, item, jobId, e.getLocalizedMessage());
      }
      finally
      {
         if(!publishToAbsolutePath(m_jobData.get(jobId)))
         {
             try {
                 changeDirectory(sftp, cwd);
             }
         catch (Exception e)
          {
              ms_log.error("Could not restore current working directory: " + cwd,
                      e);
          }
         }
      }
   }

   @Override
   public Collection<IPSDeliveryResult> doLogin(long jobId, boolean failAll, 
         Integer timeout, Integer retries)
         throws PSDeliveryException
   {
      return login(getSFtpClient(), jobId, failAll, timeout, retries);
   }

   @Override
   public void logoff()
   {
      PSSFtpClientJSch sftp = getSFtpClient();
      if (sftp.isAlive())
      {
         logout(sftp);
      }      
   }
   
   /**
    * Get the SFTP client for use in this handler.
    * 
    * @return the SFTP client, never <code>null</code>.
    */
   protected PSSFtpClientJSch getSFtpClient()
   {
      PSSFtpClientJSch rval = ms_sftp.get();
      if (rval == null)
      {
         rval = new PSSFtpClientJSch();
         ms_sftp.set(rval);
      }

       //Always Load the OpenSSH config file if present to handle changes on fly
       if (new File(getSshKeysDir() + OPENSSH_CONFIG_FILE).exists()){
           ms_log.info("OpenSSH configuration file detected at: " + getSshKeysDir() + OPENSSH_CONFIG_FILE + " applying configuration...");
           rval.applySSHConfig(getSshKeysDir() + OPENSSH_CONFIG_FILE);
       }
      return rval;
   }

   /**
    * Gets the root location to start in. If the server should publish relative
    * to an absolute path, the path empty. If not, the current working directory
    * from the sftp server is used, so it will be published relative to home.
    * 
    * @param jobId the id of the job
    * @param sftp {@link PSSFtpClientJSch} object, assumed not <code>null</code>
    *           and already logged in.
    * @return {@link String} never <code>null</code> but may be empty.
    * @throws {@link SftpException} if an error occurs when getting the root
    *         path from the sftp client.
    */
   private String getRootLocation(long jobId, PSSFtpClientJSch sftp)
         throws SftpException
   {
      JobData jobData = m_jobData.get(jobId);
      if (publishToAbsolutePath(jobData))
      {
         return "";
      }
      else
      {
         return sftp.pwd();
      }
   }

   @Override
   public boolean checkConnection(IPSPubServer pubServer, IPSSite site)
   {
      PSSFtpClientJSch sftp = getSFtpClient();
      SFTPLoginInfo info = new SFTPLoginInfo(pubServer, site);
      
    boolean connection = false;
    try{
      // first try with the Delivery handler key
      String keyFilePath = getPrivateKeyFilePath();
       if (!StringUtils.isBlank(keyFilePath))
       {
          File keyFile = new File(keyFilePath);
          if(keyFile.exists())
          {
             
             sftp.loginKeyExchange(info.ipAddress, info.port, info.userName,
                   keyFilePath, m_timeout, 2);

             connection = true;
          }
       } 
       // Second, try with the site key, if any
       else if(!StringUtils.isBlank(info.privateKey))
       {
          //String filePath = PSServer.SSH_PRIVATE_KEYS_DIR;
          keyFilePath = getSshKeysDir() + info.privateKey;
          sftp.loginKeyExchange(info.ipAddress, info.port, info.userName,
                   keyFilePath, m_timeout, 2);

          connection = true;
       }
       // no key, we go with the password
      else
      {
        sftp.login(info.ipAddress, info.port, info.userName,
                     info.password, m_timeout, 2);

        connection = true;
      } 

     }
     catch(Exception e)
     {
        ms_log.error("SFTP Connection Check Failed to connect",e);
        connection = false;
     }
     finally
     {
        logoff();
     }

     return connection;
   }


}
