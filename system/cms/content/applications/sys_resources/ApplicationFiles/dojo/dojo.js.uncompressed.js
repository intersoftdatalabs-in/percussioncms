if(typeof dojo == "undefined"){

// TODOC: HOW TO DOC THE BELOW?
// @global: djConfig
// summary:
//		Application code can set the global 'djConfig' prior to loading
//		the library to override certain global settings for how dojo works.
// description:  The variables that can be set are as follows:
//			- isDebug: false
//			- allowQueryConfig: false
//			- baseScriptUri: ""
//			- baseRelativePath: ""
//			- libraryScriptUri: ""
//			- iePreventClobber: false
//			- ieClobberMinimal: true
//			- locale: undefined
//			- extraLocale: undefined
//			- preventBackButtonFix: true
//			- searchIds: []
//			- parseWidgets: true
// TODOC: HOW TO DOC THESE VARIABLES?
// TODOC: IS THIS A COMPLETE LIST?
// note:
//		'djConfig' does not exist under 'dojo.*' so that it can be set before the
//		'dojo' variable exists.
// note:
//		Setting any of these variables *after* the library has loaded does nothing at all.
// TODOC: is this still true?  Release notes for 0.3 indicated they could be set after load.
//


//TODOC:  HOW TO DOC THIS?
// @global: dj_global
// summary:
//		an alias for the top-level global object in the host environment
//		(e.g., the window object in a browser).
// description:
//		Refer to 'dj_global' rather than referring to window to ensure your
//		code runs correctly in contexts other than web browsers (eg: Rhino on a server).
var dj_global = this;

//TODOC:  HOW TO DOC THIS?
// @global: dj_currentContext
// summary:
//		Private global context object. Where 'dj_global' always refers to the boot-time
//    global context, 'dj_currentContext' can be modified for temporary context shifting.
//    dojo.global() returns dj_currentContext.
// description:
//		Refer to dojo.global() rather than referring to dj_global to ensure your
//		code runs correctly in managed contexts.
var dj_currentContext = this;


// ****************************************************************
// global public utils
// TODOC: DO WE WANT TO NOTE THAT THESE ARE GLOBAL PUBLIC UTILS?
// ****************************************************************

function dj_undef(/*String*/ name, /*Object?*/ object){
	//summary: Returns true if 'name' is defined on 'object' (or globally if 'object' is null).
	//description: Note that 'defined' and 'exists' are not the same concept.
	return (typeof (object || dj_currentContext)[name] == "undefined");	// Boolean
}

// make sure djConfig is defined
if(dj_undef("djConfig", this)){
	var djConfig = {};
}

//TODOC:  HOW TO DOC THIS?
// dojo is the root variable of (almost all) our public symbols -- make sure it is defined.
if(dj_undef("dojo", this)){
	var dojo = {};
}

dojo.global = function(){
	// summary:
	//		return the current global context object
	//		(e.g., the window object in a browser).
	// description:
	//		Refer to 'dojo.global()' rather than referring to window to ensure your
	//		code runs correctly in contexts other than web browsers (eg: Rhino on a server).
	return dj_currentContext;
};

// Override locale setting, if specified
dojo.locale  = djConfig.locale;

//TODOC:  HOW TO DOC THIS?
dojo.version = {
	// summary: version number of this instance of dojo.
	major: 0, minor: 4, patch: 3, flag: "release",
	revision: Number("$Rev: 8617 $".match(/[0-9]+/)[0]),
	toString: function(){
		with(dojo.version){
			return major + "." + minor + "." + patch + flag + " (" + revision + ")";	// String
		}
	}
}

dojo.evalProp = function(/*String*/ name, /*Object*/ object, /*Boolean?*/ create){
	// summary: Returns 'object[name]'.  If not defined and 'create' is true, will return a new Object.
	// description:
	//		Returns null if 'object[name]' is not defined and 'create' is not true.
	// 		Note: 'defined' and 'exists' are not the same concept.
	if((!object)||(!name)) return undefined; // undefined
	if(!dj_undef(name, object)) return object[name]; // mixed
	return (create ? (object[name]={}) : undefined);	// mixed
}

dojo.parseObjPath = function(/*String*/ path, /*Object?*/ context, /*Boolean?*/ create){
	// summary: Parse string path to an object, and return corresponding object reference and property name.
	// description:
	//		Returns an object with two properties, 'obj' and 'prop'.
	//		'obj[prop]' is the reference indicated by 'path'.
	// path: Path to an object, in the form "A.B.C".
	// context: Object to use as root of path.  Defaults to 'dojo.global()'.
	// create: If true, Objects will be created at any point along the 'path' that is undefined.
	var object = (context || dojo.global());
	var names = path.split('.');
	var prop = names.pop();
	for (var i=0,l=names.length;i<l && object;i++){
		object = dojo.evalProp(names[i], object, create);
	}
	return {obj: object, prop: prop};	// Object: {obj: Object, prop: String}
}

dojo.evalObjPath = function(/*String*/ path, /*Boolean?*/ create){
	// summary: Return the value of object at 'path' in the global scope, without using 'eval()'.
	// path: Path to an object, in the form "A.B.C".
	// create: If true, Objects will be created at any point along the 'path' that is undefined.
	if(typeof path != "string"){
		return dojo.global();
	}
	// fast path for no periods
	if(path.indexOf('.') == -1){
		return dojo.evalProp(path, dojo.global(), create);		// mixed
	}

	//MOW: old 'with' syntax was confusing and would throw an error if parseObjPath returned null.
	var ref = dojo.parseObjPath(path, dojo.global(), create);
	if(ref){
		return dojo.evalProp(ref.prop, ref.obj, create);	// mixed
	}
	return null;
}

dojo.errorToString = function(/*Error*/ exception){
	// summary: Return an exception's 'message', 'description' or text.

	// TODO: overriding Error.prototype.toString won't accomplish this?
 	// 		... since natively generated Error objects do not always reflect such things?
	if(!dj_undef("message", exception)){
		return exception.message;		// String
	}else if(!dj_undef("description", exception)){
		return exception.description;	// String
	}else{
		return exception;				// Error
	}
}

dojo.raise = function(/*String*/ message, /*Error?*/ exception){
	// summary: Common point for raising exceptions in Dojo to enable logging.
	//	Throws an error message with text of 'exception' if provided, or
	//	rethrows exception object.

	if(exception){
		message = message + ": "+dojo.errorToString(exception);
	}else{
		message = dojo.errorToString(message);
	}

	// print the message to the user if hostenv.println is defined
	try { if(djConfig.isDebug){ dojo.hostenv.println("FATAL exception raised: "+message); } } catch (e) {}

	throw exception || Error(message);
}

//Stub functions so things don't break.
//TODOC:  HOW TO DOC THESE?
dojo.debug = function(){};
dojo.debugShallow = function(obj){};
dojo.profile = { start: function(){}, end: function(){}, stop: function(){}, dump: function(){} };

function dj_eval(/*String*/ scriptFragment){
	// summary: Perform an evaluation in the global scope.  Use this rather than calling 'eval()' directly.
	// description: Placed in a separate function to minimize size of trapped evaluation context.
	// note:
	//	 - JSC eval() takes an optional second argument which can be 'unsafe'.
	//	 - Mozilla/SpiderMonkey eval() takes an optional second argument which is the
	//  	 scope object for new symbols.
	return dj_global.eval ? dj_global.eval(scriptFragment) : eval(scriptFragment); 	// mixed
}

dojo.unimplemented = function(/*String*/ funcname, /*String?*/ extra){
	// summary: Throw an exception because some function is not implemented.
	// extra: Text to append to the exception message.
	var message = "'" + funcname + "' not implemented";
	if (extra != null) { message += " " + extra; }
	dojo.raise(message);
}

dojo.deprecated = function(/*String*/ behaviour, /*String?*/ extra, /*String?*/ removal){
	// summary: Log a debug message to indicate that a behavior has been deprecated.
	// extra: Text to append to the message.
	// removal: Text to indicate when in the future the behavior will be removed.
	var message = "DEPRECATED: " + behaviour;
	if(extra){ message += " " + extra; }
	if(removal){ message += " -- will be removed in version: " + removal; }
	dojo.debug(message);
}

dojo.render = (function(){
	//TODOC: HOW TO DOC THIS?
	// summary: Details rendering support, OS and browser of the current environment.
	// TODOC: is this something many folks will interact with?  If so, we should doc the structure created...
	function vscaffold(prefs, names){
		var tmp = {
			capable: false,
			support: {
				builtin: false,
				plugin: false
			},
			prefixes: prefs
		};
		for(var i=0; i<names.length; i++){
			tmp[names[i]] = false;
		}
		return tmp;
	}

	return {
		name: "",
		ver: dojo.version,
		os: { win: false, linux: false, osx: false },
		html: vscaffold(["html"], ["ie", "opera", "khtml", "safari", "moz"]),
		svg: vscaffold(["svg"], ["corel", "adobe", "batik"]),
		vml: vscaffold(["vml"], ["ie"]),
		swf: vscaffold(["Swf", "Flash", "Mm"], ["mm"]),
		swt: vscaffold(["Swt"], ["ibm"])
	};
})();

// ****************************************************************
// dojo.hostenv methods that must be defined in hostenv_*.js
// ****************************************************************

/**
 * The interface definining the interaction with the EcmaScript host environment.
*/

/*
 * None of these methods should ever be called directly by library users.
 * Instead public methods such as loadModule should be called instead.
 */
dojo.hostenv = (function(){
	// TODOC:  HOW TO DOC THIS?
	// summary: Provides encapsulation of behavior that changes across different 'host environments'
	//			(different browsers, server via Rhino, etc).
	// description: None of these methods should ever be called directly by library users.
	//				Use public methods such as 'loadModule' instead.

	// default configuration options
	var config = {
		isDebug: false,
		allowQueryConfig: false,
		baseScriptUri: "",
		baseRelativePath: "",
		libraryScriptUri: "",
		iePreventClobber: false,
		ieClobberMinimal: true,
		preventBackButtonFix: true,
		delayMozLoadingFix: false,
		searchIds: [],
		parseWidgets: true
	};

	if (typeof djConfig == "undefined") { djConfig = config; }
	else {
		for (var option in config) {
			if (typeof djConfig[option] == "undefined") {
				djConfig[option] = config[option];
			}
		}
	}

	return {
		name_: '(unset)',
		version_: '(unset)',


		getName: function(){
			// sumary: Return the name of the host environment.
			return this.name_; 	// String
		},


		getVersion: function(){
			// summary: Return the version of the hostenv.
			return this.version_; // String
		},

		getText: function(/*String*/ uri){
			// summary:	Read the plain/text contents at the specified 'uri'.
			// description:
			//			If 'getText()' is not implemented, then it is necessary to override
			//			'loadUri()' with an implementation that doesn't rely on it.

			dojo.unimplemented('getText', "uri=" + uri);
		}
	};
})();


dojo.hostenv.getBaseScriptUri = function(){
	// summary: Return the base script uri that other scripts are found relative to.
	// TODOC: HUH?  This comment means nothing to me.  What other scripts? Is this the path to other dojo libraries?
	//		MAYBE:  Return the base uri to scripts in the dojo library.	 ???
	// return: Empty string or a path ending in '/'.
	if(djConfig.baseScriptUri.length){
		return djConfig.baseScriptUri;
	}

	// MOW: Why not:
	//			uri = djConfig.libraryScriptUri || djConfig.baseRelativePath
	//		??? Why 'new String(...)'
	var uri = new String(djConfig.libraryScriptUri||djConfig.baseRelativePath);
	if (!uri) { dojo.raise("Nothing returned by getLibraryScriptUri(): " + uri); }

	// MOW: uri seems to not be actually used.  Seems to be hard-coding to djConfig.baseRelativePath... ???
	var lastslash = uri.lastIndexOf('/');		// MOW ???
	djConfig.baseScriptUri = djConfig.baseRelativePath;
	return djConfig.baseScriptUri;	// String
}

/*
 * loader.js - A bootstrap module.  Runs before the hostenv_*.js file. Contains all of the package loading methods.
 */

//A semi-colon is at the start of the line because after doing a build, this function definition
//get compressed onto the same line as the last line in bootstrap1.js. That list line is just a
//curly bracket, and the browser complains about that syntax. The semicolon fixes it. Putting it
//here instead of at the end of bootstrap1.js, since it is more of an issue for this file, (using
//the closure), and bootstrap1.js could change in the future.
;(function(){
	//Additional properties for dojo.hostenv
	var _addHostEnv = {
		pkgFileName: "__package__",
	
		// for recursion protection
		loading_modules_: {},
		loaded_modules_: {},
		addedToLoadingCount: [],
		removedFromLoadingCount: [],
	
		inFlightCount: 0,
	
		// FIXME: it should be possible to pull module prefixes in from djConfig
		modulePrefixes_: {
			dojo: {name: "dojo", value: "src"}
		},

		setModulePrefix: function(/*String*/module, /*String*/prefix){
			// summary: establishes module/prefix pair
			this.modulePrefixes_[module] = {name: module, value: prefix};
		},

		moduleHasPrefix: function(/*String*/module){
			// summary: checks to see if module has been established
			var mp = this.modulePrefixes_;
			return Boolean(mp[module] && mp[module].value); // Boolean
		},

		getModulePrefix: function(/*String*/module){
			// summary: gets the prefix associated with module
			if(this.moduleHasPrefix(module)){
				return this.modulePrefixes_[module].value; // String
			}
			return module; // String
		},

		getTextStack: [],
		loadUriStack: [],
		loadedUris: [],
	
		//WARNING: This variable is referenced by packages outside of bootstrap: FloatingPane.js and undo/browser.js
		post_load_: false,
		
		//Egad! Lots of test files push on this directly instead of using dojo.addOnLoad.
		modulesLoadedListeners: [],
		unloadListeners: [],
		loadNotifying: false
	};
	
	//Add all of these properties to dojo.hostenv
	for(var param in _addHostEnv){
		dojo.hostenv[param] = _addHostEnv[param];
	}
})();

dojo.hostenv.loadPath = function(/*String*/relpath, /*String?*/module, /*Function?*/cb){
// summary:
//	Load a Javascript module given a relative path
//
// description:
//	Loads and interprets the script located at relpath, which is relative to the
//	script root directory.  If the script is found but its interpretation causes
//	a runtime exception, that exception is not caught by us, so the caller will
//	see it.  We return a true value if and only if the script is found.
//
//	For now, we do not have an implementation of a true search path.  We
//	consider only the single base script uri, as returned by getBaseScriptUri().
//
// relpath: A relative path to a script (no leading '/', and typically
// 	ending in '.js').
// module: A module whose existance to check for after loading a path.
//	Can be used to determine success or failure of the load.
// cb: a callback function to pass the result of evaluating the script

	var uri;
	if(relpath.charAt(0) == '/' || relpath.match(/^\w+:/)){
		// dojo.raise("relpath '" + relpath + "'; must be relative");
		uri = relpath;
	}else{
		uri = this.getBaseScriptUri() + relpath;
	}
	if(djConfig.cacheBust && dojo.render.html.capable){
		uri += "?" + String(djConfig.cacheBust).replace(/\W+/g,"");
	}
	try{
		return !module ? this.loadUri(uri, cb) : this.loadUriAndCheck(uri, module, cb); // Boolean
	}catch(e){
		dojo.debug(e);
		return false; // Boolean
	}
}

dojo.hostenv.loadUri = function(/*String (URL)*/uri, /*Function?*/cb){
// summary:
//	Loads JavaScript from a URI
//
// description:
//	Reads the contents of the URI, and evaluates the contents.  This is used to load modules as well
//	as resource bundles.  Returns true if it succeeded. Returns false if the URI reading failed.
//	Throws if the evaluation throws.
//
// uri: a uri which points at the script to be loaded
// cb: a callback function to process the result of evaluating the script as an expression, typically
//	used by the resource bundle loader to load JSON-style resources

	if(this.loadedUris[uri]){
		return true; // Boolean
	}
	var contents = this.getText(uri, null, true);
	if(!contents){ return false; } // Boolean
	this.loadedUris[uri] = true;
	if(cb){ contents = '('+contents+')'; }
	var value = dj_eval(contents);
	if(cb){ cb(value); }
	return true; // Boolean
}

// FIXME: probably need to add logging to this method
dojo.hostenv.loadUriAndCheck = function(/*String (URL)*/uri, /*String*/moduleName, /*Function?*/cb){
	// summary: calls loadUri then findModule and returns true if both succeed
	var ok = true;
	try{
		ok = this.loadUri(uri, cb);
	}catch(e){
		dojo.debug("failed loading ", uri, " with error: ", e);
	}
	return Boolean(ok && this.findModule(moduleName, false)); // Boolean
}

dojo.loaded = function(){ }
dojo.unloaded = function(){ }

dojo.hostenv.loaded = function(){
	this.loadNotifying = true;
	this.post_load_ = true;
	var mll = this.modulesLoadedListeners;
	for(var x=0; x<mll.length; x++){
		mll[x]();
	}

	//Clear listeners so new ones can be added
	//For other xdomain package loads after the initial load.
	this.modulesLoadedListeners = [];
	this.loadNotifying = false;

	dojo.loaded();
}

dojo.hostenv.unloaded = function(){
	var mll = this.unloadListeners;
	while(mll.length){
		(mll.pop())();
	}
	dojo.unloaded();
}

dojo.addOnLoad = function(/*Object?*/obj, /*String|Function*/functionName) {
// summary:
//	Registers a function to be triggered after the DOM has finished loading 
//	and widgets declared in markup have been instantiated.  Images and CSS files
//	may or may not have finished downloading when the specified function is called.
//	(Note that widgets' CSS and HTML code is guaranteed to be downloaded before said
//	widgets are instantiated.)
//
// usage:
//	dojo.addOnLoad(functionPointer)
//	dojo.addOnLoad(object, "functionName")

	var dh = dojo.hostenv;
	if(arguments.length == 1) {
		dh.modulesLoadedListeners.push(obj);
	} else if(arguments.length > 1) {
		dh.modulesLoadedListeners.push(function() {
			obj[functionName]();
		});
	}

	//Added for xdomain loading. dojo.addOnLoad is used to
	//indicate callbacks after doing some dojo.require() statements.
	//In the xdomain case, if all the requires are loaded (after initial
	//page load), then immediately call any listeners.
	if(dh.post_load_ && dh.inFlightCount == 0 && !dh.loadNotifying){
		dh.callLoaded();
	}
}

dojo.addOnUnload = function(/*Object?*/obj, /*String|Function?*/functionName){
// summary: registers a function to be triggered when the page unloads
//
// usage:
//	dojo.addOnLoad(functionPointer)
//	dojo.addOnLoad(object, "functionName")
	var dh = dojo.hostenv;
	if(arguments.length == 1){
		dh.unloadListeners.push(obj);
	} else if(arguments.length > 1) {
		dh.unloadListeners.push(function() {
			obj[functionName]();
		});
	}
}

dojo.hostenv.modulesLoaded = function(){
	if(this.post_load_){ return; }
	if(this.loadUriStack.length==0 && this.getTextStack.length==0){
		if(this.inFlightCount > 0){ 
			dojo.debug("files still in flight!");
			return;
		}
		dojo.hostenv.callLoaded();
	}
}

dojo.hostenv.callLoaded = function(){
	//The "object" check is for IE, and the other opera check fixes an issue
	//in Opera where it could not find the body element in some widget test cases.
	//For 0.9, maybe route all browsers through the setTimeout (need protection
	//still for non-browser environments though). This might also help the issue with
	//FF 2.0 and freezing issues where we try to do sync xhr while background css images
	//are being loaded (trac #2572)? Consider for 0.9.
	if(typeof setTimeout == "object" || (djConfig["useXDomain"] && dojo.render.html.opera)){
		setTimeout("dojo.hostenv.loaded();", 0);
	}else{
		dojo.hostenv.loaded();
	}
}

dojo.hostenv.getModuleSymbols = function(/*String*/modulename){
// summary:
//	Converts a module name in dotted JS notation to an array representing the path in the source tree
	var syms = modulename.split(".");
	for(var i = syms.length; i>0; i--){
		var parentModule = syms.slice(0, i).join(".");
		if((i==1) && !this.moduleHasPrefix(parentModule)){		
			// Support default module directory (sibling of dojo) for top-level modules 
			syms[0] = "../" + syms[0];
		}else{
			var parentModulePath = this.getModulePrefix(parentModule);
			if(parentModulePath != parentModule){
				syms.splice(0, i, parentModulePath);
				break;
			}
		}
	}
	return syms; // Array
}

dojo.hostenv._global_omit_module_check = false;
dojo.hostenv.loadModule = function(/*String*/moduleName, /*Boolean?*/exactOnly, /*Boolean?*/omitModuleCheck){
// summary:
//	loads a Javascript module from the appropriate URI
//
// description:
//	loadModule("A.B") first checks to see if symbol A.B is defined. 
//	If it is, it is simply returned (nothing to do).
//	
//	If it is not defined, it will look for "A/B.js" in the script root directory,
//	followed by "A.js".
//	
//	It throws if it cannot find a file to load, or if the symbol A.B is not
//	defined after loading.
//	
//	It returns the object A.B.
//	
//	This does nothing about importing symbols into the current package.
//	It is presumed that the caller will take care of that. For example, to import
//	all symbols:
//	
//	   with (dojo.hostenv.loadModule("A.B")) {
//	      ...
//	   }
//	
//	And to import just the leaf symbol:
//	
//	   var B = dojo.hostenv.loadModule("A.B");
//	   ...
//	
//	dj_load is an alias for dojo.hostenv.loadModule

	if(!moduleName){ return; }
	omitModuleCheck = this._global_omit_module_check || omitModuleCheck;
	var module = this.findModule(moduleName, false);
	if(module){
		return module;
	}

	// protect against infinite recursion from mutual dependencies
	if(dj_undef(moduleName, this.loading_modules_)){
		this.addedToLoadingCount.push(moduleName);
	}
	this.loading_modules_[moduleName] = 1;

	// convert periods to slashes
	var relpath = moduleName.replace(/\./g, '/') + '.js';

	var nsyms = moduleName.split(".");
	
	// this line allowed loading of a module manifest as if it were a namespace
	// it's an interesting idea, but shouldn't be combined with 'namespaces' proper
	// and leads to unwanted dependencies
	// the effect can be achieved in other (albeit less-flexible) ways now, so I am
	// removing this pending further design work
	// perhaps we can explicitly define this idea of a 'module manifest', and subclass
	// 'namespace manifest' from that
	//dojo.getNamespace(nsyms[0]);

	var syms = this.getModuleSymbols(moduleName);
	var startedRelative = ((syms[0].charAt(0) != '/') && !syms[0].match(/^\w+:/));
	var last = syms[syms.length - 1];
	var ok;
	// figure out if we're looking for a full package, if so, we want to do
	// things slightly diffrently
	if(last=="*"){
		moduleName = nsyms.slice(0, -1).join('.');
		while(syms.length){
			syms.pop();
			syms.push(this.pkgFileName);
			relpath = syms.join("/") + '.js';
			if(startedRelative && relpath.charAt(0)=="/"){
				relpath = relpath.slice(1);
			}
			ok = this.loadPath(relpath, !omitModuleCheck ? moduleName : null);
			if(ok){ break; }
			syms.pop();
		}
	}else{
		relpath = syms.join("/") + '.js';
		moduleName = nsyms.join('.');
		var modArg = !omitModuleCheck ? moduleName : null;
		ok = this.loadPath(relpath, modArg);
		if(!ok && !exactOnly){
			syms.pop();
			while(syms.length){
				relpath = syms.join('/') + '.js';
				ok = this.loadPath(relpath, modArg);
				if(ok){ break; }
				syms.pop();
				relpath = syms.join('/') + '/'+this.pkgFileName+'.js';
				if(startedRelative && relpath.charAt(0)=="/"){
					relpath = relpath.slice(1);
				}
				ok = this.loadPath(relpath, modArg);
				if(ok){ break; }
			}
		}

		if(!ok && !omitModuleCheck){
			dojo.raise("Could not load '" + moduleName + "'; last tried '" + relpath + "'");
		}
	}

	// check that the symbol was defined
	//Don't bother if we're doing xdomain (asynchronous) loading.
	if(!omitModuleCheck && !this["isXDomain"]){
		// pass in false so we can give better error
		module = this.findModule(moduleName, false);
		if(!module){
			dojo.raise("symbol '" + moduleName + "' is not defined after loading '" + relpath + "'"); 
		}
	}

	return module;
}

dojo.hostenv.startPackage = function(/*String*/packageName){
// summary:
//	Creates a JavaScript package
//
// description:
//	startPackage("A.B") follows the path, and at each level creates a new empty
//	object or uses what already exists. It returns the result.
//
// packageName: the package to be created as a String in dot notation

	//Make sure we have a string.
	var fullPkgName = String(packageName);
	var strippedPkgName = fullPkgName;

	var syms = packageName.split(/\./);
	if(syms[syms.length-1]=="*"){
		syms.pop();
		strippedPkgName = syms.join(".");
	}
	var evaledPkg = dojo.evalObjPath(strippedPkgName, true);
	this.loaded_modules_[fullPkgName] = evaledPkg;
	this.loaded_modules_[strippedPkgName] = evaledPkg;
	
	return evaledPkg; // Object
}

dojo.hostenv.findModule = function(/*String*/moduleName, /*Boolean?*/mustExist){
// summary:
//	Returns the Object representing the module, if it exists, otherwise null.
//
// moduleName A fully qualified module including package name, like 'A.B'.
// mustExist Optional, default false. throw instead of returning null
//	if the module does not currently exist.

	var lmn = String(moduleName);

	if(this.loaded_modules_[lmn]){
		return this.loaded_modules_[lmn]; // Object
	}

	if(mustExist){
		dojo.raise("no loaded module named '" + moduleName + "'");
	}
	return null; // null
}

//Start of old bootstrap2:

dojo.kwCompoundRequire = function(/*Object containing Arrays*/modMap){
// description:
//	This method taks a "map" of arrays which one can use to optionally load dojo
//	modules. The map is indexed by the possible dojo.hostenv.name_ values, with
//	two additional values: "default" and "common". The items in the "default"
//	array will be loaded if none of the other items have been choosen based on
//	the hostenv.name_ item. The items in the "common" array will _always_ be
//	loaded, regardless of which list is chosen.  Here's how it's normally
//	called:
//	
//	dojo.kwCompoundRequire({
//		browser: [
//			["foo.bar.baz", true, true], // an example that passes multiple args to loadModule()
//			"foo.sample.*",
//			"foo.test,
//		],
//		default: [ "foo.sample.*" ],
//		common: [ "really.important.module.*" ]
//	});

	var common = modMap["common"]||[];
	var result = modMap[dojo.hostenv.name_] ? common.concat(modMap[dojo.hostenv.name_]||[]) : common.concat(modMap["default"]||[]);

	for(var x=0; x<result.length; x++){
		var curr = result[x];
		if(curr.constructor == Array){
			dojo.hostenv.loadModule.apply(dojo.hostenv, curr);
		}else{
			dojo.hostenv.loadModule(curr);
		}
	}
}

dojo.require = function(/*String*/ resourceName){
	// summary
	//	Ensure that the given resource (ie, javascript
	//	source file) has been loaded.
	// description
	//	dojo.require() is similar to C's #include command or java's "import" command.
	//	You call dojo.require() to pull in the resources (ie, javascript source files)
	//	that define the functions you are using. 
	//
	//	Note that in the case of a build, many resources have already been included
	//	into dojo.js (ie, many of the javascript source files have been compressed and
	//	concatened into dojo.js), so many dojo.require() calls will simply return
	//	without downloading anything.
	dojo.hostenv.loadModule.apply(dojo.hostenv, arguments);
}

dojo.requireIf = function(/*Boolean*/ condition, /*String*/ resourceName){
	// summary
	//	If the condition is true then call dojo.require() for the specified resource
	var arg0 = arguments[0];
	if((arg0 === true)||(arg0=="common")||(arg0 && dojo.render[arg0].capable)){
		var args = [];
		for (var i = 1; i < arguments.length; i++) { args.push(arguments[i]); }
		dojo.require.apply(dojo, args);
	}
}

dojo.requireAfterIf = dojo.requireIf;

dojo.provide = function(/*String*/ resourceName){
	// summary
	//	Each javascript source file must have (exactly) one dojo.provide()
	//	call at the top of the file, corresponding to the file name.
	//	For example, dojo/src/foo.js must have dojo.provide("dojo.foo"); at the top of the file.
	//
	// description
	//	Each javascript source file is called a resource.  When a resource
	//	is loaded by the browser, dojo.provide() registers that it has
	//	been loaded.
	//	
	//	For backwards compatibility reasons, in addition to registering the resource,
	//	dojo.provide() also ensures that the javascript object for the module exists.  For
	//	example, dojo.provide("dojo.html.common"), in addition to registering that common.js
	//	is a resource for the dojo.html module, will ensure that the dojo.html javascript object
	//	exists, so that calls like dojo.html.foo = function(){ ... } don't fail.
	//
	//	In the case of a build (or in the future, a rollup), where multiple javascript source
	//	files are combined into one bigger file (similar to a .lib or .jar file), that file
	//	will contain multiple dojo.provide() calls, to note that it includes
	//	multiple resources.
	return dojo.hostenv.startPackage.apply(dojo.hostenv, arguments);
}

dojo.registerModulePath = function(/*String*/module, /*String*/prefix){
	// summary: maps a module name to a path
	// description: An unregistered module is given the default path of ../<module>,
	//	relative to Dojo root. For example, module acme is mapped to ../acme.
	//	If you want to use a different module name, use dojo.registerModulePath. 
	return dojo.hostenv.setModulePrefix(module, prefix);
}

if(djConfig["modulePaths"]){
	for(var param in djConfig["modulePaths"]){
		dojo.registerModulePath(param, djConfig["modulePaths"][param]);
	}
}

dojo.setModulePrefix = function(/*String*/module, /*String*/prefix){
	// summary: maps a module name to a path
	dojo.deprecated('dojo.setModulePrefix("' + module + '", "' + prefix + '")', "replaced by dojo.registerModulePath", "0.5");
	return dojo.registerModulePath(module, prefix);
}

dojo.exists = function(/*Object*/obj, /*String*/name){
	// summary: determine if an object supports a given method
	// description: useful for longer api chains where you have to test each object in the chain
	var p = name.split(".");
	for(var i = 0; i < p.length; i++){
		if(!obj[p[i]]){ return false; } // Boolean
		obj = obj[p[i]];
	}
	return true; // Boolean
}

// Localization routines

dojo.hostenv.normalizeLocale = function(/*String?*/locale){
//	summary:
//		Returns canonical form of locale, as used by Dojo.  All variants are case-insensitive and are separated by '-'
//		as specified in RFC 3066. If no locale is specified, the user agent's default is returned.

	var result = locale ? locale.toLowerCase() : dojo.locale;
	if(result == "root"){
		result = "ROOT";
	}
	return result;// String
};

dojo.hostenv.searchLocalePath = function(/*String*/locale, /*Boolean*/down, /*Function*/searchFunc){
//	summary:
//		A helper method to assist in searching for locale-based resources.  Will iterate through
//		the variants of a particular locale, either up or down, executing a callback function.
//		For example, "en-us" and true will try "en-us" followed by "en" and finally "ROOT".

	locale = dojo.hostenv.normalizeLocale(locale);

	var elements = locale.split('-');
	var searchlist = [];
	for(var i = elements.length; i > 0; i--){
		searchlist.push(elements.slice(0, i).join('-'));
	}
	searchlist.push(false);
	if(down){searchlist.reverse();}

	for(var j = searchlist.length - 1; j >= 0; j--){
		var loc = searchlist[j] || "ROOT";
		var stop = searchFunc(loc);
		if(stop){ break; }
	}
}

//These two functions are placed outside of preloadLocalizations
//So that the xd loading can use/override them.
dojo.hostenv.localesGenerated /***BUILD:localesGenerated***/; // value will be inserted here at build time, if necessary

dojo.hostenv.registerNlsPrefix = function(){
// summary:
//	Register module "nls" to point where Dojo can find pre-built localization files
	dojo.registerModulePath("nls","nls");	
}

dojo.hostenv.preloadLocalizations = function(){
// summary:
//	Load built, flattened resource bundles, if available for all locales used in the page.
//	Execute only once.  Note that this is a no-op unless there is a build.

	if(dojo.hostenv.localesGenerated){
		dojo.hostenv.registerNlsPrefix();

		function preload(locale){
			locale = dojo.hostenv.normalizeLocale(locale);
			dojo.hostenv.searchLocalePath(locale, true, function(loc){
				for(var i=0; i<dojo.hostenv.localesGenerated.length;i++){
					if(dojo.hostenv.localesGenerated[i] == loc){
						dojo["require"]("nls.dojo_"+loc);
						return true; // Boolean
					}
				}
				return false; // Boolean
			});
		}
		preload();
		var extra = djConfig.extraLocale||[];
		for(var i=0; i<extra.length; i++){
			preload(extra[i]);
		}
	}
	dojo.hostenv.preloadLocalizations = function(){};
}

dojo.requireLocalization = function(/*String*/moduleName, /*String*/bundleName, /*String?*/locale, /*String?*/availableFlatLocales){
// summary:
//	Declares translated resources and loads them if necessary, in the same style as dojo.require.
//	Contents of the resource bundle are typically strings, but may be any name/value pair,
//	represented in JSON format.  See also dojo.i18n.getLocalization.
//
// moduleName: name of the package containing the "nls" directory in which the bundle is found
// bundleName: bundle name, i.e. the filename without the '.js' suffix
// locale: the locale to load (optional)  By default, the browser's user locale as defined by dojo.locale
// availableFlatLocales: A comma-separated list of the available, flattened locales for this bundle.
// This argument should only be set by the build process.
//
// description:
//	Load translated resource bundles provided underneath the "nls" directory within a package.
//	Translated resources may be located in different packages throughout the source tree.  For example,
//	a particular widget may define one or more resource bundles, structured in a program as follows,
//	where moduleName is mycode.mywidget and bundleNames available include bundleone and bundletwo:
//	...
//	mycode/
//	 mywidget/
//	  nls/
//	   bundleone.js (the fallback translation, English in this example)
//	   bundletwo.js (also a fallback translation)
//	   de/
//	    bundleone.js
//	    bundletwo.js
//	   de-at/
//	    bundleone.js
//	   en/
//	    (empty; use the fallback translation)
//	   en-us/
//	    bundleone.js
//	   en-gb/
//	    bundleone.js
//	   es/
//	    bundleone.js
//	    bundletwo.js
//	  ...etc
//	...
//	Each directory is named for a locale as specified by RFC 3066, (http://www.ietf.org/rfc/rfc3066.txt),
//	normalized in lowercase.  Note that the two bundles in the example do not define all the same variants.
//	For a given locale, bundles will be loaded for that locale and all more general locales above it, including
//	a fallback at the root directory.  For example, a declaration for the "de-at" locale will first
//	load nls/de-at/bundleone.js, then nls/de/bundleone.js and finally nls/bundleone.js.  The data will
//	be flattened into a single Object so that lookups will follow this cascading pattern.  An optional build
//	step can preload the bundles to avoid data redundancy and the multiple network hits normally required to
//	load these resources.

	dojo.hostenv.preloadLocalizations();
	var targetLocale = dojo.hostenv.normalizeLocale(locale);
 	var bundlePackage = [moduleName, "nls", bundleName].join(".");
//NOTE: When loading these resources, the packaging does not match what is on disk.  This is an
// implementation detail, as this is just a private data structure to hold the loaded resources.
// e.g. tests/hello/nls/en-us/salutations.js is loaded as the object tests.hello.nls.salutations.en_us={...}
// The structure on disk is intended to be most convenient for developers and translators, but in memory
// it is more logical and efficient to store in a different order.  Locales cannot use dashes, since the
// resulting path will not evaluate as valid JS, so we translate them to underscores.
	
	//Find the best-match locale to load if we have available flat locales.
	var bestLocale = "";
	if(availableFlatLocales){
		var flatLocales = availableFlatLocales.split(",");
		for(var i = 0; i < flatLocales.length; i++){
			//Locale must match from start of string.
			if(targetLocale.indexOf(flatLocales[i]) == 0){
				if(flatLocales[i].length > bestLocale.length){
					bestLocale = flatLocales[i];
				}
			}
		}
		if(!bestLocale){
			bestLocale = "ROOT";
		}		
	}

	//See if the desired locale is already loaded.
	var tempLocale = availableFlatLocales ? bestLocale : targetLocale;
	var bundle = dojo.hostenv.findModule(bundlePackage);
	var localizedBundle = null;
	if(bundle){
		if(djConfig.localizationComplete && bundle._built){return;}
		var jsLoc = tempLocale.replace('-', '_');
		var translationPackage = bundlePackage+"."+jsLoc;
		localizedBundle = dojo.hostenv.findModule(translationPackage);
	}

	if(!localizedBundle){
		bundle = dojo.hostenv.startPackage(bundlePackage);
		var syms = dojo.hostenv.getModuleSymbols(moduleName);
		var modpath = syms.concat("nls").join("/");
		var parent;

		dojo.hostenv.searchLocalePath(tempLocale, availableFlatLocales, function(loc){
			var jsLoc = loc.replace('-', '_');
			var translationPackage = bundlePackage + "." + jsLoc;
			var loaded = false;
			if(!dojo.hostenv.findModule(translationPackage)){
				// Mark loaded whether it's found or not, so that further load attempts will not be made
				dojo.hostenv.startPackage(translationPackage);
				var module = [modpath];
				if(loc != "ROOT"){module.push(loc);}
				module.push(bundleName);
				var filespec = module.join("/") + '.js';
				loaded = dojo.hostenv.loadPath(filespec, null, function(hash){
					// Use singleton with prototype to point to parent bundle, then mix-in result from loadPath
					var clazz = function(){};
					clazz.prototype = parent;
					bundle[jsLoc] = new clazz();
					for(var j in hash){ bundle[jsLoc][j] = hash[j]; }
				});
			}else{
				loaded = true;
			}
			if(loaded && bundle[jsLoc]){
				parent = bundle[jsLoc];
			}else{
				bundle[jsLoc] = parent;
			}
			
			if(availableFlatLocales){
				//Stop the locale path searching if we know the availableFlatLocales, since
				//the first call to this function will load the only bundle that is needed.
				return true;
			}
		});
	}

	//Save the best locale bundle as the target locale bundle when we know the
	//the available bundles.
	if(availableFlatLocales && targetLocale != bestLocale){
		bundle[targetLocale.replace('-', '_')] = bundle[bestLocale.replace('-', '_')];
	}
};

(function(){
	// If other locales are used, dojo.requireLocalization should load them as well, by default.
	// Override dojo.requireLocalization to do load the default bundle, then iterate through the
	// extraLocale list and load those translations as well, unless a particular locale was requested.

	var extra = djConfig.extraLocale;
	if(extra){
		if(!extra instanceof Array){
			extra = [extra];
		}

		var req = dojo.requireLocalization;
		dojo.requireLocalization = function(m, b, locale, availableFlatLocales){
			req(m,b,locale, availableFlatLocales);
			if(locale){return;}
			for(var i=0; i<extra.length; i++){
				req(m,b,extra[i], availableFlatLocales);
			}
		};
	}
})();

};

if(typeof window != 'undefined'){

	// attempt to figure out the path to dojo if it isn't set in the config
	(function(){
		// before we get any further with the config options, try to pick them out
		// of the URL. Most of this code is from NW
		if(djConfig.allowQueryConfig){
			var baseUrl = document.location.toString(); // FIXME: use location.query instead?
			var params = baseUrl.split("?", 2);
			if(params.length > 1){
				var paramStr = params[1];
				var pairs = paramStr.split("&");
				for(var x in pairs){
					var sp = pairs[x].split("=");
					// FIXME: is this eval dangerous?
					if((sp[0].length > 9)&&(sp[0].substr(0, 9) == "djConfig.")){
						var opt = sp[0].substr(9);
						try{
							djConfig[opt]=eval(sp[1]);
						}catch(e){
							djConfig[opt]=sp[1];
						}
					}
				}
			}
		}

		if(
			((djConfig["baseScriptUri"] == "")||(djConfig["baseRelativePath"] == "")) && 
			(document && document.getElementsByTagName)
		){
			var scripts = document.getElementsByTagName("script");
			var rePkg = /(__package__|dojo|bootstrap1)\.js([\?\.]|$)/i;
			for(var i = 0; i < scripts.length; i++) {
				var src = scripts[i].getAttribute("src");
				if(!src) { continue; }
				var m = src.match(rePkg);
				if(m) {
					var root = src.substring(0, m.index);
					if(src.indexOf("bootstrap1") > -1) { root += "../"; }
					if(!this["djConfig"]) { djConfig = {}; }
					if(djConfig["baseScriptUri"] == "") { djConfig["baseScriptUri"] = root; }
					if(djConfig["baseRelativePath"] == "") { djConfig["baseRelativePath"] = root; }
					break;
				}
			}
		}

		// fill in the rendering support information in dojo.render.*
		var dr = dojo.render;
		var drh = dojo.render.html;
		var drs = dojo.render.svg;
		var dua = (drh.UA = navigator.userAgent);
		var dav = (drh.AV = navigator.appVersion);
		var t = true;
		var f = false;
		drh.capable = t;
		drh.support.builtin = t;

		dr.ver = parseFloat(drh.AV);
		dr.os.mac = dav.indexOf("Macintosh") >= 0;
		dr.os.win = dav.indexOf("Windows") >= 0;
		// could also be Solaris or something, but it's the same browser
		dr.os.linux = dav.indexOf("X11") >= 0;

		drh.opera = dua.indexOf("Opera") >= 0;
		drh.khtml = (dav.indexOf("Konqueror") >= 0)||(dav.indexOf("Safari") >= 0);
		drh.safari = dav.indexOf("Safari") >= 0;
		var geckoPos = dua.indexOf("Gecko");
		drh.mozilla = drh.moz = (geckoPos >= 0)&&(!drh.khtml);
		if (drh.mozilla) {
			// gecko version is YYYYMMDD
			drh.geckoVersion = dua.substring(geckoPos + 6, geckoPos + 14);
		}
		drh.ie = (document.all)&&(!drh.opera);
		drh.ie50 = drh.ie && dav.indexOf("MSIE 5.0")>=0;
		drh.ie55 = drh.ie && dav.indexOf("MSIE 5.5")>=0;
		drh.ie60 = drh.ie && dav.indexOf("MSIE 6.0")>=0;
		drh.ie70 = drh.ie && dav.indexOf("MSIE 7.0")>=0;

		var cm = document["compatMode"];
		drh.quirks = (cm == "BackCompat")||(cm == "QuirksMode")||drh.ie55||drh.ie50;

		// TODO: is the HTML LANG attribute relevant?
		dojo.locale = dojo.locale || (drh.ie ? navigator.userLanguage : navigator.language).toLowerCase();

		dr.vml.capable=drh.ie;
		drs.capable = f;
		drs.support.plugin = f;
		drs.support.builtin = f;
		var tdoc = window["document"];
		var tdi = tdoc["implementation"];

		if((tdi)&&(tdi["hasFeature"])&&(tdi.hasFeature("org.w3c.dom.svg", "1.0"))){
			drs.capable = t;
			drs.support.builtin = t;
			drs.support.plugin = f;
		}
		// webkits after 420 support SVG natively. The test string is "AppleWebKit/420+"
		if(drh.safari){
			var tmp = dua.split("AppleWebKit/")[1];
			var ver = parseFloat(tmp.split(" ")[0]);
			if(ver >= 420){
				drs.capable = t;
				drs.support.builtin = t;
				drs.support.plugin = f;
			}
		}else{
		}
	})();

	dojo.hostenv.startPackage("dojo.hostenv");

	dojo.render.name = dojo.hostenv.name_ = 'browser';
	dojo.hostenv.searchIds = [];

	// These are in order of decreasing likelihood; this will change in time.
	dojo.hostenv._XMLHTTP_PROGIDS = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];

	dojo.hostenv.getXmlhttpObject = function(){
		// summary: does the work of portably generating a new XMLHTTPRequest object.
		var http = null;
		var last_e = null;
		try{ http = new XMLHttpRequest(); }catch(e){}
		if(!http){
			for(var i=0; i<3; ++i){
				var progid = dojo.hostenv._XMLHTTP_PROGIDS[i];
				try{
					http = new ActiveXObject(progid);
				}catch(e){
					last_e = e;
				}

				if(http){
					dojo.hostenv._XMLHTTP_PROGIDS = [progid];  // so faster next time
					break;
				}
			}

			/*if(http && !http.toString) {
				http.toString = function() { "[object XMLHttpRequest]"; }
			}*/
		}

		if(!http){
			return dojo.raise("XMLHTTP not available", last_e);
		}

		return http; // XMLHTTPRequest instance
	}

	dojo.hostenv._blockAsync = false;
	dojo.hostenv.getText = function(uri, async_cb, fail_ok){
		// summary: Read the contents of the specified uri and return those contents.
		// uri:
		//		A relative or absolute uri. If absolute, it still must be in
		//		the same "domain" as we are.
		// async_cb:
		//		If not specified, load synchronously. If specified, load
		//		asynchronously, and use async_cb as the progress handler which
		//		takes the xmlhttp object as its argument. If async_cb, this
		//		function returns null.
		// fail_ok:
		//		Default false. If fail_ok and !async_cb and loading fails,
		//		return null instead of throwing.

		// need to block async callbacks from snatching this thread as the result
		// of an async callback might call another sync XHR, this hangs khtml forever
		// hostenv._blockAsync must also be checked in BrowserIO's watchInFlight()
		// NOTE: must be declared before scope switches ie. this.getXmlhttpObject()
		if(!async_cb){ this._blockAsync = true; }

		var http = this.getXmlhttpObject();

		function isDocumentOk(http){
			var stat = http["status"];
			// allow a 304 use cache, needed in konq (is this compliant with the http spec?)
			return Boolean((!stat)||((200 <= stat)&&(300 > stat))||(stat==304));
		}

		if(async_cb){
			var _this = this, timer = null, gbl = dojo.global();
			var xhr = dojo.evalObjPath("dojo.io.XMLHTTPTransport");
			http.onreadystatechange = function(){
				if(timer){ gbl.clearTimeout(timer); timer = null; }
				if(_this._blockAsync || (xhr && xhr._blockAsync)){
					timer = gbl.setTimeout(function () { http.onreadystatechange.apply(this); }, 10);
				}else{
					if(4==http.readyState){
						if(isDocumentOk(http)){
							// dojo.debug("LOADED URI: "+uri);
							async_cb(http.responseText);
						}
					}
				}
			}
		}

		http.open('GET', uri, async_cb ? true : false);
		try{
			http.send(null);
			if(async_cb){
				return null;
			}
			if(!isDocumentOk(http)){
				var err = Error("Unable to load "+uri+" status:"+ http.status);
				err.status = http.status;
				err.responseText = http.responseText;
				throw err;
			}
		}catch(e){
			this._blockAsync = false;
			if((fail_ok)&&(!async_cb)){
				return null;
			}else{
				throw e;
			}
		}

		this._blockAsync = false;
		return http.responseText; // String
	}

	dojo.hostenv.defaultDebugContainerId = 'dojoDebug';
	dojo.hostenv._println_buffer = [];
	dojo.hostenv._println_safe = false;
	dojo.hostenv.println = function(/*String*/line){
		// summary:
		//		prints the provided line to whatever logging container is
		//		available. If the page isn't loaded yet, the line may be added
		//		to a buffer for printing later.
		if(!dojo.hostenv._println_safe){
			dojo.hostenv._println_buffer.push(line);
		}else{
			try {
				var console = document.getElementById(djConfig.debugContainerId ?
					djConfig.debugContainerId : dojo.hostenv.defaultDebugContainerId);
				if(!console) { console = dojo.body(); }

				var div = document.createElement("div");
				div.appendChild(document.createTextNode(line));
				console.appendChild(div);
			} catch (e) {
				try{
					// safari needs the output wrapped in an element for some reason
					document.write("<div>" + line + "</div>");
				}catch(e2){
					window.status = line;
				}
			}
		}
	}

	dojo.addOnLoad(function(){
		dojo.hostenv._println_safe = true;
		while(dojo.hostenv._println_buffer.length > 0){
			dojo.hostenv.println(dojo.hostenv._println_buffer.shift());
		}
	});

	function dj_addNodeEvtHdlr(/*DomNode*/node, /*String*/evtName, /*Function*/fp){
		// summary:
		//		non-destructively adds the specified function to the node's
		//		evtName handler.
		// node: the DomNode to add the handler to
		// evtName: should be in the form "click" for "onclick" handlers
		var oldHandler = node["on"+evtName] || function(){};
		node["on"+evtName] = function(){
			fp.apply(node, arguments);
			oldHandler.apply(node, arguments);
		}
		return true;
	}

	dojo.hostenv._djInitFired = false;
	//	BEGIN DOMContentLoaded, from Dean Edwards (http://dean.edwards.name/weblog/2006/06/again/)
	function dj_load_init(e){
		dojo.hostenv._djInitFired = true;
		// allow multiple calls, only first one will take effect
		// A bug in khtml calls events callbacks for document for event which isnt supported
		// for example a created contextmenu event calls DOMContentLoaded, workaround
		var type = (e && e.type) ? e.type.toLowerCase() : "load";
		if(arguments.callee.initialized || (type!="domcontentloaded" && type!="load")){ return; }
		arguments.callee.initialized = true;
		if(typeof(_timer) != 'undefined'){
			clearInterval(_timer);
			delete _timer;
		}

		var initFunc = function(){
			//perform initialization
			if(dojo.render.html.ie){
				dojo.hostenv.makeWidgets();
			}
		};

		if(dojo.hostenv.inFlightCount == 0){
			initFunc();
			dojo.hostenv.modulesLoaded();
		}else{
			//This else case should be xdomain loading.
			//Make sure this is the first thing in the load listener array.
			//Part of the dojo.addOnLoad guarantee is that when the listeners are notified,
			//It means the DOM (or page) has loaded and that widgets have been parsed.
			dojo.hostenv.modulesLoadedListeners.unshift(initFunc);
		}
	}

	//	START DOMContentLoaded
	// Mozilla and Opera 9 expose the event we could use
	if(document.addEventListener){
		// NOTE: 
		//		due to a threading issue in Firefox 2.0, we can't enable
		//		DOMContentLoaded on that platform. For more information, see:
		//		http://trac.dojotoolkit.org/ticket/1704
		if(dojo.render.html.opera || (dojo.render.html.moz && (djConfig["enableMozDomContentLoaded"] === true))){
			document.addEventListener("DOMContentLoaded", dj_load_init, null);
		}

		//	mainly for Opera 8.5, won't be fired if DOMContentLoaded fired already.
		//  also used for Mozilla because of trac #1640
		window.addEventListener("load", dj_load_init, null);
	}

	// 	for Internet Explorer. readyState will not be achieved on init call, but dojo doesn't need it
	//	however, we'll include it because we don't know if there are other functions added that might.
	//	Note that this has changed because the build process strips all comments--including conditional
	//		ones.
	if(dojo.render.html.ie && dojo.render.os.win){
		document.attachEvent("onreadystatechange", function(e){
			if(document.readyState == "complete"){
				dj_load_init();
			}
		});
	}

	if (/(WebKit|khtml)/i.test(navigator.userAgent)) { // sniff
		var _timer = setInterval(function() {
			if (/loaded|complete/.test(document.readyState)) {
				dj_load_init(); // call the onload handler
			}
		}, 10);
	}
	//	END DOMContentLoaded

	// IE WebControl hosted in an application can fire "beforeunload" and "unload"
	// events when control visibility changes, causing Dojo to unload too soon. The
	// following code fixes the problem
	// Reference: http://support.microsoft.com/default.aspx?scid=kb;en-us;199155
	if(dojo.render.html.ie){
		dj_addNodeEvtHdlr(window, "beforeunload", function(){
			dojo.hostenv._unloading = true;
			window.setTimeout(function() {
				dojo.hostenv._unloading = false;
			}, 0);
		});
	}

	dj_addNodeEvtHdlr(window, "unload", function(){
		dojo.hostenv.unloaded();
		if((!dojo.render.html.ie)||(dojo.render.html.ie && dojo.hostenv._unloading)){
			dojo.hostenv.unloaded();
		}
	});

	dojo.hostenv.makeWidgets = function(){
		// you can put searchIds in djConfig and dojo.hostenv at the moment
		// we should probably eventually move to one or the other
		var sids = [];
		if(djConfig.searchIds && djConfig.searchIds.length > 0) {
			sids = sids.concat(djConfig.searchIds);
		}
		if(dojo.hostenv.searchIds && dojo.hostenv.searchIds.length > 0) {
			sids = sids.concat(dojo.hostenv.searchIds);
		}

		if((djConfig.parseWidgets)||(sids.length > 0)){
			if(dojo.evalObjPath("dojo.widget.Parse")){
				// we must do this on a delay to avoid:
				//	http://www.shaftek.org/blog/archives/000212.html
				// (IE bug)
					var parser = new dojo.xml.Parse();
					if(sids.length > 0){
						for(var x=0; x<sids.length; x++){
							var tmpNode = document.getElementById(sids[x]);
							if(!tmpNode){ continue; }
							var frag = parser.parseElement(tmpNode, null, true);
							dojo.widget.getParser().createComponents(frag);
						}
					}else if(djConfig.parseWidgets){
						var frag  = parser.parseElement(dojo.body(), null, true);
						dojo.widget.getParser().createComponents(frag);
					}
			}
		}
	}

	dojo.addOnLoad(function(){
		if(!dojo.render.html.ie) {
			dojo.hostenv.makeWidgets();
		}
	});

	try{
		if(dojo.render.html.ie){
			document.namespaces.add("v","urn:schemas-microsoft-com:vml");
			document.createStyleSheet().addRule("v\\:*", "behavior:url(#default#VML)");
		}
	}catch(e){ }

	// stub, over-ridden by debugging code. This will at least keep us from
	// breaking when it's not included
	dojo.hostenv.writeIncludes = function(){}

	//TODOC:  HOW TO DOC THIS?
	// @global: dj_currentDocument
	// summary:
	//		Current document object. 'dj_currentDocument' can be modified for temporary context shifting.
	// description:
	//    dojo.doc() returns dojo.currentDocument.
	//		Refer to dojo.doc() rather than referring to 'window.document' to ensure your
	//		code runs correctly in managed contexts.
	if(!dj_undef("document", this)){
		dj_currentDocument = this.document;
	}

	dojo.doc = function(){
		// summary:
		//		return the document object associated with the dojo.global()
		return dj_currentDocument;
	}

	dojo.body = function(){
		// summary:
		//		return the body object associated with dojo.doc()
		// Note: document.body is not defined for a strict xhtml document
		return dojo.doc().body || dojo.doc().getElementsByTagName("body")[0];
	}

	dojo.byId = function(/*String*/id, /*DocumentElement*/doc){
		// summary:
		// 		similar to other library's "$" function, takes a string
		// 		representing a DOM id or a DomNode and returns the
		// 		corresponding DomNode. If a Node is passed, this function is a
		// 		no-op. Returns a single DOM node or null, working around
		// 		several browser-specific bugs to do so.
		// id: DOM id or DOM Node
		// doc:
		//		optional, defaults to the current value of dj_currentDocument.
		//		Can be used to retreive node references from other documents.
		if((id)&&((typeof id == "string")||(id instanceof String))){
			if(!doc){ doc = dj_currentDocument; }
			var ele = doc.getElementById(id);
			// workaround bug in IE and Opera 8.2 where getElementById returns wrong element
			if(ele && (ele.id != id) && doc.all){
				ele = null;
				// get all matching elements with this id
				eles = doc.all[id];
				if(eles){
					// if more than 1, choose first with the correct id
					if(eles.length){
						for(var i=0; i<eles.length; i++){
							if(eles[i].id == id){
								ele = eles[i];
								break;
							}
						}
					// return 1 and only element
					}else{
						ele = eles;
					}
				}
			}
			return ele; // DomNode
		}
		return id; // DomNode
	}

	dojo.setContext = function(/*Object*/globalObject, /*DocumentElement*/globalDocument){
		// summary:
		//		changes the behavior of many core Dojo functions that deal with
		//		namespace and DOM lookup, changing them to work in a new global
		//		context. The varibles dj_currentContext and dj_currentDocument
		//		are modified as a result of calling this function.
		dj_currentContext = globalObject;
		dj_currentDocument = globalDocument;
	};

	dojo._fireCallback = function(callback, context, cbArguments){
		if((context)&&((typeof callback == "string")||(callback instanceof String))){
			callback=context[callback];
		}
		return (context ? callback.apply(context, cbArguments || [ ]) : callback());
	}

	dojo.withGlobal = function(/*Object*/globalObject, /*Function*/callback, /*Object?*/thisObject, /*Array?*/cbArguments){
		// summary:
		//		Call callback with globalObject as dojo.global() and globalObject.document
		//		as dojo.doc(). If provided, globalObject will be executed in the context of
		//		object thisObject
		// description:
		//		When callback() returns or throws an error, the dojo.global() and dojo.doc() will
		//		be restored to its previous state.
		var rval;
		var oldGlob = dj_currentContext;
		var oldDoc = dj_currentDocument;
		try{
			dojo.setContext(globalObject, globalObject.document);
			rval = dojo._fireCallback(callback, thisObject, cbArguments);
		}finally{
			dojo.setContext(oldGlob, oldDoc);
		}
		return rval;
	}

	dojo.withDoc = function (/*Object*/documentObject, /*Function*/callback, /*Object?*/thisObject, /*Array?*/cbArguments) {
		// summary:
		//		Call callback with documentObject as dojo.doc(). If provided, callback will be executed
		//		in the context of object thisObject
		// description:
		//		When callback() returns or throws an error, the dojo.doc() will
		//		be restored to its previous state.
		var rval;
		var oldDoc = dj_currentDocument;
		try{
			dj_currentDocument = documentObject;
			rval = dojo._fireCallback(callback, thisObject, cbArguments);
		}finally{
			dj_currentDocument = oldDoc;
		}
		return rval;
	}

} //if (typeof window != 'undefined')

//Load debug code if necessary.
dojo.requireIf((djConfig["isDebug"] || djConfig["debugAtAllCosts"]), "dojo.debug");

//window.widget is for Dashboard detection
//The full conditionals are spelled out to avoid issues during builds.
//Builds may be looking for require/requireIf statements and processing them.
dojo.requireIf(djConfig["debugAtAllCosts"] && !window.widget && !djConfig["useXDomain"], "dojo.browser_debug");
dojo.requireIf(djConfig["debugAtAllCosts"] && !window.widget && djConfig["useXDomain"], "dojo.browser_debug_xd");

dojo.provide("dojo.collections.Collections");

dojo.collections.DictionaryEntry=function(/* string */k, /* object */v){
	//	summary
	//	return an object of type dojo.collections.DictionaryEntry
	this.key=k;
	this.value=v;
	this.valueOf=function(){ 
		return this.value; 	//	object
	};
	this.toString=function(){ 
		return String(this.value);	//	string 
	};
}

/*	Iterators
 *	The collections.Iterators (Iterator and DictionaryIterator) are built to
 *	work with the Collections included in this module.  However, they *can*
 *	be used with arrays and objects, respectively, should one choose to do so.
 */
dojo.collections.Iterator=function(/* array */arr){
	//	summary
	//	return an object of type dojo.collections.Iterator
	var a=arr;
	var position=0;
	this.element=a[position]||null;
	this.atEnd=function(){
		//	summary
		//	Test to see if the internal cursor has reached the end of the internal collection.
		return (position>=a.length);	//	bool
	};
	this.get=function(){
		//	summary
		//	Test to see if the internal cursor has reached the end of the internal collection.
		if(this.atEnd()){
			return null;		//	object
		}
		this.element=a[position++];
		return this.element;	//	object
	};
	this.map=function(/* function */fn, /* object? */scope){
		//	summary
		//	Functional iteration with optional scope.
		var s=scope||dj_global;
		if(Array.map){
			return Array.map(a,fn,s);	//	array
		}else{
			var arr=[];
			for(var i=0; i<a.length; i++){
				arr.push(fn.call(s,a[i]));
			}
			return arr;		//	array
		}
	};
	this.reset=function(){
		//	summary
		//	reset the internal cursor.
		position=0;
		this.element=a[position];
	};
}

/*	Notes:
 *	The DictionaryIterator no longer supports a key and value property;
 *	the reality is that you can use this to iterate over a JS object
 *	being used as a hashtable.
 */
dojo.collections.DictionaryIterator=function(/* object */obj){
	//	summary
	//	return an object of type dojo.collections.DictionaryIterator
	var a=[];	//	Create an indexing array
	var testObject={};
	for(var p in obj){
		if(!testObject[p]){
			a.push(obj[p]);	//	fill it up
		}
	}
	var position=0;
	this.element=a[position]||null;
	this.atEnd=function(){
		//	summary
		//	Test to see if the internal cursor has reached the end of the internal collection.
		return (position>=a.length);	//	bool
	};
	this.get=function(){
		//	summary
		//	Test to see if the internal cursor has reached the end of the internal collection.
		if(this.atEnd()){
			return null;		//	object
		}
		this.element=a[position++];
		return this.element;	//	object
	};
	this.map=function(/* function */fn, /* object? */scope){
		//	summary
		//	Functional iteration with optional scope.
		var s=scope||dj_global;
		if(Array.map){
			return Array.map(a,fn,s);	//	array
		}else{
			var arr=[];
			for(var i=0; i<a.length; i++){
				arr.push(fn.call(s,a[i]));
			}
			return arr;		//	array
		}
	};
	this.reset=function() { 
		//	summary
		//	reset the internal cursor.
		position=0; 
		this.element=a[position];
	};
};

dojo.provide("dojo.collections.ArrayList");


dojo.collections.ArrayList=function(/* array? */arr){
	//	summary
	//	Returns a new object of type dojo.collections.ArrayList
	var items=[];
	if(arr) items=items.concat(arr);
	this.count=items.length;
	this.add=function(/* object */obj){
		//	summary
		//	Add an element to the collection.
		items.push(obj);
		this.count=items.length;
	};
	this.addRange=function(/* array */a){
		//	summary
		//	Add a range of objects to the ArrayList
		if(a.getIterator){
			var e=a.getIterator();
			while(!e.atEnd()){
				this.add(e.get());
			}
			this.count=items.length;
		}else{
			for(var i=0; i<a.length; i++){
				items.push(a[i]);
			}
			this.count=items.length;
		}
	};
	this.clear=function(){
		//	summary
		//	Clear all elements out of the collection, and reset the count.
		items.splice(0, items.length);
		this.count=0;
	};
	this.clone=function(){
		//	summary
		//	Clone the array list
		return new dojo.collections.ArrayList(items);	//	dojo.collections.ArrayList
	};
	this.contains=function(/* object */obj){
		//	summary
		//	Check to see if the passed object is a member in the ArrayList
		for(var i=0; i < items.length; i++){
			if(items[i] == obj) {
				return true;	//	bool
			}
		}
		return false;	//	bool
	};
	this.forEach=function(/* function */ fn, /* object? */ scope){
		//	summary
		//	functional iterator, following the mozilla spec.
		var s=scope||dj_global;
		if(Array.forEach){
			Array.forEach(items, fn, s);
		}else{
			for(var i=0; i<items.length; i++){
				fn.call(s, items[i], i, items);
			}
		}
	};
	this.getIterator=function(){
		//	summary
		//	Get an Iterator for this object
		return new dojo.collections.Iterator(items);	//	dojo.collections.Iterator
	};
	this.indexOf=function(/* object */obj){
		//	summary
		//	Return the numeric index of the passed object; will return -1 if not found.
		for(var i=0; i < items.length; i++){
			if(items[i] == obj) {
				return i;	//	int
			}
		}
		return -1;	// int
	};
	this.insert=function(/* int */ i, /* object */ obj){
		//	summary
		//	Insert the passed object at index i
		items.splice(i,0,obj);
		this.count=items.length;
	};
	this.item=function(/* int */ i){
		//	summary
		//	return the element at index i
		return items[i];	//	object
	};
	this.remove=function(/* object */obj){
		//	summary
		//	Look for the passed object, and if found, remove it from the internal array.
		var i=this.indexOf(obj);
		if(i >=0) {
			items.splice(i,1);
		}
		this.count=items.length;
	};
	this.removeAt=function(/* int */ i){
		//	summary
		//	return an array with function applied to all elements
		items.splice(i,1);
		this.count=items.length;
	};
	this.reverse=function(){
		//	summary
		//	Reverse the internal array
		items.reverse();
	};
	this.sort=function(/* function? */ fn){
		//	summary
		//	sort the internal array
		if(fn){
			items.sort(fn);
		}else{
			items.sort();
		}
	};
	this.setByIndex=function(/* int */ i, /* object */ obj){
		//	summary
		//	Set an element in the array by the passed index.
		items[i]=obj;
		this.count=items.length;
	};
	this.toArray=function(){
		//	summary
		//	Return a new array with all of the items of the internal array concatenated.
		return [].concat(items);
	}
	this.toString=function(/* string */ delim){
		//	summary
		//	implementation of toString, follows [].toString();
		return items.join((delim||","));
	};
};

dojo.provide("dojo.collections.Dictionary");


dojo.collections.Dictionary=function(/* dojo.collections.Dictionary? */dictionary){
	//	summary
	//	Returns an object of type dojo.collections.Dictionary
	var items={};
	this.count=0;

	//	comparator for property addition and access.
	var testObject={};

	this.add=function(/* string */k, /* object */v){
		//	summary
		//	Add a new item to the Dictionary.
		var b=(k in items);
		items[k]=new dojo.collections.DictionaryEntry(k,v);
		if(!b){
			this.count++;
		}
	};
	this.clear=function(){
		//	summary
		//	Clears the internal dictionary.
		items={};
		this.count=0;
	};
	this.clone=function(){
		//	summary
		//	Returns a new instance of dojo.collections.Dictionary; note the the dictionary is a clone but items might not be.
		return new dojo.collections.Dictionary(this);	//	dojo.collections.Dictionary
	};
	this.contains=this.containsKey=function(/* string */k){
		//	summary
		//	Check to see if the dictionary has an entry at key "k".
		if(testObject[k]){
			return false;			// bool
		}
		return (items[k]!=null);	//	bool
	};
	this.containsValue=function(/* object */v){
		//	summary
		//	Check to see if the dictionary has an entry with value "v".
		var e=this.getIterator();
		while(e.get()){
			if(e.element.value==v){
				return true;	//	bool
			}
		}
		return false;	//	bool
	};
	this.entry=function(/* string */k){
		//	summary
		//	Accessor method; similar to dojo.collections.Dictionary.item but returns the actual Entry object.
		return items[k];	//	dojo.collections.DictionaryEntry
	};
	this.forEach=function(/* function */ fn, /* object? */ scope){
		//	summary
		//	functional iterator, following the mozilla spec.
		var a=[];	//	Create an indexing array
		for(var p in items) {
			if(!testObject[p]){
				a.push(items[p]);	//	fill it up
			}
		}
		var s=scope||dj_global;
		if(Array.forEach){
			Array.forEach(a, fn, s);
		}else{
			for(var i=0; i<a.length; i++){
				fn.call(s, a[i], i, a);
			}
		}
	};
	this.getKeyList=function(){
		//	summary
		//	Returns an array of the keys in the dictionary.
		return (this.getIterator()).map(function(entry){ 
			return entry.key; 
		});	//	array
	};
	this.getValueList=function(){
		//	summary
		//	Returns an array of the values in the dictionary.
		return (this.getIterator()).map(function(entry){ 
			return entry.value; 
		});	//	array
	};
	this.item=function(/* string */k){
		//	summary
		//	Accessor method.
		if(k in items){
			return items[k].valueOf();	//	object
		}
		return undefined;	//	object
	};
	this.getIterator=function(){
		//	summary
		//	Gets a dojo.collections.DictionaryIterator for iteration purposes.
		return new dojo.collections.DictionaryIterator(items);	//	dojo.collections.DictionaryIterator
	};
	this.remove=function(/* string */k){
		//	summary
		//	Removes the item at k from the internal collection.
		if(k in items && !testObject[k]){
			delete items[k];
			this.count--;
			return true;	//	bool
		}
		return false;	//	bool
	};

	if (dictionary){
		var e=dictionary.getIterator();
		while(e.get()) {
			 this.add(e.element.key, e.element.value);
		}
	}
};

dojo.provide("dojo.collections.Stack");


dojo.collections.Stack=function(/* array? */arr){
	//	summary
	//	returns an object of type dojo.collections.Stack
	var q=[];
	if (arr) q=q.concat(arr);
	this.count=q.length;
	this.clear=function(){
		//	summary
		//	Clear the internal array and reset the count
		q=[];
		this.count=q.length;
	};
	this.clone=function(){
		//	summary
		//	Create and return a clone of this Stack
		return new dojo.collections.Stack(q);
	};
	this.contains=function(/* object */o){
		//	summary
		//	check to see if the stack contains object o
		for (var i=0; i<q.length; i++){
			if (q[i] == o){
				return true;	//	bool
			}
		}
		return false;	//	bool
	};
	this.copyTo=function(/* array */ arr, /* int */ i){
		//	summary
		//	copy the stack into array arr at index i
		arr.splice(i,0,q);
	};
	this.forEach=function(/* function */ fn, /* object? */ scope){
		//	summary
		//	functional iterator, following the mozilla spec.
		var s=scope||dj_global;
		if(Array.forEach){
			Array.forEach(q, fn, s);
		}else{
			for(var i=0; i<q.length; i++){
				fn.call(s, q[i], i, q);
			}
		}
	};
	this.getIterator=function(){
		//	summary
		//	get an iterator for this collection
		return new dojo.collections.Iterator(q);	//	dojo.collections.Iterator
	};
	this.peek=function(){
		//	summary
		//	Return the next item without altering the stack itself.
		return q[(q.length-1)];	//	object
	};
	this.pop=function(){
		//	summary
		//	pop and return the next item on the stack
		var r=q.pop();
		this.count=q.length;
		return r;	//	object
	};
	this.push=function(/* object */ o){
		//	summary
		//	Push object o onto the stack
		this.count=q.push(o);
	};
	this.toArray=function(){
		//	summary
		//	create and return an array based on the internal collection
		return [].concat(q);	//	array
	};
}

dojo.provide("dojo.dom");

dojo.dom.ELEMENT_NODE                  = 1;
dojo.dom.ATTRIBUTE_NODE                = 2;
dojo.dom.TEXT_NODE                     = 3;
dojo.dom.CDATA_SECTION_NODE            = 4;
dojo.dom.ENTITY_REFERENCE_NODE         = 5;
dojo.dom.ENTITY_NODE                   = 6;
dojo.dom.PROCESSING_INSTRUCTION_NODE   = 7;
dojo.dom.COMMENT_NODE                  = 8;
dojo.dom.DOCUMENT_NODE                 = 9;
dojo.dom.DOCUMENT_TYPE_NODE            = 10;
dojo.dom.DOCUMENT_FRAGMENT_NODE        = 11;
dojo.dom.NOTATION_NODE                 = 12;
	
dojo.dom.dojoml = "http://www.dojotoolkit.org/2004/dojoml";

/**
 *	comprehensive list of XML namespaces
**/
dojo.dom.xmlns = {
	//	summary
	//	aliases for various common XML namespaces
	svg : "http://www.w3.org/2000/svg",
	smil : "http://www.w3.org/2001/SMIL20/",
	mml : "http://www.w3.org/1998/Math/MathML",
	cml : "http://www.xml-cml.org",
	xlink : "http://www.w3.org/1999/xlink",
	xhtml : "http://www.w3.org/1999/xhtml",
	xul : "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
	xbl : "http://www.mozilla.org/xbl",
	fo : "http://www.w3.org/1999/XSL/Format",
	xsl : "http://www.w3.org/1999/XSL/Transform",
	xslt : "http://www.w3.org/1999/XSL/Transform",
	xi : "http://www.w3.org/2001/XInclude",
	xforms : "http://www.w3.org/2002/01/xforms",
	saxon : "http://icl.com/saxon",
	xsd : "http://www.w3.org/2001/XMLSchema",
	dt: "http://www.w3.org/2001/XMLSchema-datatypes",
	xsi : "http://www.w3.org/2001/XMLSchema-instance",
	rdf : "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
	rdfs : "http://www.w3.org/2000/01/rdf-schema#",
	dc : "http://purl.org/dc/elements/1.1/",
	dcq: "http://purl.org/dc/qualifiers/1.0",
	"soap-env" : "http://schemas.xmlsoap.org/soap/envelope/",
	wsdl : "http://schemas.xmlsoap.org/wsdl/",
	AdobeExtensions : "http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/"
};

dojo.dom.isNode = function(/* object */wh){
	//	summary:
	//		checks to see if wh is actually a node.
	if(typeof Element == "function") {
		try {
			return wh instanceof Element;	//	boolean
		} catch(e) {}
	} else {
		// best-guess
		return wh && !isNaN(wh.nodeType);	//	boolean
	}
}

dojo.dom.getUniqueId = function(){
	//	summary:
	//		returns a unique string for use with any DOM element
	var _document = dojo.doc();
	do {
		var id = "dj_unique_" + (++arguments.callee._idIncrement);
	}while(_document.getElementById(id));
	return id;	//	string
}
dojo.dom.getUniqueId._idIncrement = 0;

dojo.dom.firstElement = dojo.dom.getFirstChildElement = function(/* Element */parentNode, /* string? */tagName){
	//	summary:
	//		returns the first child element matching tagName
	var node = parentNode.firstChild;
	while(node && node.nodeType != dojo.dom.ELEMENT_NODE){
		node = node.nextSibling;
	}
	if(tagName && node && node.tagName && node.tagName.toLowerCase() != tagName.toLowerCase()) {
		node = dojo.dom.nextElement(node, tagName);
	}
	return node;	//	Element
}

dojo.dom.lastElement = dojo.dom.getLastChildElement = function(/* Element */parentNode, /* string? */tagName){
	//	summary:
	//		returns the last child element matching tagName
	var node = parentNode.lastChild;
	while(node && node.nodeType != dojo.dom.ELEMENT_NODE) {
		node = node.previousSibling;
	}
	if(tagName && node && node.tagName && node.tagName.toLowerCase() != tagName.toLowerCase()) {
		node = dojo.dom.prevElement(node, tagName);
	}
	return node;	//	Element
}

dojo.dom.nextElement = dojo.dom.getNextSiblingElement = function(/* Node */node, /* string? */tagName){
	//	summary:
	//		returns the next sibling element matching tagName
	if(!node) { return null; }
	do {
		node = node.nextSibling;
	} while(node && node.nodeType != dojo.dom.ELEMENT_NODE);

	if(node && tagName && tagName.toLowerCase() != node.tagName.toLowerCase()) {
		return dojo.dom.nextElement(node, tagName);
	}
	return node;	//	Element
}

dojo.dom.prevElement = dojo.dom.getPreviousSiblingElement = function(/* Node */node, /* string? */tagName){
	//	summary:
	//		returns the previous sibling element matching tagName
	if(!node) { return null; }
	if(tagName) { tagName = tagName.toLowerCase(); }
	do {
		node = node.previousSibling;
	} while(node && node.nodeType != dojo.dom.ELEMENT_NODE);

	if(node && tagName && tagName.toLowerCase() != node.tagName.toLowerCase()) {
		return dojo.dom.prevElement(node, tagName);
	}
	return node;	//	Element
}

// TODO: hmph
/*this.forEachChildTag = function(node, unaryFunc) {
	var child = this.getFirstChildTag(node);
	while(child) {
		if(unaryFunc(child) == "break") { break; }
		child = this.getNextSiblingTag(child);
	}
}*/

dojo.dom.moveChildren = function(/*Element*/srcNode, /*Element*/destNode, /*boolean?*/trim){
	//	summary:
	//		Moves children from srcNode to destNode and returns the count of
	//		children moved; will trim off text nodes if trim == true
	var count = 0;
	if(trim) {
		while(srcNode.hasChildNodes() &&
			srcNode.firstChild.nodeType == dojo.dom.TEXT_NODE) {
			srcNode.removeChild(srcNode.firstChild);
		}
		while(srcNode.hasChildNodes() &&
			srcNode.lastChild.nodeType == dojo.dom.TEXT_NODE) {
			srcNode.removeChild(srcNode.lastChild);
		}
	}
	while(srcNode.hasChildNodes()){
		destNode.appendChild(srcNode.firstChild);
		count++;
	}
	return count;	//	number
}

dojo.dom.copyChildren = function(/*Element*/srcNode, /*Element*/destNode, /*boolean?*/trim){
	//	summary:
	//		Copies children from srcNde to destNode and returns the count of
	//		children copied; will trim off text nodes if trim == true
	var clonedNode = srcNode.cloneNode(true);
	return this.moveChildren(clonedNode, destNode, trim);	//	number
}

dojo.dom.replaceChildren = function(/*Element*/node, /*Node*/newChild){
	//	summary:
	//		Removes all children of node and appends newChild. All the existing
	//		children will be destroyed.
	// FIXME: what if newChild is an array-like object?
	var nodes = [];
	if(dojo.render.html.ie){
		for(var i=0;i<node.childNodes.length;i++){
			nodes.push(node.childNodes[i]);
		}
	}
	dojo.dom.removeChildren(node);
	node.appendChild(newChild);
	for(var i=0;i<nodes.length;i++){
		dojo.dom.destroyNode(nodes[i]);
	}
}

dojo.dom.removeChildren = function(/*Element*/node){
	//	summary:
	//		removes all children from node and returns the count of children removed.
	//		The children nodes are not destroyed. Be sure to call destroyNode on them
	//		after they are not used anymore.
	var count = node.childNodes.length;
	while(node.hasChildNodes()){ dojo.dom.removeNode(node.firstChild); }
	return count; // int
}

dojo.dom.replaceNode = function(/*Element*/node, /*Element*/newNode){
	//	summary:
	//		replaces node with newNode and returns a reference to the removed node.
	//		To prevent IE memory leak, call destroyNode on the returned node when
	//		it is no longer needed.
	return node.parentNode.replaceChild(newNode, node); // Node
}

dojo.dom.destroyNode = function(/*Node*/node){
	// summary:
	//		destroy a node (it can not be used any more). For IE, this is the
	//		right function to call to prevent memory leaks. While for other
	//		browsers, this is identical to dojo.dom.removeNode
	if(node.parentNode){
		node = dojo.dom.removeNode(node);
	}
	if(node.nodeType != 3){ // ingore TEXT_NODE
		if(dojo.evalObjPath("dojo.event.browser.clean", false)){
			dojo.event.browser.clean(node);
		}
		if(dojo.render.html.ie){
			node.outerHTML=''; //prevent ugly IE mem leak associated with Node.removeChild (ticket #1727)
		}
	}
}

dojo.dom.removeNode = function(/*Node*/node){
	// summary:
	//		if node has a parent, removes node from parent and returns a
	//		reference to the removed child.
	//		To prevent IE memory leak, call destroyNode on the returned node when
	//		it is no longer needed.
	//	node:
	//		the node to remove from its parent.

	if(node && node.parentNode){
		// return a ref to the removed child
		return node.parentNode.removeChild(node); //Node
	}
}

dojo.dom.getAncestors = function(/*Node*/node, /*function?*/filterFunction, /*boolean?*/returnFirstHit){
	//	summary:
	//		returns all ancestors matching optional filterFunction; will return
	//		only the first if returnFirstHit
	var ancestors = [];
	var isFunction = (filterFunction && (filterFunction instanceof Function || typeof filterFunction == "function"));
	while(node){
		if(!isFunction || filterFunction(node)){
			ancestors.push(node);
		}
		if(returnFirstHit && ancestors.length > 0){ 
			return ancestors[0]; 	//	Node
		}
		
		node = node.parentNode;
	}
	if(returnFirstHit){ return null; }
	return ancestors;	//	array
}

dojo.dom.getAncestorsByTag = function(/*Node*/node, /*String*/tag, /*boolean?*/returnFirstHit){
	//	summary:
	//		returns all ancestors matching tag (as tagName), will only return
	//		first one if returnFirstHit
	tag = tag.toLowerCase();
	return dojo.dom.getAncestors(node, function(el){
		return ((el.tagName)&&(el.tagName.toLowerCase() == tag));
	}, returnFirstHit);	//	Node || array
}

dojo.dom.getFirstAncestorByTag = function(/*Node*/node, /*string*/tag){
	//	summary:
	//		Returns first ancestor of node with tag tagName
	return dojo.dom.getAncestorsByTag(node, tag, true);	//	Node
}

dojo.dom.isDescendantOf = function(/* Node */node, /* Node */ancestor, /* boolean? */guaranteeDescendant){
	//	summary
	//	Returns boolean if node is a descendant of ancestor
	// guaranteeDescendant allows us to be a "true" isDescendantOf function
	if(guaranteeDescendant && node) { node = node.parentNode; }
	while(node) {
		if(node == ancestor){ 
			return true; 	//	boolean
		}
		node = node.parentNode;
	}
	return false;	//	boolean
}

dojo.dom.innerXML = function(/*Node*/node){
	//	summary:
	//		Implementation of MS's innerXML function.
	if(node.innerXML){
		return node.innerXML;	//	string
	}else if (node.xml){
		return node.xml;		//	string
	}else if(typeof XMLSerializer != "undefined"){
		return (new XMLSerializer()).serializeToString(node);	//	string
	}
}

dojo.dom.createDocument = function(){
	//	summary:
	//		cross-browser implementation of creating an XML document object.
	var doc = null;
	var _document = dojo.doc();

	if(!dj_undef("ActiveXObject")){
		var prefixes = [ "MSXML2", "Microsoft", "MSXML", "MSXML3" ];
		for(var i = 0; i<prefixes.length; i++){
			try{
				doc = new ActiveXObject(prefixes[i]+".XMLDOM");
			}catch(e){ /* squelch */ };

			if(doc){ break; }
		}
	}else if((_document.implementation)&&
		(_document.implementation.createDocument)){
		doc = _document.implementation.createDocument("", "", null);
	}
	
	return doc;	//	DOMDocument
}

dojo.dom.createDocumentFromText = function(/*string*/str, /*string?*/mimetype){
	//	summary:
	//		attempts to create a Document object based on optional mime-type,
	//		using str as the contents of the document
	if(!mimetype){ mimetype = "text/xml"; }
	if(!dj_undef("DOMParser")){
		var parser = new DOMParser();
		return parser.parseFromString(str, mimetype);	//	DOMDocument
	}else if(!dj_undef("ActiveXObject")){
		var domDoc = dojo.dom.createDocument();
		if(domDoc){
			domDoc.async = false;
			domDoc.loadXML(str);
			return domDoc;	//	DOMDocument
		}else{
			dojo.debug("toXml didn't work?");
		}
	/*
	}else if((dojo.render.html.capable)&&(dojo.render.html.safari)){
		// FIXME: this doesn't appear to work!
		// from: http://web-graphics.com/mtarchive/001606.php
		// var xml = '<?xml version="1.0"?>'+str;
		var mtype = "text/xml";
		var xml = '<?xml version="1.0"?>'+str;
		var url = "data:"+mtype+";charset=utf-8,"+encodeURIComponent(xml);
		var req = new XMLHttpRequest();
		req.open("GET", url, false);
		req.overrideMimeType(mtype);
		req.send(null);
		return req.responseXML;
	*/
	}else{
		var _document = dojo.doc();
		if(_document.createElement){
			// FIXME: this may change all tags to uppercase!
			var tmp = _document.createElement("xml");
			tmp.innerHTML = str;
			if(_document.implementation && _document.implementation.createDocument){
				var xmlDoc = _document.implementation.createDocument("foo", "", null);
				for(var i = 0; i < tmp.childNodes.length; i++) {
					xmlDoc.importNode(tmp.childNodes.item(i), true);
				}
				return xmlDoc;	//	DOMDocument
			}
			// FIXME: probably not a good idea to have to return an HTML fragment
			// FIXME: the tmp.doc.firstChild is as tested from IE, so it may not
			// work that way across the board
			return ((tmp.document)&&
				(tmp.document.firstChild ?  tmp.document.firstChild : tmp));	//	DOMDocument
		}
	}
	return null;
}

dojo.dom.prependChild = function(/*Element*/node, /*Element*/parent){
	//	summary:
	//		prepends node to parent's children nodes
	if(parent.firstChild) {
		parent.insertBefore(node, parent.firstChild);
	} else {
		parent.appendChild(node);
	}
	return true;	//	boolean
}

dojo.dom.insertBefore = function(/*Node*/node, /*Node*/ref, /*boolean?*/force){
	//	summary:
	//		Try to insert node before ref
	if(	(force != true)&&
		(node === ref || node.nextSibling === ref)){ return false; }
	var parent = ref.parentNode;
	parent.insertBefore(node, ref);
	return true;	//	boolean
}

dojo.dom.insertAfter = function(/*Node*/node, /*Node*/ref, /*boolean?*/force){
	//	summary:
	//		Try to insert node after ref
	var pn = ref.parentNode;
	if(ref == pn.lastChild){
		if((force != true)&&(node === ref)){
			return false;	//	boolean
		}
		pn.appendChild(node);
	}else{
		return this.insertBefore(node, ref.nextSibling, force);	//	boolean
	}
	return true;	//	boolean
}

dojo.dom.insertAtPosition = function(/*Node*/node, /*Node*/ref, /*string*/position){
	//	summary:
	//		attempt to insert node in relation to ref based on position
	if((!node)||(!ref)||(!position)){ 
		return false;	//	boolean 
	}
	switch(position.toLowerCase()){
		case "before":
			return dojo.dom.insertBefore(node, ref);	//	boolean
		case "after":
			return dojo.dom.insertAfter(node, ref);		//	boolean
		case "first":
			if(ref.firstChild){
				return dojo.dom.insertBefore(node, ref.firstChild);	//	boolean
			}else{
				ref.appendChild(node);
				return true;	//	boolean
			}
			break;
		default: // aka: last
			ref.appendChild(node);
			return true;	//	boolean
	}
}

dojo.dom.insertAtIndex = function(/*Node*/node, /*Element*/containingNode, /*number*/insertionIndex){
	//	summary:
	//		insert node into child nodes nodelist of containingNode at
	//		insertionIndex. insertionIndex should be between 0 and 
	//		the number of the childNodes in containingNode. insertionIndex
	//		specifys after how many childNodes in containingNode the node
	//		shall be inserted. If 0 is given, node will be appended to 
	//		containingNode.
	var siblingNodes = containingNode.childNodes;

	// if there aren't any kids yet, just add it to the beginning

	if (!siblingNodes.length || siblingNodes.length == insertionIndex){
		containingNode.appendChild(node);
		return true;	//	boolean
	}

	if(insertionIndex == 0){
		return dojo.dom.prependChild(node, containingNode);	//	boolean
	}
	// otherwise we need to walk the childNodes
	// and find our spot

	return dojo.dom.insertAfter(node, siblingNodes[insertionIndex-1]);	//	boolean
}
	
dojo.dom.textContent = function(/*Node*/node, /*string*/text){
	//	summary:
	//		implementation of the DOM Level 3 attribute; scan node for text
	if (arguments.length>1) {
		var _document = dojo.doc();
		dojo.dom.replaceChildren(node, _document.createTextNode(text));
		return text;	//	string
	} else {
		if(node.textContent != undefined){ //FF 1.5
			return node.textContent;	//	string
		}
		var _result = "";
		if (node == null) { return _result; }
		for (var i = 0; i < node.childNodes.length; i++) {
			switch (node.childNodes[i].nodeType) {
				case 1: // ELEMENT_NODE
				case 5: // ENTITY_REFERENCE_NODE
					_result += dojo.dom.textContent(node.childNodes[i]);
					break;
				case 3: // TEXT_NODE
				case 2: // ATTRIBUTE_NODE
				case 4: // CDATA_SECTION_NODE
					_result += node.childNodes[i].nodeValue;
					break;
				default:
					break;
			}
		}
		return _result;	//	string
	}
}

dojo.dom.hasParent = function(/*Node*/node){
	//	summary:
	//		returns whether or not node is a child of another node.
	return Boolean(node && node.parentNode && dojo.dom.isNode(node.parentNode));	//	boolean
}

/**
 * Examples:
 *
 * myFooNode = <foo />
 * isTag(myFooNode, "foo"); // returns "foo"
 * isTag(myFooNode, "bar"); // returns ""
 * isTag(myFooNode, "FOO"); // returns ""
 * isTag(myFooNode, "hey", "foo", "bar"); // returns "foo"
**/
dojo.dom.isTag = function(/* Node */node /* ... */){
	//	summary:
	//		determines if node has any of the provided tag names and returns
	//		the tag name that matches, empty string otherwise.
	if(node && node.tagName) {
		for(var i=1; i<arguments.length; i++){
			if(node.tagName==String(arguments[i])){
				return String(arguments[i]);	//	string
			}
		}
	}
	return "";	//	string
}

dojo.dom.setAttributeNS = function(	/*Element*/elem, /*string*/namespaceURI, 
									/*string*/attrName, /*string*/attrValue){
	//	summary:
	//		implementation of DOM2 setAttributeNS that works cross browser.
	if(elem == null || ((elem == undefined)&&(typeof elem == "undefined"))){
		dojo.raise("No element given to dojo.dom.setAttributeNS");
	}
	
	if(!((elem.setAttributeNS == undefined)&&(typeof elem.setAttributeNS == "undefined"))){ // w3c
		elem.setAttributeNS(namespaceURI, attrName, attrValue);
	}else{ // IE
		// get a root XML document
		var ownerDoc = elem.ownerDocument;
		var attribute = ownerDoc.createNode(
			2, // node type
			attrName,
			namespaceURI
		);
		
		// set value
		attribute.nodeValue = attrValue;
		
		// attach to element
		elem.setAttributeNode(attribute);
	}
}

dojo.provide("dojo.lang.common");

dojo.lang.inherits = function(/*Function*/subclass, /*Function*/superclass){
	// summary: Set up inheritance between two classes.
	if(!dojo.lang.isFunction(superclass)){ 
		dojo.raise("dojo.inherits: superclass argument ["+superclass+"] must be a function (subclass: ["+subclass+"']");
	}
	subclass.prototype = new superclass();
	subclass.prototype.constructor = subclass;
	subclass.superclass = superclass.prototype;
	// DEPRECATED: super is a reserved word, use 'superclass'
	subclass['super'] = superclass.prototype;
}

dojo.lang._mixin = function(/*Object*/ obj, /*Object*/ props){
	// summary:
	//		Adds all properties and methods of props to obj. This addition is
	//		"prototype extension safe", so that instances of objects will not
	//		pass along prototype defaults.
	var tobj = {};
	for(var x in props){
		// the "tobj" condition avoid copying properties in "props"
		// inherited from Object.prototype.  For example, if obj has a custom
		// toString() method, don't overwrite it with the toString() method
		// that props inherited from Object.protoype
		if((typeof tobj[x] == "undefined") || (tobj[x] != props[x])){
			obj[x] = props[x];
		}
	}
	// IE doesn't recognize custom toStrings in for..in
	if(dojo.render.html.ie 
		&& (typeof(props["toString"]) == "function")
		&& (props["toString"] != obj["toString"])
		&& (props["toString"] != tobj["toString"]))
	{
		obj.toString = props.toString;
	}
	return obj; // Object
}

dojo.lang.mixin = function(/*Object*/obj, /*Object...*/props){
	// summary:	Adds all properties and methods of props to obj. 
	for(var i=1, l=arguments.length; i<l; i++){
		dojo.lang._mixin(obj, arguments[i]);
	}
	return obj; // Object
}

dojo.lang.extend = function(/*Object*/ constructor, /*Object...*/ props){
	// summary:
	//		Adds all properties and methods of props to constructor's
	//		prototype, making them available to all instances created with
	//		constructor.
	for(var i=1, l=arguments.length; i<l; i++){
		dojo.lang._mixin(constructor.prototype, arguments[i]);
	}
	return constructor; // Object
}

// Promote to dojo module
dojo.inherits = dojo.lang.inherits;
//dojo.lang._mixin = dojo.lang._mixin;
dojo.mixin = dojo.lang.mixin;
dojo.extend = dojo.lang.extend;

dojo.lang.find = function(	/*Array*/		array, 
							/*Object*/		value,
							/*Boolean?*/	identity,
							/*Boolean?*/	findLast){
	// summary:	
	//		Return the index of value in array, returning -1 if not found.
	// array: just what you think
	// value: the value to locate
	// identity: 
	//		If true, matches with identity comparison (===). If false, uses
	//		normal comparison (==).
	// findLast: 
	//		If true, returns index of last instance of value.
	// examples:
	//		find(array, value[, identity [findLast]]) // recommended
 	//		find(value, array[, identity [findLast]]) // deprecated
							
	// support both (array, value) and (value, array)
	if(!dojo.lang.isArrayLike(array) && dojo.lang.isArrayLike(value)) {
		dojo.deprecated('dojo.lang.find(value, array)', 'use dojo.lang.find(array, value) instead', "0.5");
		var temp = array;
		array = value;
		value = temp;
	}
	var isString = dojo.lang.isString(array);
	if(isString) { array = array.split(""); }

	if(findLast) {
		var step = -1;
		var i = array.length - 1;
		var end = -1;
	} else {
		var step = 1;
		var i = 0;
		var end = array.length;
	}
	if(identity){
		while(i != end) {
			if(array[i] === value){ return i; }
			i += step;
		}
	}else{
		while(i != end) {
			if(array[i] == value){ return i; }
			i += step;
		}
	}
	return -1;	// number
}

dojo.lang.indexOf = dojo.lang.find;

dojo.lang.findLast = function(/*Array*/array, /*Object*/value, /*boolean?*/identity){
	// summary:
	//		Return index of last occurance of value in array, returning -1 if
	//		not found. This is a shortcut for dojo.lang.find() with a true
	//		value for its "findLast" parameter.
	// identity:
	//		If true, matches with identity comparison (===). If false, uses
	//		normal comparison (==).
	return dojo.lang.find(array, value, identity, true); // number
}

dojo.lang.lastIndexOf = dojo.lang.findLast;

dojo.lang.inArray = function(array /*Array*/, value /*Object*/){
	// summary:	Return true if value is present in array.
	return dojo.lang.find(array, value) > -1; // boolean
}

/**
 * Partial implmentation of is* functions from
 * http://www.crockford.com/javascript/recommend.html
 * NOTE: some of these may not be the best thing to use in all situations
 * as they aren't part of core JS and therefore can't work in every case.
 * See WARNING messages inline for tips.
 *
 * The following is* functions are fairly "safe"
 */

dojo.lang.isObject = function(/*anything*/ it){
	// summary:	Return true if it is an Object, Array or Function.
	if(typeof it == "undefined"){ return false; }
	return (typeof it == "object" || it === null || dojo.lang.isArray(it) || dojo.lang.isFunction(it)); // Boolean
}

dojo.lang.isArray = function(/*anything*/ it){
	// summary:	Return true if it is an Array.
	return (it && it instanceof Array || typeof it == "array"); // Boolean
}

dojo.lang.isArrayLike = function(/*anything*/ it){
	// summary:	
	//		Return true if it can be used as an array (i.e. is an object with
	//		an integer length property).
	if((!it)||(dojo.lang.isUndefined(it))){ return false; }
	if(dojo.lang.isString(it)){ return false; }
	if(dojo.lang.isFunction(it)){ return false; } // keeps out built-in constructors (Number, String, ...) which have length properties
	if(dojo.lang.isArray(it)){ return true; }
	// form node itself is ArrayLike, but not always iterable. Use form.elements instead.
	if((it.tagName)&&(it.tagName.toLowerCase()=='form')){ return false; }
	if(dojo.lang.isNumber(it.length) && isFinite(it.length)){ return true; }
	return false; // Boolean
}

dojo.lang.isFunction = function(/*anything*/ it){
	// summary:	Return true if it is a Function.
	return (it instanceof Function || typeof it == "function"); // Boolean
};

(function(){
	// webkit treats NodeList as a function, which is bad
	if((dojo.render.html.capable)&&(dojo.render.html["safari"])){
		dojo.lang.isFunction = function(/*anything*/ it){
			if((typeof(it) == "function") && (it == "[object NodeList]")) { return false; }
			return (it instanceof Function || typeof it == "function"); // Boolean
		}
	}
})();

dojo.lang.isString = function(/*anything*/ it){
	// summary:	Return true if it is a String.
	return (typeof it == "string" || it instanceof String);
}

dojo.lang.isAlien = function(/*anything*/ it){
	// summary: Return true if it is not a built-in function. False if not.
	if(!it){ return false; }
	return !dojo.lang.isFunction(it) && /\{\s*\[native code\]\s*\}/.test(String(it)); // Boolean
}

dojo.lang.isBoolean = function(/*anything*/ it){
	// summary:	Return true if it is a Boolean.
	return (it instanceof Boolean || typeof it == "boolean"); // Boolean
}

/**
 * The following is***() functions are somewhat "unsafe". Fortunately,
 * there are workarounds the the language provides and are mentioned
 * in the WARNING messages.
 *
 */
dojo.lang.isNumber = function(/*anything*/ it){
	// summary:	Return true if it is a number.
	// description: 
	//		WARNING - In most cases, isNaN(it) is sufficient to determine whether or not
	// 		something is a number or can be used as such. For example, a number or string
	// 		can be used interchangably when accessing array items (array["1"] is the same as
	// 		array[1]) and isNaN will return false for both values ("1" and 1). However,
	// 		isNumber("1")  will return false, which is generally not too useful.
	// 		Also, isNumber(NaN) returns true, again, this isn't generally useful, but there
	// 		are corner cases (like when you want to make sure that two things are really
	// 		the same type of thing). That is really where isNumber "shines".
	//
	// Recommendation - Use isNaN(it) when possible
	
	return (it instanceof Number || typeof it == "number"); // Boolean
}

/*
 * FIXME: Should isUndefined go away since it is error prone?
 */
dojo.lang.isUndefined = function(/*anything*/ it){
	// summary: Return true if it is not defined.
	// description: 
	//		WARNING - In some cases, isUndefined will not behave as you
	// 		might expect. If you do isUndefined(foo) and there is no earlier
	// 		reference to foo, an error will be thrown before isUndefined is
	// 		called. It behaves correctly if you scope yor object first, i.e.
	// 		isUndefined(foo.bar) where foo is an object and bar isn't a
	// 		property of the object.
	//
	// Recommendation - Use typeof foo == "undefined" when possible

	return ((typeof(it) == "undefined")&&(it == undefined)); // Boolean
}

// end Crockford functions

dojo.provide("dojo.lang.array");



// FIXME: Is this worthless since you can do: if(name in obj)
// is this the right place for this?

dojo.lang.mixin(dojo.lang, {
	has: function(/*Object*/obj, /*String*/name){
		// summary: is there a property with the passed name in obj?
		try{
			return typeof obj[name] != "undefined"; // Boolean
		}catch(e){ return false; } // Boolean
	},

	isEmpty: function(/*Object*/obj){
		// summary:
		//		can be used to determine if the passed object is "empty". In
		//		the case of array-like objects, the length, property is
		//		examined, but for other types of objects iteration is used to
		//		examine the iterable "surface area" to determine if any
		//		non-prototypal properties have been assigned. This iteration is
		//		prototype-extension safe.
		if(dojo.lang.isObject(obj)){
			var tmp = {};
			var count = 0;
			for(var x in obj){
				if(obj[x] && (!tmp[x])){
					count++;
					break;
				} 
			}
			return count == 0; // boolean
		}else if(dojo.lang.isArrayLike(obj) || dojo.lang.isString(obj)){
			return obj.length == 0; // boolean
		}
	},

	map: function(/*Array*/arr, /*Object|Function*/obj, /*Function?*/unary_func){
		// summary:
		//		returns a new array constituded from the return values of
		//		passing each element of arr into unary_func. The obj parameter
		//		may be passed to enable the passed function to be called in
		//		that scope. In environments that support JavaScript 1.6, this
		//		function is a passthrough to the built-in map() function
		//		provided by Array instances. For details on this, see:
		// 			http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:map
		// examples:
		//		dojo.lang.map([1, 2, 3, 4], function(item){ return item+1 });
		//		// returns [2, 3, 4, 5]
		var isString = dojo.lang.isString(arr);
		if(isString){
			// arr: String
			arr = arr.split("");
		}
		if(dojo.lang.isFunction(obj)&&(!unary_func)){
			unary_func = obj;
			obj = dj_global;
		}else if(dojo.lang.isFunction(obj) && unary_func){
			// ff 1.5 compat
			var tmpObj = obj;
			obj = unary_func;
			unary_func = tmpObj;
		}
		if(Array.map){
			var outArr = Array.map(arr, unary_func, obj);
		}else{
			var outArr = [];
			for(var i=0;i<arr.length;++i){
				outArr.push(unary_func.call(obj, arr[i]));
			}
		}
		if(isString) {
			return outArr.join(""); // String
		} else {
			return outArr; // Array
		}
	},

	reduce: function(/*Array*/arr, initialValue, /*Object|Function*/obj, /*Function*/binary_func){
		// summary:
		// 		similar to Python's builtin reduce() function. The result of
		// 		the previous computation is passed as the first argument to
		// 		binary_func along with the next value from arr. The result of
		// 		this call is used along with the subsequent value from arr, and
		// 		this continues until arr is exhausted. The return value is the
		// 		last result. The "obj" and "initialValue" parameters may be
		// 		safely omitted and the order of obj and binary_func may be
		// 		reversed. The default order of the obj and binary_func argument
		// 		will probably be reversed in a future release, and this call
		// 		order is supported today.
		// examples:
		//		dojo.lang.reduce([1, 2, 3, 4], function(last, next){ return last+next});
		//		returns 10
		var reducedValue = initialValue;
		if(arguments.length == 2){
			binary_func = initialValue;
			reducedValue = arr[0];
			arr = arr.slice(1);
		}else if(arguments.length == 3){
			if(dojo.lang.isFunction(obj)){
				binary_func = obj;
				obj = null;
			}
		}else{
			// un-fsck the default order
			// FIXME:
			//		could be wrong for some strange function object cases. Not
			//		sure how to test for them.
			if(dojo.lang.isFunction(obj)){
				var tmp = binary_func;
				binary_func = obj;
				obj = tmp;
			}
		}

		var ob = obj || dj_global;
		dojo.lang.map(arr, 
			function(val){
				reducedValue = binary_func.call(ob, reducedValue, val);
			}
		);
		return reducedValue;
	},

	forEach: function(/*Array*/anArray, /*Function*/callback, /*Object?*/thisObject){
		// summary:
		//		for every item in anArray, call callback with that item as its
		//		only parameter. Return values are ignored. This funciton
		//		corresponds (and wraps) the JavaScript 1.6 forEach method. For
		//		more details, see:
		//			http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:forEach
		if(dojo.lang.isString(anArray)){
			// anArray: String
			anArray = anArray.split(""); 
		}
		if(Array.forEach){
			Array.forEach(anArray, callback, thisObject);
		}else{
			// FIXME: there are several ways of handilng thisObject. Is dj_global always the default context?
			if(!thisObject){
				thisObject=dj_global;
			}
			for(var i=0,l=anArray.length; i<l; i++){ 
				callback.call(thisObject, anArray[i], i, anArray);
			}
		}
	},

	_everyOrSome: function(/*Boolean*/every, /*Array*/arr, /*Function*/callback, /*Object?*/thisObject){
		if(dojo.lang.isString(arr)){ 
			//arr: String
			arr = arr.split(""); 
		}
		if(Array.every){
			return Array[ every ? "every" : "some" ](arr, callback, thisObject);
		}else{
			if(!thisObject){
				thisObject = dj_global;
			}
			for(var i=0,l=arr.length; i<l; i++){
				var result = callback.call(thisObject, arr[i], i, arr);
				if(every && !result){
					return false; // Boolean
				}else if((!every)&&(result)){
					return true; // Boolean
				}
			}
			return Boolean(every); // Boolean
		}
	},

	every: function(/*Array*/arr, /*Function*/callback, /*Object?*/thisObject){
		// summary:
		//		determines whether or not every item in the array satisfies the
		//		condition implemented by callback. thisObject may be used to
		//		scope the call to callback. The function signature is derived
		//		from the JavaScript 1.6 Array.every() function. More
		//		information on this can be found here:
		//			http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:every
		// examples:
		//		dojo.lang.every([1, 2, 3, 4], function(item){ return item>1; });
		//		// returns false
		//		dojo.lang.every([1, 2, 3, 4], function(item){ return item>0; });
		//		// returns true 
		return this._everyOrSome(true, arr, callback, thisObject); // Boolean
	},

	some: function(/*Array*/arr, /*Function*/callback, /*Object?*/thisObject){
		// summary:
		//		determines whether or not any item in the array satisfies the
		//		condition implemented by callback. thisObject may be used to
		//		scope the call to callback. The function signature is derived
		//		from the JavaScript 1.6 Array.some() function. More
		//		information on this can be found here:
		//			http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:some
		// examples:
		//		dojo.lang.some([1, 2, 3, 4], function(item){ return item>1; });
		//		// returns true
		//		dojo.lang.some([1, 2, 3, 4], function(item){ return item<1; });
		//		// returns false
		return this._everyOrSome(false, arr, callback, thisObject); // Boolean
	},

	filter: function(/*Array*/arr, /*Function*/callback, /*Object?*/thisObject){
		// summary:
		//		returns a new Array with those items from arr that match the
		//		condition implemented by callback.thisObject may be used to
		//		scope the call to callback. The function signature is derived
		//		from the JavaScript 1.6 Array.filter() function, although
		//		special accomidation is made in our implementation for strings.
		//		More information on the JS 1.6 API can be found here:
		//			http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:filter
		// examples:
		//		dojo.lang.some([1, 2, 3, 4], function(item){ return item>1; });
		//		// returns [2, 3, 4]
		var isString = dojo.lang.isString(arr);
		if(isString){ /*arr: String*/arr = arr.split(""); }
		var outArr;
		if(Array.filter){
			outArr = Array.filter(arr, callback, thisObject);
		}else{
			if(!thisObject){
				if(arguments.length >= 3){ dojo.raise("thisObject doesn't exist!"); }
				thisObject = dj_global;
			}

			outArr = [];
			for(var i = 0; i < arr.length; i++){
				if(callback.call(thisObject, arr[i], i, arr)){
					outArr.push(arr[i]);
				}
			}
		}
		if(isString){
			return outArr.join(""); // String
		} else {
			return outArr; // Array
		}
	},

	unnest: function(/* ... */){
		// summary:
		//		Creates a 1-D array out of all the arguments passed,
		//		unravelling any array-like objects in the process
		// usage:
		//		unnest(1, 2, 3) ==> [1, 2, 3]
		//		unnest(1, [2, [3], [[[4]]]]) ==> [1, 2, 3, 4]

		var out = [];
		for(var i = 0; i < arguments.length; i++){
			if(dojo.lang.isArrayLike(arguments[i])){
				var add = dojo.lang.unnest.apply(this, arguments[i]);
				out = out.concat(add);
			}else{
				out.push(arguments[i]);
			}
		}
		return out; // Array
	},

	toArray: function(/*Object*/arrayLike, /*Number*/startOffset){
		// summary:
		//		Converts an array-like object (i.e. arguments, DOMCollection)
		//		to an array. Returns a new Array object.
		var array = [];
		for(var i = startOffset||0; i < arrayLike.length; i++){
			array.push(arrayLike[i]);
		}
		return array; // Array
	}
});

dojo.provide("dojo.lang.extras");



dojo.lang.setTimeout = function(/*Function*/func, /*int*/delay /*, ...*/){
	// summary:
	//		Sets a timeout in milliseconds to execute a function in a given
	//		context with optional arguments.
	// usage:
	//		dojo.lang.setTimeout(Object context, function func, number delay[, arg1[, ...]]);
	//		dojo.lang.setTimeout(function func, number delay[, arg1[, ...]]);

	var context = window, argsStart = 2;
	if(!dojo.lang.isFunction(func)){
		context = func;
		func = delay;
		delay = arguments[2];
		argsStart++;
	}

	if(dojo.lang.isString(func)){
		func = context[func];
	}
	
	var args = [];
	for (var i = argsStart; i < arguments.length; i++){
		args.push(arguments[i]);
	}
	return dojo.global().setTimeout(function(){ func.apply(context, args); }, delay); // int
}

dojo.lang.clearTimeout = function(/*int*/timer){
	// summary: clears timer by number from the execution queue

	// FIXME:
	//		why do we have this function? It's not portable outside of browser
	//		environments and it's a stupid wrapper on something that browsers
	//		provide anyway.
	dojo.global().clearTimeout(timer);
}

dojo.lang.getNameInObj = function(/*Object*/ns, /*unknown*/item){
	// summary: 
	//		looks for a value in the object ns with a value matching item and
	//		returns the property name
	// ns: if null, dj_global is used
	// item: value to return a name for
	if(!ns){ ns = dj_global; }

	for(var x in ns){
		if(ns[x] === item){
			return new String(x); // String
		}
	}
	return null; // null
}

dojo.lang.shallowCopy = function(/*Object*/obj, /*Boolean?*/deep){
	// summary:
	//		copies object obj one level deep, or full depth if deep is true
	var i, ret;	

	if(obj === null){ /*obj: null*/ return null; } // null
	
	if(dojo.lang.isObject(obj)){
		// obj: Object	
		ret = new obj.constructor();
		for(i in obj){
			if(dojo.lang.isUndefined(ret[i])){
				ret[i] = deep ? dojo.lang.shallowCopy(obj[i], deep) : obj[i];
			}
		}
	}else if(dojo.lang.isArray(obj)){
		// obj: Array
		ret = [];
		for(i=0; i<obj.length; i++){
			ret[i] = deep ? dojo.lang.shallowCopy(obj[i], deep) : obj[i];
		}
	}else{
		// obj: Object
		ret = obj;
	}

	return ret; // Object
}

dojo.lang.firstValued = function(/* ... */){
	// summary: Return the first argument that isn't undefined

	for(var i = 0; i < arguments.length; i++){
		if(typeof arguments[i] != "undefined"){
			return arguments[i]; // Object
		}
	}
	return undefined; // undefined
}

dojo.lang.getObjPathValue = function(/*String*/objpath, /*Object?*/context, /*Boolean?*/create){
	// summary:
	//		Gets a value from a reference specified as a string descriptor,
	//		(e.g. "A.B") in the given context.
	// context: if not specified, dj_global is used
	// create: if true, undefined objects in the path are created.
	with(dojo.parseObjPath(objpath, context, create)){
		return dojo.evalProp(prop, obj, create); // Object
	}
}

dojo.lang.setObjPathValue = function(/*String*/objpath, /*anything*/value, /*Object?*/context, /*Boolean?*/create){
	// summary:
	//		Sets a value on a reference specified as a string descriptor.
	//		(e.g. "A.B") in the given context. This is similar to straight
	//		assignment, except that the object structure in question can
	//		optionally be created if it does not exist.
	//	context: if not specified, dj_global is used
	//	create: if true, undefined objects in the path are created.

	// FIXME: why is this function valuable? It should be scheduled for
	// removal on the grounds that dojo.parseObjPath does most of it's work and
	// is more straightforward and has fewer dependencies. Also, the order of
	// arguments is bone-headed. "context" should clearly come after "create".
	// *sigh*
	dojo.deprecated("dojo.lang.setObjPathValue", "use dojo.parseObjPath and the '=' operator", "0.6");

	if(arguments.length < 4){
		create = true;
	}
	with(dojo.parseObjPath(objpath, context, create)){
		if(obj && (create || (prop in obj))){
			obj[prop] = value;
		}
	}
}

dojo.provide("dojo.lang.func");


dojo.lang.hitch = function(/*Object*/thisObject, /*Function|String*/method /*, ...*/){
	// summary: 
	//		Returns a function that will only ever execute in the a given scope
	//		(thisObject). This allows for easy use of object member functions
	//		in callbacks and other places in which the "this" keyword may
	//		otherwise not reference the expected scope. Any number of default
	//		positional arguments may be passed as parameters beyond "method".
	//		Each of these values will be used to "placehold" (similar to curry)
	//		for the hitched function. Note that the order of arguments may be
	//		reversed in a future version.
	// thisObject: the scope to run the method in
	// method:
	//		a function to be "bound" to thisObject or the name of the method in
	//		thisObject to be used as the basis for the binding
	// usage:
	//		dojo.lang.hitch(foo, "bar")(); // runs foo.bar() in the scope of foo
	//		dojo.lang.hitch(foo, myFunction); // returns a function that runs myFunction in the scope of foo

	var args = [];
	for(var x=2; x<arguments.length; x++){
		args.push(arguments[x]);
	}
	var fcn = (dojo.lang.isString(method) ? thisObject[method] : method) || function(){};
	return function(){
		var ta = args.concat([]); // make a copy
		for(var x=0; x<arguments.length; x++){
			ta.push(arguments[x]);
		}
		return fcn.apply(thisObject, ta); // Function
		// return fcn.apply(thisObject, arguments); // Function
	};
}

dojo.lang.anonCtr = 0;
dojo.lang.anon = {};

dojo.lang.nameAnonFunc = function(/*Function*/anonFuncPtr, /*Object*/thisObj, /*Boolean*/searchForNames){
	// summary:
	//		Creates a reference to anonFuncPtr in thisObj with a completely
	//		unique name. The new name is returned as a String.  If
	//		searchForNames is true, an effort will be made to locate an
	//		existing reference to anonFuncPtr in thisObj, and if one is found,
	//		the existing name will be returned instead. The default is for
	//		searchForNames to be false.
	var nso = (thisObj|| dojo.lang.anon);
	if( (searchForNames) ||
		((dj_global["djConfig"])&&(djConfig["slowAnonFuncLookups"] == true)) ){
		for(var x in nso){
			try{
				if(nso[x] === anonFuncPtr){
					return x;
				}
			}catch(e){} // window.external fails in IE embedded in Eclipse (Eclipse bug #151165)
		}
	}
	var ret = "__"+dojo.lang.anonCtr++;
	while(typeof nso[ret] != "undefined"){
		ret = "__"+dojo.lang.anonCtr++;
	}
	nso[ret] = anonFuncPtr;
	return ret; // String
}

dojo.lang.forward = function(funcName){
	// summary:
	// 		Returns a function that forwards a method call to
	// 		this.funcName(...).  Unlike dojo.lang.hitch(), the "this" scope is
	// 		not fixed on a single object. Ported from MochiKit.
	return function(){
		return this[funcName].apply(this, arguments);
	}; // Function
}

dojo.lang.curry = function(thisObj, func /* args ... */){
	// summary:
	//		similar to the curry() method found in many functional programming
	//		environments, this function returns an "argument accumulator"
	//		function, bound to a particular scope, and "primed" with a variable
	//		number of arguments. The curry method is unique in that it returns
	//		a function that may return other "partial" function which can be
	//		called repeatedly. New functions are returned until the arity of
	//		the original function is reached, at which point the underlying
	//		function (func) is called in the scope thisObj with all of the
	//		accumulated arguments (plus any extras) in positional order.
	// examples:
	//		assuming a function defined like this:
	//			var foo = {
	//				bar: function(arg1, arg2, arg3){
	//					dojo.debug.apply(dojo, arguments);
	//				}
	//			};
	//		
	//		dojo.lang.curry() can be used most simply in this way:
	//		
	//			tmp = dojo.lang.curry(foo, foo.bar, "arg one", "thinger");
	//			tmp("blah", "this is superfluous");
	//			// debugs: "arg one thinger blah this is superfluous"
	//			tmp("blah");
	//			// debugs: "arg one thinger blah"
	//			tmp();
	//			// returns a function exactly like tmp that expects one argument
	//
	//		other intermittent functions could be created until the 3
	//		positional arguments are filled:
	//
	//			tmp = dojo.lang.curry(foo, foo.bar, "arg one");
	//			tmp2 = tmp("arg two");
	//			tmp2("blah blah");
	//			// debugs: "arg one arg two blah blah"
	//			tmp2("oy");
	//			// debugs: "arg one arg two oy"
	//
	//		curry() can also be used to call the function if enough arguments
	//		are passed in the initial invocation:
	//
	//			dojo.lang.curry(foo, foo.bar, "one", "two", "three", "four");
	//			// debugs: "one two three four"
	//			dojo.lang.curry(foo, foo.bar, "one", "two", "three");
	//			// debugs: "one two three"


	// FIXME: the order of func and thisObj should be changed!!!
	var outerArgs = [];
	thisObj = thisObj||dj_global;
	if(dojo.lang.isString(func)){
		func = thisObj[func];
	}
	for(var x=2; x<arguments.length; x++){
		outerArgs.push(arguments[x]);
	}
	// since the event system replaces the original function with a new
	// join-point runner with an arity of 0, we check to see if it's left us
	// any clues about the original arity in lieu of the function's actual
	// length property
	var ecount = (func["__preJoinArity"]||func.length) - outerArgs.length;
	// borrowed from svend tofte
	function gather(nextArgs, innerArgs, expected){
		var texpected = expected;
		var totalArgs = innerArgs.slice(0); // copy
		for(var x=0; x<nextArgs.length; x++){
			totalArgs.push(nextArgs[x]);
		}
		// check the list of provided nextArgs to see if it, plus the
		// number of innerArgs already supplied, meets the total
		// expected.
		expected = expected-nextArgs.length;
		if(expected<=0){
			var res = func.apply(thisObj, totalArgs);
			expected = texpected;
			return res;
		}else{
			return function(){
				return gather(arguments,// check to see if we've been run
										// with enough args
							totalArgs,	// a copy
							expected);	// how many more do we need to run?;
			};
		}
	}
	return gather([], outerArgs, ecount);
}

dojo.lang.curryArguments = function(/*Object*/thisObj, /*Function*/func, /*Array*/args, /*Integer, optional*/offset){
	// summary:
	//		similar to dojo.lang.curry(), except that a list of arguments to
	//		start the curry with may be provided as an array instead of as
	//		positional arguments. An offset may be specified from the 0 index
	//		to skip some elements in args.
	var targs = [];
	var x = offset||0;
	for(x=offset; x<args.length; x++){
		targs.push(args[x]); // ensure that it's an arr
	}
	return dojo.lang.curry.apply(dojo.lang, [thisObj, func].concat(targs));
}

dojo.lang.tryThese = function(/*...*/){
	// summary:
	//		executes each function argument in turn, returning the return value
	//		from the first one which does not throw an exception in execution.
	//		Any number of functions may be passed.
	for(var x=0; x<arguments.length; x++){
		try{
			if(typeof arguments[x] == "function"){
				var ret = (arguments[x]());
				if(ret){
					return ret;
				}
			}
		}catch(e){
			dojo.debug(e);
		}
	}
}

dojo.lang.delayThese = function(/*Array*/farr, /*Function, optional*/cb, /*Integer*/delay, /*Function, optional*/onend){
	// summary:
	//		executes a series of functions contained in farr, but spaces out
	//		calls to each function by the millisecond delay provided. If cb is
	//		provided, it will be called directly after each item in farr is
	//		called and if onend is passed, it will be called when all items
	//		have completed executing.

	/**
	 * alternate: (array funcArray, function callback, function onend)
	 * alternate: (array funcArray, function callback)
	 * alternate: (array funcArray)
	 */
	if(!farr.length){ 
		if(typeof onend == "function"){
			onend();
		}
		return;
	}
	if((typeof delay == "undefined")&&(typeof cb == "number")){
		delay = cb;
		cb = function(){};
	}else if(!cb){
		cb = function(){};
		if(!delay){ delay = 0; }
	}
	setTimeout(function(){
		(farr.shift())();
		cb();
		dojo.lang.delayThese(farr, cb, delay, onend);
	}, delay);
}

dojo.provide("dojo.event.common");





// TODO: connection filter functions
//			these are functions that accept a method invocation (like around
//			advice) and return a boolean based on it. That value determines
//			whether or not the connection proceeds. It could "feel" like around
//			advice for those who know what it is (calling proceed() or not),
//			but I think presenting it as a "filter" and/or calling it with the
//			function args and not the MethodInvocation might make it more
//			palletable to "normal" users than around-advice currently is
// TODO: execution scope mangling
//			YUI's event facility by default executes listeners in the context
//			of the source object. This is very odd, but should probably be
//			supported as an option (both for the source and for the dest). It
//			can be thought of as a connection-specific hitch().
// TODO: more resiliency for 4+ arguments to connect()

dojo.event = new function(){
	this._canTimeout = dojo.lang.isFunction(dj_global["setTimeout"])||dojo.lang.isAlien(dj_global["setTimeout"]);

	// FIXME: where should we put this method (not here!)?
	function interpolateArgs(args, searchForNames){
		var dl = dojo.lang;
		var ao = {
			srcObj: dj_global,
			srcFunc: null,
			adviceObj: dj_global,
			adviceFunc: null,
			aroundObj: null,
			aroundFunc: null,
			adviceType: (args.length>2) ? args[0] : "after",
			precedence: "last",
			once: false,
			delay: null,
			rate: 0,
			adviceMsg: false,
			maxCalls: -1
		};

		switch(args.length){
			case 0: return;
			case 1: return;
			case 2:
				ao.srcFunc = args[0];
				ao.adviceFunc = args[1];
				break;
			case 3:
				if((dl.isObject(args[0]))&&(dl.isString(args[1]))&&(dl.isString(args[2]))){
					ao.adviceType = "after";
					ao.srcObj = args[0];
					ao.srcFunc = args[1];
					ao.adviceFunc = args[2];
				}else if((dl.isString(args[1]))&&(dl.isString(args[2]))){
					ao.srcFunc = args[1];
					ao.adviceFunc = args[2];
				}else if((dl.isObject(args[0]))&&(dl.isString(args[1]))&&(dl.isFunction(args[2]))){
					ao.adviceType = "after";
					ao.srcObj = args[0];
					ao.srcFunc = args[1];
					var tmpName  = dl.nameAnonFunc(args[2], ao.adviceObj, searchForNames);
					ao.adviceFunc = tmpName;
				}else if((dl.isFunction(args[0]))&&(dl.isObject(args[1]))&&(dl.isString(args[2]))){
					ao.adviceType = "after";
					ao.srcObj = dj_global;
					var tmpName  = dl.nameAnonFunc(args[0], ao.srcObj, searchForNames);
					ao.srcFunc = tmpName;
					ao.adviceObj = args[1];
					ao.adviceFunc = args[2];
				}
				break;
			case 4:
				if((dl.isObject(args[0]))&&(dl.isObject(args[2]))){
					// we can assume that we've got an old-style "connect" from
					// the sigslot school of event attachment. We therefore
					// assume after-advice.
					ao.adviceType = "after";
					ao.srcObj = args[0];
					ao.srcFunc = args[1];
					ao.adviceObj = args[2];
					ao.adviceFunc = args[3];
				}else if((dl.isString(args[0]))&&(dl.isString(args[1]))&&(dl.isObject(args[2]))){
					ao.adviceType = args[0];
					ao.srcObj = dj_global;
					ao.srcFunc = args[1];
					ao.adviceObj = args[2];
					ao.adviceFunc = args[3];
				}else if((dl.isString(args[0]))&&(dl.isFunction(args[1]))&&(dl.isObject(args[2]))){
					ao.adviceType = args[0];
					ao.srcObj = dj_global;
					var tmpName  = dl.nameAnonFunc(args[1], dj_global, searchForNames);
					ao.srcFunc = tmpName;
					ao.adviceObj = args[2];
					ao.adviceFunc = args[3];
				}else if((dl.isString(args[0]))&&(dl.isObject(args[1]))&&(dl.isString(args[2]))&&(dl.isFunction(args[3]))){
					ao.srcObj = args[1];
					ao.srcFunc = args[2];
					var tmpName  = dl.nameAnonFunc(args[3], dj_global, searchForNames);
					ao.adviceObj = dj_global;
					ao.adviceFunc = tmpName;
				}else if(dl.isObject(args[1])){
					ao.srcObj = args[1];
					ao.srcFunc = args[2];
					ao.adviceObj = dj_global;
					ao.adviceFunc = args[3];
				}else if(dl.isObject(args[2])){
					ao.srcObj = dj_global;
					ao.srcFunc = args[1];
					ao.adviceObj = args[2];
					ao.adviceFunc = args[3];
				}else{
					ao.srcObj = ao.adviceObj = ao.aroundObj = dj_global;
					ao.srcFunc = args[1];
					ao.adviceFunc = args[2];
					ao.aroundFunc = args[3];
				}
				break;
			case 6:
				ao.srcObj = args[1];
				ao.srcFunc = args[2];
				ao.adviceObj = args[3]
				ao.adviceFunc = args[4];
				ao.aroundFunc = args[5];
				ao.aroundObj = dj_global;
				break;
			default:
				ao.srcObj = args[1];
				ao.srcFunc = args[2];
				ao.adviceObj = args[3]
				ao.adviceFunc = args[4];
				ao.aroundObj = args[5];
				ao.aroundFunc = args[6];
				ao.once = args[7];
				ao.delay = args[8];
				ao.rate = args[9];
				ao.adviceMsg = args[10];
				ao.maxCalls = (!isNaN(parseInt(args[11]))) ? args[11] : -1;
				break;
		}

		if(dl.isFunction(ao.aroundFunc)){
			var tmpName  = dl.nameAnonFunc(ao.aroundFunc, ao.aroundObj, searchForNames);
			ao.aroundFunc = tmpName;
		}

		if(dl.isFunction(ao.srcFunc)){
			ao.srcFunc = dl.getNameInObj(ao.srcObj, ao.srcFunc);
		}

		if(dl.isFunction(ao.adviceFunc)){
			ao.adviceFunc = dl.getNameInObj(ao.adviceObj, ao.adviceFunc);
		}

		if((ao.aroundObj)&&(dl.isFunction(ao.aroundFunc))){
			ao.aroundFunc = dl.getNameInObj(ao.aroundObj, ao.aroundFunc);
		}

		if(!ao.srcObj){
			dojo.raise("bad srcObj for srcFunc: "+ao.srcFunc);
		}
		if(!ao.adviceObj){
			dojo.raise("bad adviceObj for adviceFunc: "+ao.adviceFunc);
		}
		
		if(!ao.adviceFunc){
			dojo.debug("bad adviceFunc for srcFunc: "+ao.srcFunc);
			dojo.debugShallow(ao);
		} 
		
		return ao;
	}

	this.connect = function(/*...*/){
		// summary:
		//		dojo.event.connect is the glue that holds most Dojo-based
		//		applications together. Most combinations of arguments are
		//		supported, with the connect() method attempting to disambiguate
		//		the implied types of positional parameters. The following will
		//		all work:
		//			dojo.event.connect("globalFunctionName1", "globalFunctionName2");
		//			dojo.event.connect(functionReference1, functionReference2);
		//			dojo.event.connect("globalFunctionName1", functionReference2);
		//			dojo.event.connect(functionReference1, "globalFunctionName2");
		//			dojo.event.connect(scope1, "functionName1", "globalFunctionName2");
		//			dojo.event.connect("globalFunctionName1", scope2, "functionName2");
		//			dojo.event.connect(scope1, "functionName1", scope2, "functionName2");
		//			dojo.event.connect("after", scope1, "functionName1", scope2, "functionName2");
		//			dojo.event.connect("before", scope1, "functionName1", scope2, "functionName2");
		//			dojo.event.connect("around", 	scope1, "functionName1", 
		//											scope2, "functionName2",
		//											aroundFunctionReference);
		//			dojo.event.connect("around", 	scope1, "functionName1", 
		//											scope2, "functionName2",
		//											scope3, "aroundFunctionName");
		//			dojo.event.connect("before-around", 	scope1, "functionName1", 
		//													scope2, "functionName2",
		//													aroundFunctionReference);
		//			dojo.event.connect("after-around", 		scope1, "functionName1", 
		//													scope2, "functionName2",
		//													aroundFunctionReference);
		//			dojo.event.connect("after-around", 		scope1, "functionName1", 
		//													scope2, "functionName2",
		//													scope3, "aroundFunctionName");
		//			dojo.event.connect("around", 	scope1, "functionName1", 
		//											scope2, "functionName2",
		//											scope3, "aroundFunctionName", true, 30);
		//			dojo.event.connect("around", 	scope1, "functionName1", 
		//											scope2, "functionName2",
		//											scope3, "aroundFunctionName", null, null, 10);
		// adviceType: 
		//		Optional. String. One of "before", "after", "around",
		//		"before-around", or "after-around". FIXME
		// srcObj:
		//		the scope in which to locate/execute the named srcFunc. Along
		//		with srcFunc, this creates a way to dereference the function to
		//		call. So if the function in question is "foo.bar", the
		//		srcObj/srcFunc pair would be foo and "bar", where "bar" is a
		//		string and foo is an object reference.
		// srcFunc:
		//		the name of the function to connect to. When it is executed,
		//		the listener being registered with this call will be called.
		//		The adviceType defines the call order between the source and
		//		the target functions.
		// adviceObj:
		//		the scope in which to locate/execute the named adviceFunc.
		// adviceFunc:
		//		the name of the function being conected to srcObj.srcFunc
		// aroundObj:
		//		the scope in which to locate/execute the named aroundFunc.
		// aroundFunc:
		//		the name of, or a reference to, the function that will be used
		//		to mediate the advice call. Around advice requires a special
		//		unary function that will be passed a "MethodInvocation" object.
		//		These objects have several important properties, namely:
		//			- args
		//				a mutable array of arguments to be passed into the
		//				wrapped function
		//			- proceed
		//				a function that "continues" the invocation. The result
		//				of this function is the return of the wrapped function.
		//				You can then manipulate this return before passing it
		//				back out (or take further action based on it).
		// once:
		//		boolean that determines whether or not this connect() will
		//		create a new connection if an identical connect() has already
		//		been made. Defaults to "false".
		// delay:
		//		an optional delay (in ms), as an integer, for dispatch of a
		//		listener after the source has been fired.
		// rate:
		//		an optional rate throttling parameter (integer, in ms). When
		//		specified, this particular connection will not fire more than
		//		once in the interval specified by the rate
		// adviceMsg:
		//		boolean. Should the listener have all the parameters passed in
		//		as a single argument?

		/*
				ao.adviceType = args[0];
				ao.srcObj = args[1];
				ao.srcFunc = args[2];
				ao.adviceObj = args[3]
				ao.adviceFunc = args[4];
				ao.aroundObj = args[5];
				ao.aroundFunc = args[6];
				ao.once = args[7];
				ao.delay = args[8];
				ao.rate = args[9];
				ao.adviceMsg = args[10];
				ao.maxCalls = args[11];
		*/
		if(arguments.length == 1){
			var ao = arguments[0];
		}else{
			var ao = interpolateArgs(arguments, true);
		}
		if(dojo.lang.isString(ao.srcFunc) && (ao.srcFunc.toLowerCase() == "onkey") ){
			if(dojo.render.html.ie){
				ao.srcFunc = "onkeydown";
				this.connect(ao);
			}
			ao.srcFunc = "onkeypress";
		}

		if(dojo.lang.isArray(ao.srcObj) && ao.srcObj!=""){
			var tmpAO = {};
			for(var x in ao){
				tmpAO[x] = ao[x];
			}
			var mjps = [];
			dojo.lang.forEach(ao.srcObj, function(src){
				if((dojo.render.html.capable)&&(dojo.lang.isString(src))){
					src = dojo.byId(src);
					// dojo.debug(src);
				}
				tmpAO.srcObj = src;
				// dojo.debug(tmpAO.srcObj, tmpAO.srcFunc);
				// dojo.debug(tmpAO.adviceObj, tmpAO.adviceFunc);
				mjps.push(dojo.event.connect.call(dojo.event, tmpAO));
			});
			return mjps;
		}

		// FIXME: just doing a "getForMethod()" seems to be enough to put this into infinite recursion!!
		var mjp = dojo.event.MethodJoinPoint.getForMethod(ao.srcObj, ao.srcFunc);
		if(ao.adviceFunc){
			var mjp2 = dojo.event.MethodJoinPoint.getForMethod(ao.adviceObj, ao.adviceFunc);
		}

		mjp.kwAddAdvice(ao);

		// advanced users might want to fsck w/ the join point manually
		return mjp; // a MethodJoinPoint object
	}

	this.log = function(/*object or funcName*/ a1, /*funcName*/ a2){
		// summary:
		//		a function that will wrap and log all calls to the specified
		//		a1.a2() function. If only a1 is passed, it'll be used as a
		//		function or function name on the global context. Logging will
		//		be sent to dojo.debug
		// a1:
		//		if a2 is passed, this should be an object. If not, it can be a
		//		function or function name.
		// a2:
		//		a function name
		var kwArgs;
		if((arguments.length == 1)&&(typeof a1 == "object")){
			kwArgs = a1;
		}else{
			kwArgs = {
				srcObj: a1,
				srcFunc: a2
			};
		}
		kwArgs.adviceFunc = function(){
			var argsStr = [];
			for(var x=0; x<arguments.length; x++){
				argsStr.push(arguments[x]);
			}
			dojo.debug("("+kwArgs.srcObj+")."+kwArgs.srcFunc, ":", argsStr.join(", "));
		};
		this.kwConnect(kwArgs);
	}

	this.connectBefore = function(){
		// summary:
		//	 	takes the same parameters as dojo.event.connect(), except that
		//	 	the advice type will always be "before"
		var args = ["before"];
		for(var i = 0; i < arguments.length; i++){ args.push(arguments[i]); }
		return this.connect.apply(this, args); // a MethodJoinPoint object
	}

	this.connectAround = function(){
		// summary:
		//	 	takes the same parameters as dojo.event.connect(), except that
		//	 	the advice type will always be "around"
		var args = ["around"];
		for(var i = 0; i < arguments.length; i++){ args.push(arguments[i]); }
		return this.connect.apply(this, args); // a MethodJoinPoint object
	}

	this.connectOnce = function(){
		// summary:
		//	 	takes the same parameters as dojo.event.connect(), except that
		//	 	the "once" flag will always be set to "true"
		var ao = interpolateArgs(arguments, true);
		ao.once = true;
		return this.connect(ao); // a MethodJoinPoint object
	}

	this.connectRunOnce = function(){
		// summary:
		//	 	takes the same parameters as dojo.event.connect(), except that
		//	 	the "maxCalls" flag will always be set to 1
		var ao = interpolateArgs(arguments, true);
		ao.maxCalls = 1;
		return this.connect(ao); // a MethodJoinPoint object
	}

	this._kwConnectImpl = function(kwArgs, disconnect){
		var fn = (disconnect) ? "disconnect" : "connect";
		if(typeof kwArgs["srcFunc"] == "function"){
			kwArgs.srcObj = kwArgs["srcObj"]||dj_global;
			var tmpName  = dojo.lang.nameAnonFunc(kwArgs.srcFunc, kwArgs.srcObj, true);
			kwArgs.srcFunc = tmpName;
		}
		if(typeof kwArgs["adviceFunc"] == "function"){
			kwArgs.adviceObj = kwArgs["adviceObj"]||dj_global;
			var tmpName  = dojo.lang.nameAnonFunc(kwArgs.adviceFunc, kwArgs.adviceObj, true);
			kwArgs.adviceFunc = tmpName;
		}
		kwArgs.srcObj = kwArgs["srcObj"]||dj_global;
		kwArgs.adviceObj = kwArgs["adviceObj"]||kwArgs["targetObj"]||dj_global;
		kwArgs.adviceFunc = kwArgs["adviceFunc"]||kwArgs["targetFunc"];
		// pass kwargs to avoid unrolling/repacking
		return dojo.event[fn](kwArgs);
	}

	this.kwConnect = function(/*Object*/ kwArgs){
		// summary:
		//		A version of dojo.event.connect() that takes a map of named
		//		parameters instead of the positional parameters that
		//		dojo.event.connect() uses. For many advanced connection types,
		//		this can be a much more readable (and potentially faster)
		//		alternative.
		// kwArgs:
		// 		An object that can have the following properties:
		//			- adviceType
		//			- srcObj
		//			- srcFunc
		//			- adviceObj
		//			- adviceFunc 
		//			- aroundObj
		//			- aroundFunc
		//			- once
		//			- delay
		//			- rate
		//			- adviceMsg
		//		As with connect, only srcFunc and adviceFunc are generally
		//		required

		return this._kwConnectImpl(kwArgs, false); // a MethodJoinPoint object

	}

	this.disconnect = function(){
		// summary:
		//		Takes the same parameters as dojo.event.connect() but destroys
		//		an existing connection instead of building a new one. For
		//		multiple identical connections, multiple disconnect() calls
		//		will unroll one each time it's called.
		if(arguments.length == 1){
			var ao = arguments[0];
		}else{
			var ao = interpolateArgs(arguments, true);
		}
		if(!ao.adviceFunc){ return; } // nothing to disconnect
		if(dojo.lang.isString(ao.srcFunc) && (ao.srcFunc.toLowerCase() == "onkey") ){
			if(dojo.render.html.ie){
				ao.srcFunc = "onkeydown";
				this.disconnect(ao);
			}
			ao.srcFunc = "onkeypress";
		}
		if(!ao.srcObj[ao.srcFunc]){ return null; } // prevent un-necessaray joinpoint creation
		var mjp = dojo.event.MethodJoinPoint.getForMethod(ao.srcObj, ao.srcFunc, true);
		mjp.removeAdvice(ao.adviceObj, ao.adviceFunc, ao.adviceType, ao.once); // a MethodJoinPoint object
		return mjp;
	}

	this.kwDisconnect = function(kwArgs){
		// summary:
		//		Takes the same parameters as dojo.event.kwConnect() but
		//		destroys an existing connection instead of building a new one.
		return this._kwConnectImpl(kwArgs, true);
	}
}

// exactly one of these is created whenever a method with a joint point is run,
// if there is at least one 'around' advice.
dojo.event.MethodInvocation = function(/*dojo.event.MethodJoinPoint*/join_point, /*Object*/obj, /*Array*/args){
	// summary:
	//		a class the models the call into a function. This is used under the
	//		covers for all method invocations on both ends of a
	//		connect()-wrapped function dispatch. This allows us to "pickle"
	//		calls, such as in the case of around advice.
	// join_point:
	//		a dojo.event.MethodJoinPoint object that represents a connection
	// obj:
	//		the scope the call will execute in
	// args:
	//		an array of parameters that will get passed to the callee
	this.jp_ = join_point;
	this.object = obj;
	this.args = [];
	// make sure we don't lock into a mutable object which can change under us.
	// It's ok if the individual items change, though.
	for(var x=0; x<args.length; x++){
		this.args[x] = args[x];
	}
	// the index of the 'around' that is currently being executed.
	this.around_index = -1;
}

dojo.event.MethodInvocation.prototype.proceed = function(){
	// summary:
	//		proceed with the method call that's represented by this invocation
	//		object
	this.around_index++;
	if(this.around_index >= this.jp_.around.length){
		return this.jp_.object[this.jp_.methodname].apply(this.jp_.object, this.args);
		// return this.jp_.run_before_after(this.object, this.args);
	}else{
		var ti = this.jp_.around[this.around_index];
		var mobj = ti[0]||dj_global;
		var meth = ti[1];
		return mobj[meth].call(mobj, this);
	}
} 


dojo.event.MethodJoinPoint = function(/*Object*/obj, /*String*/funcName){
	this.object = obj||dj_global;
	this.methodname = funcName;
	this.methodfunc = this.object[funcName];
	this.squelch = false;
	// this.before = [];
	// this.after = [];
	// this.around = [];
}

dojo.event.MethodJoinPoint.getForMethod = function(/*Object*/obj, /*String*/funcName){
	// summary:
	//		"static" class function for returning a MethodJoinPoint from a
	//		scoped function. If one doesn't exist, one is created.
	// obj:
	//		the scope to search for the function in
	// funcName:
	//		the name of the function to return a MethodJoinPoint for
	if(!obj){ obj = dj_global; }
	var ofn = obj[funcName];
	if(!ofn){
		// supply a do-nothing method implementation
		ofn = obj[funcName] = function(){};
		if(!obj[funcName]){
			// e.g. cannot add to inbuilt objects in IE6
			dojo.raise("Cannot set do-nothing method on that object "+funcName);
		}
	}else if((typeof ofn != "function")&&(!dojo.lang.isFunction(ofn))&&(!dojo.lang.isAlien(ofn))){
		// FIXME: should we throw an exception here instead?
		return null; 
	}
	// we hide our joinpoint instance in obj[funcName + '$joinpoint']
	var jpname = funcName + "$joinpoint";
	var jpfuncname = funcName + "$joinpoint$method";
	var joinpoint = obj[jpname];
	if(!joinpoint){
		var isNode = false;
		if(dojo.event["browser"]){
			if( (obj["attachEvent"])||
				(obj["nodeType"])||
				(obj["addEventListener"]) ){
				isNode = true;
				dojo.event.browser.addClobberNodeAttrs(obj, [jpname, jpfuncname, funcName]);
			}
		}
		var origArity = ofn.length;
		obj[jpfuncname] = ofn;
		// joinpoint = obj[jpname] = new dojo.event.MethodJoinPoint(obj, funcName);
		joinpoint = obj[jpname] = new dojo.event.MethodJoinPoint(obj, jpfuncname);

		if(!isNode){
			obj[funcName] = function(){ 
				// var args = [];
				// for(var x=0; x<arguments.length; x++){
					// args.push(arguments[x]);
				// }
				// return joinpoint.run.apply(joinpoint, args); 
				return joinpoint.run.apply(joinpoint, arguments); 
			}
		}else{
			obj[funcName] = function(){ 
				var args = [];

				if(!arguments.length){
					var evt = null;
					try{
						if(obj.ownerDocument){
							evt = obj.ownerDocument.parentWindow.event;
						}else if(obj.documentElement){
							evt = obj.documentElement.ownerDocument.parentWindow.event;
						}else if(obj.event){ //obj is a window
							evt = obj.event;
						}else{
							evt = window.event;
						}
					}catch(e){
						evt = window.event;
					}

					if(evt){
						args.push(dojo.event.browser.fixEvent(evt, this));
					}
				}else{
					for(var x=0; x<arguments.length; x++){
						if((x==0)&&(dojo.event.browser.isEvent(arguments[x]))){
							args.push(dojo.event.browser.fixEvent(arguments[x], this));
						}else{
							args.push(arguments[x]);
						}
					}
				}
				// return joinpoint.run.apply(joinpoint, arguments); 
				return joinpoint.run.apply(joinpoint, args); 
			}
		}
		obj[funcName].__preJoinArity = origArity;
	}
	return joinpoint; // dojo.event.MethodJoinPoint
}

dojo.lang.extend(dojo.event.MethodJoinPoint, {
	squelch: false,

	unintercept: function(){
		// summary: 
		//		destroy the connection to all listeners that may have been
		//		registered on this joinpoint
		this.object[this.methodname] = this.methodfunc;
		this.before = [];
		this.after = [];
		this.around = [];
	},

	disconnect: dojo.lang.forward("unintercept"),

	run: function(){
		// summary:
		//		execute the connection represented by this join point. The
		//		arguments passed to run() will be passed to the function and
		//		its listeners.
		var obj = this.object||dj_global;
		var args = arguments;

		// optimization. We only compute once the array version of the arguments
		// pseudo-arr in order to prevent building it each time advice is unrolled.
		var aargs = [];
		for(var x=0; x<args.length; x++){
			aargs[x] = args[x];
		}

		var unrollAdvice  = function(marr){ 
			if(!marr){
				dojo.debug("Null argument to unrollAdvice()");
				return;
			}
		  
			var callObj = marr[0]||dj_global;
			var callFunc = marr[1];
			
			if(!callObj[callFunc]){
				dojo.raise("function \"" + callFunc + "\" does not exist on \"" + callObj + "\"");
			}
			
			var aroundObj = marr[2]||dj_global;
			var aroundFunc = marr[3];
			var msg = marr[6];
			var maxCount = marr[7];
			if(maxCount > -1){
				if(maxCount == 0){
					return;
				}
				marr[7]--;
			}
			var undef;

			var to = {
				args: [],
				jp_: this,
				object: obj,
				proceed: function(){
					return callObj[callFunc].apply(callObj, to.args);
				}
			};
			to.args = aargs;

			var delay = parseInt(marr[4]);
			var hasDelay = ((!isNaN(delay))&&(marr[4]!==null)&&(typeof marr[4] != "undefined"));
			if(marr[5]){
				var rate = parseInt(marr[5]);
				var cur = new Date();
				var timerSet = false;
				if((marr["last"])&&((cur-marr.last)<=rate)){
					if(dojo.event._canTimeout){
						if(marr["delayTimer"]){
							clearTimeout(marr.delayTimer);
						}
						var tod = parseInt(rate*2); // is rate*2 naive?
						var mcpy = dojo.lang.shallowCopy(marr);
						marr.delayTimer = setTimeout(function(){
							// FIXME: on IE at least, event objects from the
							// browser can go out of scope. How (or should?) we
							// deal with it?
							mcpy[5] = 0;
							unrollAdvice(mcpy);
						}, tod);
					}
					return;
				}else{
					marr.last = cur;
				}
			}

			// FIXME: need to enforce rates for a connection here!

			if(aroundFunc){
				// NOTE: around advice can't delay since we might otherwise depend
				// on execution order!
				aroundObj[aroundFunc].call(aroundObj, to);
			}else{
				// var tmjp = dojo.event.MethodJoinPoint.getForMethod(obj, methname);
				if((hasDelay)&&((dojo.render.html)||(dojo.render.svg))){  // FIXME: the render checks are grotty!
					dj_global["setTimeout"](function(){
						if(msg){
							callObj[callFunc].call(callObj, to); 
						}else{
							callObj[callFunc].apply(callObj, args); 
						}
					}, delay);
				}else{ // many environments can't support delay!
					if(msg){
						callObj[callFunc].call(callObj, to); 
					}else{
						callObj[callFunc].apply(callObj, args); 
					}
				}
			}
		};

		var unRollSquelch = function(){
			if(this.squelch){
				try{
					return unrollAdvice.apply(this, arguments);
				}catch(e){ 
					dojo.debug(e);
				}
			}else{
				return unrollAdvice.apply(this, arguments);
			}
		};

		if((this["before"])&&(this.before.length>0)){
			// pass a cloned array, if this event disconnects this event forEach on this.before wont work
			dojo.lang.forEach(this.before.concat(new Array()), unRollSquelch);
		}

		var result;
		try{
			if((this["around"])&&(this.around.length>0)){
				var mi = new dojo.event.MethodInvocation(this, obj, args);
				result = mi.proceed();
			}else if(this.methodfunc){
				result = this.object[this.methodname].apply(this.object, args);
			}
		}catch(e){ 
			if(!this.squelch){ 
				dojo.debug(e,"when calling",this.methodname,"on",this.object,"with arguments",args);
				dojo.raise(e);
			} 
		}

		if((this["after"])&&(this.after.length>0)){
			// see comment on this.before above
			dojo.lang.forEach(this.after.concat(new Array()), unRollSquelch);
		}

		return (this.methodfunc) ? result : null;
	},

	getArr: function(/*String*/kind){
		// summary: return a list of listeners of the past "kind"
		// kind:
		//		can be one of: "before", "after", "around", "before-around", or
		//		"after-around"
		var type = "after";
		// FIXME: we should be able to do this through props or Array.in()
		if((typeof kind == "string")&&(kind.indexOf("before")!=-1)){
			type = "before";
		}else if(kind=="around"){
			type = "around";
		}
		if(!this[type]){ this[type] = []; }
		return this[type]; // Array
	},

	kwAddAdvice: function(/*Object*/args){
		// summary:
		//		adds advice to the joinpoint with arguments in a map
		// args:
		// 		An object that can have the following properties:
		//			- adviceType
		//			- adviceObj
		//			- adviceFunc 
		//			- aroundObj
		//			- aroundFunc
		//			- once
		//			- delay
		//			- rate
		//			- adviceMsg
		//			- maxCalls
		this.addAdvice(	args["adviceObj"], args["adviceFunc"], 
						args["aroundObj"], args["aroundFunc"], 
						args["adviceType"], args["precedence"], 
						args["once"], args["delay"], args["rate"], 
						args["adviceMsg"], args["maxCalls"]);
	},

	addAdvice: function(	thisAdviceObj, thisAdvice, 
							thisAroundObj, thisAround, 
							adviceType, precedence, 
							once, delay, rate, asMessage,
							maxCalls){
		// summary:
		//		add advice to this joinpoint using positional parameters
		// thisAdviceObj:
		//		the scope in which to locate/execute the named adviceFunc.
		// thisAdviceFunc:
		//		the name of the function being conected
		// thisAroundObj:
		//		the scope in which to locate/execute the named aroundFunc.
		// thisAroundFunc:
		//		the name of the function that will be used to mediate the
		//		advice call.
		// adviceType: 
		//		Optional. String. One of "before", "after", "around",
		//		"before-around", or "after-around". FIXME
		// once:
		//		boolean that determines whether or not this advice will create
		//		a new connection if an identical advice set has already been
		//		provided. Defaults to "false".
		// delay:
		//		an optional delay (in ms), as an integer, for dispatch of a
		//		listener after the source has been fired.
		// rate:
		//		an optional rate throttling parameter (integer, in ms). When
		//		specified, this particular connection will not fire more than
		//		once in the interval specified by the rate
		// adviceMsg:
		//		boolean. Should the listener have all the parameters passed in
		//		as a single argument?
		// maxCalls:
		//		Integer. The maximum number of times this connection can be
		//		used before being auto-disconnected. -1 signals that the
		//		connection should never be disconnected.
		var arr = this.getArr(adviceType);
		if(!arr){
			dojo.raise("bad this: " + this);
		}

		var ao = [thisAdviceObj, thisAdvice, thisAroundObj, thisAround, delay, rate, asMessage, maxCalls];
		
		if(once){
			if(this.hasAdvice(thisAdviceObj, thisAdvice, adviceType, arr) >= 0){
				return;
			}
		}

		if(precedence == "first"){
			arr.unshift(ao);
		}else{
			arr.push(ao);
		}
	},

	hasAdvice: function(thisAdviceObj, thisAdvice, adviceType, arr){
		// summary:
		//		returns the array index of the first existing connection
		//		betweened the passed advice and this joinpoint. Will be -1 if
		//		none exists.
		// thisAdviceObj:
		//		the scope in which to locate/execute the named adviceFunc.
		// thisAdviceFunc:
		//		the name of the function being conected
		// adviceType: 
		//		Optional. String. One of "before", "after", "around",
		//		"before-around", or "after-around". FIXME
		// arr:
		//		Optional. The list of advices to search. Will be found via
		//		adviceType if not passed
		if(!arr){ arr = this.getArr(adviceType); }
		var ind = -1;
		for(var x=0; x<arr.length; x++){
			var aao = (typeof thisAdvice == "object") ? (new String(thisAdvice)).toString() : thisAdvice;
			var a1o = (typeof arr[x][1] == "object") ? (new String(arr[x][1])).toString() : arr[x][1];
			if((arr[x][0] == thisAdviceObj)&&(a1o == aao)){
				ind = x;
			}
		}
		return ind; // Integer
	},

	removeAdvice: function(thisAdviceObj, thisAdvice, adviceType, once){
		// summary:
		//		returns the array index of the first existing connection
		//		betweened the passed advice and this joinpoint. Will be -1 if
		//		none exists.
		// thisAdviceObj:
		//		the scope in which to locate/execute the named adviceFunc.
		// thisAdviceFunc:
		//		the name of the function being conected
		// adviceType: 
		//		Optional. String. One of "before", "after", "around",
		//		"before-around", or "after-around". FIXME
		// once:
		//		Optional. Should this only remove the first occurance of the
		//		connection?
		var arr = this.getArr(adviceType);
		var ind = this.hasAdvice(thisAdviceObj, thisAdvice, adviceType, arr);
		if(ind == -1){
			return false;
		}
		while(ind != -1){
			arr.splice(ind, 1);
			if(once){ break; }
			ind = this.hasAdvice(thisAdviceObj, thisAdvice, adviceType, arr);
		}
		return true;
	}
});


dojo.provide("dojo.event.topic");

dojo.event.topic = new function(){
	this.topics = {};

	this.getTopic = function(/*String*/topic){
		// summary:
		//		returns a topic implementation object of type
		//		dojo.event.topic.TopicImpl
		// topic:
		//		a unique, opaque string that names the topic
		if(!this.topics[topic]){
			this.topics[topic] = new this.TopicImpl(topic);
		}
		return this.topics[topic]; // a dojo.event.topic.TopicImpl object
	}

	this.registerPublisher = function(/*String*/topic, /*Object*/obj, /*String*/funcName){
		// summary:
		//		registers a function as a publisher on a topic. Subsequent
		//		calls to the function will cause a publish event on the topic
		//		with the arguments passed to the function passed to registered
		//		listeners.
		// topic: 
		//		a unique, opaque string that names the topic
		// obj:
		//		the scope to locate the function in
		// funcName:
		//		the name of the function to register
		var topic = this.getTopic(topic);
		topic.registerPublisher(obj, funcName);
	}

	this.subscribe = function(/*String*/topic, /*Object*/obj, /*String*/funcName){
		// summary:
		//		susbscribes the function to the topic. Subsequent events
		//		dispached to the topic will create a function call for the
		//		obj.funcName() function.
		// topic: 
		//		a unique, opaque string that names the topic
		// obj:
		//		the scope to locate the function in
		// funcName:
		//		the name of the function to being registered as a listener
		var topic = this.getTopic(topic);
		topic.subscribe(obj, funcName);
	}

	this.unsubscribe = function(/*String*/topic, /*Object*/obj, /*String*/funcName){
		// summary:
		//		unsubscribes the obj.funcName() from the topic
		// topic: 
		//		a unique, opaque string that names the topic
		// obj:
		//		the scope to locate the function in
		// funcName:
		//		the name of the function to being unregistered as a listener
		var topic = this.getTopic(topic);
		topic.unsubscribe(obj, funcName);
	}

	this.destroy = function(/*String*/topic){
		// summary: 
		//		destroys the topic and unregisters all listeners
		// topic:
		//		a unique, opaque string that names the topic
		this.getTopic(topic).destroy();
		delete this.topics[topic];
	}

	this.publishApply = function(/*String*/topic, /*Array*/args){
		// summary: 
		//		dispatches an event to the topic using the args array as the
		//		source for the call arguments to each listener. This is similar
		//		to JavaScript's built-in Function.apply()
		// topic:
		//		a unique, opaque string that names the topic
		// args:
		//		the arguments to be passed into listeners of the topic
		var topic = this.getTopic(topic);
		topic.sendMessage.apply(topic, args);
	}

	this.publish = function(/*String*/topic, /*Object*/message){
		// summary: 
		//		manually "publish" to the passed topic
		// topic:
		//		a unique, opaque string that names the topic
		// message:
		//		can be an array of parameters (similar to publishApply), or
		//		will be treated as one of many arguments to be passed along in
		//		a "flat" unrolling
		var topic = this.getTopic(topic);
		// if message is an array, we treat it as a set of arguments,
		// otherwise, we just pass on the arguments passed in as-is
		var args = [];
		// could we use concat instead here?
		for(var x=1; x<arguments.length; x++){
			args.push(arguments[x]);
		}
		topic.sendMessage.apply(topic, args);
	}
}

dojo.event.topic.TopicImpl = function(topicName){
	// summary: a class to represent topics

	this.topicName = topicName;

	this.subscribe = function(/*Object*/listenerObject, /*Function or String*/listenerMethod){
		// summary:
		//		use dojo.event.connect() to attach the passed listener to the
		//		topic represented by this object
		// listenerObject:
		//		if a string and listenerMethod is ommitted, this is treated as
		//		the name of a function in the global namespace. If
		//		listenerMethod is provided, this is the scope to find/execute
		//		the function in.
		// listenerMethod:
		//		Optional. The function to register.
		var tf = listenerMethod||listenerObject;
		var to = (!listenerMethod) ? dj_global : listenerObject;
		return dojo.event.kwConnect({ // dojo.event.MethodJoinPoint
			srcObj:		this, 
			srcFunc:	"sendMessage", 
			adviceObj:	to,
			adviceFunc: tf
		});
	}

	this.unsubscribe = function(/*Object*/listenerObject, /*Function or String*/listenerMethod){
		// summary:
		//		use dojo.event.disconnect() to attach the passed listener to the
		//		topic represented by this object
		// listenerObject:
		//		if a string and listenerMethod is ommitted, this is treated as
		//		the name of a function in the global namespace. If
		//		listenerMethod is provided, this is the scope to find the
		//		function in.
		// listenerMethod:
		//		Optional. The function to unregister.
		var tf = (!listenerMethod) ? listenerObject : listenerMethod;
		var to = (!listenerMethod) ? null : listenerObject;
		return dojo.event.kwDisconnect({ // dojo.event.MethodJoinPoint
			srcObj:		this, 
			srcFunc:	"sendMessage", 
			adviceObj:	to,
			adviceFunc: tf
		});
	}

	this._getJoinPoint = function(){
		return dojo.event.MethodJoinPoint.getForMethod(this, "sendMessage");
	}

	this.setSquelch = function(/*Boolean*/shouldSquelch){
		// summary: 
		//		determine whether or not exceptions in the calling of a
		//		listener in the chain should stop execution of the chain.
		this._getJoinPoint().squelch = shouldSquelch;
	}

	this.destroy = function(){
		// summary: disconnects all listeners from this topic
		this._getJoinPoint().disconnect();
	}

	this.registerPublisher = function(	/*Object*/publisherObject, 
										/*Function or String*/publisherMethod){
		// summary:
		//		registers the passed function as a publisher on this topic.
		//		Each time the function is called, an event will be published on
		//		this topic.
		// publisherObject:
		//		if a string and listenerMethod is ommitted, this is treated as
		//		the name of a function in the global namespace. If
		//		listenerMethod is provided, this is the scope to find the
		//		function in.
		// publisherMethod:
		//		Optional. The function to register.
		dojo.event.connect(publisherObject, publisherMethod, this, "sendMessage");
	}

	this.sendMessage = function(message){
		// summary: a stub to be called when a message is sent to the topic.

		// The message has been propagated
	}
}


dojo.provide("dojo.event.browser");


// FIXME: any particular reason this is in the global scope?
dojo._ie_clobber = new function(){
	this.clobberNodes = [];

	function nukeProp(node, prop){
		// try{ node.removeAttribute(prop); 	}catch(e){ /* squelch */ }
		try{ node[prop] = null; 			}catch(e){ /* squelch */ }
		try{ delete node[prop]; 			}catch(e){ /* squelch */ }
		// FIXME: JotLive needs this, but I'm not sure if it's too slow or not
		try{ node.removeAttribute(prop);	}catch(e){ /* squelch */ }
	}

	this.clobber = function(nodeRef){
		var na;
		var tna;
		if(nodeRef){
			tna = nodeRef.all || nodeRef.getElementsByTagName("*");
			na = [nodeRef];
			for(var x=0; x<tna.length; x++){
				// if we're gonna be clobbering the thing, at least make sure
				// we aren't trying to do it twice
				if(tna[x]["__doClobber__"]){
					na.push(tna[x]);
				}
			}
		}else{
			try{ window.onload = null; }catch(e){}
			na = (this.clobberNodes.length) ? this.clobberNodes : document.all;
		}
		tna = null;
		var basis = {};
		for(var i = na.length-1; i>=0; i=i-1){
			var el = na[i];
			try{
				if(el && el["__clobberAttrs__"]){
					for(var j=0; j<el.__clobberAttrs__.length; j++){
						nukeProp(el, el.__clobberAttrs__[j]);
					}
					nukeProp(el, "__clobberAttrs__");
					nukeProp(el, "__doClobber__");
				}
			}catch(e){ /* squelch! */};
		}
		na = null;
	}
}

if(dojo.render.html.ie){
	dojo.addOnUnload(function(){
		dojo._ie_clobber.clobber();
		try{
			if((dojo["widget"])&&(dojo.widget["manager"])){
				dojo.widget.manager.destroyAll();
			}
		}catch(e){}

		// Workaround for IE leak recommended in ticket #1727 by schallm
		if(dojo.widget){
			for(var name in dojo.widget._templateCache){
				if(dojo.widget._templateCache[name].node){
					dojo.dom.destroyNode(dojo.widget._templateCache[name].node);
					dojo.widget._templateCache[name].node = null;
					delete dojo.widget._templateCache[name].node;
				}
			}
		}

		try{ window.onload = null; }catch(e){}
		try{ window.onunload = null; }catch(e){}
		dojo._ie_clobber.clobberNodes = [];
		// CollectGarbage();
	});
}

dojo.event.browser = new function(){

	var clobberIdx = 0;

	this.normalizedEventName = function(/*String*/eventName){
		switch(eventName){
			case "CheckboxStateChange":
			case "DOMAttrModified":
			case "DOMMenuItemActive":
			case "DOMMenuItemInactive":
			case "DOMMouseScroll":
			case "DOMNodeInserted":
			case "DOMNodeRemoved":
			case "RadioStateChange":
				return eventName;
				break;
			default:
				var lcn = eventName.toLowerCase();
				return (lcn.indexOf("on") == 0) ? lcn.substr(2) : lcn;
				break;
		}
	}
	
	this.clean = function(/*DOMNode*/node){
		// summary:
		//		removes native event handlers so that destruction of the node
		//		will not leak memory. On most browsers this is a no-op, but
		//		it's critical for manual node removal on IE.
		// node:
		//		A DOM node. All of it's children will also be cleaned.
		if(dojo.render.html.ie){ 
			dojo._ie_clobber.clobber(node);
		}
	}

	this.addClobberNode = function(/*DOMNode*/node){
		// summary:
		//		register the passed node to support event stripping
		// node:
		//		A DOM node
		if(!dojo.render.html.ie){ return; }
		if(!node["__doClobber__"]){
			node.__doClobber__ = true;
			dojo._ie_clobber.clobberNodes.push(node);
			// this might not be the most efficient thing to do, but it's
			// much less error prone than other approaches which were
			// previously tried and failed
			node.__clobberAttrs__ = [];
		}
	}

	this.addClobberNodeAttrs = function(/*DOMNode*/node, /*Array*/props){
		// summary:
		//		register the passed node to support event stripping
		// node:
		//		A DOM node to stip properties from later
		// props:
		//		A list of propeties to strip from the node
		if(!dojo.render.html.ie){ return; }
		this.addClobberNode(node);
		for(var x=0; x<props.length; x++){
			node.__clobberAttrs__.push(props[x]);
		}
	}

	this.removeListener = function(	/*DOMNode*/ node, 
									/*String*/	evtName, 
									/*Function*/fp, 
									/*Boolean*/	capture){
		// summary:
		//		clobbers the listener from the node
		// evtName:
		//		the name of the handler to remove the function from
		// node:
		//		DOM node to attach the event to
		// fp:
		//		the function to register
		// capture:
		//		Optional. should this listener prevent propigation?
		if(!capture){ var capture = false; }
		evtName = dojo.event.browser.normalizedEventName(evtName);
		if(evtName == "key"){
			if(dojo.render.html.ie){
				this.removeListener(node, "onkeydown", fp, capture);
			}
			evtName = "keypress";
		}
		// FIXME: this is mostly a punt, we aren't actually doing anything on IE
		if(node.removeEventListener){
			node.removeEventListener(evtName, fp, capture);
		}
	}

	this.addListener = function(/*DOMNode*/node, /*String*/evtName, /*Function*/fp, /*Boolean*/capture, /*Boolean*/dontFix){
		// summary:
		//		adds a listener to the node
		// evtName:
		//		the name of the handler to add the listener to can be either of
		//		the form "onclick" or "click"
		// node:
		//		DOM node to attach the event to
		// fp:
		//		the function to register
		// capture:
		//		Optional. Should this listener prevent propigation?
		// dontFix:
		//		Optional. Should we avoid registering a new closure around the
		//		listener to enable fixEvent for dispatch of the registered
		//		function?
		if(!node){ return; } // FIXME: log and/or bail?
		if(!capture){ var capture = false; }
		evtName = dojo.event.browser.normalizedEventName(evtName);
		if(evtName == "key"){
			if(dojo.render.html.ie){
				this.addListener(node, "onkeydown", fp, capture, dontFix);
			}
			evtName = "keypress";
		}

		if(!dontFix){
			// build yet another closure around fp in order to inject fixEvent
			// around the resulting event
			var newfp = function(evt){
				if(!evt){ evt = window.event; }
				var ret = fp(dojo.event.browser.fixEvent(evt, this));
				if(capture){
					dojo.event.browser.stopEvent(evt);
				}
				return ret;
			}
		}else{
			newfp = fp;
		}

		if(node.addEventListener){ 
			node.addEventListener(evtName, newfp, capture);
			return newfp;
		}else{
			evtName = "on"+evtName;
			if(typeof node[evtName] == "function" ){
				var oldEvt = node[evtName];
				node[evtName] = function(e){
					oldEvt(e);
					return newfp(e);
				}
			}else{
				node[evtName]=newfp;
			}
			if(dojo.render.html.ie){
				this.addClobberNodeAttrs(node, [evtName]);
			}
			return newfp;
		}
	}

	this.isEvent = function(/*Object*/obj){
		// summary: 
		//		Tries to determine whether or not the object is a DOM event.

		// FIXME: event detection hack ... could test for additional attributes
		// if necessary
		return (typeof obj != "undefined")&&(obj)&&(typeof Event != "undefined")&&(obj.eventPhase); // Boolean
		// Event does not support instanceof in Opera, otherwise:
		//return (typeof Event != "undefined")&&(obj instanceof Event);
	}

	this.currentEvent = null;
	
	this.callListener = function(/*Function*/listener, /*DOMNode*/curTarget){
		// summary:
		//		calls the specified listener in the context of the passed node
		//		with the current DOM event object as the only parameter
		// listener:
		//		the function to call
		// curTarget:
		//		the Node to call the function in the scope of
		if(typeof listener != 'function'){
			dojo.raise("listener not a function: " + listener);
		}
		dojo.event.browser.currentEvent.currentTarget = curTarget;
		return listener.call(curTarget, dojo.event.browser.currentEvent);
	}

	this._stopPropagation = function(){
		dojo.event.browser.currentEvent.cancelBubble = true; 
	}

	this._preventDefault = function(){
		dojo.event.browser.currentEvent.returnValue = false;
	}

	this.keys = {
		KEY_BACKSPACE: 8,
		KEY_TAB: 9,
		KEY_CLEAR: 12,
		KEY_ENTER: 13,
		KEY_SHIFT: 16,
		KEY_CTRL: 17,
		KEY_ALT: 18,
		KEY_PAUSE: 19,
		KEY_CAPS_LOCK: 20,
		KEY_ESCAPE: 27,
		KEY_SPACE: 32,
		KEY_PAGE_UP: 33,
		KEY_PAGE_DOWN: 34,
		KEY_END: 35,
		KEY_HOME: 36,
		KEY_LEFT_ARROW: 37,
		KEY_UP_ARROW: 38,
		KEY_RIGHT_ARROW: 39,
		KEY_DOWN_ARROW: 40,
		KEY_INSERT: 45,
		KEY_DELETE: 46,
		KEY_HELP: 47,
		KEY_LEFT_WINDOW: 91,
		KEY_RIGHT_WINDOW: 92,
		KEY_SELECT: 93,
		KEY_NUMPAD_0: 96,
		KEY_NUMPAD_1: 97,
		KEY_NUMPAD_2: 98,
		KEY_NUMPAD_3: 99,
		KEY_NUMPAD_4: 100,
		KEY_NUMPAD_5: 101,
		KEY_NUMPAD_6: 102,
		KEY_NUMPAD_7: 103,
		KEY_NUMPAD_8: 104,
		KEY_NUMPAD_9: 105,
		KEY_NUMPAD_MULTIPLY: 106,
		KEY_NUMPAD_PLUS: 107,
		KEY_NUMPAD_ENTER: 108,
		KEY_NUMPAD_MINUS: 109,
		KEY_NUMPAD_PERIOD: 110,
		KEY_NUMPAD_DIVIDE: 111,
		KEY_F1: 112,
		KEY_F2: 113,
		KEY_F3: 114,
		KEY_F4: 115,
		KEY_F5: 116,
		KEY_F6: 117,
		KEY_F7: 118,
		KEY_F8: 119,
		KEY_F9: 120,
		KEY_F10: 121,
		KEY_F11: 122,
		KEY_F12: 123,
		KEY_F13: 124,
		KEY_F14: 125,
		KEY_F15: 126,
		KEY_NUM_LOCK: 144,
		KEY_SCROLL_LOCK: 145
	};

	// reverse lookup
	this.revKeys = [];
	for(var key in this.keys){
		this.revKeys[this.keys[key]] = key;
	}

	this.fixEvent = function(/*Event*/evt, /*DOMNode*/sender){
		// summary:
		//		normalizes properties on the event object including event
		//		bubbling methods, keystroke normalization, and x/y positions
		// evt: the native event object
		// sender: the node to treat as "currentTarget"
		if(!evt){
			if(window["event"]){
				evt = window.event;
			}
		}
		
		if((evt["type"])&&(evt["type"].indexOf("key") == 0)){ // key events
			evt.keys = this.revKeys;
			// FIXME: how can we eliminate this iteration?
			for(var key in this.keys){
				evt[key] = this.keys[key];
			}
			if(evt["type"] == "keydown" && dojo.render.html.ie){
				switch(evt.keyCode){
					case evt.KEY_SHIFT:
					case evt.KEY_CTRL:
					case evt.KEY_ALT:
					case evt.KEY_CAPS_LOCK:
					case evt.KEY_LEFT_WINDOW:
					case evt.KEY_RIGHT_WINDOW:
					case evt.KEY_SELECT:
					case evt.KEY_NUM_LOCK:
					case evt.KEY_SCROLL_LOCK:
					// I'll get these in keypress after the OS munges them based on numlock
					case evt.KEY_NUMPAD_0:
					case evt.KEY_NUMPAD_1:
					case evt.KEY_NUMPAD_2:
					case evt.KEY_NUMPAD_3:
					case evt.KEY_NUMPAD_4:
					case evt.KEY_NUMPAD_5:
					case evt.KEY_NUMPAD_6:
					case evt.KEY_NUMPAD_7:
					case evt.KEY_NUMPAD_8:
					case evt.KEY_NUMPAD_9:
					case evt.KEY_NUMPAD_PERIOD:
						break; // just ignore the keys that can morph
					case evt.KEY_NUMPAD_MULTIPLY:
					case evt.KEY_NUMPAD_PLUS:
					case evt.KEY_NUMPAD_ENTER:
					case evt.KEY_NUMPAD_MINUS:
					case evt.KEY_NUMPAD_DIVIDE:
						break; // I could handle these but just pick them up in keypress
					case evt.KEY_PAUSE:
					case evt.KEY_TAB:
					case evt.KEY_BACKSPACE:
					case evt.KEY_ENTER:
					case evt.KEY_ESCAPE:
					case evt.KEY_PAGE_UP:
					case evt.KEY_PAGE_DOWN:
					case evt.KEY_END:
					case evt.KEY_HOME:
					case evt.KEY_LEFT_ARROW:
					case evt.KEY_UP_ARROW:
					case evt.KEY_RIGHT_ARROW:
					case evt.KEY_DOWN_ARROW:
					case evt.KEY_INSERT:
					case evt.KEY_DELETE:
					case evt.KEY_F1:
					case evt.KEY_F2:
					case evt.KEY_F3:
					case evt.KEY_F4:
					case evt.KEY_F5:
					case evt.KEY_F6:
					case evt.KEY_F7:
					case evt.KEY_F8:
					case evt.KEY_F9:
					case evt.KEY_F10:
					case evt.KEY_F11:
					case evt.KEY_F12:
					case evt.KEY_F12:
					case evt.KEY_F13:
					case evt.KEY_F14:
					case evt.KEY_F15:
					case evt.KEY_CLEAR:
					case evt.KEY_HELP:
						evt.key = evt.keyCode;
						break;
					default:
						if(evt.ctrlKey || evt.altKey){
							var unifiedCharCode = evt.keyCode;
							// if lower case but keycode is uppercase, convert it
							if(unifiedCharCode >= 65 && unifiedCharCode <= 90 && evt.shiftKey == false){
								unifiedCharCode += 32;
							}
							if(unifiedCharCode >= 1 && unifiedCharCode <= 26 && evt.ctrlKey){
								unifiedCharCode += 96; // 001-032 = ctrl+[a-z]
							}
							evt.key = String.fromCharCode(unifiedCharCode);
						}
				}
			} else if(evt["type"] == "keypress"){
				if(dojo.render.html.opera){
					if(evt.which == 0){
						evt.key = evt.keyCode;
					}else if(evt.which > 0){
						switch(evt.which){
							case evt.KEY_SHIFT:
							case evt.KEY_CTRL:
							case evt.KEY_ALT:
							case evt.KEY_CAPS_LOCK:
							case evt.KEY_NUM_LOCK:
							case evt.KEY_SCROLL_LOCK:
								break;
							case evt.KEY_PAUSE:
							case evt.KEY_TAB:
							case evt.KEY_BACKSPACE:
							case evt.KEY_ENTER:
							case evt.KEY_ESCAPE:
								evt.key = evt.which;
								break;
							default:
								var unifiedCharCode = evt.which;
								if((evt.ctrlKey || evt.altKey || evt.metaKey) && (evt.which >= 65 && evt.which <= 90 && evt.shiftKey == false)){
									unifiedCharCode += 32;
								}
								evt.key = String.fromCharCode(unifiedCharCode);
						}
					}
				}else if(dojo.render.html.ie){ // catch some IE keys that are hard to get in keyDown
					// key combinations were handled in onKeyDown
					if(!evt.ctrlKey && !evt.altKey && evt.keyCode >= evt.KEY_SPACE){
						evt.key = String.fromCharCode(evt.keyCode);
					}
				}else if(dojo.render.html.safari){
					switch(evt.keyCode){
						case 25: evt.key = evt.KEY_TAB; evt.shift = true;break;
						case 63232: evt.key = evt.KEY_UP_ARROW; break;
						case 63233: evt.key = evt.KEY_DOWN_ARROW; break;
						case 63234: evt.key = evt.KEY_LEFT_ARROW; break;
						case 63235: evt.key = evt.KEY_RIGHT_ARROW; break;
						case 63236: evt.key = evt.KEY_F1; break;
						case 63237: evt.key = evt.KEY_F2; break;
						case 63238: evt.key = evt.KEY_F3; break;
						case 63239: evt.key = evt.KEY_F4; break;
						case 63240: evt.key = evt.KEY_F5; break;
						case 63241: evt.key = evt.KEY_F6; break;
						case 63242: evt.key = evt.KEY_F7; break;
						case 63243: evt.key = evt.KEY_F8; break;
						case 63244: evt.key = evt.KEY_F9; break;
						case 63245: evt.key = evt.KEY_F10; break;
						case 63246: evt.key = evt.KEY_F11; break;
						case 63247: evt.key = evt.KEY_F12; break;
						case 63250: evt.key = evt.KEY_PAUSE; break;
						case 63272: evt.key = evt.KEY_DELETE; break;
						case 63273: evt.key = evt.KEY_HOME; break;
						case 63275: evt.key = evt.KEY_END; break;
						case 63276: evt.key = evt.KEY_PAGE_UP; break;
						case 63277: evt.key = evt.KEY_PAGE_DOWN; break;
						case 63302: evt.key = evt.KEY_INSERT; break;
						case 63248://prtscr
						case 63249://scrolllock
						case 63289://numlock
							break;
						default: 
							evt.key = evt.charCode >= evt.KEY_SPACE ? String.fromCharCode(evt.charCode) : evt.keyCode;
					}
				}else{
					evt.key = evt.charCode > 0 ? String.fromCharCode(evt.charCode) : evt.keyCode;
				}
			}
		}
		if(dojo.render.html.ie){
			if(!evt.target){ evt.target = evt.srcElement; }
			if(!evt.currentTarget){ evt.currentTarget = (sender ? sender : evt.srcElement); }
			if(!evt.layerX){ evt.layerX = evt.offsetX; }
			if(!evt.layerY){ evt.layerY = evt.offsetY; }
			// FIXME: scroll position query is duped from dojo.html to avoid dependency on that entire module
			// DONOT replace the following to use dojo.body(), in IE, document.documentElement should be used
			// here rather than document.body
			var doc = (evt.srcElement && evt.srcElement.ownerDocument) ? evt.srcElement.ownerDocument : document;
			var docBody = ((dojo.render.html.ie55)||(doc["compatMode"] == "BackCompat")) ? doc.body : doc.documentElement;
			if(!evt.pageX){ evt.pageX = evt.clientX + (docBody.scrollLeft || 0) }
			if(!evt.pageY){ evt.pageY = evt.clientY + (docBody.scrollTop || 0) }
			// mouseover
			if(evt.type == "mouseover"){ evt.relatedTarget = evt.fromElement; }
			// mouseout
			if(evt.type == "mouseout"){ evt.relatedTarget = evt.toElement; }
			this.currentEvent = evt;
			evt.callListener = this.callListener;
			evt.stopPropagation = this._stopPropagation;
			evt.preventDefault = this._preventDefault;
		}
		return evt; // Event
	}

	this.stopEvent = function(/*Event*/evt){
		// summary:
		//		prevents propigation and clobbers the default action of the
		//		passed event
		// evt: Optional for IE. The native event object.
		if(window.event){
			evt.cancelBubble = true;
			evt.returnValue = false;
		}else{
			evt.preventDefault();
			evt.stopPropagation();
		}
	}
}

dojo.kwCompoundRequire({
	common: ["dojo.event.common", "dojo.event.topic"],
	browser: ["dojo.event.browser"],
	dashboard: ["dojo.event.browser"]
});
dojo.provide("dojo.event.*");

dojo.provide("dojo.event");


dojo.deprecated("dojo.event", "replaced by dojo.event.*", "0.5");

dojo.provide("dojo.string.common");

dojo.string.trim = function(/* string */str, /* integer? */wh){
	//	summary
	//	Trim whitespace from str.  If wh > 0, trim from start, if wh < 0, trim from end, else both
	if(!str.replace){ return str; }
	if(!str.length){ return str; }
	var re = (wh > 0) ? (/^\s+/) : (wh < 0) ? (/\s+$/) : (/^\s+|\s+$/g);
	return str.replace(re, "");	//	string
}

dojo.string.trimStart = function(/* string */str) {
	//	summary
	//	Trim whitespace at the beginning of 'str'
	return dojo.string.trim(str, 1);	//	string
}

dojo.string.trimEnd = function(/* string */str) {
	//	summary
	//	Trim whitespace at the end of 'str'
	return dojo.string.trim(str, -1);
}

dojo.string.repeat = function(/* string */str, /* integer */count, /* string? */separator) {
	//	summary
	//	Return 'str' repeated 'count' times, optionally placing 'separator' between each rep
	var out = "";
	for(var i = 0; i < count; i++) {
		out += str;
		if(separator && i < count - 1) {
			out += separator;
		}
	}
	return out;	//	string
}

dojo.string.pad = function(/* string */str, /* integer */len/*=2*/, /* string */ c/*='0'*/, /* integer */dir/*=1*/) {
	//	summary
	//	Pad 'str' to guarantee that it is at least 'len' length with the character 'c' at either the 
	//	start (dir=1) or end (dir=-1) of the string
	var out = String(str);
	if(!c) {
		c = '0';
	}
	if(!dir) {
		dir = 1;
	}
	while(out.length < len) {
		if(dir > 0) {
			out = c + out;
		} else {
			out += c;
		}
	}
	return out;	//	string
}

dojo.string.padLeft = function(/* string */str, /* integer */len, /* string */c) {
	//	summary
	//	same as dojo.string.pad(str, len, c, 1)
	return dojo.string.pad(str, len, c, 1);	//	string
}

dojo.string.padRight = function(/* string */str, /* integer */len, /* string */c) {
	//	summary
	//	same as dojo.string.pad(str, len, c, -1)
	return dojo.string.pad(str, len, c, -1);	//	string
}

dojo.provide("dojo.string.extras");





//TODO: should we use ${} substitution syntax instead, like widgets do?
dojo.string.substituteParams = function(/*string*/template, /* object - optional or ... */hash){
// summary:
//	Performs parameterized substitutions on a string. Throws an exception if any parameter is unmatched.
//
// description:
//	For example,
//		dojo.string.substituteParams("File '%{0}' is not found in directory '%{1}'.","foo.html","/temp");
//	returns
//		"File 'foo.html' is not found in directory '/temp'."
//
// template: the original string template with %{values} to be replaced
// hash: name/value pairs (type object) to provide substitutions.  Alternatively, substitutions may be
//	included as arguments 1..n to this function, corresponding to template parameters 0..n-1

	var map = (typeof hash == 'object') ? hash : dojo.lang.toArray(arguments, 1);

	return template.replace(/\%\{(\w+)\}/g, function(match, key){
		if(typeof(map[key]) != "undefined" && map[key] != null){
			return map[key];
		}
		dojo.raise("Substitution not found: " + key);
	}); // string
};

dojo.string.capitalize = function(/*string*/str){
// summary:
//	Uppercases the first letter of each word

	if(!dojo.lang.isString(str)){ return ""; }
	if(arguments.length == 0){ str = this; }

	var words = str.split(' ');
	for(var i=0; i<words.length; i++){
		words[i] = words[i].charAt(0).toUpperCase() + words[i].substring(1);
	}
	return words.join(" "); // string
}

dojo.string.isBlank = function(/*string*/str){
// summary:
//	Return true if the entire string is whitespace characters

	if(!dojo.lang.isString(str)){ return true; }
	return (dojo.string.trim(str).length == 0); // boolean
}

//FIXME: not sure exactly what encodeAscii is trying to do, or if it's working right
dojo.string.encodeAscii = function(/*string*/str){
	if(!dojo.lang.isString(str)){ return str; } // unknown
	var ret = "";
	var value = escape(str);
	var match, re = /%u([0-9A-F]{4})/i;
	while((match = value.match(re))){
		var num = Number("0x"+match[1]);
		var newVal = escape("&#" + num + ";");
		ret += value.substring(0, match.index) + newVal;
		value = value.substring(match.index+match[0].length);
	}
	ret += value.replace(/\+/g, "%2B");
	return ret; // string
}

dojo.string.escape = function(/*string*/type, /*string*/str){
// summary:
//	Adds escape sequences for special characters according to the convention of 'type'
//
// type: one of xml|html|xhtml|sql|regexp|regex|javascript|jscript|js|ascii
// str: the string to be escaped

	var args = dojo.lang.toArray(arguments, 1);
	switch(type.toLowerCase()){
		case "xml":
		case "html":
		case "xhtml":
			return dojo.string.escapeXml.apply(this, args); // string
		case "sql":
			return dojo.string.escapeSql.apply(this, args); // string
		case "regexp":
		case "regex":
			return dojo.string.escapeRegExp.apply(this, args); // string
		case "javascript":
		case "jscript":
		case "js":
			return dojo.string.escapeJavaScript.apply(this, args); // string
		case "ascii":
			// so it's encode, but it seems useful
			return dojo.string.encodeAscii.apply(this, args); // string
		default:
			return str; // string
	}
}

dojo.string.escapeXml = function(/*string*/str, /*boolean*/noSingleQuotes){
//summary:
//	Adds escape sequences for special characters in XML: &<>"'
//  Optionally skips escapes for single quotes

	str = str.replace(/&/gm, "&amp;").replace(/</gm, "&lt;")
		.replace(/>/gm, "&gt;").replace(/"/gm, "&quot;");
	if(!noSingleQuotes){ str = str.replace(/'/gm, "&#39;"); }
	return str; // string
}

dojo.string.escapeSql = function(/*string*/str){
//summary:
//	Adds escape sequences for single quotes in SQL expressions

	return str.replace(/'/gm, "''"); //string
}

dojo.string.escapeRegExp = function(/*string*/str){
//summary:
//	Adds escape sequences for special characters in regular expressions

	return str.replace(/\\/gm, "\\\\").replace(/([\f\b\n\t\r[\^$|?*+(){}])/gm, "\\$1"); // string
}

//FIXME: should this one also escape backslash?
dojo.string.escapeJavaScript = function(/*string*/str){
//summary:
//	Adds escape sequences for single and double quotes as well
//	as non-visible characters in JavaScript string literal expressions

	return str.replace(/(["'\f\b\n\t\r])/gm, "\\$1"); // string
}

//FIXME: looks a lot like escapeJavaScript, just adds quotes? deprecate one?
dojo.string.escapeString = function(/*string*/str){
//summary:
//	Adds escape sequences for non-visual characters, double quote and backslash
//	and surrounds with double quotes to form a valid string literal.
	return ('"' + str.replace(/(["\\])/g, '\\$1') + '"'
		).replace(/[\f]/g, "\\f"
		).replace(/[\b]/g, "\\b"
		).replace(/[\n]/g, "\\n"
		).replace(/[\t]/g, "\\t"
		).replace(/[\r]/g, "\\r"); // string
}

// TODO: make an HTML version
dojo.string.summary = function(/*string*/str, /*number*/len){
// summary:
//	Truncates 'str' after 'len' characters and appends periods as necessary so that it ends with "..."

	if(!len || str.length <= len){
		return str; // string
	}

	return str.substring(0, len).replace(/\.+$/, "") + "..."; // string
}

dojo.string.endsWith = function(/*string*/str, /*string*/end, /*boolean*/ignoreCase){
// summary:
//	Returns true if 'str' ends with 'end'

	if(ignoreCase){
		str = str.toLowerCase();
		end = end.toLowerCase();
	}
	if((str.length - end.length) < 0){
		return false; // boolean
	}
	return str.lastIndexOf(end) == str.length - end.length; // boolean
}

dojo.string.endsWithAny = function(/*string*/str /* , ... */){
// summary:
//	Returns true if 'str' ends with any of the arguments[2 -> n]

	for(var i = 1; i < arguments.length; i++) {
		if(dojo.string.endsWith(str, arguments[i])) {
			return true; // boolean
		}
	}
	return false; // boolean
}

dojo.string.startsWith = function(/*string*/str, /*string*/start, /*boolean*/ignoreCase){
// summary:
//	Returns true if 'str' starts with 'start'

	if(ignoreCase) {
		str = str.toLowerCase();
		start = start.toLowerCase();
	}
	return str.indexOf(start) == 0; // boolean
}

dojo.string.startsWithAny = function(/*string*/str /* , ... */){
// summary:
//	Returns true if 'str' starts with any of the arguments[2 -> n]

	for(var i = 1; i < arguments.length; i++) {
		if(dojo.string.startsWith(str, arguments[i])) {
			return true; // boolean
		}
	}
	return false; // boolean
}

dojo.string.has = function(/*string*/str /* , ... */) {
// summary:
//	Returns true if 'str' contains any of the arguments 2 -> n

	for(var i = 1; i < arguments.length; i++) {
		if(str.indexOf(arguments[i]) > -1){
			return true; // boolean
		}
	}
	return false; // boolean
}

dojo.string.normalizeNewlines = function(/*string*/text, /*string? (\n or \r)*/newlineChar){
// summary:
//	Changes occurences of CR and LF in text to CRLF, or if newlineChar is provided as '\n' or '\r',
//	substitutes newlineChar for occurrences of CR/LF and CRLF

	if (newlineChar == "\n"){
		text = text.replace(/\r\n/g, "\n");
		text = text.replace(/\r/g, "\n");
	} else if (newlineChar == "\r"){
		text = text.replace(/\r\n/g, "\r");
		text = text.replace(/\n/g, "\r");
	}else{
		text = text.replace(/([^\r])\n/g, "$1\r\n").replace(/\r([^\n])/g, "\r\n$1");
	}
	return text; // string
}

dojo.string.splitEscaped = function(/*string*/str, /*string of length=1*/charac){
// summary:
//	Splits 'str' into an array separated by 'charac', but skips characters escaped with a backslash

	var components = [];
	for (var i = 0, prevcomma = 0; i < str.length; i++){
		if (str.charAt(i) == '\\'){ i++; continue; }
		if (str.charAt(i) == charac){
			components.push(str.substring(prevcomma, i));
			prevcomma = i + 1;
		}
	}
	components.push(str.substr(prevcomma));
	return components; // array
}

dojo.provide("dojo.AdapterRegistry");


dojo.AdapterRegistry = function(/*Boolean?*/ returnWrappers){
	// summary:
	//		A registry to make contextual calling/searching easier.
	// description:
	//		Objects of this class keep list of arrays in the form [name, check,
	//		wrap, directReturn] that are used to determine what the contextual
	//		result of a set of checked arguments is. All check/wrap functions
	//		in this registry should be of the same arity.
	this.pairs = [];
	this.returnWrappers = returnWrappers || false;
}

dojo.lang.extend(dojo.AdapterRegistry, {
	register: function(name, check, /*Function*/ wrap, directReturn, override){
		// summary: 
		//		register a check function to determine if the wrap function or
		//		object gets selected
		// name: String
		//		a way to identify this matcher.
		// check: Function
		//		a function that arguments are passed to from the adapter's
		//		match() function.  The check function should return true if the
		//		given arguments are appropriate for the wrap function.
		// directReturn: Boolean?
		//		If directReturn is true, the value passed in for wrap will be
		//		returned instead of being called. Alternately, the
		//		AdapterRegistry can be set globally to "return not call" using
		//		the returnWrappers property. Either way, this behavior allows
		//		the registry to act as a "search" function instead of a
		//		function interception library.
		// override: Boolean?
		//		If override is given and true, the check function will be given
		//		highest priority. Otherwise, it will be the lowest priority
		//		adapter.

		var type = (override) ? "unshift" : "push";
		this.pairs[type]([name, check, wrap, directReturn]);
	},

	match: function(/* ... */){
    // summary:
		//		Find an adapter for the given arguments. If no suitable adapter
		//		is found, throws an exception. match() accepts any number of
		//		arguments, all of which are passed to all matching functions
		//		from the registered pairs.
		for(var i = 0; i < this.pairs.length; i++){
			var pair = this.pairs[i];
			if(pair[1].apply(this, arguments)){
				if((pair[3])||(this.returnWrappers)){
					return pair[2];
				}else{
					return pair[2].apply(this, arguments);
				}
			}
		}
		throw new Error("No match found");
		// dojo.raise("No match found");
	},

	unregister: function(name){
		// summary: Remove a named adapter from the registry

		// FIXME: this is kind of a dumb way to handle this. On a large
		// registry this will be slow-ish and we can use the name as a lookup
		// should we choose to trade memory for speed.
		for(var i = 0; i < this.pairs.length; i++){
			var pair = this.pairs[i];
			if(pair[0] == name){
				this.pairs.splice(i, 1);
				return true;
			}
		}
		return false;
	}
});

dojo.provide("dojo.json");




dojo.json = {
	// jsonRegistry: AdapterRegistry a registry of type-based serializers
	jsonRegistry: new dojo.AdapterRegistry(),

	register: function(	/*String*/		name, 
						/*function*/	check, 
						/*function*/	wrap, 
						/*optional, boolean*/ override){
		// summary:
		//		Register a JSON serialization function. JSON serialization
		//		functions should take one argument and return an object
		//		suitable for JSON serialization:
		//			- string
		//			- number
		//			- boolean
		//			- undefined
		//			- object
		//				- null
		//				- Array-like (length property that is a number)
		//				- Objects with a "json" method will have this method called
		//				- Any other object will be used as {key:value, ...} pairs
		//			
		//		If override is given, it is used as the highest priority JSON
		//		serialization, otherwise it will be used as the lowest.
		// name:
		//		a descriptive type for this serializer
		// check:
		//		a unary function that will be passed an object to determine
		//		whether or not wrap will be used to serialize the object
		// wrap:
		//		the serialization function
		// override:
		//		optional, determines if the this serialization function will be
		//		given priority in the test order

		dojo.json.jsonRegistry.register(name, check, wrap, override);
	},

	evalJson: function(/*String*/ json){
		// summary:
		// 		evaluates the passed string-form of a JSON object
		// json: 
		//		a string literal of a JSON item, for instance:
		//			'{ "foo": [ "bar", 1, { "baz": "thud" } ] }'
		// return:
		//		the result of the evaluation

		// FIXME: should this accept mozilla's optional second arg?
		try {
			return eval("(" + json + ")");
		}catch(e){
			dojo.debug(e);
			return json;
		}
	},

	serialize: function(/*Object*/ o){
		// summary:
		//		Create a JSON serialization of an object, note that this
		//		doesn't check for infinite recursion, so don't do that!
		// o:
		//		an object to be serialized. Objects may define their own
		//		serialization via a special "__json__" or "json" function
		//		property. If a specialized serializer has been defined, it will
		//		be used as a fallback.
		// return:
		//		a String representing the serialized version of the passed
		//		object

		var objtype = typeof(o);
		if(objtype == "undefined"){
			return "undefined";
		}else if((objtype == "number")||(objtype == "boolean")){
			return o + "";
		}else if(o === null){
			return "null";
		}
		if (objtype == "string") { return dojo.string.escapeString(o); }
		// recurse
		var me = arguments.callee;
		// short-circuit for objects that support "json" serialization
		// if they return "self" then just pass-through...
		var newObj;
		if(typeof(o.__json__) == "function"){
			newObj = o.__json__();
			if(o !== newObj){
				return me(newObj);
			}
		}
		if(typeof(o.json) == "function"){
			newObj = o.json();
			if (o !== newObj) {
				return me(newObj);
			}
		}
		// array
		if(objtype != "function" && typeof(o.length) == "number"){
			var res = [];
			for(var i = 0; i < o.length; i++){
				var val = me(o[i]);
				if(typeof(val) != "string"){
					val = "undefined";
				}
				res.push(val);
			}
			return "[" + res.join(",") + "]";
		}
		// look in the registry
		try {
			window.o = o;
			newObj = dojo.json.jsonRegistry.match(o);
			return me(newObj);
		}catch(e){
			// dojo.debug(e);
		}
		// it's a function with no adapter, bad
		if(objtype == "function"){
			return null;
		}
		// generic object code path
		res = [];
		for (var k in o){
			var useKey;
			if (typeof(k) == "number"){
				useKey = '"' + k + '"';
			}else if (typeof(k) == "string"){
				useKey = dojo.string.escapeString(k);
			}else{
				// skip non-string or number keys
				continue;
			}
			val = me(o[k]);
			if(typeof(val) != "string"){
				// skip non-serializable values
				continue;
			}
			res.push(useKey + ":" + val);
		}
		return "{" + res.join(",") + "}";
	}
};

dojo.provide("dojo.html.common");



dojo.lang.mixin(dojo.html, dojo.dom);

dojo.html.body = function(){
	dojo.deprecated("dojo.html.body() moved to dojo.body()", "0.5");
	return dojo.body();
}

// FIXME: we are going to assume that we can throw any and every rendering
// engine into the IE 5.x box model. In Mozilla, we do this w/ CSS.
// Need to investigate for KHTML and Opera

dojo.html.getEventTarget = function(/* DOMEvent */evt){
	//	summary
	//	Returns the target of an event
	if(!evt) { evt = dojo.global().event || {} };
	var t = (evt.srcElement ? evt.srcElement : (evt.target ? evt.target : null));
	while((t)&&(t.nodeType!=1)){ t = t.parentNode; }
	return t;	//	HTMLElement
}

dojo.html.getViewport = function(){
	//	summary
	//	Returns the dimensions of the viewable area of a browser window
	var _window = dojo.global();
	var _document = dojo.doc();
	var w = 0;
	var h = 0;

	if(dojo.render.html.mozilla){
		// mozilla
		w = _document.documentElement.clientWidth;
		h = _window.innerHeight;
	}else if(!dojo.render.html.opera && _window.innerWidth){
		//in opera9, dojo.body().clientWidth should be used, instead
		//of window.innerWidth/document.documentElement.clientWidth
		//so we have to check whether it is opera
		w = _window.innerWidth;
		h = _window.innerHeight;
	} else if (!dojo.render.html.opera && dojo.exists(_document, "documentElement.clientWidth")){
		// IE6 Strict
		var w2 = _document.documentElement.clientWidth;
		// this lets us account for scrollbars
		if(!w || w2 && w2 < w) {
			w = w2;
		}
		h = _document.documentElement.clientHeight;
	} else if (dojo.body().clientWidth){
		// IE, Opera
		w = dojo.body().clientWidth;
		h = dojo.body().clientHeight;
	}
	return { width: w, height: h };	//	object
}

dojo.html.getScroll = function(){
	//	summary
	//	Returns the scroll position of the document
	var _window = dojo.global();
	var _document = dojo.doc();
	var top = _window.pageYOffset || _document.documentElement.scrollTop || dojo.body().scrollTop || 0;
	var left = _window.pageXOffset || _document.documentElement.scrollLeft || dojo.body().scrollLeft || 0;
	return { 
		top: top, 
		left: left, 
		offset:{ x: left, y: top }	//	note the change, NOT an Array with added properties. 
	};	//	object
}

dojo.html.getParentByType = function(/* HTMLElement */node, /* string */type) {
	//	summary
	//	Returns the first ancestor of node with tagName type.
	var _document = dojo.doc();
	var parent = dojo.byId(node);
	type = type.toLowerCase();
	while((parent)&&(parent.nodeName.toLowerCase()!=type)){
		if(parent==(_document["body"]||_document["documentElement"])){
			return null;
		}
		parent = parent.parentNode;
	}
	return parent;	//	HTMLElement
}

dojo.html.getAttribute = function(/* HTMLElement */node, /* string */attr){
	//	summary
	//	Returns the value of attribute attr from node.
	node = dojo.byId(node);
	// FIXME: need to add support for attr-specific accessors
	if((!node)||(!node.getAttribute)){
		// if(attr !== 'nwType'){
		//	alert("getAttr of '" + attr + "' with bad node"); 
		// }
		return null;
	}
	var ta = typeof attr == 'string' ? attr : new String(attr);

	// first try the approach most likely to succeed
	var v = node.getAttribute(ta.toUpperCase());
	if((v)&&(typeof v == 'string')&&(v!="")){ 
		return v;	//	string 
	}

	// try returning the attributes value, if we couldn't get it as a string
	if(v && v.value){ 
		return v.value;	//	string 
	}

	// this should work on Opera 7, but it's a little on the crashy side
	if((node.getAttributeNode)&&(node.getAttributeNode(ta))){
		return (node.getAttributeNode(ta)).value;	//	string
	}else if(node.getAttribute(ta)){
		return node.getAttribute(ta);	//	string
	}else if(node.getAttribute(ta.toLowerCase())){
		return node.getAttribute(ta.toLowerCase());	//	string
	}
	return null;	//	string
}
	
dojo.html.hasAttribute = function(/* HTMLElement */node, /* string */attr){
	//	summary
	//	Determines whether or not the specified node carries a value for the attribute in question.
	return dojo.html.getAttribute(dojo.byId(node), attr) ? true : false;	//	boolean
}
	
dojo.html.getCursorPosition = function(/* DOMEvent */e){
	//	summary
	//	Returns the mouse position relative to the document (not the viewport).
	//	For example, if you have a document that is 10000px tall,
	//	but your browser window is only 100px tall,
	//	if you scroll to the bottom of the document and call this function it
	//	will return {x: 0, y: 10000}
	//	NOTE: for events delivered via dojo.event.connect() and/or dojoAttachEvent (for widgets),
	//	you can just access evt.pageX and evt.pageY, rather than calling this function.
	e = e || dojo.global().event;
	var cursor = {x:0, y:0};
	if(e.pageX || e.pageY){
		cursor.x = e.pageX;
		cursor.y = e.pageY;
	}else{
		var de = dojo.doc().documentElement;
		var db = dojo.body();
		cursor.x = e.clientX + ((de||db)["scrollLeft"]) - ((de||db)["clientLeft"]);
		cursor.y = e.clientY + ((de||db)["scrollTop"]) - ((de||db)["clientTop"]);
	}
	return cursor;	//	object
}

dojo.html.isTag = function(/* HTMLElement */node) {
	//	summary
	//	Like dojo.dom.isTag, except case-insensitive
	node = dojo.byId(node);
	if(node && node.tagName) {
		for (var i=1; i<arguments.length; i++){
			if (node.tagName.toLowerCase()==String(arguments[i]).toLowerCase()){
				return String(arguments[i]).toLowerCase();	//	string
			}
		}
	}
	return "";	//	string
}

//define dojo.html.createExternalElement for IE to workaround the annoying activation "feature" in new IE
//details: http://msdn.microsoft.com/library/default.asp?url=/workshop/author/dhtml/overview/activating_activex.asp
if(dojo.render.html.ie && !dojo.render.html.ie70){
	//only define createExternalElement for IE in none https to avoid "mixed content" warning dialog
	if(window.location.href.substr(0,6).toLowerCase() != "https:"){
		(function(){
			// FIXME: this seems not to work correctly on IE 7!!

			//The trick is to define a function in a script.src property:
			// <script src="javascript:'function createExternalElement(){...}'"></script>,
			//which will be treated as an external javascript file in IE
			var xscript = dojo.doc().createElement('script');
			xscript.src = "javascript:'dojo.html.createExternalElement=function(doc, tag){ return doc.createElement(tag); }'";
			dojo.doc().getElementsByTagName("head")[0].appendChild(xscript);
		})();
	}
}else{
	//for other browsers, simply use document.createElement
	//is enough
	dojo.html.createExternalElement = function(/* HTMLDocument */doc, /* string */tag){
		//	summary
		//	Creates an element in the HTML document, here for ActiveX activation workaround.
		return doc.createElement(tag);	//	HTMLElement
	}
}

dojo.html._callDeprecated = function(inFunc, replFunc, args, argName, retValue){
	dojo.deprecated("dojo.html." + inFunc,
					"replaced by dojo.html." + replFunc + "(" + (argName ? "node, {"+ argName + ": " + argName + "}" : "" ) + ")" + (retValue ? "." + retValue : ""), "0.5");
	var newArgs = [];
	if(argName){ var argsIn = {}; argsIn[argName] = args[1]; newArgs.push(args[0]); newArgs.push(argsIn); }
	else { newArgs = args }
	var ret = dojo.html[replFunc].apply(dojo.html, args);
	if(retValue){ return ret[retValue]; }
	else { return ret; }
}

dojo.html.getViewportWidth = function(){
	return dojo.html._callDeprecated("getViewportWidth", "getViewport", arguments, null, "width");
}
dojo.html.getViewportHeight = function(){
	return dojo.html._callDeprecated("getViewportHeight", "getViewport", arguments, null, "height");
}
dojo.html.getViewportSize = function(){
	return dojo.html._callDeprecated("getViewportSize", "getViewport", arguments);
}
dojo.html.getScrollTop = function(){
	return dojo.html._callDeprecated("getScrollTop", "getScroll", arguments, null, "top");
}
dojo.html.getScrollLeft = function(){
	return dojo.html._callDeprecated("getScrollLeft", "getScroll", arguments, null, "left");
}
dojo.html.getScrollOffset = function(){
	return dojo.html._callDeprecated("getScrollOffset", "getScroll", arguments, null, "offset");
}

dojo.provide("dojo.uri.Uri");

dojo.uri = new function() {
	this.dojoUri = function (/*dojo.uri.Uri||String*/uri) {
		// summary: returns a Uri object resolved relative to the dojo root
		return new dojo.uri.Uri(dojo.hostenv.getBaseScriptUri(), uri);
	}

	this.moduleUri = function(/*String*/module, /*dojo.uri.Uri||String*/uri){
		// summary: returns a Uri object relative to a module
		// description: Examples: dojo.uri.moduleUri("dojo.widget","templates/template.html"), or dojo.uri.moduleUri("acme","images/small.png")
		var loc = dojo.hostenv.getModuleSymbols(module).join('/');
		if(!loc){
			return null;
		}
		if(loc.lastIndexOf("/") != loc.length-1){
			loc += "/";
		}
		
		//If the path is an absolute path (starts with a / or is on another domain/xdomain)
		//then don't add the baseScriptUri.
		var colonIndex = loc.indexOf(":");
		var slashIndex = loc.indexOf("/");
		if(loc.charAt(0) != "/" && (colonIndex == -1 || colonIndex > slashIndex)){
			loc = dojo.hostenv.getBaseScriptUri() + loc;
		}

		return new dojo.uri.Uri(loc,uri);
	}

	this.Uri = function (/*dojo.uri.Uri||String...*/) {
		// summary: Constructor to create an object representing a URI.
		// description: 
		//  Each argument is evaluated in order relative to the next until
		//  a canonical uri is produced. To get an absolute Uri relative
		//  to the current document use
		//      new dojo.uri.Uri(document.baseURI, uri)

		// TODO: support for IPv6, see RFC 2732

		// resolve uri components relative to each other
		var uri = arguments[0];
		for (var i = 1; i < arguments.length; i++) {
			if(!arguments[i]) { continue; }

			// Safari doesn't support this.constructor so we have to be explicit
			var relobj = new dojo.uri.Uri(arguments[i].toString());
			var uriobj = new dojo.uri.Uri(uri.toString());

			if ((relobj.path=="")&&(relobj.scheme==null)&&(relobj.authority==null)&&(relobj.query==null)) {
				if (relobj.fragment != null) { uriobj.fragment = relobj.fragment; }
				relobj = uriobj;
			} else if (relobj.scheme == null) {
				relobj.scheme = uriobj.scheme;

				if (relobj.authority == null) {
					relobj.authority = uriobj.authority;

					if (relobj.path.charAt(0) != "/") {
						var path = uriobj.path.substring(0,
							uriobj.path.lastIndexOf("/") + 1) + relobj.path;

						var segs = path.split("/");
						for (var j = 0; j < segs.length; j++) {
							if (segs[j] == ".") {
								if (j == segs.length - 1) { segs[j] = ""; }
								else { segs.splice(j, 1); j--; }
							} else if (j > 0 && !(j == 1 && segs[0] == "") &&
								segs[j] == ".." && segs[j-1] != "..") {

								if (j == segs.length - 1) { segs.splice(j, 1); segs[j - 1] = ""; }
								else { segs.splice(j - 1, 2); j -= 2; }
							}
						}
						relobj.path = segs.join("/");
					}
				}
			}

			uri = "";
			if (relobj.scheme != null) { uri += relobj.scheme + ":"; }
			if (relobj.authority != null) { uri += "//" + relobj.authority; }
			uri += relobj.path;
			if (relobj.query != null) { uri += "?" + relobj.query; }
			if (relobj.fragment != null) { uri += "#" + relobj.fragment; }
		}

		this.uri = uri.toString();

		// break the uri into its main components
		var regexp = "^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$";
		var r = this.uri.match(new RegExp(regexp));

		this.scheme = r[2] || (r[1] ? "" : null);
		this.authority = r[4] || (r[3] ? "" : null);
		this.path = r[5]; // can never be undefined
		this.query = r[7] || (r[6] ? "" : null);
		this.fragment  = r[9] || (r[8] ? "" : null);

		if (this.authority != null) {
			// server based naming authority
			regexp = "^((([^:]+:)?([^@]+))@)?([^:]*)(:([0-9]+))?$";
			r = this.authority.match(new RegExp(regexp));

			this.user = r[3] || null;
			this.password = r[4] || null;
			this.host = r[5];
			this.port = r[7] || null;
		}

		this.toString = function(){ return this.uri; }
	}
};

dojo.provide("dojo.html.style");



dojo.html.getClass = function(/* HTMLElement */node){
	//	summary
	//	Returns the string value of the list of CSS classes currently assigned directly 
	//	to the node in question. Returns an empty string if no class attribute is found;
	node = dojo.byId(node);
	if(!node){ return ""; }
	var cs = "";
	if(node.className){
		cs = node.className;
	}else if(dojo.html.hasAttribute(node, "class")){
		cs = dojo.html.getAttribute(node, "class");
	}
	return cs.replace(/^\s+|\s+$/g, "");	//	string
}

dojo.html.getClasses = function(/* HTMLElement */node) {
	//	summary
	//	Returns an array of CSS classes currently assigned directly to the node in question. 
	//	Returns an empty array if no classes are found;
	var c = dojo.html.getClass(node);
	return (c == "") ? [] : c.split(/\s+/g);	//	array
}

dojo.html.hasClass = function(/* HTMLElement */node, /* string */classname){
	//	summary
	//	Returns whether or not the specified classname is a portion of the
	//	class list currently applied to the node. Does not cover cascaded
	//	styles, only classes directly applied to the node.
	return (new RegExp('(^|\\s+)'+classname+'(\\s+|$)')).test(dojo.html.getClass(node))	//	boolean
}

dojo.html.prependClass = function(/* HTMLElement */node, /* string */classStr){
	//	summary
	//	Adds the specified class to the beginning of the class list on the
	//	passed node. This gives the specified class the highest precidence
	//	when style cascading is calculated for the node. Returns true or
	//	false; indicating success or failure of the operation, respectively.
	classStr += " " + dojo.html.getClass(node);
	return dojo.html.setClass(node, classStr);	//	boolean
}

dojo.html.addClass = function(/* HTMLElement */node, /* string */classStr){
	//	summary
	//	Adds the specified class to the end of the class list on the
	//	passed &node;. Returns &true; or &false; indicating success or failure.
	if (dojo.html.hasClass(node, classStr)) {
	  return false;
	}
	classStr = (dojo.html.getClass(node) + " " + classStr).replace(/^\s+|\s+$/g,"");
	return dojo.html.setClass(node, classStr);	//	boolean
}

dojo.html.setClass = function(/* HTMLElement */node, /* string */classStr){
	//	summary
	//	Clobbers the existing list of classes for the node, replacing it with
	//	the list given in the 2nd argument. Returns true or false
	//	indicating success or failure.
	node = dojo.byId(node);
	var cs = new String(classStr);
	try{
		if(typeof node.className == "string"){
			node.className = cs;
		}else if(node.setAttribute){
			node.setAttribute("class", classStr);
			node.className = cs;
		}else{
			return false;
		}
	}catch(e){
		dojo.debug("dojo.html.setClass() failed", e);
	}
	return true;
}

dojo.html.removeClass = function(/* HTMLElement */node, /* string */classStr, /* boolean? */allowPartialMatches){
	//	summary
	//	Removes the className from the node;. Returns true or false indicating success or failure.
	try{
		if (!allowPartialMatches) {
			var newcs = dojo.html.getClass(node).replace(new RegExp('(^|\\s+)'+classStr+'(\\s+|$)'), "$1$2");
		} else {
			var newcs = dojo.html.getClass(node).replace(classStr,'');
		}
		dojo.html.setClass(node, newcs);
	}catch(e){
		dojo.debug("dojo.html.removeClass() failed", e);
	}
	return true;	//	boolean
}

dojo.html.replaceClass = function(/* HTMLElement */node, /* string */newClass, /* string */oldClass) {
	//	summary
	//	Replaces 'oldClass' and adds 'newClass' to node
	dojo.html.removeClass(node, oldClass);
	dojo.html.addClass(node, newClass);
}

// Enum type for getElementsByClass classMatchType arg:
dojo.html.classMatchType = {
	ContainsAll : 0, // all of the classes are part of the node's class (default)
	ContainsAny : 1, // any of the classes are part of the node's class
	IsOnly : 2 // only all of the classes are part of the node's class
}


dojo.html.getElementsByClass = function(
	/* string */classStr, 
	/* HTMLElement? */parent, 
	/* string? */nodeType, 
	/* integer? */classMatchType, 
	/* boolean? */useNonXpath
){
	//	summary
	//	Returns an array of nodes for the given classStr, children of a
	//	parent, and optionally of a certain nodeType
	// FIXME: temporarily set to false because of several dojo tickets related
	// to the xpath version not working consistently in firefox.
	useNonXpath = false;
	var _document = dojo.doc();
	parent = dojo.byId(parent) || _document;
	var classes = classStr.split(/\s+/g);
	var nodes = [];
	if( classMatchType != 1 && classMatchType != 2 ) classMatchType = 0; // make it enum
	var reClass = new RegExp("(\\s|^)((" + classes.join(")|(") + "))(\\s|$)");
	var srtLength = classes.join(" ").length;
	var candidateNodes = [];
	
	if(!useNonXpath && _document.evaluate) { // supports dom 3 xpath
		var xpath = ".//" + (nodeType || "*") + "[contains(";
		if(classMatchType != dojo.html.classMatchType.ContainsAny){
			xpath += "concat(' ',@class,' '), ' " +
			classes.join(" ') and contains(concat(' ',@class,' '), ' ") +
			" ')";
			if (classMatchType == 2) {
				xpath += " and string-length(@class)="+srtLength+"]";
			}else{
				xpath += "]";
			}
		}else{
			xpath += "concat(' ',@class,' '), ' " +
			classes.join(" ') or contains(concat(' ',@class,' '), ' ") +
			" ')]";
		}
		var xpathResult = _document.evaluate(xpath, parent, null, XPathResult.ANY_TYPE, null);
		var result = xpathResult.iterateNext();
		while(result){
			try{
				candidateNodes.push(result);
				result = xpathResult.iterateNext();
			}catch(e){ break; }
		}
		return candidateNodes;	//	NodeList
	}else{
		if(!nodeType){
			nodeType = "*";
		}
		candidateNodes = parent.getElementsByTagName(nodeType);

		var node, i = 0;
		outer:
		while(node = candidateNodes[i++]){
			var nodeClasses = dojo.html.getClasses(node);
			if(nodeClasses.length == 0){ continue outer; }
			var matches = 0;
	
			for(var j = 0; j < nodeClasses.length; j++){
				if(reClass.test(nodeClasses[j])){
					if(classMatchType == dojo.html.classMatchType.ContainsAny){
						nodes.push(node);
						continue outer;
					}else{
						matches++;
					}
				}else{
					if(classMatchType == dojo.html.classMatchType.IsOnly){
						continue outer;
					}
				}
			}
	
			if(matches == classes.length){
				if(	(classMatchType == dojo.html.classMatchType.IsOnly)&&
					(matches == nodeClasses.length)){
					nodes.push(node);
				}else if(classMatchType == dojo.html.classMatchType.ContainsAll){
					nodes.push(node);
				}
			}
		}
		return nodes;	//	NodeList
	}
}
dojo.html.getElementsByClassName = dojo.html.getElementsByClass;

dojo.html.toCamelCase = function(/* string */selector){
	//	summary
	//	Translates a CSS selector string to a camel-cased one.
	var arr = selector.split('-'), cc = arr[0];
	for(var i = 1; i < arr.length; i++) {
		cc += arr[i].charAt(0).toUpperCase() + arr[i].substring(1);
	}
	return cc;	//	string
}

dojo.html.toSelectorCase = function(/* string */selector){
	//	summary
	//	Translates a camel cased string to a selector cased one.
	return selector.replace(/([A-Z])/g, "-$1" ).toLowerCase();	//	string
}

if (dojo.render.html.ie) {
	// IE branch
	dojo.html.getComputedStyle = function(/*HTMLElement|String*/node, /*String*/property, /*String*/value) {
		// summary
		// Get the computed style value for style "property" on "node" (IE).
		node = dojo.byId(node); // FIXME: remove ability to access nodes by id for this time-critical function
		if(!node || !node.currentStyle){return value;}
		// FIXME: standardize on camel-case input to improve speed
		return node.currentStyle[dojo.html.toCamelCase(property)]; // String
	}
	// SJM: getComputedStyle should be abandoned and replaced with the below function.
	// All our supported browsers can return CSS2 compliant CssStyleDeclaration objects
	// which can be queried directly for multiple styles.
	dojo.html.getComputedStyles = function(/*HTMLElement*/node) {
		// summary
		// Get a style object containing computed styles for HTML Element node (IE).
		return node.currentStyle; // CSSStyleDeclaration
	}
} else {
	// non-IE branch
	dojo.html.getComputedStyle = function(/*HTMLElement|String*/node, /*String*/property, /*Any*/value) {
		// summary
		// Get the computed style value for style "property" on "node" (non-IE).
		node = dojo.byId(node);
		if(!node || !node.style){return value;}
		var s = document.defaultView.getComputedStyle(node, null);
		// s may be null on Safari
		return (s&&s[dojo.html.toCamelCase(property)])||''; // String
	}	
	// SJM: getComputedStyle should be abandoned and replaced with the below function.
	// All our supported browsers can return CSS2 compliant CssStyleDeclaration objects
	// which can be queried directly for multiple styles.
	dojo.html.getComputedStyles = function(node) {
		// summary
		// Get a style object containing computed styles for HTML Element node (non-IE).
		return document.defaultView.getComputedStyle(node, null); // CSSStyleDeclaration
	}	
}

dojo.html.getStyleProperty = function(/* HTMLElement */node, /* string */cssSelector){
	//	summary
	//	Returns the value of the passed style
	node = dojo.byId(node);
	return (node && node.style ? node.style[dojo.html.toCamelCase(cssSelector)] : undefined);	//	string
}

dojo.html.getStyle = function(/* HTMLElement */node, /* string */cssSelector){
	//	summary
	//	Returns the computed value of the passed style
	var value = dojo.html.getStyleProperty(node, cssSelector);
	return (value ? value : dojo.html.getComputedStyle(node, cssSelector));	//	string || integer
}

dojo.html.setStyle = function(/* HTMLElement */node, /* string */cssSelector, /* string */value){
	//	summary
	//	Set the value of passed style on node
	node = dojo.byId(node);
	if(node && node.style){
		var camelCased = dojo.html.toCamelCase(cssSelector);
		node.style[camelCased] = value;
	}
}

dojo.html.setStyleText = function (/* HTMLElement */target, /* string */text) {
	//	summary
	//	Try to set the entire cssText property of the passed target; equiv of setting style attribute.
	try {
	 	target.style.cssText = text;
	} catch (e) {
		target.setAttribute("style", text);
	}
}

dojo.html.copyStyle = function(/* HTMLElement */target, /* HTMLElement */source){
	//	summary
	// work around for opera which doesn't have cssText, and for IE which fails on setAttribute 
	if(!source.style.cssText){ 
		target.setAttribute("style", source.getAttribute("style")); 
	}else{
		target.style.cssText = source.style.cssText; 
	}
	dojo.html.addClass(target, dojo.html.getClass(source));
}

dojo.html.getUnitValue = function(/* HTMLElement */node, /* string */cssSelector, /* boolean? */autoIsZero){
	//	summary
	//	Get the value of passed selector, with the specific units used
	var s = dojo.html.getComputedStyle(node, cssSelector);
	if((!s)||((s == 'auto')&&(autoIsZero))){ 
		return { value: 0, units: 'px' };	//	object 
	}
	// FIXME: is regex inefficient vs. parseInt or some manual test? 
	var match = s.match(/(\-?[\d.]+)([a-z%]*)/i);
	if (!match){return dojo.html.getUnitValue.bad;}
	return { value: Number(match[1]), units: match[2].toLowerCase() };	//	object
}
dojo.html.getUnitValue.bad = { value: NaN, units: '' };

if (dojo.render.html.ie) {
	// IE branch
	dojo.html.toPixelValue = function(/* HTMLElement */element, /* String */styleValue){
		// summary
		//  Extract value in pixels from styleValue (IE version).
		//  If a value cannot be extracted, zero is returned.
		if(!styleValue){return 0;}
		if(styleValue.slice(-2) == 'px'){return parseFloat(styleValue);}
		var pixelValue = 0;
		with(element){
			var sLeft = style.left;
			var rsLeft = runtimeStyle.left;
			runtimeStyle.left = currentStyle.left;
			try {
				style.left = styleValue || 0;
				pixelValue = style.pixelLeft;
				style.left = sLeft;
				runtimeStyle.left = rsLeft;
			}catch(e){
				// FIXME: it's possible for styleValue to be incompatible with
				// style.left. In particular, border width values of 
				// "thick", "medium", or "thin" will provoke an exception.
			}
		}
		return pixelValue; // Number
	}
} else {
	// non-IE branch
	dojo.html.toPixelValue = function(/* HTMLElement */element, /* String */styleValue){
		// summary
		//  Extract value in pixels from styleValue (non-IE version).
		//  If a value cannot be extracted, zero is returned.
		return (styleValue && (styleValue.slice(-2)=='px') ? parseFloat(styleValue) : 0); // Number
	}
}

dojo.html.getPixelValue = function(/* HTMLElement */node, /* string */styleProperty, /* boolean? */autoIsZero){
	// summary
	//  Get a computed style value, in pixels.
	// node: HTMLElement
	//  Node to interrogate
	// styleProperty: String
	//  Style property to query, in either css-selector or camelCase (property) format.
	// autoIsZero: Boolean
	//  Deprecated. Any value that cannot be converted to pixels is returned as zero.
	// 
	//  summary
	//  Get the value of passed selector in pixels.
	//
	return dojo.html.toPixelValue(node, dojo.html.getComputedStyle(node, styleProperty));
} 

dojo.html.setPositivePixelValue = function(/* HTMLElement */node, /* string */selector, /* integer */value){
	//	summary
	//	Attempt to set the value of selector on node as a positive pixel value.
	if(isNaN(value)){return false;}
	node.style[selector] = Math.max(0, value) + 'px'; 
	return true;	//	boolean
}

dojo.html.styleSheet = null;

// FIXME: this is a really basic stub for adding and removing cssRules, but
// it assumes that you know the index of the cssRule that you want to add 
// or remove, making it less than useful.  So we need something that can 
// search for the selector that you you want to remove.
dojo.html.insertCssRule = function(/* string */selector, /* string */declaration, /* integer? */index) {
	//	summary
	//	Attempt to insert declaration as selector on the internal stylesheet; if index try to set it there.
	if (!dojo.html.styleSheet) {
		if (document.createStyleSheet) { // IE
			dojo.html.styleSheet = document.createStyleSheet();
		} else if (document.styleSheets[0]) { // rest
			// FIXME: should create a new style sheet here
			// fall back on an exsiting style sheet
			dojo.html.styleSheet = document.styleSheets[0];
		} else { 
			return null;	//	integer 
		} // fail
	}

	if (arguments.length < 3) { // index may == 0
		if (dojo.html.styleSheet.cssRules) { // W3
			index = dojo.html.styleSheet.cssRules.length;
		} else if (dojo.html.styleSheet.rules) { // IE
			index = dojo.html.styleSheet.rules.length;
		} else { 
			return null;	//	integer 
		} // fail
	}

	if (dojo.html.styleSheet.insertRule) { // W3
		var rule = selector + " { " + declaration + " }";
		return dojo.html.styleSheet.insertRule(rule, index);	//	integer
	} else if (dojo.html.styleSheet.addRule) { // IE
		return dojo.html.styleSheet.addRule(selector, declaration, index);	//	integer
	} else { 
		return null; // integer
	} // fail
}

dojo.html.removeCssRule = function(/* integer? */index){
	//	summary
	//	Attempt to remove the rule at index.
	if(!dojo.html.styleSheet){
		dojo.debug("no stylesheet defined for removing rules");
		return false;
	}
	if(dojo.render.html.ie){
		if(!index){
			index = dojo.html.styleSheet.rules.length;
			dojo.html.styleSheet.removeRule(index);
		}
	}else if(document.styleSheets[0]){
		if(!index){
			index = dojo.html.styleSheet.cssRules.length;
		}
		dojo.html.styleSheet.deleteRule(index);
	}
	return true;	//	boolean
}

dojo.html._insertedCssFiles = []; // cache container needed because IE reformats cssText when added to DOM
dojo.html.insertCssFile = function(/* string */URI, /* HTMLDocument? */doc, /* boolean? */checkDuplicates, /* boolean */fail_ok){
	//	summary
	// calls css by XmlHTTP and inserts it into DOM as <style [widgetType="widgetType"]> *downloaded cssText*</style>
	if(!URI){ return; }
	if(!doc){ doc = document; }
	var cssStr = dojo.hostenv.getText(URI, false, fail_ok);
	if(cssStr===null){ return; }
	cssStr = dojo.html.fixPathsInCssText(cssStr, URI);

	if(checkDuplicates){
		var idx = -1, node, ent = dojo.html._insertedCssFiles;
		for(var i = 0; i < ent.length; i++){
			if((ent[i].doc == doc) && (ent[i].cssText == cssStr)){
				idx = i; node = ent[i].nodeRef;
				break;
			}
		}
		// make sure we havent deleted our node
		if(node){
			var styles = doc.getElementsByTagName("style");
			for(var i = 0; i < styles.length; i++){
				if(styles[i] == node){
					return;
				}
			}
			// delete this entry
			dojo.html._insertedCssFiles.shift(idx, 1);
		}
	}

	var style = dojo.html.insertCssText(cssStr, doc);
	dojo.html._insertedCssFiles.push({'doc': doc, 'cssText': cssStr, 'nodeRef': style});

	// insert custom attribute ex dbgHref="../foo.css" usefull when debugging in DOM inspectors, no?
	if(style && djConfig.isDebug){
		style.setAttribute("dbgHref", URI);
	}
	return style;	//	HTMLStyleElement
}

dojo.html.insertCssText = function(/* string */cssStr, /* HTMLDocument? */doc, /* string? */URI){
	//	summary
	//	Attempt to insert CSS rules into the document through inserting a style element
	// DomNode Style  = insertCssText(String ".dojoMenu {color: green;}"[, DomDoc document, dojo.uri.Uri Url ])
	if(!cssStr){ 
		return; //	HTMLStyleElement
	}
	if(!doc){ doc = document; }
	if(URI){// fix paths in cssStr
		cssStr = dojo.html.fixPathsInCssText(cssStr, URI);
	}
	var style = doc.createElement("style");
	style.setAttribute("type", "text/css");
	// IE is b0rken enough to require that we add the element to the doc
	// before changing it's properties
	var head = doc.getElementsByTagName("head")[0];
	if(!head){ // must have a head tag 
		dojo.debug("No head tag in document, aborting styles");
		return;	//	HTMLStyleElement
	}else{
		head.appendChild(style);
	}
	if(style.styleSheet){// IE
		var setFunc = function(){ 
			try{
				style.styleSheet.cssText = cssStr;
			}catch(e){ dojo.debug(e); }
		};
		if(style.styleSheet.disabled){
			setTimeout(setFunc, 10);
		}else{
			setFunc();
		}
	}else{ // w3c
		var cssText = doc.createTextNode(cssStr);
		style.appendChild(cssText);
	}
	return style;	//	HTMLStyleElement
}

dojo.html.fixPathsInCssText = function(/* string */cssStr, /* string */URI){
	//	summary
	// usage: cssText comes from dojoroot/src/widget/templates/Foobar.css
	// 	it has .dojoFoo { background-image: url(images/bar.png);} then uri should point to dojoroot/src/widget/templates/
	if(!cssStr || !URI){ return; }
	var match, str = "", url = "", urlChrs = "[\\t\\s\\w\\(\\)\\/\\.\\\\'\"-:#=&?~]+";
	var regex = new RegExp('url\\(\\s*('+urlChrs+')\\s*\\)');
	var regexProtocol = /(file|https?|ftps?):\/\//;
	regexTrim = new RegExp("^[\\s]*(['\"]?)("+urlChrs+")\\1[\\s]*?$");
	if(dojo.render.html.ie55 || dojo.render.html.ie60){
		var regexIe = new RegExp("AlphaImageLoader\\((.*)src\=['\"]("+urlChrs+")['\"]");
		// TODO: need to decide how to handle relative paths and AlphaImageLoader see #1441
		// current implementation breaks on build with intern_strings
		while(match = regexIe.exec(cssStr)){
			url = match[2].replace(regexTrim, "$2");
			if(!regexProtocol.exec(url)){
				url = (new dojo.uri.Uri(URI, url).toString());
			}
			str += cssStr.substring(0, match.index) + "AlphaImageLoader(" + match[1] + "src='" + url + "'";
			cssStr = cssStr.substr(match.index + match[0].length);
		}
		cssStr = str + cssStr;
		str = "";
	}

	while(match = regex.exec(cssStr)){
		url = match[1].replace(regexTrim, "$2");
		if(!regexProtocol.exec(url)){
			url = (new dojo.uri.Uri(URI, url).toString());
		}
		str += cssStr.substring(0, match.index) + "url(" + url + ")";
		cssStr = cssStr.substr(match.index + match[0].length);
	}
	return str + cssStr;	//	string
}

dojo.html.setActiveStyleSheet = function(/* string */title){
	//	summary
	//	Activate style sheet with specified title.
	var i = 0, a, els = dojo.doc().getElementsByTagName("link");
	while (a = els[i++]) {
		if(a.getAttribute("rel").indexOf("style") != -1 && a.getAttribute("title")){
			a.disabled = true;
			if (a.getAttribute("title") == title) { a.disabled = false; }
		}
	}
}

dojo.html.getActiveStyleSheet = function(){
	//	summary
	//	return the title of the currently active stylesheet
	var i = 0, a, els = dojo.doc().getElementsByTagName("link");
	while (a = els[i++]) {
		if (a.getAttribute("rel").indexOf("style") != -1 
			&& a.getAttribute("title") 
			&& !a.disabled
		){
			return a.getAttribute("title");	//	string 
		}
	}
	return null;	//	string
}

dojo.html.getPreferredStyleSheet = function(){
	//	summary
	//	Return the preferred stylesheet title (i.e. link without alt attribute)
	var i = 0, a, els = dojo.doc().getElementsByTagName("link");
	while (a = els[i++]) {
		if(a.getAttribute("rel").indexOf("style") != -1
			&& a.getAttribute("rel").indexOf("alt") == -1
			&& a.getAttribute("title")
		){ 
			return a.getAttribute("title"); 	//	string
		}
	}
	return null;	//	string
}

dojo.html.applyBrowserClass = function(/* HTMLElement */node){
	//	summary
	//	Applies pre-set class names based on browser & version to the passed node.
	//	Modified version of Morris' CSS hack.
	var drh=dojo.render.html;
	var classes = {
		dj_ie: drh.ie,
		dj_ie55: drh.ie55,
		dj_ie6: drh.ie60,
		dj_ie7: drh.ie70,
		dj_iequirks: drh.ie && drh.quirks,
		dj_opera: drh.opera,
		dj_opera8: drh.opera && (Math.floor(dojo.render.version)==8),
		dj_opera9: drh.opera && (Math.floor(dojo.render.version)==9),
		dj_khtml: drh.khtml,
		dj_safari: drh.safari,
		dj_gecko: drh.mozilla
	}; // no dojo unsupported browsers
	for(var p in classes){
		if(classes[p]){
			dojo.html.addClass(node, p);
		}
	}
};

dojo.kwCompoundRequire({
	common: [ "dojo.html.common",
			  "dojo.html.style" ]
});
dojo.provide("dojo.html.*");

dojo.provide("dojo.html");


dojo.deprecated("dojo.html", "replaced by dojo.html.*", "0.5");

dojo.provide("dojo.html.display");


dojo.html._toggle = function(node, tester, setter){
	node = dojo.byId(node);
	setter(node, !tester(node));
	return tester(node);
}

dojo.html.show = function(/* HTMLElement */node){
	//	summary
	//	Show the passed element by reverting display property set by dojo.html.hide
	node = dojo.byId(node);
	if(dojo.html.getStyleProperty(node, 'display')=='none'){
		dojo.html.setStyle(node, 'display', (node.dojoDisplayCache||''));
		node.dojoDisplayCache = undefined;	// cannot use delete on a node in IE6
	}
}

dojo.html.hide = function(/* HTMLElement */node){
	//	summary
	//	Hide the passed element by setting display:none
	node = dojo.byId(node);
	if(typeof node["dojoDisplayCache"] == "undefined"){ // it could == '', so we cannot say !node.dojoDisplayCount
		var d = dojo.html.getStyleProperty(node, 'display')
		if(d!='none'){
			node.dojoDisplayCache = d;
		}
	}
	dojo.html.setStyle(node, 'display', 'none');
}

dojo.html.setShowing = function(/* HTMLElement */node, /* boolean? */showing){
	//	summary
	// Calls show() if showing is true, hide() otherwise
	dojo.html[(showing ? 'show' : 'hide')](node);
}

dojo.html.isShowing = function(/* HTMLElement */node){
	//	summary
	//	Returns whether the element is displayed or not.
	// FIXME: returns true if node is bad, isHidden would be easier to make correct
	return (dojo.html.getStyleProperty(node, 'display') != 'none');	//	boolean
}

dojo.html.toggleShowing = function(/* HTMLElement */node){
	//	summary
	// Call setShowing() on node with the complement of isShowing(), then return the new value of isShowing()
	return dojo.html._toggle(node, dojo.html.isShowing, dojo.html.setShowing);	//	boolean
}

// Simple mapping of tag names to display values
// FIXME: simplistic 
dojo.html.displayMap = { tr: '', td: '', th: '', img: 'inline', span: 'inline', input: 'inline', button: 'inline' };

dojo.html.suggestDisplayByTagName = function(/* HTMLElement */node){
	//	summary
	// Suggest a value for the display property that will show 'node' based on it's tag
	node = dojo.byId(node);
	if(node && node.tagName){
		var tag = node.tagName.toLowerCase();
		return (tag in dojo.html.displayMap ? dojo.html.displayMap[tag] : 'block');	//	string
	}
}

dojo.html.setDisplay = function(/* HTMLElement */node, /* string */display){
	//	summary
	// 	Sets the value of style.display to value of 'display' parameter if it is a string.
	// 	Otherwise, if 'display' is false, set style.display to 'none'.
	// 	Finally, set 'display' to a suggested display value based on the node's tag
	dojo.html.setStyle(node, 'display', ((display instanceof String || typeof display == "string") ? display : (display ? dojo.html.suggestDisplayByTagName(node) : 'none')));
}

dojo.html.isDisplayed = function(/* HTMLElement */node){
	//	summary
	// 	Is true if the the computed display style for node is not 'none'
	// 	FIXME: returns true if node is bad, isNotDisplayed would be easier to make correct
	return (dojo.html.getComputedStyle(node, 'display') != 'none');	//	boolean
}

dojo.html.toggleDisplay = function(/* HTMLElement */node){
	//	summary
	// 	Call setDisplay() on node with the complement of isDisplayed(), then
	// 	return the new value of isDisplayed()
	return dojo.html._toggle(node, dojo.html.isDisplayed, dojo.html.setDisplay);	//	boolean
}

dojo.html.setVisibility = function(/* HTMLElement */node, /* string */visibility){
	//	summary
	// 	Sets the value of style.visibility to value of 'visibility' parameter if it is a string.
	// 	Otherwise, if 'visibility' is false, set style.visibility to 'hidden'. Finally, set style.visibility to 'visible'.
	dojo.html.setStyle(node, 'visibility', ((visibility instanceof String || typeof visibility == "string") ? visibility : (visibility ? 'visible' : 'hidden')));
}

dojo.html.isVisible = function(/* HTMLElement */node){
	//	summary
	// 	Returns true if the the computed visibility style for node is not 'hidden'
	// 	FIXME: returns true if node is bad, isInvisible would be easier to make correct
	return (dojo.html.getComputedStyle(node, 'visibility') != 'hidden');	//	boolean
}

dojo.html.toggleVisibility = function(node){
	//	summary
	// Call setVisibility() on node with the complement of isVisible(), then return the new value of isVisible()
	return dojo.html._toggle(node, dojo.html.isVisible, dojo.html.setVisibility);	//	boolean
}

dojo.html.setOpacity = function(/* HTMLElement */node, /* float */opacity, /* boolean? */dontFixOpacity){
	//	summary
	//	Sets the opacity of node in a cross-browser way.
	//	float between 0.0 (transparent) and 1.0 (opaque)
	node = dojo.byId(node);
	var h = dojo.render.html;
	if(!dontFixOpacity){
		if( opacity >= 1.0){
			if(h.ie){
				dojo.html.clearOpacity(node);
				return;
			}else{
				opacity = 0.999999;
			}
		}else if( opacity < 0.0){ opacity = 0; }
	}
	if(h.ie){
		if(node.nodeName.toLowerCase() == "tr"){
			// FIXME: is this too naive? will we get more than we want?
			var tds = node.getElementsByTagName("td");
			for(var x=0; x<tds.length; x++){
				tds[x].style.filter = "Alpha(Opacity="+opacity*100+")";
			}
		}
		node.style.filter = "Alpha(Opacity="+opacity*100+")";
	}else if(h.moz){
		node.style.opacity = opacity; // ffox 1.0 directly supports "opacity"
		node.style.MozOpacity = opacity;
	}else if(h.safari){
		node.style.opacity = opacity; // 1.3 directly supports "opacity"
		node.style.KhtmlOpacity = opacity;
	}else{
		node.style.opacity = opacity;
	}
}

dojo.html.clearOpacity = function(/* HTMLElement */node){
	//	summary
	//	Clears any opacity setting on the passed element.
	node = dojo.byId(node);
	var ns = node.style;
	var h = dojo.render.html;
	if(h.ie){
		try {
			if( node.filters && node.filters.alpha ){
				ns.filter = ""; // FIXME: may get rid of other filter effects
			}
		} catch(e) {
			/*
			 * IE7 gives error if node.filters not set;
			 * don't know why or how to workaround (other than this)
			 */
		}
	}else if(h.moz){
		ns.opacity = 1;
		ns.MozOpacity = 1;
	}else if(h.safari){
		ns.opacity = 1;
		ns.KhtmlOpacity = 1;
	}else{
		ns.opacity = 1;
	}
}

dojo.html.getOpacity = function(/* HTMLElement */node){
	//	summary
	//	Returns the opacity of the passed element
	node = dojo.byId(node);
	var h = dojo.render.html;
	if(h.ie){
		var opac = (node.filters && node.filters.alpha &&
			typeof node.filters.alpha.opacity == "number"
			? node.filters.alpha.opacity : 100) / 100;
	}else{
		var opac = node.style.opacity || node.style.MozOpacity ||
			node.style.KhtmlOpacity || 1;
	}
	return opac >= 0.999999 ? 1.0 : Number(opac);	//	float
}

dojo.provide("dojo.html.layout");





dojo.html.sumAncestorProperties = function(/* HTMLElement */node, /* string */prop){
	//	summary
	//	Returns the sum of the passed property on all ancestors of node.
	node = dojo.byId(node);
	if(!node){ return 0; } // FIXME: throw an error?
	
	var retVal = 0;
	while(node){
		if(dojo.html.getComputedStyle(node, 'position') == 'fixed'){
			return 0;
		}
		var val = node[prop];
		if(val){
			retVal += val - 0;
			if(node==dojo.body()){ break; }// opera and khtml #body & #html has the same values, we only need one value
		}
		node = node.parentNode;
	}
	return retVal;	//	integer
}

dojo.html.setStyleAttributes = function(/* HTMLElement */node, /* string */attributes) { 
	//	summary
	//	allows a dev to pass a string similar to what you'd pass in style="", and apply it to a node.
	node = dojo.byId(node);
	var splittedAttribs=attributes.replace(/(;)?\s*$/, "").split(";"); 
	for(var i=0; i<splittedAttribs.length; i++){ 
		var nameValue=splittedAttribs[i].split(":"); 
		var name=nameValue[0].replace(/\s*$/, "").replace(/^\s*/, "").toLowerCase();
		var value=nameValue[1].replace(/\s*$/, "").replace(/^\s*/, "");
		switch(name){
			case "opacity":
				dojo.html.setOpacity(node, value); 
				break; 
			case "content-height":
				dojo.html.setContentBox(node, {height: value}); 
				break; 
			case "content-width":
				dojo.html.setContentBox(node, {width: value}); 
				break; 
			case "outer-height":
				dojo.html.setMarginBox(node, {height: value}); 
				break; 
			case "outer-width":
				dojo.html.setMarginBox(node, {width: value}); 
				break; 
			default:
				node.style[dojo.html.toCamelCase(name)]=value; 
		}
	} 
}

dojo.html.boxSizing = {
	MARGIN_BOX: "margin-box",
	BORDER_BOX: "border-box",
	PADDING_BOX: "padding-box",
	CONTENT_BOX: "content-box"
};

dojo.html.getAbsolutePosition = dojo.html.abs = function(/* HTMLElement */node, /* boolean? */includeScroll, /* string? */boxType){
	//	summary
	//	Gets the absolute position of the passed element based on the document itself.
	node = dojo.byId(node, node.ownerDocument);
	var ret = {
		x: 0,
		y: 0
	};

	var bs = dojo.html.boxSizing;
	if(!boxType) { boxType = bs.CONTENT_BOX; }
	var nativeBoxType = 2; //BORDER box
	var targetBoxType;
	switch(boxType){
		case bs.MARGIN_BOX:
			targetBoxType = 3;
			break;
		case bs.BORDER_BOX:
			targetBoxType = 2;
			break;
		case bs.PADDING_BOX:
		default:
			targetBoxType = 1;
			break;
		case bs.CONTENT_BOX:
			targetBoxType = 0;
			break;
	}

	var h = dojo.render.html;
	var db = document["body"]||document["documentElement"];

	if(h.ie){
		with(node.getBoundingClientRect()){
			ret.x = left-2;
			ret.y = top-2;
		}
	}else if(document.getBoxObjectFor){
		// mozilla
		nativeBoxType = 1; //getBoxObjectFor return padding box coordinate
		try{
			var bo = document.getBoxObjectFor(node);
			ret.x = bo.x - dojo.html.sumAncestorProperties(node, "scrollLeft");
			ret.y = bo.y - dojo.html.sumAncestorProperties(node, "scrollTop");
		}catch(e){
			// squelch
		}
	}else{
		if(node["offsetParent"]){
			var endNode;
			// in Safari, if the node is an absolutely positioned child of
			// the body and the body has a margin the offset of the child
			// and the body contain the body's margins, so we need to end
			// at the body
			if(	(h.safari)&&
				(node.style.getPropertyValue("position") == "absolute")&&
				(node.parentNode == db)){
				endNode = db;
			}else{
				endNode = db.parentNode;
			}

			//TODO: set correct nativeBoxType for safari/konqueror

			if(node.parentNode != db){
				var nd = node;
				if(dojo.render.html.opera){ nd = db; }
				ret.x -= dojo.html.sumAncestorProperties(nd, "scrollLeft");
				ret.y -= dojo.html.sumAncestorProperties(nd, "scrollTop");
			}
			var curnode = node;
			do{
				var n = curnode["offsetLeft"];
				//FIXME: ugly hack to workaround the submenu in 
				//popupmenu2 does not shown up correctly in opera. 
				//Someone have a better workaround?
				if(!h.opera || n>0){
					ret.x += isNaN(n) ? 0 : n;
				}
				var m = curnode["offsetTop"];
				ret.y += isNaN(m) ? 0 : m;
				curnode = curnode.offsetParent;
			}while((curnode != endNode)&&(curnode != null));
		}else if(node["x"]&&node["y"]){
			ret.x += isNaN(node.x) ? 0 : node.x;
			ret.y += isNaN(node.y) ? 0 : node.y;
		}
	}

	// account for document scrolling!
	if(includeScroll){
		var scroll = dojo.html.getScroll();
		ret.y += scroll.top;
		ret.x += scroll.left;
	}

	var extentFuncArray=[dojo.html.getPaddingExtent, dojo.html.getBorderExtent, dojo.html.getMarginExtent];
	if(nativeBoxType > targetBoxType){
		for(var i=targetBoxType;i<nativeBoxType;++i){
			ret.y += extentFuncArray[i](node, 'top');
			ret.x += extentFuncArray[i](node, 'left');
		}
	}else if(nativeBoxType < targetBoxType){
		for(var i=targetBoxType;i>nativeBoxType;--i){
			ret.y -= extentFuncArray[i-1](node, 'top');
			ret.x -= extentFuncArray[i-1](node, 'left');
		}
	}
	ret.top = ret.y;
	ret.left = ret.x;
	return ret;	//	object
}

dojo.html.isPositionAbsolute = function(/* HTMLElement */node){
	//	summary
	//	Returns true if the element is absolutely positioned.
	return (dojo.html.getComputedStyle(node, 'position') == 'absolute');	//	boolean
}

dojo.html._sumPixelValues = function(/* HTMLElement */node, selectors, autoIsZero){
	var total = 0;
	for(var x=0; x<selectors.length; x++){
		total += dojo.html.getPixelValue(node, selectors[x], autoIsZero);
	}
	return total;
}

dojo.html.getMargin = function(/* HTMLElement */node){
	//	summary
	//	Returns the width and height of the passed node's margin
	return {
		width: dojo.html._sumPixelValues(node, ["margin-left", "margin-right"], (dojo.html.getComputedStyle(node, 'position') == 'absolute')),
		height: dojo.html._sumPixelValues(node, ["margin-top", "margin-bottom"], (dojo.html.getComputedStyle(node, 'position') == 'absolute'))
	};	//	object
}

dojo.html.getBorder = function(/* HTMLElement */node){
	//	summary
	//	Returns the width and height of the passed node's border
	return {
		width: dojo.html.getBorderExtent(node, 'left') + dojo.html.getBorderExtent(node, 'right'),
		height: dojo.html.getBorderExtent(node, 'top') + dojo.html.getBorderExtent(node, 'bottom')
	};	//	object
}

dojo.html.getBorderExtent = function(/* HTMLElement */node, /* string */side){
	//	summary
	//	returns the width of the requested border
	return (dojo.html.getStyle(node, 'border-' + side + '-style') == 'none' ? 0 : dojo.html.getPixelValue(node, 'border-' + side + '-width'));	// integer
}

dojo.html.getMarginExtent = function(/* HTMLElement */node, /* string */side){
	//	summary
	//	returns the width of the requested margin
	return dojo.html._sumPixelValues(node, ["margin-" + side], dojo.html.isPositionAbsolute(node));	//	integer
}

dojo.html.getPaddingExtent = function(/* HTMLElement */node, /* string */side){
	//	summary
	//	Returns the width of the requested padding 
	return dojo.html._sumPixelValues(node, ["padding-" + side], true);	//	integer
}

dojo.html.getPadding = function(/* HTMLElement */node){
	//	summary
	//	Returns the width and height of the passed node's padding
	return {
		width: dojo.html._sumPixelValues(node, ["padding-left", "padding-right"], true),
		height: dojo.html._sumPixelValues(node, ["padding-top", "padding-bottom"], true)
	};	//	object
}

dojo.html.getPadBorder = function(/* HTMLElement */node){
	//	summary
	//	Returns the width and height of the passed node's padding and border
	var pad = dojo.html.getPadding(node);
	var border = dojo.html.getBorder(node);
	return { width: pad.width + border.width, height: pad.height + border.height };	//	object
}

dojo.html.getBoxSizing = function(/* HTMLElement */node){
	//	summary
	//	Returns which box model the passed element is working with
	var h = dojo.render.html;
	var bs = dojo.html.boxSizing;
	if(((h.ie)||(h.opera)) && node.nodeName.toLowerCase() != "img"){ 
		var cm = document["compatMode"];
		if((cm == "BackCompat")||(cm == "QuirksMode")){
			return bs.BORDER_BOX; 	//	string
		}else{
			return bs.CONTENT_BOX; 	//	string
		}
	}else{
		if(arguments.length == 0){ node = document.documentElement; }
		var sizing;
		if(!h.ie){
			sizing = dojo.html.getStyle(node, "-moz-box-sizing");
			if(!sizing){ 
				sizing = dojo.html.getStyle(node, "box-sizing");
			}
		}
		return (sizing ? sizing : bs.CONTENT_BOX);	//	string
	}
}

dojo.html.isBorderBox = function(/* HTMLElement */node){
	//	summary
	//	returns whether the passed element is using border box sizing or not.
	return (dojo.html.getBoxSizing(node) == dojo.html.boxSizing.BORDER_BOX);	//	boolean
}

dojo.html.getBorderBox = function(/* HTMLElement */node){
	//	summary
	//	Returns the dimensions of the passed element based on border-box sizing.
	node = dojo.byId(node);
	return { width: node.offsetWidth, height: node.offsetHeight };	//	object
}

dojo.html.getPaddingBox = function(/* HTMLElement */node){
	//	summary
	//	Returns the dimensions of the padding box (see http://www.w3.org/TR/CSS21/box.html)
	var box = dojo.html.getBorderBox(node);
	var border = dojo.html.getBorder(node);
	return {
		width: box.width - border.width,
		height:box.height - border.height
	};	//	object
}

dojo.html.getContentBox = function(/* HTMLElement */node){
	//	summary
	//	Returns the dimensions of the content box (see http://www.w3.org/TR/CSS21/box.html)
	node = dojo.byId(node);
	var padborder = dojo.html.getPadBorder(node);
	return {
		width: node.offsetWidth - padborder.width,
		height: node.offsetHeight - padborder.height
	};	//	object
}

dojo.html.setContentBox = function(/* HTMLElement */node, /* object */args){
	//	summary
	//	Sets the dimensions of the passed node according to content sizing.
	node = dojo.byId(node);
	var width = 0; var height = 0;
	var isbb = dojo.html.isBorderBox(node);
	var padborder = (isbb ? dojo.html.getPadBorder(node) : { width: 0, height: 0});
	var ret = {};
	if(typeof args.width != "undefined"){
		width = args.width + padborder.width;
		ret.width = dojo.html.setPositivePixelValue(node, "width", width);
	}
	if(typeof args.height != "undefined"){
		height = args.height + padborder.height;
		ret.height = dojo.html.setPositivePixelValue(node, "height", height);
	}
	return ret;	//	object
}

dojo.html.getMarginBox = function(/* HTMLElement */node){
	//	summary
	//	returns the dimensions of the passed node including any margins.
	var borderbox = dojo.html.getBorderBox(node);
	var margin = dojo.html.getMargin(node);
	return { width: borderbox.width + margin.width, height: borderbox.height + margin.height };	//	object
}

dojo.html.setMarginBox = function(/* HTMLElement */node, /* object */args){
	//	summary
	//	Sets the dimensions of the passed node using margin box calcs.
	node = dojo.byId(node);
	var width = 0; var height = 0;
	var isbb = dojo.html.isBorderBox(node);
	var padborder = (!isbb ? dojo.html.getPadBorder(node) : { width: 0, height: 0 });
	var margin = dojo.html.getMargin(node);
	var ret = {};
	if(typeof args.width != "undefined"){
		width = args.width - padborder.width;
		width -= margin.width;
		ret.width = dojo.html.setPositivePixelValue(node, "width", width);
	}
	if(typeof args.height != "undefined"){
		height = args.height - padborder.height;
		height -= margin.height;
		ret.height = dojo.html.setPositivePixelValue(node, "height", height);
	}
	return ret;	//	object
}

dojo.html.getElementBox = function(/* HTMLElement */node, /* string */type){
	//	summary
	//	return dimesions of a node based on the passed box model type.
	var bs = dojo.html.boxSizing;
	switch(type){
		case bs.MARGIN_BOX:
			return dojo.html.getMarginBox(node);	//	object
		case bs.BORDER_BOX:
			return dojo.html.getBorderBox(node);	//	object
		case bs.PADDING_BOX:
			return dojo.html.getPaddingBox(node);	//	object
		case bs.CONTENT_BOX:
		default:
			return dojo.html.getContentBox(node);	//	object
	}
}
// in: coordinate array [x,y,w,h] or dom node
// return: coordinate object
dojo.html.toCoordinateObject = dojo.html.toCoordinateArray = function(/* array */coords, /* boolean? */includeScroll, /* string? */boxtype) {
	//	summary
	//	Converts an array of coordinates into an object of named arguments.
	if(coords instanceof Array || typeof coords == "array"){
		dojo.deprecated("dojo.html.toCoordinateArray", "use dojo.html.toCoordinateObject({left: , top: , width: , height: }) instead", "0.5");
		// coords is already an array (of format [x,y,w,h]), just return it
		while ( coords.length < 4 ) { coords.push(0); }
		while ( coords.length > 4 ) { coords.pop(); }
		var ret = {
			left: coords[0],
			top: coords[1],
			width: coords[2],
			height: coords[3]
		};
	}else if(!coords.nodeType && !(coords instanceof String || typeof coords == "string") &&
			 ('width' in coords || 'height' in coords || 'left' in coords ||
			  'x' in coords || 'top' in coords || 'y' in coords)){
		// coords is a coordinate object or at least part of one
		var ret = {
			left: coords.left||coords.x||0,
			top: coords.top||coords.y||0,
			width: coords.width||0,
			height: coords.height||0
		};
	}else{
		// coords is an dom object (or dom object id); return it's coordinates
		var node = dojo.byId(coords);
		var pos = dojo.html.abs(node, includeScroll, boxtype);
		var marginbox = dojo.html.getMarginBox(node);
		var ret = {
			left: pos.left,
			top: pos.top,
			width: marginbox.width,
			height: marginbox.height
		};
	}
	ret.x = ret.left;
	ret.y = ret.top;
	return ret;	//	object
}

dojo.html.setMarginBoxWidth = dojo.html.setOuterWidth = function(node, width){
	return dojo.html._callDeprecated("setMarginBoxWidth", "setMarginBox", arguments, "width");
}
dojo.html.setMarginBoxHeight = dojo.html.setOuterHeight = function(){
	return dojo.html._callDeprecated("setMarginBoxHeight", "setMarginBox", arguments, "height");
}
dojo.html.getMarginBoxWidth = dojo.html.getOuterWidth = function(){
	return dojo.html._callDeprecated("getMarginBoxWidth", "getMarginBox", arguments, null, "width");
}
dojo.html.getMarginBoxHeight = dojo.html.getOuterHeight = function(){
	return dojo.html._callDeprecated("getMarginBoxHeight", "getMarginBox", arguments, null, "height");
}
dojo.html.getTotalOffset = function(node, type, includeScroll){
	return dojo.html._callDeprecated("getTotalOffset", "getAbsolutePosition", arguments, null, type);
}
dojo.html.getAbsoluteX = function(node, includeScroll){
	return dojo.html._callDeprecated("getAbsoluteX", "getAbsolutePosition", arguments, null, "x");
}
dojo.html.getAbsoluteY = function(node, includeScroll){
	return dojo.html._callDeprecated("getAbsoluteY", "getAbsolutePosition", arguments, null, "y");
}
dojo.html.totalOffsetLeft = function(node, includeScroll){
	return dojo.html._callDeprecated("totalOffsetLeft", "getAbsolutePosition", arguments, null, "left");
}
dojo.html.totalOffsetTop = function(node, includeScroll){
	return dojo.html._callDeprecated("totalOffsetTop", "getAbsolutePosition", arguments, null, "top");
}
dojo.html.getMarginWidth = function(node){
	return dojo.html._callDeprecated("getMarginWidth", "getMargin", arguments, null, "width");
}
dojo.html.getMarginHeight = function(node){
	return dojo.html._callDeprecated("getMarginHeight", "getMargin", arguments, null, "height");
}
dojo.html.getBorderWidth = function(node){
	return dojo.html._callDeprecated("getBorderWidth", "getBorder", arguments, null, "width");
}
dojo.html.getBorderHeight = function(node){
	return dojo.html._callDeprecated("getBorderHeight", "getBorder", arguments, null, "height");
}
dojo.html.getPaddingWidth = function(node){
	return dojo.html._callDeprecated("getPaddingWidth", "getPadding", arguments, null, "width");
}
dojo.html.getPaddingHeight = function(node){
	return dojo.html._callDeprecated("getPaddingHeight", "getPadding", arguments, null, "height");
}
dojo.html.getPadBorderWidth = function(node){
	return dojo.html._callDeprecated("getPadBorderWidth", "getPadBorder", arguments, null, "width");
}
dojo.html.getPadBorderHeight = function(node){
	return dojo.html._callDeprecated("getPadBorderHeight", "getPadBorder", arguments, null, "height");
}
dojo.html.getBorderBoxWidth = dojo.html.getInnerWidth = function(){
	return dojo.html._callDeprecated("getBorderBoxWidth", "getBorderBox", arguments, null, "width");
}
dojo.html.getBorderBoxHeight = dojo.html.getInnerHeight = function(){
	return dojo.html._callDeprecated("getBorderBoxHeight", "getBorderBox", arguments, null, "height");
}
dojo.html.getContentBoxWidth = dojo.html.getContentWidth = function(){
	return dojo.html._callDeprecated("getContentBoxWidth", "getContentBox", arguments, null, "width");
}
dojo.html.getContentBoxHeight = dojo.html.getContentHeight = function(){
	return dojo.html._callDeprecated("getContentBoxHeight", "getContentBox", arguments, null, "height");
}
dojo.html.setContentBoxWidth = dojo.html.setContentWidth = function(node, width){
	return dojo.html._callDeprecated("setContentBoxWidth", "setContentBox", arguments, "width");
}
dojo.html.setContentBoxHeight = dojo.html.setContentHeight = function(node, height){
	return dojo.html._callDeprecated("setContentBoxHeight", "setContentBox", arguments, "height");
}

dojo.provide("dojo.lang.type");


dojo.lang.whatAmI = function(value) {
	dojo.deprecated("dojo.lang.whatAmI", "use dojo.lang.getType instead", "0.5");
	return dojo.lang.getType(value);
}
dojo.lang.whatAmI.custom = {};

dojo.lang.getType = function(/* anything */ value){
	// summary: Attempts to determine what type value is.
	// value: Any literal value or object instance.
	try{
		if(dojo.lang.isArray(value)){ 
			return "array";	//	string 
		}
		if(dojo.lang.isFunction(value)){ 
			return "function";	//	string 
		}
		if(dojo.lang.isString(value)){ 
			return "string";	//	string 
		}
		if(dojo.lang.isNumber(value)){ 
			return "number";	//	string 
		}
		if(dojo.lang.isBoolean(value)){ 
			return "boolean";	//	string 
		}
		if(dojo.lang.isAlien(value)){ 
			return "alien";	//	string 
		}
		if(dojo.lang.isUndefined(value)){ 
			return "undefined";	//	string 
		}
		// FIXME: should this go first?
		for(var name in dojo.lang.whatAmI.custom){
			if(dojo.lang.whatAmI.custom[name](value)){
				return name;	//	string
			}
		}
		if(dojo.lang.isObject(value)){ 
			return "object";	//	string 
		}
	}catch(e){}
	return "unknown";	//	string
}

dojo.lang.isNumeric = function(/* anything */ value){
	// summary:
	//		Returns true if value can be interpreted as a number
	// value: Any literal value or object instance.
	// examples: 
	//		dojo.lang.isNumeric(3);                 // returns true
	//		dojo.lang.isNumeric("3");               // returns true
	//		dojo.lang.isNumeric(new Number(3));     // returns true
	//		dojo.lang.isNumeric(new String("3"));   // returns true
	//
	//		dojo.lang.isNumeric(3/0);               // returns false
	//		dojo.lang.isNumeric("foo");             // returns false
	//		dojo.lang.isNumeric(new Number("foo")); // returns false
	//		dojo.lang.isNumeric(false);             // returns false
	//		dojo.lang.isNumeric(true);              // returns false
	return (!isNaN(value) 
		&& isFinite(value) 
		&& (value != null) 
		&& !dojo.lang.isBoolean(value) 
		&& !dojo.lang.isArray(value) 
		&& !/^\s*$/.test(value)
	);	//	boolean
}

dojo.lang.isBuiltIn = function(/* anything */ value){
	// summary:
	//		Returns true if value is of a type provided by core JavaScript
	// description: 
	//		Returns true for any literal, and for any object that is an
	//		instance of a built-in type like String, Number, Boolean, Array,
	//		Function, or Error.  
	// value: Any literal value or object instance.
	
	return (dojo.lang.isArray(value)
		|| dojo.lang.isFunction(value)	
		|| dojo.lang.isString(value)
		|| dojo.lang.isNumber(value)
		|| dojo.lang.isBoolean(value)
		|| (value == null)
		|| (value instanceof Error)
		|| (typeof value == "error") 
	);	//	boolean
}

dojo.lang.isPureObject = function(/* anything */ value){
	// summary:
	//		Returns true for any value where the value of value.constructor ==
	//		Object
	// description: 
	//		Returns true for any literal, and for any object that is an
	//		instance of a built-in type like String, Number, Boolean, Array,
	//		Function, or Error.
	// value:
	//		Any literal value or object instance.
	// examples: 
	//		dojo.lang.isPureObject(new Object()); // returns true
	//		dojo.lang.isPureObject({a: 1, b: 2}); // returns true
	//
	//		dojo.lang.isPureObject(new Date());   // returns false
	//		dojo.lang.isPureObject([11, 2, 3]);   // returns false
	return ((value != null) 
		&& dojo.lang.isObject(value) 
		&& value.constructor == Object
	);	//	boolean
}

dojo.lang.isOfType = function(/* anything */ value, /* function */ type, /* object? */ keywordParameters) {
	/* summary:
	 *	 Returns true if 'value' is of type 'type'
	 * description: 
	 *	 Given a value and a datatype, this method returns true if the
	 *	 type of the value matches the datatype. The datatype parameter
	 *	 can be an array of datatypes, in which case the method returns
	 *	 true if the type of the value matches any of the datatypes.
	 * value: Any literal value or object instance.
	 * type: A class of object, or a literal type, or the string name of a type, or an array with a list of types.
	 * keywordParameters: {optional: boolean}
	 */
	 
	/* examples: 
	 *   dojo.lang.isOfType("foo", String);                // returns true
	 *   dojo.lang.isOfType(12345, Number);                // returns true
	 *   dojo.lang.isOfType(false, Boolean);               // returns true
	 *   dojo.lang.isOfType([6, 8], Array);                // returns true
	 *   dojo.lang.isOfType(dojo.lang.isOfType, Function); // returns true
	 *   dojo.lang.isOfType({foo: "bar"}, Object);         // returns true
	 *   dojo.lang.isOfType(new Date(), Date);             // returns true
	 *
	 *   dojo.lang.isOfType("foo", "string");                // returns true
	 *   dojo.lang.isOfType(12345, "number");                // returns true
	 *   dojo.lang.isOfType(false, "boolean");               // returns true
	 *   dojo.lang.isOfType([6, 8], "array");                // returns true
	 *   dojo.lang.isOfType(dojo.lang.isOfType, "function"); // returns true
	 *   dojo.lang.isOfType({foo: "bar"}, "object");         // returns true
	 *   dojo.lang.isOfType(xxxxx, "undefined");             // returns true
	 *   dojo.lang.isOfType(null, "null");                   // returns true
	 *
	 *   dojo.lang.isOfType("foo", [Number, String, Boolean]); // returns true
	 *   dojo.lang.isOfType(12345, [Number, String, Boolean]); // returns true
	 *   dojo.lang.isOfType(false, [Number, String, Boolean]); // returns true
	 *
	 *   dojo.lang.isOfType(null, Date, {optional: true} );    // returns true	// description: 
	 */
	var optional = false;
	if(keywordParameters){
		optional = keywordParameters["optional"];
	}
	if(optional && ((value === null) || dojo.lang.isUndefined(value))){
		return true;	//	boolean
	}
	if(dojo.lang.isArray(type)){
		var arrayOfTypes = type;
		for(var i in arrayOfTypes){
			var aType = arrayOfTypes[i];
			if(dojo.lang.isOfType(value, aType)){
				return true; 	//	boolean
			}
		}
		return false;	//	boolean
	}else{
		if(dojo.lang.isString(type)){
			type = type.toLowerCase();
		}
		switch (type) {
			case Array:
			case "array":
				return dojo.lang.isArray(value);	//	boolean
			case Function:
			case "function":
				return dojo.lang.isFunction(value);	//	boolean
			case String:
			case "string":
				return dojo.lang.isString(value);	//	boolean
			case Number:
			case "number":
				return dojo.lang.isNumber(value);	//	boolean
			case "numeric":
				return dojo.lang.isNumeric(value);	//	boolean
			case Boolean:
			case "boolean":
				return dojo.lang.isBoolean(value);	//	boolean
			case Object:
			case "object":
				return dojo.lang.isObject(value);	//	boolean
			case "pureobject":
				return dojo.lang.isPureObject(value);	//	boolean
			case "builtin":
				return dojo.lang.isBuiltIn(value);	//	boolean
			case "alien":
				return dojo.lang.isAlien(value);	//	boolean
			case "undefined":
				return dojo.lang.isUndefined(value);	//	boolean
			case null:
			case "null":
				return (value === null);	//	boolean
			case "optional":
				dojo.deprecated('dojo.lang.isOfType(value, [type, "optional"])', 'use dojo.lang.isOfType(value, type, {optional: true} ) instead', "0.5");
				return ((value === null) || dojo.lang.isUndefined(value));	//	boolean
			default:
				if(dojo.lang.isFunction(type)){
					return (value instanceof type);	//	boolean
				}else{
					dojo.raise("dojo.lang.isOfType() was passed an invalid type");
				}
		}
	}
	dojo.raise("If we get here, it means a bug was introduced above.");
}

dojo.lang.getObject=function(/* String */ str){
	// summary:
	//   Will return an object, if it exists, based on the name in the passed string.
	var parts=str.split("."), i=0, obj=dj_global; 
	do{ 
		obj=obj[parts[i++]]; 
	}while(i<parts.length&&obj); 
	return (obj!=dj_global)?obj:null;	//	Object
}

dojo.lang.doesObjectExist=function(/* String */ str){
	// summary:
	//   Check to see if object [str] exists, based on the passed string.
	var parts=str.split("."), i=0, obj=dj_global; 
	do{ 
		obj=obj[parts[i++]]; 
	}while(i<parts.length&&obj); 
	return (obj&&obj!=dj_global);	//	boolean
}

dojo.provide("dojo.lang.assert");





dojo.lang.assert = function(/* boolean */ booleanValue, /* string? */ message){
	/* summary: 
	 *   Throws an exception if the assertion fails.
	 * description: 
	 *   If the asserted condition is true, this method does nothing. If the
	 *   condition is false, we throw an error with a error message. 
	 * booleanValue: Must be true for the assertion to succeed.
	 * message: A string describing the assertion.
	 */

	 // throws: Throws an Error if 'booleanValue' is false.
	 if(!booleanValue){
		var errorMessage = "An assert statement failed.\n" +
			"The method dojo.lang.assert() was called with a 'false' value.\n";
		if(message){
			errorMessage += "Here's the assert message:\n" + message + "\n";
		}
		// Use throw instead of dojo.raise, until bug #264 is fixed:
		// dojo.raise(errorMessage);
		throw new Error(errorMessage);
	}
}

dojo.lang.assertType = function(/* anything */ value, /* misc. */ type, /* object? */ keywordParameters){
	/* summary: 
	 *   Throws an exception if 'value' is not of type 'type'
	 * description: 
	 *   Given a value and a data type, this method checks the type of the value
	 *   to make sure it matches the data type, and throws an exception if there
	 *   is a mismatch.
	 * value: Any literal value or object instance.
	 * type: A class of object, or a literal type, or the string name of a type, or an array with a list of types.
	 * keywordParameters: {optional: boolean}
	 */
	 
	/* examples: 
	 *   dojo.lang.assertType("foo", String);
	 *   dojo.lang.assertType(12345, Number);
	 *   dojo.lang.assertType(false, Boolean);
	 *   dojo.lang.assertType([6, 8], Array);
	 *   dojo.lang.assertType(dojo.lang.assertType, Function);
	 *   dojo.lang.assertType({foo: "bar"}, Object);
	 *   dojo.lang.assertType(new Date(), Date);
	 *   dojo.lang.assertType(null, Array, {optional: true});
	 * throws: Throws an Error if 'value' is not of type 'type'.
	 */
	if (dojo.lang.isString(keywordParameters)) {
		dojo.deprecated('dojo.lang.assertType(value, type, "message")', 'use dojo.lang.assertType(value, type) instead', "0.5");
	}
	if(!dojo.lang.isOfType(value, type, keywordParameters)){
		if(!dojo.lang.assertType._errorMessage){
			dojo.lang.assertType._errorMessage = "Type mismatch: dojo.lang.assertType() failed.";
		}
		dojo.lang.assert(false, dojo.lang.assertType._errorMessage);
	}
}

dojo.lang.assertValidKeywords = function(/* object */ object, /* array */ expectedProperties, /* string? */ message){
	/* summary: 
	 *   Throws an exception 'object' has any properties other than the 'expectedProperties'.
	 * description: 
	 *   Given an anonymous object and a list of expected property names, this
	 *   method check to make sure the object does not have any properties
	 *   that aren't on the list of expected properties, and throws an Error
	 *   if there are unexpected properties. This is useful for doing error
	 *   checking on keyword arguments, to make sure there aren't typos.
	 * object: An anonymous object.
	 * expectedProperties: An array of strings (or an object with all the expected properties).
	 * message: A message describing the assertion.
	 */
	 
	/* examples: 
	 *   dojo.lang.assertValidKeywords({a: 1, b: 2}, ["a", "b"]);
	 *   dojo.lang.assertValidKeywords({a: 1, b: 2}, ["a", "b", "c"]);
	 *   dojo.lang.assertValidKeywords({foo: "iggy"}, ["foo"]);
	 *   dojo.lang.assertValidKeywords({foo: "iggy"}, ["foo", "bar"]);
	 *   dojo.lang.assertValidKeywords({foo: "iggy"}, {foo: null, bar: null});
	 * throws: Throws an Error if 'object' has unexpected properties.
	 */
	var key;
	if(!message){
		if(!dojo.lang.assertValidKeywords._errorMessage){
			dojo.lang.assertValidKeywords._errorMessage = "In dojo.lang.assertValidKeywords(), found invalid keyword:";
		}
		message = dojo.lang.assertValidKeywords._errorMessage;
	}
	if(dojo.lang.isArray(expectedProperties)){
		for(key in object){
			if(!dojo.lang.inArray(expectedProperties, key)){
				dojo.lang.assert(false, message + " " + key);
			}
		}
	}else{
		for(key in object){
			if(!(key in expectedProperties)){
				dojo.lang.assert(false, message + " " + key);
			}
		}
	}
}

dojo.provide("dojo.lang");


dojo.deprecated("dojo.lang", "replaced by dojo.lang.common", "0.5");

dojo.provide("dojo.lang.repr");





dojo.lang.reprRegistry = new dojo.AdapterRegistry();
dojo.lang.registerRepr = function(/*String*/name, /*Function*/check, /*Function*/wrap, /*Boolean?*/override){
	// summary:
	//	Register a repr function.  repr functions should take
	//	one argument and return a string representation of it
	//	suitable for developers, primarily used when debugging.
	//
	//	If override is given, it is used as the highest priority
	//	repr, otherwise it will be used as the lowest.

	dojo.lang.reprRegistry.register(name, check, wrap, override);
};

dojo.lang.repr = function(/*Object*/obj){
	// summary: Return a "programmer representation" for an object
	// description: returns a string representation of an object suitable for developers, primarily used when debugging

	if(typeof(obj) == "undefined"){
		// obj: undefined
		return "undefined"; // String
	}else if(obj === null){
		// obj: null
		return "null"; // String
	}

	try{
		if(typeof(obj["__repr__"]) == 'function'){
			return obj["__repr__"]();
		}else if((typeof(obj["repr"]) == 'function')&&(obj.repr != arguments.callee)){
			return obj["repr"]();
		}
		return dojo.lang.reprRegistry.match(obj);
	}catch(e){
		if(typeof(obj.NAME) == 'string' && (
				obj.toString == Function.prototype.toString ||
				obj.toString == Object.prototype.toString
			)){
			return obj.NAME; // String
		}
	}

	if(typeof(obj) == "function"){
		// obj: Function
		obj = (obj + "").replace(/^\s+/, "");
		var idx = obj.indexOf("{");
		if(idx != -1){
			obj = obj.substr(0, idx) + "{...}";
		}
	}
	return obj + ""; // String
}

dojo.lang.reprArrayLike = function(/*Array*/arr){
	// summary: Maps each element of arr to dojo.lang.repr and provides output in an array-like format
	// description: returns an array-like string representation of the provided array suitable for developers, primarily used when debugging
	try{
		var na = dojo.lang.map(arr, dojo.lang.repr);
		return "[" + na.join(", ") + "]"; // String
	}catch(e){ }
};

(function(){
	var m = dojo.lang;
	m.registerRepr("arrayLike", m.isArrayLike, m.reprArrayLike);
	m.registerRepr("string", m.isString, m.reprString);
	m.registerRepr("numbers", m.isNumber, m.reprNumber);
	m.registerRepr("boolean", m.isBoolean, m.reprNumber);
	// m.registerRepr("numbers", m.typeMatcher("number", "boolean"), m.reprNumber);
})();

dojo.provide("dojo.lang.declare");




dojo.lang.declare = function(	/*String*/ className, 
								/*Function|Array*/ superclass, 
								/*Function?*/ init, 
								/*Object|Array*/ props){
	/*
	 *	summary: Create a feature-rich constructor with a compact notation
	 *	className: the name of the constructor (loosely, a "class")
	 * 	superclass:
	 *		may be a Function, or an Array of Functions. If "superclass" is an
	 *		array, the first element is used as the prototypical ancestor and
	 *		any following Functions become mixin ancestors.
	 *	init: an initializer function
	 *	props:
	 *		an object (or array of objects) whose properties are copied to the
	 *		created prototype
	 *	description:
	 *		Create a constructor using a compact notation for inheritance and
	 *		prototype extension. "superclass" argument may be a Function, or an
	 *		array of Functions. 
	 *
	 *		If "superclass" is an array, the first element is used as the
	 *		prototypical ancestor and any following Functions become mixin
	 *		ancestors. 
	 * 
	 *		All "superclass(es)" must be Functions (not mere Objects).
	 *
	 *		Using mixin ancestors provides a type of multiple inheritance.
	 *		Mixin ancestors prototypical properties are copied to the subclass,
	 *		and any inializater/constructor is invoked. 
	 *
	 *		Properties of object "props" are copied to the constructor
	 *		prototype. If "props" is an array, properties of each object in the
	 *		array are copied to the constructor prototype.
	 *
	 *		name of the class ("className" argument) is stored in
	 *		"declaredClass" property
	 * 
	 *		Initializer functions are called when an object is instantiated
	 *		from this constructor.
	 * 
	 *		Aliased as "dojo.declare"
	 *
	 * Usage:
	 *
	 *		dojo.declare("my.classes.bar", my.classes.foo,
	 *			function(){
	 *				// initialization function
	 *				this.myComplicatedObject = new ReallyComplicatedObject(); 
	 *			},
	 *			{ // properties to be added to the class prototype
	 *				someValue: 2,
	 *				someMethod: function(){ 
	 *					doStuff(); 
	 *				}
	 *			}
	 *		);
	 *
	 */
	if((dojo.lang.isFunction(props))||((!props)&&(!dojo.lang.isFunction(init)))){ 
		// parameter juggling to support omitting init param (also allows
		// reordering init and props arguments)
		var temp = props;
		props = init;
		init = temp;
	}	
	var mixins = [ ];
	if(dojo.lang.isArray(superclass)){
		mixins = superclass;
		superclass = mixins.shift();
	}
	if(!init){
		init = dojo.evalObjPath(className, false);
		if((init)&&(!dojo.lang.isFunction(init))){ init = null };
	}
	var ctor = dojo.lang.declare._makeConstructor();
	var scp = (superclass ? superclass.prototype : null);
	if(scp){
		scp.prototyping = true;
		ctor.prototype = new superclass();
		scp.prototyping = false; 
	}
	ctor.superclass = scp;
	ctor.mixins = mixins;
	for(var i=0,l=mixins.length; i<l; i++){
		dojo.lang.extend(ctor, mixins[i].prototype);
	}
	ctor.prototype.initializer = null;
	ctor.prototype.declaredClass = className;
	if(dojo.lang.isArray(props)){
		dojo.lang.extend.apply(dojo.lang, [ctor].concat(props));
	}else{
		dojo.lang.extend(ctor, (props)||{});
	}
	dojo.lang.extend(ctor, dojo.lang.declare._common);
	ctor.prototype.constructor = ctor;
	ctor.prototype.initializer = (ctor.prototype.initializer)||(init)||(function(){});
	var created = dojo.parseObjPath(className, null, true);
	created.obj[created.prop] = ctor;
	return ctor; // Function
}

dojo.lang.declare._makeConstructor = function(){
	return function(){ 
		// get the generational context (which object [or prototype] should be constructed)
		var self = this._getPropContext();
		var s = self.constructor.superclass;
		if((s)&&(s.constructor)){
			if(s.constructor==arguments.callee){
				// if this constructor is invoked directly (my.ancestor.call(this))
				this._inherited("constructor", arguments);
			}else{
				this._contextMethod(s, "constructor", arguments);
			}
		}
		var ms = (self.constructor.mixins)||([]);
		for(var i=0, m; (m=ms[i]); i++) {
			(((m.prototype)&&(m.prototype.initializer))||(m)).apply(this, arguments);
		}
		if((!this.prototyping)&&(self.initializer)){
			self.initializer.apply(this, arguments);
		}
	}
}

dojo.lang.declare._common = {
	_getPropContext: function(){ return (this.___proto||this); },
	// caches ptype context and calls method on it
	_contextMethod: function(ptype, method, args){
		var result, stack = this.___proto;
		this.___proto = ptype;
		try { result = ptype[method].apply(this,(args||[])); }
		catch(e) { throw e; }	
		finally { this.___proto = stack; }
		return result;
	},
	_inherited: function(prop, args){
		// summary:
		//		Searches backward thru prototype chain to find nearest
		//		ancestral instance of prop. Internal use only.
		var p = this._getPropContext();
		do{
			if((!p.constructor)||(!p.constructor.superclass)){ return; }
			p = p.constructor.superclass;
		}while(!(prop in p));
		return (dojo.lang.isFunction(p[prop]) ? this._contextMethod(p, prop, args) : p[prop]);
	},
	inherited: function(prop, args){
		dojo.deprecated("'inherited' method is dangerous, do not up-call! 'inherited' is slated for removal in 0.5; name your super class (or use superclass property) instead.", "0.5");
		this._inherited(prop, args);
	}
}

dojo.declare = dojo.lang.declare;

dojo.kwCompoundRequire({
	common: [
		"dojo.lang.common",
		"dojo.lang.assert",
		"dojo.lang.array",
		"dojo.lang.type",
		"dojo.lang.func",
		"dojo.lang.extras",
		"dojo.lang.repr",
		"dojo.lang.declare"
	]
});
dojo.provide("dojo.lang.*");

dojo.provide("dojo.xml.Parse");


//TODO: determine dependencies
// currently has dependency on dojo.xml.DomUtil nodeTypes constants...

// using documentFragment nomenclature to generalize in case we don't want to require passing a collection of nodes with a single parent

dojo.xml.Parse = function(){
	// summary:
	//		generic class for taking a DOM node and parsing it into an object
	//		based on the "dojo tag name" of that node.
	// 
	//		supported dojoTagName's:
	//			<prefix:tag> => prefix:tag
	//			<dojo:tag> => dojo:tag
	//			<dojoTag> => dojo:tag
	//			<tag dojoType="type"> => dojo:type
	//			<tag dojoType="prefix:type"> => prefix:type
	//			<tag dojo:type="type"> => dojo:type
	//			<tag class="classa dojo-type classb"> => dojo:type	

	var isIE = ((dojo.render.html.capable)&&(dojo.render.html.ie));

	// get normalized (lowercase) tagName
	// some browsers report tagNames in lowercase no matter what
	function getTagName(node){
		/*
		return ((node)&&(node["tagName"]) ? node.tagName.toLowerCase() : '');
		*/
		try{
			return node.tagName.toLowerCase();
		}catch(e){
			return "";
		}
	}

	// locate dojo qualified tag name
	function getDojoTagName(node){
		var tagName = getTagName(node);
		if (!tagName){
				return '';
		}
		// any registered tag
		if((dojo.widget)&&(dojo.widget.tags[tagName])){
			return tagName;
		}
		// <prefix:tag> => prefix:tag
		var p = tagName.indexOf(":");
		if(p>=0){
			return tagName;
		}
		// <dojo:tag> => dojo:tag
		if(tagName.substr(0,5) == "dojo:"){
			return tagName;
		}
		if(dojo.render.html.capable && dojo.render.html.ie && node.scopeName != 'HTML'){
			return node.scopeName.toLowerCase() + ':' + tagName;
		}
		// <dojoTag> => dojo:tag
		if(tagName.substr(0,4) == "dojo"){
			// FIXME: this assumes tag names are always lower case
			return "dojo:" + tagName.substring(4);
		}
		// <tag dojoType="prefix:type"> => prefix:type
		// <tag dojoType="type"> => dojo:type
		var djt = node.getAttribute("dojoType") || node.getAttribute("dojotype");
		if(djt){
			if (djt.indexOf(":")<0){
				djt = "dojo:"+djt;
			}
			return djt.toLowerCase();
		}
		// <tag dojo:type="type"> => dojo:type
		djt = node.getAttributeNS && node.getAttributeNS(dojo.dom.dojoml,"type");
		if(djt){
			return "dojo:" + djt.toLowerCase();
		}
		// <tag dojo:type="type"> => dojo:type
		try{
			// FIXME: IE really really doesn't like this, so we squelch errors for it
			djt = node.getAttribute("dojo:type");
		}catch(e){ 
			// FIXME: log?  
		}
		if(djt){ return "dojo:"+djt.toLowerCase(); }
		// <tag class="classa dojo-type classb"> => dojo:type	
		if((dj_global["djConfig"])&&(!djConfig["ignoreClassNames"])){ 
			// FIXME: should we make this optionally enabled via djConfig?
			var classes = node.className||node.getAttribute("class");
			// FIXME: following line, without check for existence of classes.indexOf
			// breaks firefox 1.5's svg widgets
			if((classes )&&(classes.indexOf)&&(classes.indexOf("dojo-")!=-1)){
				var aclasses = classes.split(" ");
				for(var x=0, c=aclasses.length; x<c; x++){
					if(aclasses[x].slice(0, 5) == "dojo-"){
						return "dojo:"+aclasses[x].substr(5).toLowerCase(); 
					}
				}
			}
		}
		// no dojo-qualified name
		return '';
	}


	this.parseElement = function(	/*DomNode*/node,
									/*Boolean*/hasParentNodeSet, 
									/*Boolean*/optimizeForDojoML, 
									/*Integer*/thisIdx	){
		// summary:
		//		recursively parse the passed node, returning a normalized data
		//		structure that represents the "attributes of interest" of said
		//		elements. If optimizeForDojoML is true, only nodes that contain
		//		a "dojo tag name" will be inspected for attributes.
		// node: the DomNode to be treated as the root of inspection
		// hasParentNodeSet: no-op, please pass "null"
		// optimizeForDojoML: should we ignore non-Dojo nodes? Defaults to false.
		// thisIdx:
		//		a way to specify a synthetic "index" property in the resulting
		//		data structure. Otherwise the index property of the top-level
		//		return element is always "0".

		// TODOC: document return structure of a non-trivial element set

		// run shortcuts to bail out of processing up front to save time and
		// object alloc if possible.
		var tagName = getTagName(node);
		//There's a weird bug in IE where it counts end tags, e.g. </dojo:button> as nodes that should be parsed.  Ignore these
		if(isIE && tagName.indexOf("/")==0){ return null; }

		try{
			var attr = node.getAttribute("parseWidgets");
			if(attr && attr.toLowerCase() == "false"){
				return {};
			}
		}catch(e){/*continue*/}

		
		// look for a dojoml qualified name
		// process dojoml only when optimizeForDojoML is true
		var process = true;
		if(optimizeForDojoML){
			var dojoTagName = getDojoTagName(node);
			tagName = dojoTagName || tagName;
			process = Boolean(dojoTagName);
		}

		var parsedNodeSet = {};
		parsedNodeSet[tagName] = [];
		var pos = tagName.indexOf(":");
		if(pos>0){
			var ns = tagName.substring(0,pos);
			parsedNodeSet["ns"] = ns;
			// honor user namespace filters
			if((dojo.ns)&&(!dojo.ns.allow(ns))){process=false;}
		}

		if(process){
			var attributeSet = this.parseAttributes(node);
			for(var attr in attributeSet){
				if((!parsedNodeSet[tagName][attr])||(typeof parsedNodeSet[tagName][attr] != "array")){
					parsedNodeSet[tagName][attr] = [];
				}
				parsedNodeSet[tagName][attr].push(attributeSet[attr]);
			}	
			// FIXME: we might want to make this optional or provide cloning instead of
			// referencing, but for now, we include a node reference to allow
			// instantiated components to figure out their "roots"
			parsedNodeSet[tagName].nodeRef = node;
			parsedNodeSet.tagName = tagName;
			parsedNodeSet.index = thisIdx||0;
		}

		var count = 0;
		for(var i = 0; i < node.childNodes.length; i++){
			var tcn = node.childNodes.item(i);
			switch(tcn.nodeType){
				case  dojo.dom.ELEMENT_NODE: // element nodes, call this function recursively
					var ctn = getDojoTagName(tcn) || getTagName(tcn);
					if(!parsedNodeSet[ctn]){
						parsedNodeSet[ctn] = [];
					}
					parsedNodeSet[ctn].push(this.parseElement(tcn, true, optimizeForDojoML, count));
					if(	(tcn.childNodes.length == 1)&&
						(tcn.childNodes.item(0).nodeType == dojo.dom.TEXT_NODE)){
						parsedNodeSet[ctn][parsedNodeSet[ctn].length-1].value = tcn.childNodes.item(0).nodeValue;
					}
					count++;
					break;
				case  dojo.dom.TEXT_NODE: // if a single text node is the child, treat it as an attribute
					if(node.childNodes.length == 1){
						parsedNodeSet[tagName].push({ value: node.childNodes.item(0).nodeValue });
					}
					break;
				default: break;
				/*
				case  dojo.dom.ATTRIBUTE_NODE: // attribute node... not meaningful here
					break;
				case  dojo.dom.CDATA_SECTION_NODE: // cdata section... not sure if this would ever be meaningful... might be...
					break;
				case  dojo.dom.ENTITY_REFERENCE_NODE: // entity reference node... not meaningful here
					break;
				case  dojo.dom.ENTITY_NODE: // entity node... not sure if this would ever be meaningful
					break;
				case  dojo.dom.PROCESSING_INSTRUCTION_NODE: // processing instruction node... not meaningful here
					break;
				case  dojo.dom.COMMENT_NODE: // comment node... not not sure if this would ever be meaningful 
					break;
				case  dojo.dom.DOCUMENT_NODE: // document node... not sure if this would ever be meaningful
					break;
				case  dojo.dom.DOCUMENT_TYPE_NODE: // document type node... not meaningful here
					break;
				case  dojo.dom.DOCUMENT_FRAGMENT_NODE: // document fragment node... not meaningful here
					break;
				case  dojo.dom.NOTATION_NODE:// notation node... not meaningful here
					break;
				*/
			}
		}
		//return (hasParentNodeSet) ? parsedNodeSet[node.tagName] : parsedNodeSet;
		//if(parsedNodeSet.tagName)dojo.debug("parseElement: RETURNING NODE WITH TAGNAME "+parsedNodeSet.tagName);
		return parsedNodeSet;
	};


	/* parses a set of attributes on a node into an object tree */
	this.parseAttributes = function(/*DomNode*/node){
		// summary:
		// 		creates an attribute object that maps attribute values for the
		// 		passed node. Note that this is similar to creating a JSON
		// 		representation of a DOM node.
		// usage:
		//		a node with the following serialization:
		//			<div foo="bar" baz="thud">...</div>	
		//		would yeild the following return structure when passed into this
		//		function:
		//			{
		//				"foo": {
		//					"value": "bar"
		//				},
		//				"baz": {
		//					"value": "thud"
		//				}
		//			}
		//
		var parsedAttributeSet = {};
		var atts = node.attributes;
		// TODO: should we allow for duplicate attributes at this point...
		// would any of the relevant dom implementations even allow this?
		var attnode, i=0;
		while((attnode=atts[i++])){
			if(isIE){
				if(!attnode){ continue; }
				if((typeof attnode == "object")&&
					(typeof attnode.nodeValue == 'undefined')||
					(attnode.nodeValue == null)||
					(attnode.nodeValue == '')){ 
					continue; 
				}
			}

			var nn = attnode.nodeName.split(":");
			nn = (nn.length == 2) ? nn[1] : attnode.nodeName;
						
			parsedAttributeSet[nn] = { 
				value: attnode.nodeValue 
			};
		}
		return parsedAttributeSet;
	};
};

dojo.provide("dojo.ns");

dojo.ns = {
	// summary: private object that implements widget namespace management
	namespaces: {},
	failed: {},
	loading: {},
	loaded: {},
	register: function(/*String*/name, /*String*/module, /*Function?*/resolver, /*Boolean?*/noOverride){
		// summary: creates and registers a dojo.ns.Ns object
		if(!noOverride || !this.namespaces[name]){
			this.namespaces[name] = new dojo.ns.Ns(name, module, resolver);
		}
	},
	allow: function(/*String*/name){
		// summary: Returns false if 'name' is filtered by configuration or has failed to load, true otherwise
		if(this.failed[name]){return false;} // Boolean
		if((djConfig.excludeNamespace)&&(dojo.lang.inArray(djConfig.excludeNamespace, name))){return false;} // Boolean
		// If the namespace is "dojo", or the user has not specified allowed namespaces return true.
		// Otherwise, if the user has specifically allowed this namespace, return true, otherwise false.
		return((name==this.dojo)||(!djConfig.includeNamespace)||(dojo.lang.inArray(djConfig.includeNamespace, name))); // Boolean
	},
	get: function(/*String*/name){
		// summary
		//  Return Ns object registered to 'name', if any
		return this.namespaces[name]; // Ns
	},
	require: function(/*String*/name){
		// summary
  	//  Try to ensure that 'name' is registered, loading a namespace manifest if necessary
		var ns = this.namespaces[name];
		if((ns)&&(this.loaded[name])){return ns;} // Ns
		if(!this.allow(name)){return false;} // Boolean
 		if(this.loading[name]){
			// FIXME: do we really ever have re-entrancy situation? this would appear to be really bad
			// original code did not throw an exception, although that seems the only course
			// adding debug output here to track if this occurs.
			dojo.debug('dojo.namespace.require: re-entrant request to load namespace "' + name + '" must fail.'); 
			return false; // Boolean
		}
		// workaround so we don't break the build system
		var req = dojo.require;
		this.loading[name] = true;
		try {
			//dojo namespace file is always in the Dojo namespaces folder, not any custom folder
			if(name=="dojo"){
				req("dojo.namespaces.dojo");
			}else{
				// if no registered module prefix, use ../<name> by convention
				if(!dojo.hostenv.moduleHasPrefix(name)){
					dojo.registerModulePath(name, "../" + name);
				}
				req([name, 'manifest'].join('.'), false, true);
			}
			if(!this.namespaces[name]){
				this.failed[name] = true; //only look for a namespace once
			}
		}finally{
			this.loading[name]=false;
		}
		return this.namespaces[name]; // Ns
	}
}

dojo.ns.Ns = function(/*String*/name, /*String*/module, /*Function?*/resolver){
	// summary: this object simply encapsulates namespace data
	this.name = name;
	this.module = module;
	this.resolver = resolver;
	this._loaded = [ ];
	this._failed = [ ];
}

dojo.ns.Ns.prototype.resolve = function(/*String*/name, /*String*/domain, /*Boolean?*/omitModuleCheck){
	//summary: map component with 'name' and 'domain' to a module via namespace resolver, if specified
	if(!this.resolver || djConfig["skipAutoRequire"]){return false;} // Boolean
	var fullName = this.resolver(name, domain);
	//only load a widget once. This is a quicker check than dojo.require does
	if((fullName)&&(!this._loaded[fullName])&&(!this._failed[fullName])){
		//workaround so we don't break the build system
		var req = dojo.require;
		req(fullName, false, true); //omit the module check, we'll do it ourselves.
		if(dojo.hostenv.findModule(fullName, false)){
			this._loaded[fullName] = true;
		}else{
			if(!omitModuleCheck){dojo.raise("dojo.ns.Ns.resolve: module '" + fullName + "' not found after loading via namespace '" + this.name + "'");} 
			this._failed[fullName] = true;
		}
	}
	return Boolean(this._loaded[fullName]); // Boolean
}

dojo.registerNamespace = function(/*String*/name, /*String*/module, /*Function?*/resolver){
	// summary: maps a module name to a namespace for widgets, and optionally maps widget names to modules for auto-loading
	// description: An unregistered namespace is mapped to an eponymous module.
	//	For example, namespace acme is mapped to module acme, and widgets are
	//	assumed to belong to acme.widget. If you want to use a different widget
	//	module, use dojo.registerNamespace.
	dojo.ns.register.apply(dojo.ns, arguments);
}

dojo.registerNamespaceResolver = function(/*String*/name, /*Function*/resolver){
	// summary: a resolver function maps widget names to modules, so the
	//	widget manager can auto-load needed widget implementations
	//
	// description: The resolver provides information to allow Dojo
	//	to load widget modules on demand. When a widget is created,
	//	a namespace resolver can tell Dojo what module to require
	//	to ensure that the widget implementation code is loaded.
	//
	// name: will always be lower-case.
	//
	// example:
	//  dojo.registerNamespaceResolver("acme",
	//    function(name){ 
	//      return "acme.widget."+dojo.string.capitalize(name);
	//    }
	//  );
	var n = dojo.ns.namespaces[name];
	if(n){
		n.resolver = resolver;
	}
}

dojo.registerNamespaceManifest = function(/*String*/module, /*String*/path, /*String*/name, /*String*/widgetModule, /*Function?*/resolver){
	// summary: convenience function to register a module path, a namespace, and optionally a resolver all at once.
	dojo.registerModulePath(name, path);
	dojo.registerNamespace(name, widgetModule, resolver);
}

// NOTE: rather put this in dojo.widget.Widget, but that fubars debugAtAllCosts
dojo.registerNamespace("dojo", "dojo.widget");

dojo.provide("dojo.widget.Manager");




// summary
//	Manager class for the widgets.
//	This is an internal class used by dojo; users shouldn't call this class directly.
dojo.widget.manager = new function(){
	this.widgets = [];
	this.widgetIds = [];
	
	// map of widgetId-->widget for widgets without parents (top level widgets)
	this.topWidgets = {};

	var widgetTypeCtr = {};
	var renderPrefixCache = [];

	this.getUniqueId = function (widgetType) {
		var widgetId;
		do{
			widgetId = widgetType + "_" + (widgetTypeCtr[widgetType] != undefined ?
			++widgetTypeCtr[widgetType] : widgetTypeCtr[widgetType] = 0);
		}while(this.getWidgetById(widgetId));
		return widgetId;
	}

	this.add = function(widget){
		//dojo.profile.start("dojo.widget.manager.add");
		this.widgets.push(widget);
		// Opera9 uses ID (caps)
		if(!widget.extraArgs["id"]){
			widget.extraArgs["id"] = widget.extraArgs["ID"];
		}
		// FIXME: the rest of this method is very slow!
		if(widget.widgetId == ""){
			if(widget["id"]){
				widget.widgetId = widget["id"];
			}else if(widget.extraArgs["id"]){
				widget.widgetId = widget.extraArgs["id"];
			}else{
				widget.widgetId = this.getUniqueId(widget.ns+'_'+widget.widgetType);
			}
		}
		if(this.widgetIds[widget.widgetId]){
			dojo.debug("widget ID collision on ID: "+widget.widgetId);
		}
		this.widgetIds[widget.widgetId] = widget;
		// Widget.destroy already calls removeById(), so we don't need to
		// connect() it here
		//dojo.profile.end("dojo.widget.manager.add");
	}

	this.destroyAll = function(){
		for(var x=this.widgets.length-1; x>=0; x--){
			try{
				// this.widgets[x].destroyChildren();
				this.widgets[x].destroy(true);
				delete this.widgets[x];
			}catch(e){ }
		}
	}

	// FIXME: we should never allow removal of the root widget until all others
	// are removed!
	this.remove = function(widgetIndex){
		if(dojo.lang.isNumber(widgetIndex)){
			var tw = this.widgets[widgetIndex].widgetId;
			delete this.topWidgets[tw];
			delete this.widgetIds[tw];
			this.widgets.splice(widgetIndex, 1);
		}else{
			this.removeById(widgetIndex);
		}
	}
	
	// FIXME: suboptimal performance
	this.removeById = function(id) {
		if(!dojo.lang.isString(id)){
			id = id["widgetId"];
			if(!id){ dojo.debug("invalid widget or id passed to removeById"); return; }
		}
		for (var i=0; i<this.widgets.length; i++){
			if(this.widgets[i].widgetId == id){
				this.remove(i);
				break;
			}
		}
	}

	this.getWidgetById = function(id){
		if(dojo.lang.isString(id)){
			return this.widgetIds[id];
		}
		return id;
	}

	this.getWidgetsByType = function(type){
		var lt = type.toLowerCase();
		var getType = (type.indexOf(":") < 0 ? 
			function(x) { return x.widgetType.toLowerCase(); } :
			function(x) { return x.getNamespacedType(); }
		);
		var ret = [];
		dojo.lang.forEach(this.widgets, function(x){
			if(getType(x) == lt){ret.push(x);}
		});
		return ret;
	}

	this.getWidgetsByFilter = function(unaryFunc, onlyOne){
		var ret = [];
		dojo.lang.every(this.widgets, function(x){
			if(unaryFunc(x)){
				ret.push(x);
				if(onlyOne){return false;}
			}
			return true;
		});
		return (onlyOne ? ret[0] : ret);
	}

	this.getAllWidgets = function() {
		return this.widgets.concat();
	}

	//	added, trt 2006-01-20
	this.getWidgetByNode = function(/* DOMNode */ node){
		var w=this.getAllWidgets();
		node = dojo.byId(node);
		for(var i=0; i<w.length; i++){
			if(w[i].domNode==node){
				return w[i];
			}
		}
		return null;
	}

	// shortcuts, baby
	this.byId = this.getWidgetById;
	this.byType = this.getWidgetsByType;
	this.byFilter = this.getWidgetsByFilter;
	this.byNode = this.getWidgetByNode;

	// map of previousally discovered implementation names to constructors
	var knownWidgetImplementations = {};

	// support manually registered widget packages
	var widgetPackages = ["dojo.widget"];
	for (var i=0; i<widgetPackages.length; i++) {
		// convenience for checking if a package exists (reverse lookup)
		widgetPackages[widgetPackages[i]] = true;
	}

	this.registerWidgetPackage = function(pname) {
		if(!widgetPackages[pname]){
			widgetPackages[pname] = true;
			widgetPackages.push(pname);
		}
	}
	
	this.getWidgetPackageList = function() {
		return dojo.lang.map(widgetPackages, function(elt) { return(elt!==true ? elt : undefined); });
	}
	
	this.getImplementation = function(widgetName, ctorObject, mixins, ns){
		// try and find a name for the widget
		var impl = this.getImplementationName(widgetName, ns);
		if(impl){ 
			// var tic = new Date();
			var ret = ctorObject ? new impl(ctorObject) : new impl();
			// dojo.debug(new Date() - tic);
			return ret;
		}
	}

	function buildPrefixCache() {
		for(var renderer in dojo.render){
			if(dojo.render[renderer]["capable"] === true){
				var prefixes = dojo.render[renderer].prefixes;
				for(var i=0; i<prefixes.length; i++){
					renderPrefixCache.push(prefixes[i].toLowerCase());
				}
			}
		}
		// make sure we don't HAVE to prefix widget implementation names
		// with anything to get them to render
		//renderPrefixCache.push("");
		// empty prefix is included automatically
	}
	
	var findImplementationInModule = function(lowerCaseWidgetName, module){
		if(!module){return null;}
		for(var i=0, l=renderPrefixCache.length, widgetModule; i<=l; i++){
			widgetModule = (i<l ? module[renderPrefixCache[i]] : module);
			if(!widgetModule){continue;}
			for(var name in widgetModule){
				if(name.toLowerCase() == lowerCaseWidgetName){
					return widgetModule[name];
				}
			}
		}
		return null;
	}

	var findImplementation = function(lowerCaseWidgetName, moduleName){
		// locate registered widget module
		var module = dojo.evalObjPath(moduleName, false);
		// locate a widget implementation in the registered module for our current rendering environment
		return (module ? findImplementationInModule(lowerCaseWidgetName, module) : null);
	}

	this.getImplementationName = function(widgetName, ns){
		/*
		 * Locate an implementation (constructor) for 'widgetName' in namespace 'ns' 
		 * widgetNames are case INSENSITIVE
		 * 
		 * 1. Return value from implementation cache, if available, for quick turnaround.
		 * 2. Locate a namespace registration for 'ns'
		 * 3. If no namespace found, register the conventional one (ns.widget)
		 * 4. Allow the namespace resolver (if any) to load a module for this widget.
		 * 5. Permute the widget name and capable rendering prefixes to locate, cache, and return 
		 *    an appropriate widget implementation.
		 * 6. If no implementation is found, attempt to load the namespace manifest,
		 *    and then look again for an implementation to cache and return.
		 * 7. Use the deprecated widgetPackages registration system to attempt to locate the widget
		 * 8. Fail
		 */
		var lowerCaseWidgetName = widgetName.toLowerCase();

		// default to dojo namespace
		ns=ns||"dojo";
		// use cache if available
		var imps = knownWidgetImplementations[ns] || (knownWidgetImplementations[ns]={});
		//if(!knownWidgetImplementations[ns]){knownWidgetImplementations[ns]={};}
		var impl = imps[lowerCaseWidgetName];
		if(impl){
			return impl;
		}
		
		// (one time) store a list of the render prefixes we are capable of rendering
		if(!renderPrefixCache.length){
			buildPrefixCache();
		}

		// lookup namespace
		var nsObj = dojo.ns.get(ns);
		if(!nsObj){
			// default to <ns>.widget by convention
			dojo.ns.register(ns, ns + '.widget');
			nsObj = dojo.ns.get(ns);
		}
		
		// allow the namespace to resolve the widget module
		if(nsObj){nsObj.resolve(widgetName);}

		// locate a widget implementation in the registered module for our current rendering environment
		impl = findImplementation(lowerCaseWidgetName, nsObj.module);
		if(impl){return(imps[lowerCaseWidgetName] = impl)};

		// try to load a manifest to resolve this implemenation
		nsObj = dojo.ns.require(ns);
		if((nsObj)&&(nsObj.resolver)){
			nsObj.resolve(widgetName);
			impl = findImplementation(lowerCaseWidgetName, nsObj.module);
			if(impl){return(imps[lowerCaseWidgetName] = impl)};
		}
	
		// this is an error condition under new rules
		dojo.deprecated('dojo.widget.Manager.getImplementationName', 
			'Could not locate widget implementation for "' + widgetName + '" in "' + nsObj.module + '" registered to namespace "' + nsObj.name + '". '										
			+ "Developers must specify correct namespaces for all non-Dojo widgets", "0.5");

		// backward compat: if the user has not specified any namespace and their widget is not in dojo.widget.*
		// search registered widget packages [sic]
		// note: registerWidgetPackage itself is now deprecated 
		for(var i=0; i<widgetPackages.length; i++){
			impl = findImplementation(lowerCaseWidgetName, widgetPackages[i]);
			if(impl){return(imps[lowerCaseWidgetName] = impl)};
		}
		
		throw new Error('Could not locate widget implementation for "' + widgetName + '" in "' + nsObj.module + '" registered to namespace "' + nsObj.name + '"');
	}

	// FIXME: does it even belong in this module?
	// NOTE: this method is implemented by DomWidget.js since not all
	// hostenv's would have an implementation.
	/*this.getWidgetFromPrimitive = function(baseRenderType){
		dojo.unimplemented("dojo.widget.manager.getWidgetFromPrimitive");
	}

	this.getWidgetFromEvent = function(nativeEvt){
		dojo.unimplemented("dojo.widget.manager.getWidgetFromEvent");
	}*/

	// Catch window resize events and notify top level widgets
	this.resizing=false;
	this.onWindowResized = function(){
		if(this.resizing){
			return;	// duplicate event
		}
		try{
			this.resizing=true;
			for(var id in this.topWidgets){
				var child = this.topWidgets[id];
				if(child.checkSize ){
					child.checkSize();
				}
			}
		}catch(e){
		}finally{
			this.resizing=false;
		}
	}
	if(typeof window != "undefined") {
		dojo.addOnLoad(this, 'onWindowResized');							// initial sizing
		dojo.event.connect(window, 'onresize', this, 'onWindowResized');	// window resize
	}

	// FIXME: what else?
};

(function(){
	var dw = dojo.widget;
	var dwm = dw.manager;
	var h = dojo.lang.curry(dojo.lang, "hitch", dwm);
	var g = function(oldName, newName){
		dw[(newName||oldName)] = h(oldName);
	}
	// copy the methods from the default manager (this) to the widget namespace
	g("add", "addWidget");
	g("destroyAll", "destroyAllWidgets");
	g("remove", "removeWidget");
	g("removeById", "removeWidgetById");
	g("getWidgetById");
	g("getWidgetById", "byId");
	g("getWidgetsByType");
	g("getWidgetsByFilter");
	g("getWidgetsByType", "byType");
	g("getWidgetsByFilter", "byFilter");
	g("getWidgetByNode", "byNode");
	dw.all = function(n){
		var widgets = dwm.getAllWidgets.apply(dwm, arguments);
		if(arguments.length > 0) {
			return widgets[n];
		}
		return widgets;
	}
	g("registerWidgetPackage");
	g("getImplementation", "getWidgetImplementation");
	g("getImplementationName", "getWidgetImplementationName");

	dw.widgets = dwm.widgets;
	dw.widgetIds = dwm.widgetIds;
	dw.root = dwm.root;
})();

dojo.kwCompoundRequire({
	common: [["dojo.uri.Uri", false, false]]
});
dojo.provide("dojo.uri.*");

dojo.provide("dojo.a11y");




dojo.a11y = {
	// imgPath: String path to the test image for determining if images are displayed or not
	// doAccessibleCheck: Boolean if true will perform check for need to create accessible widgets
	// accessible: Boolean uninitialized when null (accessible check has not been performed)
	//   if true generate accessible widgets
	imgPath:dojo.uri.moduleUri("dojo.widget", "templates/images"),
	doAccessibleCheck: true,
	accessible: null,		

	checkAccessible: function(){ 
	// summary: 
	//		perform check for accessibility if accessibility checking is turned
	//		on and the accessibility test has not been performed yet
		if(this.accessible === null){ 
			this.accessible = false; //default
			if(this.doAccessibleCheck == true){ 
				this.accessible = this.testAccessible();
			}
		}
		return this.accessible; /* Boolean */
	},
	
	testAccessible: function(){
	// summary: 
	//		Always perform the accessibility check to determine if high 
	//		contrast mode is on or display of images are turned off. Currently only checks 
	//		in IE and Mozilla. 
		this.accessible = false; //default
		if (dojo.render.html.ie || dojo.render.html.mozilla){
			var div = document.createElement("div");
			//div.style.color="rgb(153,204,204)";
			div.style.backgroundImage = "url(\"" + this.imgPath + "/tab_close.gif\")";
			// must add to hierarchy before can view currentStyle below
			dojo.body().appendChild(div);
			// in FF and IE the value for the current background style of the added div
			// will be "none" in high contrast mode
			// in FF the return value will be url(invalid-url:) when running over http 
			var bkImg = null;
			if (window.getComputedStyle  ) {
				var cStyle = getComputedStyle(div, ""); 
				bkImg = cStyle.getPropertyValue("background-image");
			}else{
				bkImg = div.currentStyle.backgroundImage;
			}
			var bUseImgElem = false;
			if (bkImg != null && (bkImg == "none" || bkImg == "url(invalid-url:)" )) {
				this.accessible = true;
			}
			/*
			if(this.accessible == false && document.images){
				// test if images are off in IE
				var testImg = new Image();
				if(testImg.fileSize) {
					testImg.src = this.imgPath + "/tab_close.gif";
					if(testImg.fileSize < 0){ 
						this.accessible = true;
					}
				}	
			}*/
			dojo.body().removeChild(div);
		}
		return this.accessible; /* Boolean */
	},
	
	setCheckAccessible: function(/* Boolean */ bTest){ 
	// summary: 
	//		Set whether or not to check for accessibility mode.  Default value
	//		of module is true - perform check for accessibility modes. 
	//		bTest: Boolean - true to check; false to turn off checking
		this.doAccessibleCheck = bTest;
	},

	setAccessibleMode: function(){
	// summary:
	//		perform the accessibility check and sets the correct mode to load 
	//		a11y widgets. Only runs if test for accessiiblity has not been performed yet. 
	//		Call testAccessible() to force the test.
		if (this.accessible === null){
			if (this.checkAccessible()){
				dojo.render.html.prefixes.unshift("a11y");
			}
		}
		return this.accessible; /* Boolean */
	}
};

//dojo.hostenv.modulesLoadedListeners.unshift(function() { dojo.a11y.setAccessibleMode(); });
//dojo.event.connect("before", dojo.hostenv, "makeWidgets", dojo.a11y, "setAccessibleMode");

dojo.provide("dojo.widget.Widget");










dojo.declare("dojo.widget.Widget", null,
	function(){
		// these properties aren't primitives and need to be created on a per-item
		// basis.

		// children: Array
		//		a list of all of the widgets that have been added as children of
		//		this component. Should only have values if isContainer is true.
		this.children = [];

		// extraArgs: Object
		//		a map of properties which the widget system tried to assign from
		//		user input but did not correspond to any of the properties set on
		//		the class prototype. These names will also be available in all
		//		lower-case form in this map
		this.extraArgs = {};
	},
{
	// parent: Widget
	//		the parent of this widget
	parent: null, 

	// isTopLevel: Boolean
	//		should this widget eat all events that bubble up to it?
	//		obviously, top-level and modal widgets should set these appropriately
	isTopLevel:  false, 

	// disabled: Boolean
	//		should this widget respond to user input?
	//		in markup, this is specified as "disabled='disabled'", or just "disabled"
	disabled: false,

	// isContainer: Boolean
	//		can this widget contain other widgets?
	isContainer: false, 

	// widgetId: String
	//		a unique, opaque ID string that can be assigned by users or by the
	//		system. If the developer passes an ID which is known not to be
	//		unique, the specified ID is ignored and the system-generated ID is
	//		used instead.
	widgetId: "",

	// widgetType: String
	//		used for building generic widgets
	widgetType: "Widget",

	// ns: String
	//		defaults to 'dojo'.  "namespace" is a reserved word in JavaScript, so we abbreviate
	ns: "dojo",

	getNamespacedType: function(){ 
		// summary:
		//		get the "full" name of the widget. If the widget comes from the
		//		"dojo" namespace and is a Button, calling this method will
		//		return "dojo:button", all lower-case
		return (this.ns ? this.ns + ":" + this.widgetType : this.widgetType).toLowerCase(); // String
	},
	
	toString: function(){
		// summary:
		//		returns a string that represents the widget. When a widget is
		//		cast to a string, this method will be used to generate the
		//		output. Currently, it does not implement any sort of reversable
		//		serialization.
		return '[Widget ' + this.getNamespacedType() + ', ' + (this.widgetId || 'NO ID') + ']'; // String
	},

	repr: function(){
		// summary: returns the string representation of the widget.
		return this.toString(); // String
	},

	enable: function(){
		// summary:
		//		enables the widget, usually involving unmasking inputs and
		//		turning on event handlers. Not implemented here.
		this.disabled = false;
	},

	disable: function(){
		// summary:
		//		disables the widget, usually involves masking inputs and
		//		unsetting event handlers. Not implemented here.
		this.disabled = true;
	},

	// TODO:
	//	1) this would be better in HtmlWidget rather than here?
	//	2) since many widgets don't care if they've been resized, maybe this should be a mixin?
	onResized: function(){
		// summary:
		//		A signal that widgets will call when they have been resized.
		//		Can be connected to for determining if a layout needs to be
		//		reflowed. Clients should override this function to do special
		//		processing, then call this.notifyChildrenOfResize() to notify
		//		children of resize.
		this.notifyChildrenOfResize();
	},
	
	notifyChildrenOfResize: function(){
		// summary: dispatches resized events to all children of this widget
		for(var i=0; i<this.children.length; i++){
			var child = this.children[i];
			//dojo.debug(this.widgetId + " resizing child " + child.widgetId);
			if( child.onResized ){
				child.onResized();
			}
		}
	},

	create: function(args, fragment, parent, ns){
		// summary:
		//		'create' manages the initialization part of the widget
		//		lifecycle. It's called implicitly when any widget is created.
		//		All other initialization functions for widgets, except for the
		//		constructor, are called as a result of 'create' being fired.
		// args: Object
		//		a normalized view of the parameters that the widget should take
		// fragment: Object
		//		if the widget is being instantiated from markup, this object 
		// parent: Widget?
		//		the widget, if any, that this widget will be the child of.  If
		//		none is passed, the global default widget is used.
		// ns: String?
		//		what namespace the widget belongs to
		// description:
		//		to understand the process by which widgets are instantiated, it
		//		is critical to understand what other methods 'create' calls and
		//		which of them you'll want to over-ride. Of course, adventurous
		//		developers could over-ride 'create' entirely, but this should
		//		only be done as a last resort.
		//
		//		Below is a list of the methods that are called, in the order
		//		they are fired, along with notes about what they do and if/when
		//		you should over-ride them in your widget:
		//			
		//			mixInProperties:
		//				takes the args and does lightweight type introspection
		//				on pre-existing object properties to initialize widget
		//				values by casting the values that are passed in args
		//			postMixInProperties:
		//				a stub function that you can over-ride to modify
		//				variables that may have been naively assigned by
		//				mixInProperties
		//			# widget is added to manager object here
		//			buildRendering
		//				subclasses use this method to handle all UI initialization
		//			initialize:
		//				a stub function that you can over-ride.
		//			postInitialize:
		//				a stub function that you can over-ride.
		//			postCreate
		//				a stub function that you can over-ride to modify take
		//				actions once the widget has been placed in the UI
		//
		//		all of these functions are passed the same arguments as are
		//		passed to 'create'

		//dojo.profile.start(this.widgetType + " create");
		if(ns){
			this.ns = ns;
		}
		// dojo.debug(this.widgetType, "create");
		//dojo.profile.start(this.widgetType + " satisfyPropertySets");
		this.satisfyPropertySets(args, fragment, parent);
		//dojo.profile.end(this.widgetType + " satisfyPropertySets");
		// dojo.debug(this.widgetType, "-> mixInProperties");
		//dojo.profile.start(this.widgetType + " mixInProperties");
		this.mixInProperties(args, fragment, parent);
		//dojo.profile.end(this.widgetType + " mixInProperties");
		// dojo.debug(this.widgetType, "-> postMixInProperties");
		//dojo.profile.start(this.widgetType + " postMixInProperties");
		this.postMixInProperties(args, fragment, parent);
		//dojo.profile.end(this.widgetType + " postMixInProperties");
		// dojo.debug(this.widgetType, "-> dojo.widget.manager.add");
		dojo.widget.manager.add(this);
		// dojo.debug(this.widgetType, "-> buildRendering");
		//dojo.profile.start(this.widgetType + " buildRendering");
		this.buildRendering(args, fragment, parent);
		//dojo.profile.end(this.widgetType + " buildRendering");
		// dojo.debug(this.widgetType, "-> initialize");
		//dojo.profile.start(this.widgetType + " initialize");
		this.initialize(args, fragment, parent);
		//dojo.profile.end(this.widgetType + " initialize");
		// dojo.debug(this.widgetType, "-> postInitialize");
		// postinitialize includes subcomponent creation
		// profile is put directly to function
		this.postInitialize(args, fragment, parent);
		// dojo.debug(this.widgetType, "-> postCreate");
		//dojo.profile.start(this.widgetType + " postCreate");
		this.postCreate(args, fragment, parent);
		//dojo.profile.end(this.widgetType + " postCreate");
		// dojo.debug(this.widgetType, "done!");
		
		//dojo.profile.end(this.widgetType + " create");
		
		return this;
	},

	destroy: function(finalize){
		// summary:
		// 		Destroy this widget and it's descendants. This is the generic
		// 		"destructor" function that all widget users should call to
		// 		clealy discard with a widget. Once a widget is destroyed, it's
		// 		removed from the manager object.
		// finalize: Boolean
		//		is this function being called part of global environment
		//		tear-down?

		// FIXME: this is woefully incomplete
		if(this.parent){
			this.parent.removeChild(this);
		}
		this.destroyChildren();
		this.uninitialize();
		this.destroyRendering(finalize);
		dojo.widget.manager.removeById(this.widgetId);
	},

	destroyChildren: function(){
		// summary:
		//		Recursively destroy the children of this widget and their
		//		descendents.
		var widget;
		var i=0;
		while(this.children.length > i){
			widget = this.children[i];
			if (widget instanceof dojo.widget.Widget) { // find first widget
				this.removeChild(widget);
				widget.destroy();
				continue;
			}
			
			i++; // skip data object
		}
				
	},

	getChildrenOfType: function(/*String*/type, recurse){
		// summary: 
		//		return an array of descendant widgets who match the passed type
		// recurse: Boolean
		//		should we try to get all descendants that match? Defaults to
		//		false.
		var ret = [];
		var isFunc = dojo.lang.isFunction(type);
		if(!isFunc){
			type = type.toLowerCase();
		}
		for(var x=0; x<this.children.length; x++){
			if(isFunc){
				if(this.children[x] instanceof type){
					ret.push(this.children[x]);
				}
			}else{
				if(this.children[x].widgetType.toLowerCase() == type){
					ret.push(this.children[x]);
				}
			}
			if(recurse){
				ret = ret.concat(this.children[x].getChildrenOfType(type, recurse));
			}
		}
		return ret; // Array
	},

	getDescendants: function(){
		// returns: a flattened array of all direct descendants including self
		var result = [];
		var stack = [this];
		var elem;
		while ((elem = stack.pop())){
			result.push(elem);
			// a child may be data object without children field set (not widget)
			if (elem.children) {
				dojo.lang.forEach(elem.children, function(elem) { stack.push(elem); });
			}
		}
		return result; // Array
	},


	isFirstChild: function(){
		return this === this.parent.children[0]; // Boolean
	},

	isLastChild: function() {
		return this === this.parent.children[this.parent.children.length-1]; // Boolean
	},

	satisfyPropertySets: function(args){
		// summary: not implemented!

		// dojo.profile.start("satisfyPropertySets");
		// get the default propsets for our component type
		/*
		var typePropSets = []; // FIXME: need to pull these from somewhere!
		var localPropSets = []; // pull out propsets from the parser's return structure

		// for(var x=0; x<args.length; x++){
		// }

		for(var x=0; x<typePropSets.length; x++){
		}

		for(var x=0; x<localPropSets.length; x++){
		}
		*/
		// dojo.profile.end("satisfyPropertySets");
		
		return args;
	},

	mixInProperties: function(args, /*Object*/frag){
		// summary:
		// 		takes the list of properties listed in args and sets values of
		// 		the current object based on existence of properties with the
		// 		same name (case insensitive) and the type of the pre-existing
		// 		property. This is a lightweight conversion and is not intended
		// 		to capture custom type semantics.
		// args: Object
		//		A map of properties and values to set on the current object. By
		//		default it is assumed that properties in args are in string
		//		form and need to be converted. However, if there is a
		//		'fastMixIn' property with the value 'true' in the args param,
		//		this assumption is ignored and all values in args are copied
		//		directly to the current object without any form of type
		//		casting.
		// description:
		//		The mix-in code attempts to do some type-assignment based on
		//		PRE-EXISTING properties of the "this" object. When a named
		//		property of args is located, it is first tested to make
		//		sure that the current object already "has one". Properties
		//		which are undefined in the base widget are NOT settable here.
		//		The next step is to try to determine type of the pre-existing
		//		property. If it's a string, the property value is simply
		//		assigned. If a function, it is first cast using "new
		//		Function()" and the execution scope modified such that it
		//		always evaluates in the context of the current object. This
		//		listener is then added to the original function via
		//		dojo.event.connect(). If an Array, the system attempts to split
		//		the string value on ";" chars, and no further processing is
		//		attempted (conversion of array elements to a integers, for
		//		instance). If the property value is an Object
		//		(testObj.constructor === Object), the property is split first
		//		on ";" chars, secondly on ":" chars, and the resulting
		//		key/value pairs are assigned to an object in a map style. The
		//		onus is on the property user to ensure that all property values
		//		are converted to the expected type before usage. Properties
		//		which do not occur in the "this" object are assigned to the
		//		this.extraArgs map using both the original name and the
		//		lower-case name of the property. This allows for consistent
		//		access semantics regardless of the case preservation of the
		//		source of the property names.
		
		if((args["fastMixIn"])||(frag["fastMixIn"])){
			// dojo.profile.start("mixInProperties_fastMixIn");
			// fast mix in assumes case sensitivity, no type casting, etc...
			// dojo.lang.mixin(this, args);
			for(var x in args){
				this[x] = args[x];
			}
			// dojo.profile.end("mixInProperties_fastMixIn");
			return;
		}
		// dojo.profile.start("mixInProperties");

		var undef;

		// NOTE: we cannot assume that the passed properties are case-correct
		// (esp due to some browser bugs). Therefore, we attempt to locate
		// properties for assignment regardless of case. This may cause
		// problematic assignments and bugs in the future and will need to be
		// documented with big bright neon lights.

		// FIXME: fails miserably if a mixin property has a default value of null in 
		// a widget

		// NOTE: caching lower-cased args in the prototype is only 
		// acceptable if the properties are invariant.
		// if we have a name-cache, get it
		var lcArgs = dojo.widget.lcArgsCache[this.widgetType];
		if ( lcArgs == null ){
			// build a lower-case property name cache if we don't have one
			lcArgs = {};
			for(var y in this){
				lcArgs[((new String(y)).toLowerCase())] = y;
			}
			dojo.widget.lcArgsCache[this.widgetType] = lcArgs;
		}
		var visited = {};
		for(var x in args){
			if(!this[x]){ // check the cache for properties
				var y = lcArgs[(new String(x)).toLowerCase()];
				if(y){
					args[y] = args[x];
					x = y; 
				}
			}
			if(visited[x]){ continue; }
			visited[x] = true;
			if((typeof this[x]) != (typeof undef)){
				if(typeof args[x] != "string"){
					this[x] = args[x];
				}else{
					if(dojo.lang.isString(this[x])){
						this[x] = args[x];
					}else if(dojo.lang.isNumber(this[x])){
						this[x] = new Number(args[x]); // FIXME: what if NaN is the result?
					}else if(dojo.lang.isBoolean(this[x])){
						this[x] = (args[x].toLowerCase()=="false") ? false : true;
					}else if(dojo.lang.isFunction(this[x])){

						// FIXME: need to determine if always over-writing instead
						// of attaching here is appropriate. I suspect that we
						// might want to only allow attaching w/ action items.
						
						// RAR, 1/19/05: I'm going to attach instead of
						// over-write here. Perhaps function objects could have
						// some sort of flag set on them? Or mixed-into objects
						// could have some list of non-mutable properties
						// (although I'm not sure how that would alleviate this
						// particular problem)? 

						// this[x] = new Function(args[x]);

						// after an IRC discussion last week, it was decided
						// that these event handlers should execute in the
						// context of the widget, so that the "this" pointer
						// takes correctly.
						
						// argument that contains no punctuation other than . is 
						// considered a function spec, not code
						if(args[x].search(/[^\w\.]+/i) == -1){
							this[x] = dojo.evalObjPath(args[x], false);
						}else{
							var tn = dojo.lang.nameAnonFunc(new Function(args[x]), this);
							dojo.event.kwConnect({
								srcObj: this, 
								srcFunc: x, 
								adviceObj: this, 
								adviceFunc: tn
							});
						}
					}else if(dojo.lang.isArray(this[x])){ // typeof [] == "object"
						this[x] = args[x].split(";");
					} else if (this[x] instanceof Date) {
						this[x] = new Date(Number(args[x])); // assume timestamp
					}else if(typeof this[x] == "object"){ 
						// FIXME: should we be allowing extension here to handle
						// other object types intelligently?

						// if a plain string is passed to a property of type dojo.uri.Uri,
						// we assume it is relative to root of dojo
						if (this[x] instanceof dojo.uri.Uri){
							this[x] = dojo.uri.dojoUri(args[x]);
						}else{
							// FIXME: unlike all other types, we do not replace the
							// object with a new one here. Should we change that?
							var pairs = args[x].split(";");
							for(var y=0; y<pairs.length; y++){
								var si = pairs[y].indexOf(":");
								if((si != -1)&&(pairs[y].length>si)){
									this[x][pairs[y].substr(0, si).replace(/^\s+|\s+$/g, "")] = pairs[y].substr(si+1);
								}
							}
						}
					}else{
						// the default is straight-up string assignment. When would
						// we ever hit this?
						this[x] = args[x];
					}
				}
			}else{
				// collect any extra 'non mixed in' args
				this.extraArgs[x.toLowerCase()] = args[x];
			}
		}
		// dojo.profile.end("mixInProperties");
	},
	
	postMixInProperties: function(/*Object*/args, /*Object*/frag, /*Widget*/parent){
		// summary
		//	Called after the parameters to the widget have been read-in,
		//	but before the widget template is instantiated.
		//	Especially useful to set properties that are referenced in the widget template.
	},

	initialize: function(/*Object*/args, /*Object*/frag, /*Widget*/parent){
		// summary: stub function.
		return false;
		// dojo.unimplemented("dojo.widget.Widget.initialize");
	},

	postInitialize: function(/*Object*/args, /*Object*/frag, /*Widget*/parent){
		// summary: stub function.
		return false;
	},

	postCreate: function(/*Object*/args, /*Object*/frag, /*Widget*/parent){
		// summary: stub function.
		return false;
	},

	uninitialize: function(){
		// summary: 
		//		stub function. Over-ride to implement custom widget tear-down
		//		behavior.
		return false;
	},

	buildRendering: function(/*Object*/args, /*Object*/frag, /*Widget*/parent){
		// summary: stub function. SUBCLASSES MUST IMPLEMENT
		dojo.unimplemented("dojo.widget.Widget.buildRendering, on "+this.toString()+", ");
		return false;
	},

	destroyRendering: function(){
		// summary: stub function. SUBCLASSES MUST IMPLEMENT
		dojo.unimplemented("dojo.widget.Widget.destroyRendering");
		return false;
	},

	addedTo: function(parent){
		// summary:
		//		stub function this is just a signal that can be caught
		// parent: Widget
		//		instance of dojo.widget.Widget that we were added to
	},

	addChild: function(child){
		// summary: stub function. SUBCLASSES MUST IMPLEMENT
		dojo.unimplemented("dojo.widget.Widget.addChild");
		return false;
	},

	// Detach the given child widget from me, but don't destroy it
	removeChild: function(/*Widget*/widget){
		// summary: 
		//		removes the passed widget instance from this widget but does
		//		not destroy it
		for(var x=0; x<this.children.length; x++){
			if(this.children[x] === widget){
				this.children.splice(x, 1);
				widget.parent=null;
				break;
			}
		}
		return widget; // Widget
	},

	getPreviousSibling: function(){
		// summary:
		//		returns null if this is the first child of the parent,
		//		otherwise returns the next sibling to the "left".
		var idx = this.getParentIndex();
 
		 // first node is idx=0 not found is idx<0
		if (idx<=0) return null;
 
		return this.parent.children[idx-1]; // Widget
	},
 
	getSiblings: function(){
		// summary: gets an array of all children of our parent, including "this"
		return this.parent.children; // Array
	},
 
	getParentIndex: function(){
		// summary: what index are we at in the parent's children array?
		return dojo.lang.indexOf(this.parent.children, this, true); // int
	},
 
	getNextSibling: function(){
		// summary:
		//		returns null if this is the last child of the parent,
		//		otherwise returns the next sibling to the "right".
 
		var idx = this.getParentIndex();
 
		if (idx == this.parent.children.length-1){return null;} // last node
		if (idx < 0){return null;} // not found
 
		return this.parent.children[idx+1]; // Widget
	}
});

// Lower case name cache: listing of the lower case elements in each widget.
// We can't store the lcArgs in the widget itself because if B subclasses A,
// then B.prototype.lcArgs might return A.prototype.lcArgs, which is not what we
// want
dojo.widget.lcArgsCache = {};

// TODO: should have a more general way to add tags or tag libraries?
// TODO: need a default tags class to inherit from for things like getting propertySets
// TODO: parse properties/propertySets into component attributes
// TODO: parse subcomponents
// TODO: copy/clone raw markup fragments/nodes as appropriate
dojo.widget.tags = {};
dojo.widget.tags.addParseTreeHandler = function(/*String*/type){
	// summary: deprecated!
	dojo.deprecated("addParseTreeHandler", ". ParseTreeHandlers are now reserved for components. Any unfiltered DojoML tag without a ParseTreeHandler is assumed to be a widget", "0.5");
	/*
	var ltype = type.toLowerCase();
	this[ltype] = function(fragment, widgetParser, parentComp, insertionIndex, localProps){
		var _ltype = ltype;
		dojo.profile.start(_ltype);
		var n = dojo.widget.buildWidgetFromParseTree(ltype, fragment, widgetParser, parentComp, insertionIndex, localProps);
		dojo.profile.end(_ltype);
		return n;
	}
	*/
}

//dojo.widget.tags.addParseTreeHandler("dojo:widget");

dojo.widget.tags["dojo:propertyset"] = function(fragment, widgetParser, parentComp){
	// FIXME: Is this needed?
	// FIXME: Not sure that this parses into the structure that I want it to parse into...
	// FIXME: add support for nested propertySets
	var properties = widgetParser.parseProperties(fragment["dojo:propertyset"]);
}

// FIXME: need to add the <dojo:connect />
dojo.widget.tags["dojo:connect"] = function(fragment, widgetParser, parentComp){
	var properties = widgetParser.parseProperties(fragment["dojo:connect"]);
}

// FIXME: if we know the insertion point (to a reasonable location), why then do we:
//	- create a template node
//	- clone the template node
//	- render the clone and set properties
//	- remove the clone from the render tree
//	- place the clone
// this is quite dumb
dojo.widget.buildWidgetFromParseTree = function(/*String*/				type,
												/*Object*/				frag, 
												/*dojo.widget.Parse*/	parser,
												/*Widget, optional*/	parentComp, 
												/*int, optional*/		insertionIndex,
												/*Object*/				localProps){

	// summary: creates a tree of widgets from the data structure produced by the first-pass parser (frag)
	
	// test for accessibility mode 
	dojo.a11y.setAccessibleMode();
	//dojo.profile.start("buildWidgetFromParseTree");
	// FIXME: for codepath from createComponentFromScript, we are now splitting a path 
	// that we already split and then joined
	var stype = type.split(":");
	stype = (stype.length == 2) ? stype[1] : type;
	
	// FIXME: we don't seem to be doing anything with this!
	// var propertySets = parser.getPropertySets(frag);
	var localProperties = localProps || parser.parseProperties(frag[frag["ns"]+":"+stype]);
	var twidget = dojo.widget.manager.getImplementation(stype,null,null,frag["ns"]);
	if(!twidget){
		throw new Error('cannot find "' + type + '" widget');
	}else if (!twidget.create){
		throw new Error('"' + type + '" widget object has no "create" method and does not appear to implement *Widget');
	}
	localProperties["dojoinsertionindex"] = insertionIndex;
	// FIXME: we lose no less than 5ms in construction!
	var ret = twidget.create(localProperties, frag, parentComp, frag["ns"]);
	// dojo.profile.end("buildWidgetFromParseTree");
	return ret;
}

dojo.widget.defineWidget = function(widgetClass, renderer, superclasses, init, props){
	// summary: Create a widget constructor function (aka widgetClass)
	// widgetClass: String
	//		the location in the object hierarchy to place the new widget class constructor
	// renderer: String
	//		usually "html", determines when this delcaration will be used
	// superclasses: Function||Function[]
	//		can be either a single function or an array of functions to be
	//		mixed in as superclasses. If an array, only the first will be used
	//		to set prototype inheritance.
	// init: Function
	//		an optional constructor function. Will be called after superclasses are mixed in.
	// props: Object
	//		a map of properties and functions to extend the class prototype with

	// This meta-function does parameter juggling for backward compat and overloading
	// if 4th argument is a string, we are using the old syntax
	// old sig: widgetClass, superclasses, props (object), renderer (string), init (function)
	if(dojo.lang.isString(arguments[3])){
		dojo.widget._defineWidget(arguments[0], arguments[3], arguments[1], arguments[4], arguments[2]);
	}else{
		// widgetClass
		var args = [ arguments[0] ], p = 3;
		if(dojo.lang.isString(arguments[1])){
			// renderer, superclass
			args.push(arguments[1], arguments[2]);
		}else{
			// superclass
			args.push('', arguments[1]);
			p = 2;
		}
		if(dojo.lang.isFunction(arguments[p])){
			// init (function), props (object) 
			args.push(arguments[p], arguments[p+1]);
		}else{
			// props (object) 
			args.push(null, arguments[p]);
		}
		dojo.widget._defineWidget.apply(this, args);
	}
}

dojo.widget.defineWidget.renderers = "html|svg|vml";

dojo.widget._defineWidget = function(widgetClass /*string*/, renderer /*string*/, superclasses /*function||array*/, init /*function*/, props /*object*/){
	// FIXME: uncomment next line to test parameter juggling ... remove when confidence improves
	// dojo.debug('(c:)' + widgetClass + '\n\n(r:)' + renderer + '\n\n(i:)' + init + '\n\n(p:)' + props);
	// widgetClass takes the form foo.bar.baz<.renderer>.WidgetName (e.g. foo.bar.baz.WidgetName or foo.bar.baz.html.WidgetName)
	var module = widgetClass.split(".");
	var type = module.pop(); // type <= WidgetName, module <= foo.bar.baz<.renderer>
	var regx = "\\.(" + (renderer ? renderer + '|' : '') + dojo.widget.defineWidget.renderers + ")\\.";
	var r = widgetClass.search(new RegExp(regx));
	module = (r < 0 ? module.join(".") : widgetClass.substr(0, r));

	// deprecated in favor of namespace system, remove for 0.5
	dojo.widget.manager.registerWidgetPackage(module);
	
	var pos = module.indexOf(".");
	var nsName = (pos > -1) ? module.substring(0,pos) : module;

	// FIXME: hrm, this might make things simpler
	//dojo.widget.tags.addParseTreeHandler(nsName+":"+type.toLowerCase());
	
	props=(props)||{};
	props.widgetType = type;
	if((!init)&&(props["classConstructor"])){
		init = props.classConstructor;
		delete props.classConstructor;
	}
	dojo.declare(widgetClass, superclasses, init, props);
}

dojo.provide("dojo.widget.Parse");



//
// dojoML parser should be moved out of 'widget', codifying the difference between a 'component'
// and a 'widget'. A 'component' being anything that can be generated from a tag.
//
// a particular dojoML tag would be handled by a registered tagHandler with a hook for a default handler
// if the widget system is loaded, a widget builder would be attach itself as the default handler
// 
// widget tags are no longer registered themselves:
// they are now arbitrarily namespaced, so we cannot register them all, and the non-prefixed portions 
// are no longer guaranteed unique 
// 
// therefore dojo.widget.tags should go with this parser code out of the widget module
//

dojo.widget.Parse = function(/*Object*/fragment){
	this.propertySetsList = [];
	this.fragment = fragment;

	this.createComponents = function(/*Object*/frag, /*Object*/parentComp){
		var comps = [];
		var built = false;
		// if we have items to parse/create at this level, do it!
		try{
			if(frag && frag.tagName && (frag != frag.nodeRef)){
				
				// these are in fact, not ever for widgets per-se anymore, 
				// but for other markup elements (aka components)
				var djTags = dojo.widget.tags;
				
				// we split so that you can declare multiple 
				// non-destructive components from the same ctor node
				var tna = String(frag.tagName).split(";");
				for(var x=0; x<tna.length; x++){
					var ltn = tna[x].replace(/^\s+|\s+$/g, "").toLowerCase();
					// FIXME: unsure what this does
					frag.tagName = ltn;
					var ret;
					if(djTags[ltn]){
						built = true;
						ret = djTags[ltn](frag, this, parentComp, frag.index);
						comps.push(ret);
					}else{
						// we require a namespace prefix, default to dojo:
						if(ltn.indexOf(":") == -1){
							ltn = "dojo:"+ltn;
						}
						// FIXME: handling failure condition correctly?
						// ret = djTags[ltn](frag, this, parentComp, frag.index);
						ret = dojo.widget.buildWidgetFromParseTree(ltn, frag, this, parentComp, frag.index);
						if(ret){
							built = true;
							comps.push(ret);
						}
					}
				}
			}
		}catch(e){
			dojo.debug("dojo.widget.Parse: error:", e);
			// note, commenting out the next line is breaking several widgets for me
			// throw e;
			// IE is such a pain sometimes
		}
		// if there's a sub-frag, build widgets from that too
		if(!built){
			comps = comps.concat(this.createSubComponents(frag, parentComp));
		}
		return comps; // Array
	}

	this.createSubComponents = function(/*Object*/fragment, /*Object*/parentComp){
		// summary: recurses over a raw JavaScript object structure,
		// and calls the corresponding handler for its normalized tagName if it exists

		var frag, comps = [];
		for(var item in fragment){
			frag = fragment[item];
			if(frag && typeof frag == "object"
				&&(frag!=fragment.nodeRef)
				&&(frag!=fragment.tagName)
				&&(!dojo.dom.isNode(frag))){// needed in IE when we have event.connected to the domNode
				comps = comps.concat(this.createComponents(frag, parentComp));
			}
		}
		return comps; // Array
	}

	this.parsePropertySets = function(/*Object*/fragment){
		// summary: checks the top level of a raw JavaScript object
		//	structure for any propertySets.  It stores an array of references to 
		//	propertySets that it finds.
		return [];
		/*
		var propertySets = [];
		for(var item in fragment){
			if((fragment[item]["tagName"] == "dojo:propertyset")){
				propertySets.push(fragment[item]);
			}
		}
		// FIXME: should we store these propertySets somewhere for later retrieval
		this.propertySetsList.push(propertySets);
		return propertySets;
		*/
	}

	this.parseProperties = function(/*Object*/fragment){
		// summary: parseProperties checks a raw JavaScript object structure for
		//	properties, and returns a hash of properties that it finds.
		var properties = {};
		for(var item in fragment){
			// FIXME: need to check for undefined?
			// case: its a tagName or nodeRef
			if((fragment[item] == fragment.tagName)||(fragment[item] == fragment.nodeRef)){
				// do nothing
			}else{
				var frag = fragment[item];
				if(frag.tagName && dojo.widget.tags[frag.tagName.toLowerCase()]){
					// TODO: it isn't a property or property set, it's a fragment, 
					// so do something else
					// FIXME: needs to be a better/stricter check
					// TODO: handle xlink:href for external property sets
				}else if(frag[0] && frag[0].value!="" && frag[0].value!=null){
					try{
						// FIXME: need to allow more than one provider
						if(item.toLowerCase() == "dataprovider"){
							var _this = this;
							this.getDataProvider(_this, frag[0].value);
							properties.dataProvider = this.dataProvider;
						}
						properties[item] = frag[0].value;
						var nestedProperties = this.parseProperties(frag);
						// FIXME: this kind of copying is expensive and inefficient!
						for(var property in nestedProperties){
							properties[property] = nestedProperties[property];
						}
					}catch(e){ dojo.debug(e); }
				}
				switch(item.toLowerCase()){
				case "checked":
				case "disabled":
					if (typeof properties[item] != "boolean"){ 
						properties[item] = true;
					}
					break;
				}
			} 
		}
		return properties; // Object
	}

	this.getDataProvider = function(/*Object*/objRef, /*String*/dataUrl){
		// FIXME: this is currently sync.  To make this async, we made need to move 
		//this step into the widget ctor, so that it is loaded when it is needed 
		// to populate the widget
		dojo.io.bind({
			url: dataUrl,
			load: function(type, evaldObj){
				if(type=="load"){
					objRef.dataProvider = evaldObj;
				}
			},
			mimetype: "text/javascript",
			sync: true
		});
	}

	this.getPropertySetById = function(propertySetId){
		// summary: returns the propertySet that matches the provided id
		for(var x = 0; x < this.propertySetsList.length; x++){
			if(propertySetId == this.propertySetsList[x]["id"][0].value){
				return this.propertySetsList[x];
			}
		}
		return ""; // String
	}
	
	//FIXME: doesn't use the componentType param?
	this.getPropertySetsByType = function(componentType){
		// summary: returns the propertySet(s) that match(es) the
	 	// provided componentClass

		var propertySets = [];
		for(var x=0; x < this.propertySetsList.length; x++){
			var cpl = this.propertySetsList[x];
			var cpcc = cpl.componentClass || cpl.componentType || null; //FIXME: is componentType supposed to be an indirect reference?
			var propertySetId = this.propertySetsList[x]["id"][0].value;
			if(cpcc && (propertySetId == cpcc[0].value)){
				propertySets.push(cpl);
			}
		}
		return propertySets; // Array
	}

	this.getPropertySets = function(/*Object*/fragment){
		// summary: returns the propertySet for a given component fragment

		var ppl = "dojo:propertyproviderlist";
		var propertySets = [];
		var tagname = fragment.tagName;
		if(fragment[ppl]){ 
			var propertyProviderIds = fragment[ppl].value.split(" ");
			// FIXME: should the propertyProviderList attribute contain #
			// 		  syntax for reference to ids or not?
			// FIXME: need a better test to see if this is local or external
			// FIXME: doesn't handle nested propertySets, or propertySets that
			// 		  just contain information about css documents, etc.
			for(var propertySetId in propertyProviderIds){
				if((propertySetId.indexOf("..")==-1)&&(propertySetId.indexOf("://")==-1)){
					// get a reference to a propertySet within the current parsed structure
					var propertySet = this.getPropertySetById(propertySetId);
					if(propertySet != ""){
						propertySets.push(propertySet);
					}
				}else{
					// FIXME: add code to parse and return a propertySet from
					// another document
					// alex: is this even necessaray? Do we care? If so, why?
				}
			}
		}
		// we put the typed ones first so that the parsed ones override when
		// iteration happens.
		return this.getPropertySetsByType(tagname).concat(propertySets); // Array
	}

	this.createComponentFromScript = function(/*Node*/nodeRef, /*String*/componentName, /*Object*/properties, /*String?*/ns){
		// summary:
		// nodeRef: the node to be replaced... in the future, we might want to add 
		// an alternative way to specify an insertion point
		// componentName: the expected dojo widget name, i.e. Button of ContextMenu
		// properties: an object of name value pairs
		// ns: the namespace of the widget.  Defaults to "dojo"

		properties.fastMixIn = true;			
		// FIXME: we pulled it apart and now we put it back together ... 
		var ltn = (ns || "dojo") + ":" + componentName.toLowerCase();
		if(dojo.widget.tags[ltn]){
			return [dojo.widget.tags[ltn](properties, this, null, null, properties)]; // Array
		}
		return [dojo.widget.buildWidgetFromParseTree(ltn, properties, this, null, null, properties)]; // Array
	}
}

dojo.widget._parser_collection = {"dojo": new dojo.widget.Parse() };

dojo.widget.getParser = function(/*String?*/name){
	if(!name){ name = "dojo"; }
	if(!this._parser_collection[name]){
		this._parser_collection[name] = new dojo.widget.Parse();
	}
	return this._parser_collection[name];
}

dojo.widget.createWidget = function(/*String*/name, /*String*/props, /*Node*/refNode, /*String*/position){
	// summary: Creates widget
	// name: The name of the widget to create with optional namespace prefix,
	//	e.g."ns:widget", namespace defaults to "dojo".
	// props: Key-Value pairs of properties of the widget
	// refNode: If the position argument is specified, this node is used as
	//	a reference for inserting this node into a DOM tree; else
	//	the widget becomes the domNode
	// position: The position to insert this widget's node relative to the
	//	refNode argument

	var isNode = false;
	var isNameStr = (typeof name == "string");
	if(isNameStr){
		var pos = name.indexOf(":");
		var ns = (pos > -1) ? name.substring(0,pos) : "dojo";
		if(pos > -1){ name = name.substring(pos+1); }
		var lowerCaseName = name.toLowerCase();
		var namespacedName = ns + ":" + lowerCaseName;
		isNode = (dojo.byId(name) && !dojo.widget.tags[namespacedName]); 
	}

	if((arguments.length == 1) && (isNode || !isNameStr)){
		// we got a DOM node 
		var xp = new dojo.xml.Parse(); 
		// FIXME: we should try to find the parent! 
		var tn = isNode ? dojo.byId(name) : name; 
		return dojo.widget.getParser().createComponents(xp.parseElement(tn, null, true))[0]; 
	}

	function fromScript(placeKeeperNode, name, props, ns){
		props[namespacedName] = { 
			dojotype: [{value: lowerCaseName}],
			nodeRef: placeKeeperNode,
			fastMixIn: true
		};
		props.ns = ns;
		return dojo.widget.getParser().createComponentFromScript(placeKeeperNode, name, props, ns);
	}

	props = props||{};
	var notRef = false;
	var tn = null;
	var h = dojo.render.html.capable;
	if(h){
		tn = document.createElement("span");
	}
	if(!refNode){
		notRef = true;
		refNode = tn;
		if(h){
			dojo.body().appendChild(refNode);
		}
	}else if(position){
		dojo.dom.insertAtPosition(tn, refNode, position);
	}else{ // otherwise don't replace, but build in-place
		tn = refNode;
	}
	var widgetArray = fromScript(tn, name.toLowerCase(), props, ns);
	if(	(!widgetArray)||(!widgetArray[0])||
		(typeof widgetArray[0].widgetType == "undefined") ){
		throw new Error("createWidget: Creation of \"" + name + "\" widget failed.");
	}
	try{
		if(notRef && widgetArray[0].domNode.parentNode){
			widgetArray[0].domNode.parentNode.removeChild(widgetArray[0].domNode);
		}
	}catch(e){
		/* squelch for Safari */
		dojo.debug(e);
	}
	return widgetArray[0]; // Widget
}

/*This file has been overridden to fix a bug in dojo - related rxbug# RX-12406 
The function addWidgetAsDirectChild makes the following call
dojo.dom.insertAtPosition(widget.domNode, cn, pos); 
it is supposed to be
dojo.dom.insertAtPosition(widget.domNode, ref, pos);
cn - is container node where as ref is reference node.
*/
dojo.provide("dojo.widget.DomWidget");










dojo.widget._cssFiles = {};
dojo.widget._cssStrings = {};
dojo.widget._templateCache = {};

dojo.widget.defaultStrings = {
	// summary: a mapping of strings that are used in template variable replacement
	dojoRoot: dojo.hostenv.getBaseScriptUri(),
	dojoWidgetModuleUri: dojo.uri.moduleUri("dojo.widget"),
	baseScriptUri: dojo.hostenv.getBaseScriptUri()
};

dojo.widget.fillFromTemplateCache = function(obj, templatePath, templateString, avoidCache){
	// summary:
	//		static method to build from a template w/ or w/o a real widget in
	//		place
	// obj: DomWidget
	//		an instance of dojo.widget.DomWidget to initialize the template for
	// templatePath: String
	//		the URL to get the template from. dojo.uri.Uri is often passed as well.
	// templateString: String?
	//		a string to use in lieu of fetching the template from a URL
	// avoidCache: Boolean?
	//		should the template system not use whatever is in the cache and
	//		always use the passed templatePath or templateString?

	// dojo.debug("avoidCache:", avoidCache);
	var tpath = templatePath || obj.templatePath;

	var tmplts = dojo.widget._templateCache;
	if(!tpath && !obj["widgetType"]) { // don't have a real template here
		do {
			var dummyName = "__dummyTemplate__" + dojo.widget._templateCache.dummyCount++;
		} while(tmplts[dummyName]);
		obj.widgetType = dummyName;
	}
	var wt = tpath?tpath.toString():obj.widgetType;

	var ts = tmplts[wt];
	if(!ts){
		tmplts[wt] = {"string": null, "node": null};
		if(avoidCache){
			ts = {};
		}else{
			ts = tmplts[wt];
		}
	}

	if((!obj.templateString)&&(!avoidCache)){
		obj.templateString = templateString || ts["string"];
	}
	if(obj.templateString){
		obj.templateString = this._sanitizeTemplateString(obj.templateString);
	}

	if((!obj.templateNode)&&(!avoidCache)){
		obj.templateNode = ts["node"];
	}
	if((!obj.templateNode)&&(!obj.templateString)&&(tpath)){
		// fetch a text fragment and assign it to templateString
		// NOTE: we rely on blocking IO here!
		var tstring = this._sanitizeTemplateString(dojo.hostenv.getText(tpath));

		obj.templateString = tstring;
		if(!avoidCache){
			tmplts[wt]["string"] = tstring;
		}
	}
	if((!ts["string"])&&(!avoidCache)){
		ts.string = obj.templateString;
	}
}

dojo.widget._sanitizeTemplateString = function(/*String*/tString){
	//summary: Strips <?xml ...?> declarations so that external SVG and XML
	//documents can be added to a document without worry. Also, if the string
	//is an HTML document, only the part inside the body tag is returned.
	if(tString){
		tString = tString.replace(/^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im, "");
		var matches = tString.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
		if(matches){
			tString = matches[1];
		}
	}else{
		tString = "";
	}
	return tString; //String
}

dojo.widget._templateCache.dummyCount = 0;

// Array: list of properties to search for node-to-property mappings
dojo.widget.attachProperties = ["dojoAttachPoint", "id"];

// String: name of the property to use for mapping DOM events to widget functions
dojo.widget.eventAttachProperty = "dojoAttachEvent";

// String: property name of code to evaluate when the widget is constructed
dojo.widget.onBuildProperty = "dojoOnBuild";

// Array:  possible accessibility values to set on widget elements - role or state
dojo.widget.waiNames  = ["waiRole", "waiState"];

dojo.widget.wai = {
	// summary: Contains functions to set accessibility roles and states
	//		onto widget elements
	waiRole: { 	
				// name: String:
				//		information for mapping accessibility role
				name: "waiRole", 
				// namespace: String:
				//		URI of the namespace for the set of roles
				"namespace": "http://www.w3.org/TR/xhtml2", 
				// alias: String:
				//		The alias to assign the namespace
				alias: "x2",
				// prefix: String:
				//		The prefix to assign to the role value
				prefix: "wairole:"
	},
	waiState: { 
				// name: String:
				//		information for mapping accessibility state
				name: "waiState", 
				// namespace: String:
				//		URI of the namespace for the set of states
				"namespace": "http://www.w3.org/2005/07/aaa", 
				// alias: String:
				//		The alias to assign the namespace
				alias: "aaa",
				// prefix: String:
				//		empty string - state value does not require prefix
				prefix: ""
	},
	setAttr: function(/*DomNode*/node, /*String*/ ns, /*String*/ attr, /*String|Boolean*/value){
		// summary: Use appropriate API to set the role or state attribute onto the element.
		// description: In IE use the generic setAttribute() api.  Append a namespace
		//   alias to the attribute name and appropriate prefix to the value. 
		//   Otherwise, use the setAttribueNS api to set the namespaced attribute. Also
		//   add the appropriate prefix to the attribute value.
		if(dojo.render.html.ie){
			node.setAttribute(this[ns].alias+":"+ attr, this[ns].prefix+value);
		}else{
			node.setAttributeNS(this[ns]["namespace"], attr, this[ns].prefix+value);
		}
	},

	getAttr: function(/*DomNode*/ node, /*String*/ ns, /*String|Boolena*/ attr){
		// Summary:  Use the appropriate API to retrieve the role or state value
		// Description: In IE use the generic getAttribute() api.  An alias value 
		// 	was added to the attribute name to simulate a namespace when the attribute
		//  was set.  Otherwise use the getAttributeNS() api to retrieve the state value
		if(dojo.render.html.ie){
			return node.getAttribute(this[ns].alias+":"+attr);
		}else{
			return node.getAttributeNS(this[ns]["namespace"], attr);
		}
	},
	removeAttr: function(/*DomNode*/ node, /*String*/ ns, /*String|Boolena*/ attr){
		// summary:  Use the appropriate API to remove the role or state value
		// description: In IE use the generic removeAttribute() api.  An alias value 
		// 	was added to the attribute name to simulate a namespace when the attribute
		//  was set.  Otherwise use the removeAttributeNS() api to remove the state value
		var success = true; //only IE returns a value
		if(dojo.render.html.ie){
			 success = node.removeAttribute(this[ns].alias+":"+attr);
		}else{
			node.removeAttributeNS(this[ns]["namespace"], attr);
		}
		return success;
	}
};

dojo.widget.attachTemplateNodes = function(rootNode, /*Widget*/ targetObj, events ){
	// summary:
	//		map widget properties and functions to the handlers specified in
	//		the dom node and it's descendants. This function iterates over all
	//		nodes and looks for these properties:
	//			* dojoAttachPoint
	//			* dojoAttachEvent	
	//			* waiRole
	//			* waiState
	//			* any "dojoOn*" proprties passed in the events array
	// rootNode: DomNode
	//		the node to search for properties. All children will be searched.
	// events: Array
	//		a list of properties generated from getDojoEventsFromStr.

	// FIXME: this method is still taking WAAAY too long. We need ways of optimizing:
	//	a.) what we are looking for on each node
	//	b.) the nodes that are subject to interrogation (use xpath instead?)
	//	c.) how expensive event assignment is (less eval(), more connect())
	// var start = new Date();
	var elementNodeType = dojo.dom.ELEMENT_NODE;

	function trim(str){
		return str.replace(/^\s+|\s+$/g, "");
	}

	if(!rootNode){ 
		rootNode = targetObj.domNode;
	}

	if(rootNode.nodeType != elementNodeType){
		return;
	}
	// alert(events.length);

	var nodes = rootNode.all || rootNode.getElementsByTagName("*");
	var _this = targetObj;
	for(var x=-1; x<nodes.length; x++){
		var baseNode = (x == -1) ? rootNode : nodes[x];
		// FIXME: is this going to have capitalization problems?  Could use getAttribute(name, 0); to get attributes case-insensitve
		var attachPoint = [];
		if(!targetObj.widgetsInTemplate || !baseNode.getAttribute('dojoType')){
			for(var y=0; y<this.attachProperties.length; y++){
				var tmpAttachPoint = baseNode.getAttribute(this.attachProperties[y]);
				if(tmpAttachPoint){
					attachPoint = tmpAttachPoint.split(";");
					for(var z=0; z<attachPoint.length; z++){
						if(dojo.lang.isArray(targetObj[attachPoint[z]])){
							targetObj[attachPoint[z]].push(baseNode);
						}else{
							targetObj[attachPoint[z]]=baseNode;
						}
					}
					break;
				}
			}

			var attachEvent = baseNode.getAttribute(this.eventAttachProperty);
			if(attachEvent){
				// NOTE: we want to support attributes that have the form
				// "domEvent: nativeEvent; ..."
				var evts = attachEvent.split(";");
				for(var y=0; y<evts.length; y++){
					if((!evts[y])||(!evts[y].length)){ continue; }
					var thisFunc = null;
					var tevt = trim(evts[y]);
					if(evts[y].indexOf(":") >= 0){
						// oh, if only JS had tuple assignment
						var funcNameArr = tevt.split(":");
						tevt = trim(funcNameArr[0]);
						thisFunc = trim(funcNameArr[1]);
					}
					if(!thisFunc){
						thisFunc = tevt;
					}
	
					var tf = function(){ 
						var ntf = new String(thisFunc);
						return function(evt){
							if(_this[ntf]){
								_this[ntf](dojo.event.browser.fixEvent(evt, this));
							}
						};
					}();
					dojo.event.browser.addListener(baseNode, tevt, tf, false, true);
					// dojo.event.browser.addListener(baseNode, tevt, dojo.lang.hitch(_this, thisFunc));
				}
			}
	
			for(var y=0; y<events.length; y++){
				//alert(events[x]);
				var evtVal = baseNode.getAttribute(events[y]);
				if((evtVal)&&(evtVal.length)){
					var thisFunc = null;
					var domEvt = events[y].substr(4); // clober the "dojo" prefix
					thisFunc = trim(evtVal);
					var funcs = [thisFunc];
					if(thisFunc.indexOf(";")>=0){
						funcs = dojo.lang.map(thisFunc.split(";"), trim);
					}
					for(var z=0; z<funcs.length; z++){
						if(!funcs[z].length){ continue; }
						var tf = function(){ 
							var ntf = new String(funcs[z]);
							return function(evt){
								if(_this[ntf]){
									_this[ntf](dojo.event.browser.fixEvent(evt, this));
								}
							}
						}();
						dojo.event.browser.addListener(baseNode, domEvt, tf, false, true);
						// dojo.event.browser.addListener(baseNode, domEvt, dojo.lang.hitch(_this, funcs[z]));
					}
				}
			}
		}
		// continue;

		// FIXME: we need to put this into some kind of lookup structure
		// instead of direct assignment
		var tmpltPoint = baseNode.getAttribute(this.templateProperty);
		if(tmpltPoint){
			targetObj[tmpltPoint]=baseNode;
		}

		dojo.lang.forEach(dojo.widget.waiNames, function(name){
			var wai = dojo.widget.wai[name];
			var val = baseNode.getAttribute(wai.name);
			if(val){
				if(val.indexOf('-') == -1){ 
					dojo.widget.wai.setAttr(baseNode, wai.name, "role", val);
				}else{
					// this is a state-value pair
					var statePair = val.split('-');
					dojo.widget.wai.setAttr(baseNode, wai.name, statePair[0], statePair[1]);
				}
			}
		}, this);

		var onBuild = baseNode.getAttribute(this.onBuildProperty);
		if(onBuild){
			eval("var node = baseNode; var widget = targetObj; "+onBuild);
		}
	}

}

dojo.widget.getDojoEventsFromStr = function(str){
	// summary:
	//		generates a list of properties with names that match the form
	//		dojoOn*
	// str: String
	//		the template string to search
	
	// var lstr = str.toLowerCase();
	var re = /(dojoOn([a-z]+)(\s?))=/gi;
	var evts = str ? str.match(re)||[] : [];
	var ret = [];
	var lem = {};
	for(var x=0; x<evts.length; x++){
		if(evts[x].length < 1){ continue; }
		var cm = evts[x].replace(/\s/, "");
		cm = (cm.slice(0, cm.length-1));
		if(!lem[cm]){
			lem[cm] = true;
			ret.push(cm);
		}
	}
	return ret; // Array
}

dojo.declare("dojo.widget.DomWidget", 
	dojo.widget.Widget,
	function(){
		// summary:
		//		dojo.widget.DomWidget is the superclass that provides behavior for all
		//		DOM-based renderers, including HtmlWidget and SvgWidget. DomWidget
		//		implements the templating system that most widget authors use to define
		//		the UI for their widgets.
		if((arguments.length>0)&&(typeof arguments[0] == "object")){
			this.create(arguments[0]);
		}
	},
	{							 
		// templateNode: DomNode
		//		a node that represents the widget template. Pre-empts both templateString and templatePath.
		templateNode: null,

		// templateString String:
		//		a string that represents the widget template. Pre-empts the
		//		templatePath. In builds that have their strings "interned", the
		//		templatePath is converted to an inline templateString, thereby
		//		preventing a synchronous network call.
		templateString: null,

		// templateCssString String:
		//		a string that represents the CSS for the widgettemplate.
		//		Pre-empts the templateCssPath. In builds that have their
		//		strings "interned", the templateCssPath is converted to an
		//		inline templateCssString, thereby preventing a synchronous
		//		network call.
		templateCssString: null,

		// preventClobber Boolean:
		//		should the widget not replace the node from which it was
		//		constructed? Widgets that apply behaviors to pre-existing parts
		//		of a page can be implemented easily by setting this to "true".
		//		In these cases, the domNode property will point to the node
		//		which the widget was created from.
		preventClobber: false,

		// domNode DomNode:
		//		this is our visible representation of the widget! Other DOM
		//		Nodes may by assigned to other properties, usually through the
		//		template system's dojoAttachPonit syntax, but the domNode
		//		property is the canonical "top level" node in widget UI.
		domNode: null, 

		// containerNode DomNode:
		//		holds child elements. "containerNode" is generally set via a
		//		dojoAttachPoint assignment and it designates where widgets that
		//		are defined as "children" of the parent will be placed
		//		visually.
		containerNode: null,

		// widgetsInTemplate Boolean:
		//		should we parse the template to find widgets that might be
		//		declared in markup inside it? false by default.
		widgetsInTemplate: false,

		addChild: function(/*Widget*/	widget, overrideContainerNode, pos, ref, insertIndex){
			// summary:
			//		Process the given child widget, inserting it's dom node as
			//		a child of our dom node
			// overrideContainerNode: DomNode?
			//		a non-default container node for the widget
			// pos: String?
			//		can be one of "before", "after", "first", or "last". This
			//		has the same meaning as in dojo.dom.insertAtPosition()
			// ref: DomNode?
			//		a node to place the widget relative to
			// insertIndex: int?
			//		DOM index, same meaning as in dojo.dom.insertAtIndex()
			// returns: the widget that was inserted

			// FIXME: should we support addition at an index in the children arr and
			// order the display accordingly? Right now we always append.
			if(!this.isContainer){ // we aren't allowed to contain other widgets, it seems
				dojo.debug("dojo.widget.DomWidget.addChild() attempted on non-container widget");
				return null;
			}else{
				if(insertIndex == undefined){
					insertIndex = this.children.length;
				}
				this.addWidgetAsDirectChild(widget, overrideContainerNode, pos, ref, insertIndex);
				this.registerChild(widget, insertIndex);
			}
			return widget; // Widget
		},
		
		addWidgetAsDirectChild: function(/*Widget*/	widget, overrideContainerNode, pos, ref, insertIndex){
			// summary:
			//		Process the given child widget, inserting it's dom node as
			//		a child of our dom node
			// overrideContainerNode: DomNode
			//		a non-default container node for the widget
			// pos: String?
			//		can be one of "before", "after", "first", or "last". This
			//		has the same meaning as in dojo.dom.insertAtPosition()
			// ref: DomNode?
			//		a node to place the widget relative to
			// insertIndex: int?
			//		DOM index, same meaning as in dojo.dom.insertAtIndex()
			if((!this.containerNode)&&(!overrideContainerNode)){
				this.containerNode = this.domNode;
			}
			var cn = (overrideContainerNode) ? overrideContainerNode : this.containerNode;
			if(!pos){ pos = "after"; }
			if(!ref){ 
				if(!cn){ cn = dojo.body(); }
				ref = cn.lastChild; 
			}
			if(!insertIndex) { insertIndex = 0; }
			widget.domNode.setAttribute("dojoinsertionindex", insertIndex);

			// insert the child widget domNode directly underneath my domNode, in the
			// specified position (by default, append to end)
			if(!ref){
				cn.appendChild(widget.domNode);
			}else{
				// FIXME: was this meant to be the (ugly hack) way to support insert @ index?
				//dojo.dom[pos](widget.domNode, ref, insertIndex);

				// CAL: this appears to be the intended way to insert a node at a given position...
				if (pos == 'insertAtIndex'){
					// dojo.debug("idx:", insertIndex, "isLast:", ref === cn.lastChild);
					dojo.dom.insertAtIndex(widget.domNode, ref.parentNode, insertIndex);
				}else{
					// dojo.debug("pos:", pos, "isLast:", ref === cn.lastChild);
					if((pos == "after")&&(ref === cn.lastChild)){
						cn.appendChild(widget.domNode);
					}else{
						dojo.dom.insertAtPosition(widget.domNode, ref, pos);
					}
				}
			}
		},

		registerChild: function(widget, insertionIndex){
			// summary: record that given widget descends from me
			// widget: Widget
			//		the widget that is now a child
			// insertionIndex: int
			//		where in the children[] array to place it

			// we need to insert the child at the right point in the parent's 
			// 'children' array, based on the insertionIndex

			widget.dojoInsertionIndex = insertionIndex;

			var idx = -1;
			for(var i=0; i<this.children.length; i++){

				//This appears to fix an out of order issue in the case of mixed
				//markup and programmatically added children.  Previously, if a child
				//existed from markup, and another child was addChild()d without specifying
				//any additional parameters, it would end up first in the list, when in fact
				//it should be after.  I can't see cases where this would break things, but
				//I could see no other obvious solution. -dustin

				if (this.children[i].dojoInsertionIndex <= insertionIndex){
					idx = i;
				}
			}

			this.children.splice(idx+1, 0, widget);

			widget.parent = this;
			widget.addedTo(this, idx+1);
			
			// If this widget was created programatically, then it was erroneously added
			// to dojo.widget.manager.topWidgets.  Fix that here.
			delete dojo.widget.manager.topWidgets[widget.widgetId];
		},

		removeChild: function(/*Widget*/ widget){
			// summary: detach child domNode from parent domNode
			dojo.dom.removeNode(widget.domNode);

			// remove child widget from parent widget 
			return dojo.widget.DomWidget.superclass.removeChild.call(this, widget); // Widget
		},

		getFragNodeRef: function(frag){
			// summary:
			//		returns the source node, if any, that the widget was
			//		declared from
			// frag: Object
			//		an opaque data structure generated by the first-pass parser
			if(!frag){return null;} // null
			if(!frag[this.getNamespacedType()]){
				dojo.raise("Error: no frag for widget type " + this.getNamespacedType() 
					+ ", id " + this.widgetId
					+ " (maybe a widget has set it's type incorrectly)");
			}
			return frag[this.getNamespacedType()]["nodeRef"]; // DomNode
		},
		
		postInitialize: function(/*Object*/ args, /*Object*/ frag, /*Widget*/ parentComp){
			// summary:
			//		Replace the source domNode with the generated dom
			//		structure, and register the widget with its parent.
			//		This is an implementation of the stub function defined in
			//		dojo.widget.Widget.
			
			//dojo.profile.start(this.widgetType + " postInitialize");
			
			var sourceNodeRef = this.getFragNodeRef(frag);
			// Stick my generated dom into the output tree
			//alert(this.widgetId + ": replacing " + sourceNodeRef + " with " + this.domNode.innerHTML);
			if (parentComp && (parentComp.snarfChildDomOutput || !sourceNodeRef)){
				// Add my generated dom as a direct child of my parent widget
				// This is important for generated widgets, and also cases where I am generating an
				// <li> node that can't be inserted back into the original DOM tree
				parentComp.addWidgetAsDirectChild(this, "", "insertAtIndex", "",  args["dojoinsertionindex"], sourceNodeRef);
			} else if (sourceNodeRef){
				// Do in-place replacement of the my source node with my generated dom
				if(this.domNode && (this.domNode !== sourceNodeRef)){
					this._sourceNodeRef = dojo.dom.replaceNode(sourceNodeRef, this.domNode);
				}
			}

			// Register myself with my parent, or with the widget manager if
			// I have no parent
			// TODO: the code below erroneously adds all programatically generated widgets
			// to topWidgets (since we don't know who the parent is until after creation finishes)
			if ( parentComp ) {
				parentComp.registerChild(this, args.dojoinsertionindex);
			} else {
				dojo.widget.manager.topWidgets[this.widgetId]=this;
			}

			if(this.widgetsInTemplate){
				var parser = new dojo.xml.Parse();

				var subContainerNode;
				//TODO: use xpath here?
				var subnodes = this.domNode.getElementsByTagName("*");
				for(var i=0;i<subnodes.length;i++){
					if(subnodes[i].getAttribute('dojoAttachPoint') == 'subContainerWidget'){
						subContainerNode = subnodes[i];
//						break;
					}
					if(subnodes[i].getAttribute('dojoType')){
						subnodes[i].setAttribute('isSubWidget', true);
					}
				}
				if (this.isContainer && !this.containerNode){
					//no containerNode is available, which means a widget is used as a container. find it here and move
					//all dom nodes defined in the main html page as children of this.domNode into the actual container
					//widget's node (at this point, the subwidgets defined in the template file is not parsed yet)
					if(subContainerNode){
						var src = this.getFragNodeRef(frag);
						if (src){
							dojo.dom.moveChildren(src, subContainerNode);
							//do not need to follow children nodes in the main html page, as they
							//will be dealt with in the subContainerWidget
							frag['dojoDontFollow'] = true;
						}
					}else{
						dojo.debug("No subContainerWidget node can be found in template file for widget "+this);
					}
				}

				var templatefrag = parser.parseElement(this.domNode, null, true);
				// createSubComponents not createComponents because frag has already been created
				dojo.widget.getParser().createSubComponents(templatefrag, this);
	
				//find all the sub widgets defined in the template file of this widget
				var subwidgets = [];
				var stack = [this];
				var w;
				while((w = stack.pop())){
					for(var i = 0; i < w.children.length; i++){
						var cwidget = w.children[i];
						if(cwidget._processedSubWidgets || !cwidget.extraArgs['issubwidget']){ continue; }
						subwidgets.push(cwidget);
						if(cwidget.isContainer){
							stack.push(cwidget);
						}
					}
				}
	
				//connect event to this widget/attach dom node
				for(var i = 0; i < subwidgets.length; i++){
					var widget = subwidgets[i];
					if(widget._processedSubWidgets){
						dojo.debug("This should not happen: widget._processedSubWidgets is already true!");
						return;
					}
					widget._processedSubWidgets = true;
					if(widget.extraArgs['dojoattachevent']){
						var evts = widget.extraArgs['dojoattachevent'].split(";");
						for(var j=0; j<evts.length; j++){
							var thisFunc = null;
							var tevt = dojo.string.trim(evts[j]);
							if(tevt.indexOf(":") >= 0){
								// oh, if only JS had tuple assignment
								var funcNameArr = tevt.split(":");
								tevt = dojo.string.trim(funcNameArr[0]);
								thisFunc = dojo.string.trim(funcNameArr[1]);
							}
							if(!thisFunc){
								thisFunc = tevt;
							}
							if(dojo.lang.isFunction(widget[tevt])){
								dojo.event.kwConnect({
									srcObj: widget, 
									srcFunc: tevt, 
									targetObj: this, 
									targetFunc: thisFunc
								});
							}else{
								alert(tevt+" is not a function in widget "+widget);
							}
						}
					}
	
					if(widget.extraArgs['dojoattachpoint']){
						//don't attach widget.domNode here, as we do not know which
						//dom node we should connect to (in checkbox widget case, 
						//it is inputNode). So we make the widget itself available
						this[widget.extraArgs['dojoattachpoint']] = widget;
					}
				}
			}

			//dojo.profile.end(this.widgetType + " postInitialize");

			// Expand my children widgets
			/* dojoDontFollow is important for a very special case
			 * basically if you have a widget that you instantiate from script
			 * and that widget is a container, and it contains a reference to a parent
			 * instance, the parser will start recursively parsing until the browser
			 * complains.  So the solution is to set an initialization property of 
			 * dojoDontFollow: true and then it won't recurse where it shouldn't
			 */
			if(this.isContainer && !frag["dojoDontFollow"]){
				//alert("recurse from " + this.widgetId);
				// build any sub-components with us as the parent
				dojo.widget.getParser().createSubComponents(frag, this);
			}
		},

		// method over-ride
		buildRendering: function(/*Object*/ args, /*Object*/ frag){
			// summary:
			//		Construct the UI for this widget, generally from a
			//		template. This can be over-ridden for custom UI creation to
			//		to side-step the template system.  This is an
			//		implementation of the stub function defined in
			//		dojo.widget.Widget.

			// DOM widgets construct themselves from a template
			var ts = dojo.widget._templateCache[this.widgetType];
			
			// Handle style for this widget here, as even if templatePath
			// is not set, style specified by templateCssString or templateCssPath
			// should be applied. templateCssString has higher priority
			// than templateCssPath
			if(args["templatecsspath"]){
				args["templateCssPath"] = args["templatecsspath"];
			}
			var cpath = args["templateCssPath"] || this.templateCssPath;
			if(cpath && !dojo.widget._cssFiles[cpath.toString()]){
				if((!this.templateCssString)&&(cpath)){
					this.templateCssString = dojo.hostenv.getText(cpath);
					this.templateCssPath = null;
				}
				dojo.widget._cssFiles[cpath.toString()] = true;
			}
		
			if((this["templateCssString"])&&(!dojo.widget._cssStrings[this.templateCssString])){
				dojo.html.insertCssText(this.templateCssString, null, cpath);
				dojo.widget._cssStrings[this.templateCssString] = true;
			}
			if(	
				(!this.preventClobber)&&(
					(this.templatePath)||
					(this.templateNode)||
					(
						(this["templateString"])&&(this.templateString.length) 
					)||
					(
						(typeof ts != "undefined")&&( (ts["string"])||(ts["node"]) )
					)
				)
			){
				// if it looks like we can build the thing from a template, do it!
				this.buildFromTemplate(args, frag);
			}else{
				// otherwise, assign the DOM node that was the source of the widget
				// parsing to be the root node
				this.domNode = this.getFragNodeRef(frag);
			}
			this.fillInTemplate(args, frag); 	// this is where individual widgets
												// will handle population of data
												// from properties, remote data
												// sets, etc.
		},

		buildFromTemplate: function(/*Object*/ args, /*Object*/ frag){
			// summary:
			//		Called by buildRendering, creates the actual UI in a DomWidget.

			// var start = new Date();
			// copy template properties if they're already set in the templates object
			// dojo.debug("buildFromTemplate:", this);
			var avoidCache = false;
			if(args["templatepath"]){
//				avoidCache = true;
				args["templatePath"] = args["templatepath"];
			}
			dojo.widget.fillFromTemplateCache(	this, 
												args["templatePath"], 
												null,
												avoidCache);
			var ts = dojo.widget._templateCache[this.templatePath?this.templatePath.toString():this.widgetType];
			if((ts)&&(!avoidCache)){
				if(!this.templateString.length){
					this.templateString = ts["string"];
				}
				if(!this.templateNode){
					this.templateNode = ts["node"];
				}
			}
			var matches = false;
			var node = null;
			// var tstr = new String(this.templateString); 
			var tstr = this.templateString; 
			// attempt to clone a template node, if there is one
			if((!this.templateNode)&&(this.templateString)){
				matches = this.templateString.match(/\$\{([^\}]+)\}/g);
				if(matches) {
					// if we do property replacement, don't create a templateNode
					// to clone from.
					var hash = this.strings || {};
					// FIXME: should this hash of default replacements be cached in
					// templateString?
					for(var key in dojo.widget.defaultStrings) {
						if(dojo.lang.isUndefined(hash[key])) {
							hash[key] = dojo.widget.defaultStrings[key];
						}
					}
					// FIXME: this is a lot of string munging. Can we make it faster?
					for(var i = 0; i < matches.length; i++) {
						var key = matches[i];
						key = key.substring(2, key.length-1);
						var kval = (key.substring(0, 5) == "this.") ? dojo.lang.getObjPathValue(key.substring(5), this) : hash[key];
						var value;
						if((kval)||(dojo.lang.isString(kval))){
							value = new String((dojo.lang.isFunction(kval)) ? kval.call(this, key, this.templateString) : kval);
							// Safer substitution, see heading "Attribute values" in  
							// http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.3.2
							while (value.indexOf("\"") > -1) {
								value=value.replace("\"","&quot;");
							}
							tstr = tstr.replace(matches[i], value);
						}
					}
				}else{
					// otherwise, we are required to instantiate a copy of the template
					// string if one is provided.
					
					// FIXME: need to be able to distinguish here what should be done
					// or provide a generic interface across all DOM implementations
					// FIMXE: this breaks if the template has whitespace as its first 
					// characters
					// node = this.createNodesFromText(this.templateString, true);
					// this.templateNode = node[0].cloneNode(true); // we're optimistic here
					this.templateNode = this.createNodesFromText(this.templateString, true)[0];
					if(!avoidCache){
						ts.node = this.templateNode;
					}
				}
			}
			if((!this.templateNode)&&(!matches)){ 
				dojo.debug("DomWidget.buildFromTemplate: could not create template");
				return false;
			}else if(!matches){
				node = this.templateNode.cloneNode(true);
				if(!node){ return false; }
			}else{
				node = this.createNodesFromText(tstr, true)[0];
			}

			// recurse through the node, looking for, and attaching to, our
			// attachment points which should be defined on the template node.

			this.domNode = node;
			// dojo.profile.start("attachTemplateNodes");
			this.attachTemplateNodes();
			// dojo.profile.end("attachTemplateNodes");
		
			// relocate source contents to templated container node
			// this.containerNode must be able to receive children, or exceptions will be thrown
			if (this.isContainer && this.containerNode){
				var src = this.getFragNodeRef(frag);
				if (src){
					dojo.dom.moveChildren(src, this.containerNode);
				}
			}
		},

		attachTemplateNodes: function(baseNode, targetObj){
			// summary: 
			//		hooks up event handlers and property/node linkages. Calls
			//		dojo.widget.attachTemplateNodes to do all the hard work.
			// baseNode: DomNode
			//		defaults to "this.domNode"
			// targetObj: Widget
			//		defaults to "this"
			if(!baseNode){ baseNode = this.domNode; }
			if(!targetObj){ targetObj = this; }
			return dojo.widget.attachTemplateNodes(baseNode, targetObj, 
						dojo.widget.getDojoEventsFromStr(this.templateString));
		},

		fillInTemplate: function(){
			// summary:
			//		stub function! sub-classes may use as a default UI
			//		initializer function. The UI rendering will be available by
			//		the time this is called from buildRendering. If
			//		buildRendering is over-ridden, this function may not be
			//		fired!

			// dojo.unimplemented("dojo.widget.DomWidget.fillInTemplate");
		},
		
		// method over-ride
		destroyRendering: function(){
			// summary: UI destructor.  Destroy the dom nodes associated w/this widget.
			try{
				dojo.dom.destroyNode(this.domNode);
				delete this.domNode;
			}catch(e){ /* squelch! */ }
			if(this._sourceNodeRef){
				try{
					dojo.dom.destroyNode(this._sourceNodeRef);
				}catch(e){ /* squelch! */ }
			}
		},

		createNodesFromText: function(){
			// summary
			//	Attempts to create a set of nodes based on the structure of the passed text.
			//	Implemented in HtmlWidget and SvgWidget.
			dojo.unimplemented("dojo.widget.DomWidget.createNodesFromText");
		}
	}
);

dojo.provide("dojo.html.util");


dojo.html.getElementWindow = function(/* HTMLElement */element){
	//	summary
	// 	Get the window object where the element is placed in.
	return dojo.html.getDocumentWindow( element.ownerDocument );	//	Window
}

dojo.html.getDocumentWindow = function(doc){
	//	summary
	// 	Get window object associated with document doc

	// With Safari, there is not wa to retrieve the window from the document, so we must fix it.
	if(dojo.render.html.safari && !doc._parentWindow){
		/*
			This is a Safari specific function that fix the reference to the parent
			window from the document object.
		*/

		var fix=function(win){
			win.document._parentWindow=win;
			for(var i=0; i<win.frames.length; i++){
				fix(win.frames[i]);
			}
		}
		fix(window.top);
	}

	//In some IE versions (at least 6.0), document.parentWindow does not return a
	//reference to the real window object (maybe a copy), so we must fix it as well
	//We use IE specific execScript to attach the real window reference to
	//document._parentWindow for later use
	if(dojo.render.html.ie && window !== document.parentWindow && !doc._parentWindow){
		/*
		In IE 6, only the variable "window" can be used to connect events (others
		may be only copies).
		*/
		doc.parentWindow.execScript("document._parentWindow = window;", "Javascript");
		//to prevent memory leak, unset it after use
		//another possibility is to add an onUnload handler which seems overkill to me (liucougar)
		var win = doc._parentWindow;
		doc._parentWindow = null;
		return win;	//	Window
	}

	return doc._parentWindow || doc.parentWindow || doc.defaultView;	//	Window
}

dojo.html.gravity = function(/* HTMLElement */node, /* DOMEvent */e){
	//	summary
	//	Calculates the mouse's direction of gravity relative to the centre
	//	of the given node.
	//	<p>
	//	If you wanted to insert a node into a DOM tree based on the mouse
	//	position you might use the following code:
	//	<pre>
	//	if (gravity(node, e) & gravity.NORTH) { [insert before]; }
	//	else { [insert after]; }
	//	</pre>
	//
	//	@param node The node
	//	@param e		The event containing the mouse coordinates
	//	@return		 The directions, NORTH or SOUTH and EAST or WEST. These
	//						 are properties of the function.
	node = dojo.byId(node);
	var mouse = dojo.html.getCursorPosition(e);

	with (dojo.html) {
		var absolute = getAbsolutePosition(node, true);
		var bb = getBorderBox(node);
		var nodecenterx = absolute.x + (bb.width / 2);
		var nodecentery = absolute.y + (bb.height / 2);
	}

	with (dojo.html.gravity) {
		return ((mouse.x < nodecenterx ? WEST : EAST) | (mouse.y < nodecentery ? NORTH : SOUTH));	//	integer
	}
}

dojo.html.gravity.NORTH = 1;
dojo.html.gravity.SOUTH = 1 << 1;
dojo.html.gravity.EAST = 1 << 2;
dojo.html.gravity.WEST = 1 << 3;

dojo.html.overElement = function(/* HTMLElement */element, /* DOMEvent */e){
	//	summary
	//	Returns whether the mouse is over the passed element.
	//	Element must be display:block (ie, not a <span>)
	element = dojo.byId(element);
	var mouse = dojo.html.getCursorPosition(e);
	var bb = dojo.html.getBorderBox(element);
	var absolute = dojo.html.getAbsolutePosition(element, true, dojo.html.boxSizing.BORDER_BOX);
	var top = absolute.y;
	var bottom = top + bb.height;
	var left = absolute.x;
	var right = left + bb.width;

	return (mouse.x >= left
		&& mouse.x <= right
		&& mouse.y >= top
		&& mouse.y <= bottom
	);	//	boolean
}

dojo.html.renderedTextContent = function(/* HTMLElement */node){
	//	summary
	//	Attempts to return the text as it would be rendered, with the line breaks
	//	sorted out nicely. Unfinished.
	node = dojo.byId(node);
	var result = "";
	if (node == null) { return result; }
	for (var i = 0; i < node.childNodes.length; i++) {
		switch (node.childNodes[i].nodeType) {
			case 1: // ELEMENT_NODE
			case 5: // ENTITY_REFERENCE_NODE
				var display = "unknown";
				try {
					display = dojo.html.getStyle(node.childNodes[i], "display");
				} catch(E) {}
				switch (display) {
					case "block": case "list-item": case "run-in":
					case "table": case "table-row-group": case "table-header-group":
					case "table-footer-group": case "table-row": case "table-column-group":
					case "table-column": case "table-cell": case "table-caption":
						// TODO: this shouldn't insert double spaces on aligning blocks
						result += "\n";
						result += dojo.html.renderedTextContent(node.childNodes[i]);
						result += "\n";
						break;

					case "none": break;

					default:
						if(node.childNodes[i].tagName && node.childNodes[i].tagName.toLowerCase() == "br") {
							result += "\n";
						} else {
							result += dojo.html.renderedTextContent(node.childNodes[i]);
						}
						break;
				}
				break;
			case 3: // TEXT_NODE
			case 2: // ATTRIBUTE_NODE
			case 4: // CDATA_SECTION_NODE
				var text = node.childNodes[i].nodeValue;
				var textTransform = "unknown";
				try {
					textTransform = dojo.html.getStyle(node, "text-transform");
				} catch(E) {}
				switch (textTransform){
					case "capitalize":
						var words = text.split(' ');
						for(var i=0; i<words.length; i++){
							words[i] = words[i].charAt(0).toUpperCase() + words[i].substring(1);
						}
						text = words.join(" ");
						break;
					case "uppercase": text = text.toUpperCase(); break;
					case "lowercase": text = text.toLowerCase(); break;
					default: break; // leave as is
				}
				// TODO: implement
				switch (textTransform){
					case "nowrap": break;
					case "pre-wrap": break;
					case "pre-line": break;
					case "pre": break; // leave as is
					default:
						// remove whitespace and collapse first space
						text = text.replace(/\s+/, " ");
						if (/\s$/.test(result)) { text.replace(/^\s/, ""); }
						break;
				}
				result += text;
				break;
			default:
				break;
		}
	}
	return result;	//	string
}

dojo.html.createNodesFromText = function(/* string */txt, /* boolean? */trim){
	//	summary
	//	Attempts to create a set of nodes based on the structure of the passed text.
	if(trim) { txt = txt.replace(/^\s+|\s+$/g, ""); }

	var tn = dojo.doc().createElement("div");
	// tn.style.display = "none";
	tn.style.visibility= "hidden";
	dojo.body().appendChild(tn);
	var tableType = "none";
	if((/^<t[dh][\s\r\n>]/i).test(txt.replace(/^\s+/))) {
		txt = "<table><tbody><tr>" + txt + "</tr></tbody></table>";
		tableType = "cell";
	} else if((/^<tr[\s\r\n>]/i).test(txt.replace(/^\s+/))) {
		txt = "<table><tbody>" + txt + "</tbody></table>";
		tableType = "row";
	} else if((/^<(thead|tbody|tfoot)[\s\r\n>]/i).test(txt.replace(/^\s+/))) {
		txt = "<table>" + txt + "</table>";
		tableType = "section";
	}
	tn.innerHTML = txt;
	if(tn["normalize"]){
		tn.normalize();
	}

	var parent = null;
	switch(tableType) {
		case "cell":
			parent = tn.getElementsByTagName("tr")[0];
			break;
		case "row":
			parent = tn.getElementsByTagName("tbody")[0];
			break;
		case "section":
			parent = tn.getElementsByTagName("table")[0];
			break;
		default:
			parent = tn;
			break;
	}

	/* this doesn't make much sense, I'm assuming it just meant trim() so wrap was replaced with trim
	if(wrap){
		var ret = [];
		// start hack
		var fc = tn.firstChild;
		ret[0] = ((fc.nodeValue == " ")||(fc.nodeValue == "\t")) ? fc.nextSibling : fc;
		// end hack
		// tn.style.display = "none";
		dojo.body().removeChild(tn);
		return ret;
	}
	*/
	var nodes = [];
	for(var x=0; x<parent.childNodes.length; x++){
		nodes.push(parent.childNodes[x].cloneNode(true));
	}
	tn.style.display = "none"; // FIXME: why do we do this?
	dojo.html.destroyNode(tn);
	return nodes;	//	array
}

dojo.html.placeOnScreen = function(
	/* HTMLElement */node,
	/* integer */desiredX,
	/* integer */desiredY,
	/* integer */padding,
	/* boolean? */hasScroll,
	/* string? */corners,
	/* boolean? */tryOnly
){
	//	summary
	//	Keeps 'node' in the visible area of the screen while trying to
	//	place closest to desiredX, desiredY. The input coordinates are
	//	expected to be the desired screen position, not accounting for
	//	scrolling. If you already accounted for scrolling, set 'hasScroll'
	//	to true. Set padding to either a number or array for [paddingX, paddingY]
	//	to put some buffer around the element you want to position.
	//	Set which corner(s) you want to bind to, such as
	//
	//	placeOnScreen(node, desiredX, desiredY, padding, hasScroll, "TR")
	//	placeOnScreen(node, [desiredX, desiredY], padding, hasScroll, ["TR", "BL"])
	//
	//	The desiredX/desiredY will be treated as the topleft(TL)/topright(TR) or
	//	BottomLeft(BL)/BottomRight(BR) corner of the node. Each corner is tested
	//	and if a perfect match is found, it will be used. Otherwise, it goes through
	//	all of the specified corners, and choose the most appropriate one.
	//	By default, corner = ['TL'].
	//	If tryOnly is set to true, the node will not be moved to the place.
	//
	//	NOTE: node is assumed to be absolutely or relatively positioned.
	//
	//	Alternate call sig:
	//	 placeOnScreen(node, [x, y], padding, hasScroll)
	//
	//	Examples:
	//	 placeOnScreen(node, 100, 200)
	//	 placeOnScreen("myId", [800, 623], 5)
	//	 placeOnScreen(node, 234, 3284, [2, 5], true)

	// TODO: make this function have variable call sigs
	//	kes(node, ptArray, cornerArray, padding, hasScroll)
	//	kes(node, ptX, ptY, cornerA, cornerB, cornerC, paddingArray, hasScroll)
	if(desiredX instanceof Array || typeof desiredX == "array") {
		tryOnly = corners;
		corners = hasScroll;
		hasScroll = padding;
		padding = desiredY;
		desiredY = desiredX[1];
		desiredX = desiredX[0];
	}

	if(corners instanceof String || typeof corners == "string"){
		corners = corners.split(",");
	}

	if(!isNaN(padding)) {
		padding = [Number(padding), Number(padding)];
	} else if(!(padding instanceof Array || typeof padding == "array")) {
		padding = [0, 0];
	}

	var scroll = dojo.html.getScroll().offset;
	var view = dojo.html.getViewport();

	node = dojo.byId(node);
	var oldDisplay = node.style.display;
	node.style.display="";
	var bb = dojo.html.getBorderBox(node);
	var w = bb.width;
	var h = bb.height;
	node.style.display=oldDisplay;

	if(!(corners instanceof Array || typeof corners == "array")){
		corners = ['TL'];
	}

	var bestx, besty, bestDistance = Infinity, bestCorner;

	for(var cidex=0; cidex<corners.length; ++cidex){
		var corner = corners[cidex];
		var match = true;
		var tryX = desiredX - (corner.charAt(1)=='L' ? 0 : w) + padding[0]*(corner.charAt(1)=='L' ? 1 : -1);
		var tryY = desiredY - (corner.charAt(0)=='T' ? 0 : h) + padding[1]*(corner.charAt(0)=='T' ? 1 : -1);
		if(hasScroll) {
			tryX -= scroll.x;
			tryY -= scroll.y;
		}

		if(tryX < 0){
			tryX = 0;
			match = false;
		}

		if(tryY < 0){
			tryY = 0;
			match = false;
		}

		var x = tryX + w;
		if(x > view.width) {
			x = view.width - w;
			match = false;
		} else {
			x = tryX;
		}
		x = Math.max(padding[0], x) + scroll.x;

		var y = tryY + h;
		if(y > view.height) {
			y = view.height - h;
			match = false;
		} else {
			y = tryY;
		}
		y = Math.max(padding[1], y) + scroll.y;

		if(match){ //perfect match, return now
			bestx = x;
			besty = y;
			bestDistance = 0;
			bestCorner = corner;
			break;
		}else{
			//not perfect, find out whether it is better than the saved one
			var dist = Math.pow(x-tryX-scroll.x,2)+Math.pow(y-tryY-scroll.y,2);
			if(bestDistance > dist){
				bestDistance = dist;
				bestx = x;
				besty = y;
				bestCorner = corner;
			}
		}
	}

	if(!tryOnly){
		node.style.left = bestx + "px";
		node.style.top = besty + "px";
	}

	return { left: bestx, top: besty, x: bestx, y: besty, dist: bestDistance, corner:  bestCorner};	//	object
}

dojo.html.placeOnScreenPoint = function(node, desiredX, desiredY, padding, hasScroll) {
	dojo.deprecated("dojo.html.placeOnScreenPoint", "use dojo.html.placeOnScreen() instead", "0.5");
	return dojo.html.placeOnScreen(node, desiredX, desiredY, padding, hasScroll, ['TL', 'TR', 'BL', 'BR']);
}

dojo.html.placeOnScreenAroundElement = function(
	/* HTMLElement */node,
	/* HTMLElement */aroundNode,
	/* integer */padding,
	/* string? */aroundType,
	/* string? */aroundCorners,
	/* boolean? */tryOnly
){
	//	summary
	//	Like placeOnScreen, except it accepts aroundNode instead of x,y
	//	and attempts to place node around it. aroundType (see
	//	dojo.html.boxSizing in html/layout.js) determines which box of the
	//	aroundNode should be used to calculate the outer box.
	//	aroundCorners specify Which corner of aroundNode should be
	//	used to place the node => which corner(s) of node to use (see the
	//	corners parameter in dojo.html.placeOnScreen)
	//	aroundCorners: {'TL': 'BL', 'BL': 'TL'}

	var best, bestDistance=Infinity;
	aroundNode = dojo.byId(aroundNode);
	var oldDisplay = aroundNode.style.display;
	aroundNode.style.display="";
	var mb = dojo.html.getElementBox(aroundNode, aroundType);
	var aroundNodeW = mb.width;
	var aroundNodeH = mb.height;
	var aroundNodePos = dojo.html.getAbsolutePosition(aroundNode, true, aroundType);
	aroundNode.style.display=oldDisplay;

	for(var nodeCorner in aroundCorners){
		var pos, desiredX, desiredY;
		var corners = aroundCorners[nodeCorner];

		desiredX = aroundNodePos.x + (nodeCorner.charAt(1)=='L' ? 0 : aroundNodeW);
		desiredY = aroundNodePos.y + (nodeCorner.charAt(0)=='T' ? 0 : aroundNodeH);

		pos = dojo.html.placeOnScreen(node, desiredX, desiredY, padding, true, corners, true);
		if(pos.dist == 0){
			best = pos;
			break;
		}else{
			//not perfect, find out whether it is better than the saved one
			if(bestDistance > pos.dist){
				bestDistance = pos.dist;
				best = pos;
			}
		}
	}

	if(!tryOnly){
		node.style.left = best.left + "px";
		node.style.top = best.top + "px";
	}
	return best;	//	object
}

dojo.html.scrollIntoView = function(/* HTMLElement */node){
	//	summary
	//	Scroll the passed node into view, if it is not.
	if(!node){ return; }

	// don't rely on that node.scrollIntoView works just because the function is there
	// it doesnt work in Konqueror or Opera even though the function is there and probably
	// not safari either
	// dont like browser sniffs implementations but sometimes you have to use it
	if(dojo.render.html.ie){
		//only call scrollIntoView if there is a scrollbar for this menu,
		//otherwise, scrollIntoView will scroll the window scrollbar
		if(dojo.html.getBorderBox(node.parentNode).height <= node.parentNode.scrollHeight){
			node.scrollIntoView(false);
		}
	}else if(dojo.render.html.mozilla){
		// IE, mozilla
		node.scrollIntoView(false);
	}else{
		var parent = node.parentNode;
		var parentBottom = parent.scrollTop + dojo.html.getBorderBox(parent).height;
		var nodeBottom = node.offsetTop + dojo.html.getMarginBox(node).height;
		if(parentBottom < nodeBottom){
			parent.scrollTop += (nodeBottom - parentBottom);
		}else if(parent.scrollTop > node.offsetTop){
			parent.scrollTop -= (parent.scrollTop - node.offsetTop);
		}
	}
}

dojo.provide("dojo.gfx.color");



// TODO: rewrite the "x2y" methods to take advantage of the parsing
//       abilities of the Color object. Also, beef up the Color
//       object (as possible) to parse most common formats

// takes an r, g, b, a(lpha) value, [r, g, b, a] array, "rgb(...)" string, hex string (#aaa, #aaaaaa, aaaaaaa)
dojo.gfx.color.Color = function(r, g, b, a) {
	// dojo.debug("r:", r[0], "g:", r[1], "b:", r[2]);
	if(dojo.lang.isArray(r)){
		this.r = r[0];
		this.g = r[1];
		this.b = r[2];
		this.a = r[3]||1.0;
	}else if(dojo.lang.isString(r)){
		var rgb = dojo.gfx.color.extractRGB(r);
		this.r = rgb[0];
		this.g = rgb[1];
		this.b = rgb[2];
		this.a = g||1.0;
	}else if(r instanceof dojo.gfx.color.Color){
		// why does this create a new instance if we were passed one?
		this.r = r.r;
		this.b = r.b;
		this.g = r.g;
		this.a = r.a;
	}else{
		this.r = r;
		this.g = g;
		this.b = b;
		this.a = a;
	}
}

dojo.gfx.color.Color.fromArray = function(arr) {
	return new dojo.gfx.color.Color(arr[0], arr[1], arr[2], arr[3]);
}

dojo.extend(dojo.gfx.color.Color, {
	toRgb: function(includeAlpha) {
		if(includeAlpha) {
			return this.toRgba();
		} else {
			return [this.r, this.g, this.b];
		}
	},
	toRgba: function() {
		return [this.r, this.g, this.b, this.a];
	},
	toHex: function() {
		return dojo.gfx.color.rgb2hex(this.toRgb());
	},
	toCss: function() {
		return "rgb(" + this.toRgb().join() + ")";
	},
	toString: function() {
		return this.toHex(); // decent default?
	},
	blend: function(color, weight){
		var rgb = null;
		if(dojo.lang.isArray(color)){
			rgb = color;
		}else if(color instanceof dojo.gfx.color.Color){
			rgb = color.toRgb();
		}else{
			rgb = new dojo.gfx.color.Color(color).toRgb();
		}
		return dojo.gfx.color.blend(this.toRgb(), rgb, weight);
	}
});

dojo.gfx.color.named = {
	white:      [255,255,255],
	black:      [0,0,0],
	red:        [255,0,0],
	green:	    [0,255,0],
	lime:	    [0,255,0],
	blue:       [0,0,255],
	navy:       [0,0,128],
	gray:       [128,128,128],
	silver:     [192,192,192]
};

dojo.gfx.color.blend = function(a, b, weight){
	// summary: 
	//		blend colors a and b (both as RGB array or hex strings) with weight
	//		from -1 to +1, 0 being a 50/50 blend
	if(typeof a == "string"){
		return dojo.gfx.color.blendHex(a, b, weight);
	}
	if(!weight){
		weight = 0;
	}
	weight = Math.min(Math.max(-1, weight), 1);

	// alex: this interface blows.
	// map -1 to 1 to the range 0 to 1
	weight = ((weight + 1)/2);
	
	var c = [];

	// var stop = (1000*weight);
	for(var x = 0; x < 3; x++){
		c[x] = parseInt( b[x] + ( (a[x] - b[x]) * weight) );
	}
	return c;
}

// very convenient blend that takes and returns hex values
// (will get called automatically by blend when blend gets strings)
dojo.gfx.color.blendHex = function(a, b, weight) {
	return dojo.gfx.color.rgb2hex(dojo.gfx.color.blend(dojo.gfx.color.hex2rgb(a), dojo.gfx.color.hex2rgb(b), weight));
}

// get RGB array from css-style color declarations
dojo.gfx.color.extractRGB = function(color) {
	var hex = "0123456789abcdef";
	color = color.toLowerCase();
	if( color.indexOf("rgb") == 0 ) {
		var matches = color.match(/rgba*\((\d+), *(\d+), *(\d+)/i);
		var ret = matches.splice(1, 3);
		return ret;
	} else {
		var colors = dojo.gfx.color.hex2rgb(color);
		if(colors) {
			return colors;
		} else {
			// named color (how many do we support?)
			return dojo.gfx.color.named[color] || [255, 255, 255];
		}
	}
}

dojo.gfx.color.hex2rgb = function(hex) {
	var hexNum = "0123456789ABCDEF";
	var rgb = new Array(3);
	if( hex.indexOf("#") == 0 ) { hex = hex.substring(1); }
	hex = hex.toUpperCase();
	if(hex.replace(new RegExp("["+hexNum+"]", "g"), "") != "") {
		return null;
	}
	if( hex.length == 3 ) {
		rgb[0] = hex.charAt(0) + hex.charAt(0)
		rgb[1] = hex.charAt(1) + hex.charAt(1)
		rgb[2] = hex.charAt(2) + hex.charAt(2);
	} else {
		rgb[0] = hex.substring(0, 2);
		rgb[1] = hex.substring(2, 4);
		rgb[2] = hex.substring(4);
	}
	for(var i = 0; i < rgb.length; i++) {
		rgb[i] = hexNum.indexOf(rgb[i].charAt(0)) * 16 + hexNum.indexOf(rgb[i].charAt(1));
	}
	return rgb;
}

dojo.gfx.color.rgb2hex = function(r, g, b) {
	if(dojo.lang.isArray(r)) {
		g = r[1] || 0;
		b = r[2] || 0;
		r = r[0] || 0;
	}
	var ret = dojo.lang.map([r, g, b], function(x) {
		x = new Number(x);
		var s = x.toString(16);
		while(s.length < 2) { s = "0" + s; }
		return s;
	});
	ret.unshift("#");
	return ret.join("");
}

dojo.provide("dojo.lfx.Animation");



/*
	Animation package based on Dan Pupius' work: http://pupius.co.uk/js/Toolkit.Drawing.js
*/
dojo.lfx.Line = function(/*int*/ start, /*int*/ end){
	// summary: dojo.lfx.Line is the object used to generate values
	//			from a start value to an end value
	this.start = start;
	this.end = end;
	if(dojo.lang.isArray(start)){
		/* start: Array
		   end: Array
		   pId: a */
		var diff = [];
		dojo.lang.forEach(this.start, function(s,i){
			diff[i] = this.end[i] - s;
		}, this);
		
		this.getValue = function(/*float*/ n){
			var res = [];
			dojo.lang.forEach(this.start, function(s, i){
				res[i] = (diff[i] * n) + s;
			}, this);
			return res; // Array
		}
	}else{
		var diff = end - start;
			
		this.getValue = function(/*float*/ n){
			//	summary: returns the point on the line
			//	n: a floating point number greater than 0 and less than 1
			return (diff * n) + this.start; // Decimal
		}
	}
}

if((dojo.render.html.khtml)&&(!dojo.render.html.safari)){
	// the cool kids are obviously not using konqueror...
	// found a very wierd bug in floats constants, 1.5 evals as 1
	// seems somebody mixed up ints and floats in 3.5.4 ??
	// FIXME: investigate more and post a KDE bug (Fredrik)
	dojo.lfx.easeDefault = function(/*Decimal?*/ n){
		//	summary: Returns the point for point n on a sin wave.
		return (parseFloat("0.5")+((Math.sin( (n+parseFloat("1.5")) * Math.PI))/2));
	}
}else{
	dojo.lfx.easeDefault = function(/*Decimal?*/ n){
		return (0.5+((Math.sin( (n+1.5) * Math.PI))/2));
	}
}

dojo.lfx.easeIn = function(/*Decimal?*/ n){
	//	summary: returns the point on an easing curve
	//	n: a floating point number greater than 0 and less than 1
	return Math.pow(n, 3);
}

dojo.lfx.easeOut = function(/*Decimal?*/ n){
	//	summary: returns the point on the line
	//	n: a floating point number greater than 0 and less than 1
	return ( 1 - Math.pow(1 - n, 3) );
}

dojo.lfx.easeInOut = function(/*Decimal?*/ n){
	//	summary: returns the point on the line
	//	n: a floating point number greater than 0 and less than 1
	return ( (3 * Math.pow(n, 2)) - (2 * Math.pow(n, 3)) );
}

dojo.lfx.IAnimation = function(){
	// summary: dojo.lfx.IAnimation is an interface that implements
	//			commonly used functions of animation objects
}
dojo.lang.extend(dojo.lfx.IAnimation, {
	// public properties
	curve: null,
	duration: 1000,
	easing: null,
	repeatCount: 0,
	rate: 10,
	
	// events
	handler: null,
	beforeBegin: null,
	onBegin: null,
	onAnimate: null,
	onEnd: null,
	onPlay: null,
	onPause: null,
	onStop: null,
	
	// public methods
	play: null,
	pause: null,
	stop: null,
	
	connect: function(/*Event*/ evt, /*Object*/ scope, /*Function*/ newFunc){
		// summary: Convenience function.  Quickly connect to an event
		//			of this object and save the old functions connected to it.
		// evt: The name of the event to connect to.
		// scope: the scope in which to run newFunc.
		// newFunc: the function to run when evt is fired.
		if(!newFunc){
			/* scope: Function
			   newFunc: null
			   pId: f */
			newFunc = scope;
			scope = this;
		}
		newFunc = dojo.lang.hitch(scope, newFunc);
		var oldFunc = this[evt]||function(){};
		this[evt] = function(){
			var ret = oldFunc.apply(this, arguments);
			newFunc.apply(this, arguments);
			return ret;
		}
		return this; // dojo.lfx.IAnimation
	},

	fire: function(/*Event*/ evt, /*Array*/ args){
		// summary: Convenience function.  Fire event "evt" and pass it
		//			the arguments specified in "args".
		// evt: The event to fire.
		// args: The arguments to pass to the event.
		if(this[evt]){
			this[evt].apply(this, (args||[]));
		}
		return this; // dojo.lfx.IAnimation
	},
	
	repeat: function(/*int*/ count){
		// summary: Set the repeat count of this object.
		// count: How many times to repeat the animation.
		this.repeatCount = count;
		return this; // dojo.lfx.IAnimation
	},

	// private properties
	_active: false,
	_paused: false
});

dojo.lfx.Animation = function(	/*Object*/ handlers, 
								/*int*/ duration, 
								/*dojo.lfx.Line*/ curve, 
								/*function*/ easing, 
								/*int*/ repeatCount, 
								/*int*/ rate){
	//	summary
	//		a generic animation object that fires callbacks into it's handlers
	//		object at various states
	//	handlers: { handler: Function?, onstart: Function?, onstop: Function?, onanimate: Function? }
	dojo.lfx.IAnimation.call(this);
	if(dojo.lang.isNumber(handlers)||(!handlers && duration.getValue)){
		// no handlers argument:
		rate = repeatCount;
		repeatCount = easing;
		easing = curve;
		curve = duration;
		duration = handlers;
		handlers = null;
	}else if(handlers.getValue||dojo.lang.isArray(handlers)){
		// no handlers or duration:
		rate = easing;
		repeatCount = curve;
		easing = duration;
		curve = handlers;
		duration = null;
		handlers = null;
	}
	if(dojo.lang.isArray(curve)){
		/* curve: Array
		   pId: a */
		this.curve = new dojo.lfx.Line(curve[0], curve[1]);
	}else{
		this.curve = curve;
	}
	if(duration != null && duration > 0){ this.duration = duration; }
	if(repeatCount){ this.repeatCount = repeatCount; }
	if(rate){ this.rate = rate; }
	if(handlers){
		dojo.lang.forEach([
				"handler", "beforeBegin", "onBegin", 
				"onEnd", "onPlay", "onStop", "onAnimate"
			], function(item){
				if(handlers[item]){
					this.connect(item, handlers[item]);
				}
			}, this);
	}
	if(easing && dojo.lang.isFunction(easing)){
		this.easing=easing;
	}
}
dojo.inherits(dojo.lfx.Animation, dojo.lfx.IAnimation);
dojo.lang.extend(dojo.lfx.Animation, {
	// "private" properties
	_startTime: null,
	_endTime: null,
	_timer: null,
	_percent: 0,
	_startRepeatCount: 0,

	// public methods
	play: function(/*int?*/ delay, /*bool?*/ gotoStart){
		// summary: Start the animation.
		// delay: How many milliseconds to delay before starting.
		// gotoStart: If true, starts the animation from the beginning; otherwise,
		//            starts it from its current position.
		if(gotoStart){
			clearTimeout(this._timer);
			this._active = false;
			this._paused = false;
			this._percent = 0;
		}else if(this._active && !this._paused){
			return this; // dojo.lfx.Animation
		}
		
		this.fire("handler", ["beforeBegin"]);
		this.fire("beforeBegin");

		if(delay > 0){
			setTimeout(dojo.lang.hitch(this, function(){ this.play(null, gotoStart); }), delay);
			return this; // dojo.lfx.Animation
		}
		
		this._startTime = new Date().valueOf();
		if(this._paused){
			this._startTime -= (this.duration * this._percent / 100);
		}
		this._endTime = this._startTime + this.duration;

		this._active = true;
		this._paused = false;
		
		var step = this._percent / 100;
		var value = this.curve.getValue(step);
		if(this._percent == 0 ){
			if(!this._startRepeatCount){
				this._startRepeatCount = this.repeatCount;
			}
			this.fire("handler", ["begin", value]);
			this.fire("onBegin", [value]);
		}

		this.fire("handler", ["play", value]);
		this.fire("onPlay", [value]);

		this._cycle();
		return this; // dojo.lfx.Animation
	},

	pause: function(){
		// summary: Pauses a running animation.
		clearTimeout(this._timer);
		if(!this._active){ return this; /*dojo.lfx.Animation*/}
		this._paused = true;
		var value = this.curve.getValue(this._percent / 100);
		this.fire("handler", ["pause", value]);
		this.fire("onPause", [value]);
		return this; // dojo.lfx.Animation
	},

	gotoPercent: function(/*Decimal*/ pct, /*bool?*/ andPlay){
		// summary: Sets the progress of the animation.
		// pct: A percentage in decimal notation (between and including 0.0 and 1.0).
		// andPlay: If true, play the animation after setting the progress.
		clearTimeout(this._timer);
		this._active = true;
		this._paused = true;
		this._percent = pct;
		if(andPlay){ this.play(); }
		return this; // dojo.lfx.Animation
	},

	stop: function(/*bool?*/ gotoEnd){
		// summary: Stops a running animation.
		// gotoEnd: If true, the animation will end.
		clearTimeout(this._timer);
		var step = this._percent / 100;
		if(gotoEnd){
			step = 1;
		}
		var value = this.curve.getValue(step);
		this.fire("handler", ["stop", value]);
		this.fire("onStop", [value]);
		this._active = false;
		this._paused = false;
		return this; // dojo.lfx.Animation
	},

	status: function(){
		// summary: Returns a string representation of the status of
		//			the animation.
		if(this._active){
			return this._paused ? "paused" : "playing"; // String
		}else{
			return "stopped"; // String
		}
		return this;
	},

	// "private" methods
	_cycle: function(){
		clearTimeout(this._timer);
		if(this._active){
			var curr = new Date().valueOf();
			var step = (curr - this._startTime) / (this._endTime - this._startTime);

			if(step >= 1){
				step = 1;
				this._percent = 100;
			}else{
				this._percent = step * 100;
			}
			
			// Perform easing
			if((this.easing)&&(dojo.lang.isFunction(this.easing))){
				step = this.easing(step);
			}

			var value = this.curve.getValue(step);
			this.fire("handler", ["animate", value]);
			this.fire("onAnimate", [value]);

			if( step < 1 ){
				this._timer = setTimeout(dojo.lang.hitch(this, "_cycle"), this.rate);
			}else{
				this._active = false;
				this.fire("handler", ["end"]);
				this.fire("onEnd");

				if(this.repeatCount > 0){
					this.repeatCount--;
					this.play(null, true);
				}else if(this.repeatCount == -1){
					this.play(null, true);
				}else{
					if(this._startRepeatCount){
						this.repeatCount = this._startRepeatCount;
						this._startRepeatCount = 0;
					}
				}
			}
		}
		return this; // dojo.lfx.Animation
	}
});

dojo.lfx.Combine = function(/*dojo.lfx.IAnimation...*/ animations){
	// summary: An animation object to play animations passed to it at the same time.
	dojo.lfx.IAnimation.call(this);
	this._anims = [];
	this._animsEnded = 0;
	
	var anims = arguments;
	if(anims.length == 1 && (dojo.lang.isArray(anims[0]) || dojo.lang.isArrayLike(anims[0]))){
		/* animations: dojo.lfx.IAnimation[]
		   pId: a */
		anims = anims[0];
	}
	
	dojo.lang.forEach(anims, function(anim){
		this._anims.push(anim);
		anim.connect("onEnd", dojo.lang.hitch(this, "_onAnimsEnded"));
	}, this);
}
dojo.inherits(dojo.lfx.Combine, dojo.lfx.IAnimation);
dojo.lang.extend(dojo.lfx.Combine, {
	// private members
	_animsEnded: 0,
	
	// public methods
	play: function(/*int?*/ delay, /*bool?*/ gotoStart){
		// summary: Start the animations.
		// delay: How many milliseconds to delay before starting.
		// gotoStart: If true, starts the animations from the beginning; otherwise,
		//            starts them from their current position.
		if( !this._anims.length ){ return this; /*dojo.lfx.Combine*/}

		this.fire("beforeBegin");

		if(delay > 0){
			setTimeout(dojo.lang.hitch(this, function(){ this.play(null, gotoStart); }), delay);
			return this; // dojo.lfx.Combine
		}
		
		if(gotoStart || this._anims[0].percent == 0){
			this.fire("onBegin");
		}
		this.fire("onPlay");
		this._animsCall("play", null, gotoStart);
		return this; // dojo.lfx.Combine
	},
	
	pause: function(){
		// summary: Pauses the running animations.
		this.fire("onPause");
		this._animsCall("pause"); 
		return this; // dojo.lfx.Combine
	},
	
	stop: function(/*bool?*/ gotoEnd){
		// summary: Stops the running animations.
		// gotoEnd: If true, the animations will end.
		this.fire("onStop");
		this._animsCall("stop", gotoEnd);
		return this; // dojo.lfx.Combine
	},
	
	// private methods
	_onAnimsEnded: function(){
		this._animsEnded++;
		if(this._animsEnded >= this._anims.length){
			this.fire("onEnd");
		}
		return this; // dojo.lfx.Combine
	},
	
	_animsCall: function(/*String*/ funcName){
		var args = [];
		if(arguments.length > 1){
			for(var i = 1 ; i < arguments.length ; i++){
				args.push(arguments[i]);
			}
		}
		var _this = this;
		dojo.lang.forEach(this._anims, function(anim){
			anim[funcName](args);
		}, _this);
		return this; // dojo.lfx.Combine
	}
});

dojo.lfx.Chain = function(/*dojo.lfx.IAnimation...*/ animations) {
	// summary: An animation object to play animations passed to it
	//			one after another.
	dojo.lfx.IAnimation.call(this);
	this._anims = [];
	this._currAnim = -1;
	
	var anims = arguments;
	if(anims.length == 1 && (dojo.lang.isArray(anims[0]) || dojo.lang.isArrayLike(anims[0]))){
		/* animations: dojo.lfx.IAnimation[]
		   pId: a */
		anims = anims[0];
	}
	
	var _this = this;
	dojo.lang.forEach(anims, function(anim, i, anims_arr){
		this._anims.push(anim);
		if(i < anims_arr.length - 1){
			anim.connect("onEnd", dojo.lang.hitch(this, "_playNext") );
		}else{
			anim.connect("onEnd", dojo.lang.hitch(this, function(){ this.fire("onEnd"); }) );
		}
	}, this);
}
dojo.inherits(dojo.lfx.Chain, dojo.lfx.IAnimation);
dojo.lang.extend(dojo.lfx.Chain, {
	// private members
	_currAnim: -1,
	
	// public methods
	play: function(/*int?*/ delay, /*bool?*/ gotoStart){
		// summary: Start the animation sequence.
		// delay: How many milliseconds to delay before starting.
		// gotoStart: If true, starts the sequence from the beginning; otherwise,
		//            starts it from its current position.
		if( !this._anims.length ) { return this; /*dojo.lfx.Chain*/}
		if( gotoStart || !this._anims[this._currAnim] ) {
			this._currAnim = 0;
		}

		var currentAnimation = this._anims[this._currAnim];

		this.fire("beforeBegin");
		if(delay > 0){
			setTimeout(dojo.lang.hitch(this, function(){ this.play(null, gotoStart); }), delay);
			return this; // dojo.lfx.Chain
		}
		
		if(currentAnimation){
			if(this._currAnim == 0){
				this.fire("handler", ["begin", this._currAnim]);
				this.fire("onBegin", [this._currAnim]);
			}
			this.fire("onPlay", [this._currAnim]);
			currentAnimation.play(null, gotoStart);
		}
		return this; // dojo.lfx.Chain
	},
	
	pause: function(){
		// summary: Pauses the running animation sequence.
		if( this._anims[this._currAnim] ) {
			this._anims[this._currAnim].pause();
			this.fire("onPause", [this._currAnim]);
		}
		return this; // dojo.lfx.Chain
	},
	
	playPause: function(){
		// summary: If the animation sequence is playing, pause it; otherwise,
		//			play it.
		if(this._anims.length == 0){ return this; }
		if(this._currAnim == -1){ this._currAnim = 0; }
		var currAnim = this._anims[this._currAnim];
		if( currAnim ) {
			if( !currAnim._active || currAnim._paused ) {
				this.play();
			} else {
				this.pause();
			}
		}
		return this; // dojo.lfx.Chain
	},
	
	stop: function(){
		// summary: Stops the running animations.
		var currAnim = this._anims[this._currAnim];
		if(currAnim){
			currAnim.stop();
			this.fire("onStop", [this._currAnim]);
		}
		return currAnim; // dojo.lfx.IAnimation
	},
	
	// private methods
	_playNext: function(){
		if( this._currAnim == -1 || this._anims.length == 0 ) { return this; }
		this._currAnim++;
		if( this._anims[this._currAnim] ){
			this._anims[this._currAnim].play(null, true);
		}
		return this; // dojo.lfx.Chain
	}
});

dojo.lfx.combine = function(/*dojo.lfx.IAnimation...*/ animations){
	// summary: Convenience function.  Returns a dojo.lfx.Combine created
	//			using the animations passed in.
	var anims = arguments;
	if(dojo.lang.isArray(arguments[0])){
		/* animations: dojo.lfx.IAnimation[]
		   pId: a */
		anims = arguments[0];
	}
	if(anims.length == 1){ return anims[0]; }
	return new dojo.lfx.Combine(anims); // dojo.lfx.Combine
}

dojo.lfx.chain = function(/*dojo.lfx.IAnimation...*/ animations){
	// summary: Convenience function.  Returns a dojo.lfx.Chain created
	//			using the animations passed in.
	var anims = arguments;
	if(dojo.lang.isArray(arguments[0])){
		/* animations: dojo.lfx.IAnimation[]
		   pId: a */
		anims = arguments[0];
	}
	if(anims.length == 1){ return anims[0]; }
	return new dojo.lfx.Chain(anims); // dojo.lfx.Combine
}


dojo.provide("dojo.html.color");




dojo.html.getBackgroundColor = function(/* HTMLElement */node){
	//	summary
	//	returns the background color of the passed node as a 32-bit color (RGBA)
	node = dojo.byId(node);
	var color;
	do{
		color = dojo.html.getStyle(node, "background-color");
		// Safari doesn't say "transparent"
		if(color.toLowerCase() == "rgba(0, 0, 0, 0)") { color = "transparent"; }
		if(node == document.getElementsByTagName("body")[0]) { node = null; break; }
		node = node.parentNode;
	}while(node && dojo.lang.inArray(["transparent", ""], color));
	if(color == "transparent"){
		color = [255, 255, 255, 0];
	}else{
		color = dojo.gfx.color.extractRGB(color);
	}
	return color;	//	array
}

dojo.provide("dojo.lfx.html");








dojo.lfx.html._byId = function(nodes){
	if(!nodes){ return []; }
	if(dojo.lang.isArrayLike(nodes)){
		if(!nodes.alreadyChecked){
			var n = [];
			dojo.lang.forEach(nodes, function(node){
				n.push(dojo.byId(node));
			});
			n.alreadyChecked = true;
			return n;
		}else{
			return nodes;
		}
	}else{
		var n = [];
		n.push(dojo.byId(nodes));
		n.alreadyChecked = true;
		return n;
	}
}

dojo.lfx.html.propertyAnimation = function(	/*DOMNode[]*/ nodes, 
											/*Object[]*/ propertyMap, 
											/*int*/ duration,
											/*function*/ easing,
											/*Object*/ handlers){
	// summary: Returns an animation that will transition the properties of "nodes"
	//			depending how they are defined in "propertyMap".
	// nodes: An array of DOMNodes or one DOMNode.
	// propertyMap: { property: String, start: Decimal?, end: Decimal?, units: String? }
	//				An array of objects defining properties to change.
	// duration: Duration of the animation in milliseconds.
	// easing: An easing function.
	// handlers: { handler: Function?, onstart: Function?, onstop: Function?, onanimate: Function? }
	nodes = dojo.lfx.html._byId(nodes);

	var targs = {
		"propertyMap": propertyMap,
		"nodes": nodes,
		"duration": duration,
		"easing": easing||dojo.lfx.easeDefault
	};
	
	var setEmUp = function(args){
		if(args.nodes.length==1){
			// FIXME: we're only supporting start-value filling when one node is
			// passed
			
			var pm = args.propertyMap;
			if(!dojo.lang.isArray(args.propertyMap)){
				// it's stupid to have to pack an array with a set of objects
				// when you can just pass in an object list
				var parr = [];
				for(var pname in pm){
					pm[pname].property = pname;
					parr.push(pm[pname]);
				}
				pm = args.propertyMap = parr;
			}
			dojo.lang.forEach(pm, function(prop){
				if(dj_undef("start", prop)){
					if(prop.property != "opacity"){
						prop.start = parseInt(dojo.html.getComputedStyle(args.nodes[0], prop.property));
					}else{
						prop.start = dojo.html.getOpacity(args.nodes[0]);
					}
				}
			});
		}
	}

	var coordsAsInts = function(coords){
		var cints = [];
		dojo.lang.forEach(coords, function(c){ 
			cints.push(Math.round(c));
		});
		return cints;
	}

	var setStyle = function(n, style){
		n = dojo.byId(n);
		if(!n || !n.style){ return; }
		for(var s in style){
			try{
				if(s == "opacity"){
					dojo.html.setOpacity(n, style[s]);
				}else{
						n.style[s] = style[s];
				}
			}catch(e){ dojo.debug(e); }
		}
	}

	var propLine = function(properties){
		this._properties = properties;
		this.diffs = new Array(properties.length);
		dojo.lang.forEach(properties, function(prop, i){
			// calculate the end - start to optimize a bit
			if(dojo.lang.isFunction(prop.start)){
				prop.start = prop.start(prop, i);
			}
			if(dojo.lang.isFunction(prop.end)){
				prop.end = prop.end(prop, i);
			}
			if(dojo.lang.isArray(prop.start)){
				// don't loop through the arrays
				this.diffs[i] = null;
			}else if(prop.start instanceof dojo.gfx.color.Color){
				// save these so we don't have to call toRgb() every getValue() call
				prop.startRgb = prop.start.toRgb();
				prop.endRgb = prop.end.toRgb();
			}else{
				this.diffs[i] = prop.end - prop.start;
			}
		}, this);

		this.getValue = function(n){
			var ret = {};
			dojo.lang.forEach(this._properties, function(prop, i){
				var value = null;
				if(dojo.lang.isArray(prop.start)){
					// FIXME: what to do here?
				}else if(prop.start instanceof dojo.gfx.color.Color){
					value = (prop.units||"rgb") + "(";
					for(var j = 0 ; j < prop.startRgb.length ; j++){
						value += Math.round(((prop.endRgb[j] - prop.startRgb[j]) * n) + prop.startRgb[j]) + (j < prop.startRgb.length - 1 ? "," : "");
					}
					value += ")";
				}else{
					value = ((this.diffs[i]) * n) + prop.start + (prop.property != "opacity" ? prop.units||"px" : "");
				}
				ret[dojo.html.toCamelCase(prop.property)] = value;
			}, this);
			return ret;
		}
	}
	
	var anim = new dojo.lfx.Animation({
			beforeBegin: function(){ 
				setEmUp(targs); 
				anim.curve = new propLine(targs.propertyMap);
			},
			onAnimate: function(propValues){
				dojo.lang.forEach(targs.nodes, function(node){
					setStyle(node, propValues);
				});
			}
		},
		targs.duration, 
		null,
		targs.easing
	);
	if(handlers){
		for(var x in handlers){
			if(dojo.lang.isFunction(handlers[x])){
				anim.connect(x, anim, handlers[x]);
			}
		}
	}
	
	return anim; // dojo.lfx.Animation
}

dojo.lfx.html._makeFadeable = function(nodes){
	var makeFade = function(node){
		if(dojo.render.html.ie){
			// only set the zoom if the "tickle" value would be the same as the
			// default
			if( (node.style.zoom.length == 0) &&
				(dojo.html.getStyle(node, "zoom") == "normal") ){
				// make sure the node "hasLayout"
				// NOTE: this has been tested with larger and smaller user-set text
				// sizes and works fine
				node.style.zoom = "1";
				// node.style.zoom = "normal";
			}
			// don't set the width to auto if it didn't already cascade that way.
			// We don't want to f anyones designs
			if(	(node.style.width.length == 0) &&
				(dojo.html.getStyle(node, "width") == "auto") ){
				node.style.width = "auto";
			}
		}
	}
	if(dojo.lang.isArrayLike(nodes)){
		dojo.lang.forEach(nodes, makeFade);
	}else{
		makeFade(nodes);
	}
}

dojo.lfx.html.fade = function(/*DOMNode[]*/ nodes,
							  /*Object*/values,
							  /*int?*/ duration,
							  /*Function?*/ easing,
							  /*Function?*/ callback){
	// summary:Returns an animation that will fade the "nodes" from the start to end values passed.
	// nodes: An array of DOMNodes or one DOMNode.
	// values: { start: Decimal?, end: Decimal? }
	// duration: Duration of the animation in milliseconds.
	// easing: An easing function.
	// callback: Function to run at the end of the animation.
	nodes = dojo.lfx.html._byId(nodes);
	var props = { property: "opacity" };
	if(!dj_undef("start", values)){
		props.start = values.start;
	}else{
		props.start = function(){ return dojo.html.getOpacity(nodes[0]); };
	}

	if(!dj_undef("end", values)){
		props.end = values.end;
	}else{
		dojo.raise("dojo.lfx.html.fade needs an end value");
	}

	var anim = dojo.lfx.propertyAnimation(nodes, [ props ], duration, easing);
	anim.connect("beforeBegin", function(){
		dojo.lfx.html._makeFadeable(nodes);
	});
	if(callback){
		anim.connect("onEnd", function(){ callback(nodes, anim); });
	}

	return anim; // dojo.lfx.Animation
}

dojo.lfx.html.fadeIn = function(/*DOMNode[]*/ nodes, /*int?*/ duration, /*Function?*/ easing, /*Function?*/ callback){
	// summary: Returns an animation that will fade "nodes" from its current opacity to fully opaque.
	// nodes: An array of DOMNodes or one DOMNode.
	// duration: Duration of the animation in milliseconds.
	// easing: An easing function.
	// callback: Function to run at the end of the animation.
	return dojo.lfx.html.fade(nodes, { end: 1 }, duration, easing, callback); // dojo.lfx.Animation
}

dojo.lfx.html.fadeOut = function(/*DOMNode[]*/ nodes, /*int?*/ duration, /*Function?*/ easing, /*Function?*/ callback){
	// summary: Returns an animation that will fade "nodes" from its current opacity to fully transparent.
	// nodes: An array of DOMNodes or one DOMNode.
	// duration: Duration of the animation in milliseconds.
	// easing: An easing function.
	// callback: Function to run at the end of the animation.	
	return dojo.lfx.html.fade(nodes, { end: 0 }, duration, easing, callback); // dojo.lfx.Animation
}

dojo.lfx.html.fadeShow = function(/*DOMNode[]*/ nodes, /*int?*/ duration, /*Function?*/ easing, /*Function?*/ callback){
	// summary: Returns an animation that will fade "nodes" from transparent to opaque and shows
	//			"nodes" at the end if it is hidden.
	// nodes: An array of DOMNodes or one DOMNode.
	// duration: Duration of the animation in milliseconds.
	// easing: An easing function.
	// callback: Function to run at the end of the animation.	
	nodes=dojo.lfx.html._byId(nodes);
	dojo.lang.forEach(nodes, function(node){
		dojo.html.setOpacity(node, 0.0);
	});

	var anim = dojo.lfx.html.fadeIn(nodes, duration, easing, callback);
	anim.connect("beforeBegin", function(){ 
		if(dojo.lang.isArrayLike(nodes)){
			dojo.lang.forEach(nodes, dojo.html.show);
		}else{
			dojo.html.show(nodes);
		}
	});

	return anim; // dojo.lfx.Animation
}

dojo.lfx.html.fadeHide = function(/*DOMNode[]*/ nodes, /*int?*/ duration, /*Function?*/ easing, /*Function?*/ callback){
	// summary: Returns an animation that will fade "nodes" from its current opacity to opaque and hides
	//			"nodes" at the end.
	// nodes: An array of DOMNodes or one DOMNode.
	// duration: Duration of the animation in milliseconds.
	// easing: An easing function.
	// callback: Function to run at the end of the animation.
	var anim = dojo.lfx.html.fadeOut(nodes, duration, easing, function(){
		if(dojo.lang.isArrayLike(nodes)){
			dojo.lang.forEach(nodes, dojo.html.hide);
		}else{
			dojo.html.hide(nodes);
		}
		if(callback){ callback(nodes, anim); }
	});
	
	return anim; // dojo.lfx.Animation
}

dojo.lfx.html.wipeIn = function(/*DOMNode[]*/ nodes, /*int?*/ duration, /*Function?*/ easing, /*Function?*/ callback){
	// summary: Returns an animation that will show and wipe in "nodes".
	// nodes: An array of DOMNodes or one DOMNode.
	// duration: Duration of the animation in milliseconds.
	// easing: An easing function.
	// callback: Function to run at the end of the animation.
	nodes = dojo.lfx.html._byId(nodes);
	var anims = [];

	dojo.lang.forEach(nodes, function(node){
		var oprop = {  };	// old properties of node (before we mucked w/them)
		
		// get node height, either it's natural height or it's height specified via style or class attributes
		// (for FF, the node has to be (temporarily) rendered to measure height)
		// TODO: should this offscreen code be part of dojo.html, so that getBorderBox() works on hidden nodes?
		var origTop, origLeft, origPosition;
		with(node.style){
			origTop=top; origLeft=left; origPosition=position;
			top="-9999px"; left="-9999px"; position="absolute";
			display="";
		}
		var nodeHeight = dojo.html.getBorderBox(node).height;
		with(node.style){
			top=origTop; left=origLeft; position=origPosition;
			display="none";
		}

		var anim = dojo.lfx.propertyAnimation(node,
			{	"height": {
					start: 1, // 0 causes IE to display the whole panel
					end: function(){ return nodeHeight; } 
				}
			}, 
			duration, 
			easing);
	
		anim.connect("beforeBegin", function(){
			oprop.overflow = node.style.overflow;
			oprop.height = node.style.height;
			with(node.style){
				overflow = "hidden";
				height = "1px"; // 0 causes IE to display the whole panel
			}
			dojo.html.show(node);
		});
		
		anim.connect("onEnd", function(){ 
			with(node.style){
				overflow = oprop.overflow;
				height = oprop.height;
			}
			if(callback){ callback(node, anim); }
		});
		anims.push(anim);
	});
	
	return dojo.lfx.combine(anims); // dojo.lfx.Combine
}

dojo.lfx.html.wipeOut = function(/*DOMNode[]*/ nodes, /*int?*/ duration, /*Function?*/ easing, /*Function?*/ callback){
	// summary: Returns an animation that will wipe out and hide "nodes".
	// nodes: An array of DOMNodes or one DOMNode.
	// duration: Duration of the animation in milliseconds.
	// easing: An easing function.
	// callback: Function to run at the end of the animation.
	nodes = dojo.lfx.html._byId(nodes);
	var anims = [];
	
	dojo.lang.forEach(nodes, function(node){
		var oprop = {  };	// old properties of node (before we mucked w/them)
		var anim = dojo.lfx.propertyAnimation(node,
			{	"height": {
					start: function(){ return dojo.html.getContentBox(node).height; },
					end: 1 // 0 causes IE to display the whole panel
				} 
			},
			duration,
			easing,
			{
				"beforeBegin": function(){
					oprop.overflow = node.style.overflow;
					oprop.height = node.style.height;
					with(node.style){
						overflow = "hidden";
					}
					dojo.html.show(node);
				},
				
				"onEnd": function(){ 
					dojo.html.hide(node);
					with(node.style){
						overflow = oprop.overflow;
						height = oprop.height;
					}
					if(callback){ callback(node, anim); }
				}
			}
		);
		anims.push(anim);
	});

	return dojo.lfx.combine(anims); // dojo.lfx.Combine
}

dojo.lfx.html.slideTo = function(/*DOMNode*/ nodes,
								 /*Object*/ coords,
								 /*int?*/ duration,
								 /*Function?*/ easing,
								 /*Function?*/ callback){
	// summary: Returns an animation that will slide "nodes" from its current position to
	//			the position defined in "coords".
	// nodes: An array of DOMNodes or one DOMNode.
	// coords: { top: Decimal?, left: Decimal? }
	// duration: Duration of the animation in milliseconds.
	// easing: An easing function.
	// callback: Function to run at the end of the animation.
	nodes = dojo.lfx.html._byId(nodes);
	var anims = [];
	var compute = dojo.html.getComputedStyle;
	
	if(dojo.lang.isArray(coords)){
		/* coords: Array
		   pId: a */
		dojo.deprecated('dojo.lfx.html.slideTo(node, array)', 'use dojo.lfx.html.slideTo(node, {top: value, left: value});', '0.5');
		coords = { top: coords[0], left: coords[1] };
	}
	dojo.lang.forEach(nodes, function(node){
		var top = null;
		var left = null;
		
		var init = (function(){
			var innerNode = node;
			return function(){
				var pos = compute(innerNode, 'position');
				top = (pos == 'absolute' ? node.offsetTop : parseInt(compute(node, 'top')) || 0);
				left = (pos == 'absolute' ? node.offsetLeft : parseInt(compute(node, 'left')) || 0);

				if (!dojo.lang.inArray(['absolute', 'relative'], pos)) {
					var ret = dojo.html.abs(innerNode, true);
					dojo.html.setStyleAttributes(innerNode, "position:absolute;top:"+ret.y+"px;left:"+ret.x+"px;");
					top = ret.y;
					left = ret.x;
				}
			}
		})();
		init();
		
		var anim = dojo.lfx.propertyAnimation(node,
			{	"top": { start: top, end: (coords.top||0) },
				"left": { start: left, end: (coords.left||0)  }
			},
			duration,
			easing,
			{ "beforeBegin": init }
		);

		if(callback){
			anim.connect("onEnd", function(){ callback(nodes, anim); });
		}

		anims.push(anim);
	});
	
	return dojo.lfx.combine(anims); // dojo.lfx.Combine
}

dojo.lfx.html.slideBy = function(/*DOMNode*/ nodes, /*Object*/ coords, /*int?*/ duration, /*Function?*/ easing, /*Function?*/ callback){
	// summary: Returns an animation that will slide "nodes" from its current position
	//			to its current position plus the numbers defined in "coords".
	// nodes: An array of DOMNodes or one DOMNode.
	// coords: { top: Decimal?, left: Decimal? }
	// duration: Duration of the animation in milliseconds.
	// easing: An easing function.
	// callback: Function to run at the end of the animation.
	nodes = dojo.lfx.html._byId(nodes);
	var anims = [];
	var compute = dojo.html.getComputedStyle;

	if(dojo.lang.isArray(coords)){
		/* coords: Array
		   pId: a */
		dojo.deprecated('dojo.lfx.html.slideBy(node, array)', 'use dojo.lfx.html.slideBy(node, {top: value, left: value});', '0.5');
		coords = { top: coords[0], left: coords[1] };
	}

	dojo.lang.forEach(nodes, function(node){
		var top = null;
		var left = null;
		
		var init = (function(){
			var innerNode = node;
			return function(){
				var pos = compute(innerNode, 'position');
				top = (pos == 'absolute' ? node.offsetTop : parseInt(compute(node, 'top')) || 0);
				left = (pos == 'absolute' ? node.offsetLeft : parseInt(compute(node, 'left')) || 0);

				if (!dojo.lang.inArray(['absolute', 'relative'], pos)) {
					var ret = dojo.html.abs(innerNode, true);
					dojo.html.setStyleAttributes(innerNode, "position:absolute;top:"+ret.y+"px;left:"+ret.x+"px;");
					top = ret.y;
					left = ret.x;
				}
			}
		})();
		init();
		
		var anim = dojo.lfx.propertyAnimation(node,
			{
				"top": { start: top, end: top+(coords.top||0) },
				"left": { start: left, end: left+(coords.left||0) }
			},
			duration,
			easing).connect("beforeBegin", init);

		if(callback){
			anim.connect("onEnd", function(){ callback(nodes, anim); });
		}

		anims.push(anim);
	});

	return dojo.lfx.combine(anims); // dojo.lfx.Combine
}

dojo.lfx.html.explode = function(/*DOMNode*/ start,
								 /*DOMNode*/ endNode,
								 /*int?*/ duration,
								 /*Function?*/ easing,
								 /*Function?*/ callback){
	// summary: Returns an animation that will 
	// start:
	// endNode:
	// duration: Duration of the animation in milliseconds.
	// easing: An easing function.
	// callback: Function to run at the end of the animation.
	var h = dojo.html;
	start = dojo.byId(start);
	endNode = dojo.byId(endNode);
	var startCoords = h.toCoordinateObject(start, true);
	var outline = document.createElement("div");
	h.copyStyle(outline, endNode);
	if(endNode.explodeClassName){ outline.className = endNode.explodeClassName; }
	with(outline.style){
		position = "absolute";
		display = "none";
		// border = "1px solid black";
		var backgroundStyle = h.getStyle(start, "background-color");
		backgroundColor = backgroundStyle ? backgroundStyle.toLowerCase() : "transparent";
		backgroundColor = (backgroundColor == "transparent") ? "rgb(221, 221, 221)" : backgroundColor;
	}
	dojo.body().appendChild(outline);

	with(endNode.style){
		visibility = "hidden";
		display = "block";
	}
	var endCoords = h.toCoordinateObject(endNode, true);
	with(endNode.style){
		display = "none";
		visibility = "visible";
	}

	var props = { opacity: { start: 0.5, end: 1.0 } };
	dojo.lang.forEach(["height", "width", "top", "left"], function(type){
		props[type] = { start: startCoords[type], end: endCoords[type] }
	});
	
	var anim = new dojo.lfx.propertyAnimation(outline, 
		props,
		duration,
		easing,
		{
			"beforeBegin": function(){
				h.setDisplay(outline, "block");
			},
			"onEnd": function(){
				h.setDisplay(endNode, "block");
				outline.parentNode.removeChild(outline);
			}
		}
	);

	if(callback){
		anim.connect("onEnd", function(){ callback(endNode, anim); });
	}
	return anim; // dojo.lfx.Animation
}

dojo.lfx.html.implode = function(/*DOMNode*/ startNode,
								 /*DOMNode*/ end,
								 /*int?*/ duration,
								 /*Function?*/ easing,
								 /*Function?*/ callback){
	// summary: Returns an animation that will 
	// startNode:
	// end:
	// duration: Duration of the animation in milliseconds.
	// easing: An easing function.
	// callback: Function to run at the end of the animation.
	var h = dojo.html;
	startNode = dojo.byId(startNode);
	end = dojo.byId(end);
	var startCoords = dojo.html.toCoordinateObject(startNode, true);
	var endCoords = dojo.html.toCoordinateObject(end, true);

	var outline = document.createElement("div");
	dojo.html.copyStyle(outline, startNode);
	if (startNode.explodeClassName) { outline.className = startNode.explodeClassName; }
	dojo.html.setOpacity(outline, 0.3);
	with(outline.style){
		position = "absolute";
		display = "none";
		backgroundColor = h.getStyle(startNode, "background-color").toLowerCase();
	}
	dojo.body().appendChild(outline);

	var props = { opacity: { start: 1.0, end: 0.5 } };
	dojo.lang.forEach(["height", "width", "top", "left"], function(type){
		props[type] = { start: startCoords[type], end: endCoords[type] }
	});
	
	var anim = new dojo.lfx.propertyAnimation(outline,
		props,
		duration,
		easing,
		{
			"beforeBegin": function(){
				dojo.html.hide(startNode);
				dojo.html.show(outline);
			},
			"onEnd": function(){
				outline.parentNode.removeChild(outline);
			}
		}
	);

	if(callback){
		anim.connect("onEnd", function(){ callback(startNode, anim); });
	}
	return anim; // dojo.lfx.Animation
}

dojo.lfx.html.highlight = function(/*DOMNode[]*/ nodes,
								   /*dojo.gfx.color.Color*/ startColor,
								   /*int?*/ duration,
								   /*Function?*/ easing,
								   /*Function?*/ callback){
	// summary: Returns an animation that will set the background color
	//			of "nodes" to startColor and transition it to "nodes"
	//			original color.
	// startColor: Color to transition from.
	// duration: Duration of the animation in milliseconds.
	// easing: An easing function.
	// callback: Function to run at the end of the animation.
	nodes = dojo.lfx.html._byId(nodes);
	var anims = [];

	dojo.lang.forEach(nodes, function(node){
		var color = dojo.html.getBackgroundColor(node);
		var bg = dojo.html.getStyle(node, "background-color").toLowerCase();
		var bgImage = dojo.html.getStyle(node, "background-image");
		var wasTransparent = (bg == "transparent" || bg == "rgba(0, 0, 0, 0)");
		while(color.length > 3) { color.pop(); }

		var rgb = new dojo.gfx.color.Color(startColor);
		var endRgb = new dojo.gfx.color.Color(color);

		var anim = dojo.lfx.propertyAnimation(node, 
			{ "background-color": { start: rgb, end: endRgb } }, 
			duration, 
			easing,
			{
				"beforeBegin": function(){ 
					if(bgImage){
						node.style.backgroundImage = "none";
					}
					node.style.backgroundColor = "rgb(" + rgb.toRgb().join(",") + ")";
				},
				"onEnd": function(){ 
					if(bgImage){
						node.style.backgroundImage = bgImage;
					}
					if(wasTransparent){
						node.style.backgroundColor = "transparent";
					}
					if(callback){
						callback(node, anim);
					}
				}
			}
		);

		anims.push(anim);
	});
	return dojo.lfx.combine(anims); // dojo.lfx.Combine
}

dojo.lfx.html.unhighlight = function(/*DOMNode[]*/ nodes,
									 /*dojo.gfx.color.Color*/ endColor,
									 /*int?*/ duration,
									 /*Function?*/ easing,
									 /*Function?*/ callback){
	// summary: Returns an animation that will transition "nodes" background color
	//			from its current color to "endColor".
	// endColor: Color to transition to.
	// duration: Duration of the animation in milliseconds.
	// easing: An easing function.
	// callback: Function to run at the end of the animation.
	nodes = dojo.lfx.html._byId(nodes);
	var anims = [];

	dojo.lang.forEach(nodes, function(node){
		var color = new dojo.gfx.color.Color(dojo.html.getBackgroundColor(node));
		var rgb = new dojo.gfx.color.Color(endColor);

		var bgImage = dojo.html.getStyle(node, "background-image");
		
		var anim = dojo.lfx.propertyAnimation(node, 
			{ "background-color": { start: color, end: rgb } },
			duration, 
			easing,
			{
				"beforeBegin": function(){ 
					if(bgImage){
						node.style.backgroundImage = "none";
					}
					node.style.backgroundColor = "rgb(" + color.toRgb().join(",") + ")";
				},
				"onEnd": function(){ 
					if(callback){
						callback(node, anim);
					}
				}
			}
		);
		anims.push(anim);
	});
	return dojo.lfx.combine(anims); // dojo.lfx.Combine
}

dojo.lang.mixin(dojo.lfx, dojo.lfx.html);

dojo.kwCompoundRequire({
	browser: ["dojo.lfx.html"],
	dashboard: ["dojo.lfx.html"]
});
dojo.provide("dojo.lfx.*");

dojo.provide("dojo.lfx.toggle");


dojo.lfx.toggle.plain = {
	show: function(node, duration, easing, callback){
		dojo.html.show(node);
		if(dojo.lang.isFunction(callback)){ callback(); }
	},
	
	hide: function(node, duration, easing, callback){
		dojo.html.hide(node);
		if(dojo.lang.isFunction(callback)){ callback(); }
	}
}

dojo.lfx.toggle.fade = {
	show: function(node, duration, easing, callback){
		dojo.lfx.fadeShow(node, duration, easing, callback).play();
	},

	hide: function(node, duration, easing, callback){
		dojo.lfx.fadeHide(node, duration, easing, callback).play();
	}
}

dojo.lfx.toggle.wipe = {
	show: function(node, duration, easing, callback){
		dojo.lfx.wipeIn(node, duration, easing, callback).play();
	},

	hide: function(node, duration, easing, callback){
		dojo.lfx.wipeOut(node, duration, easing, callback).play();
	}
}

dojo.lfx.toggle.explode = {
	show: function(node, duration, easing, callback, explodeSrc){
		dojo.lfx.explode(explodeSrc||{x:0,y:0,width:0,height:0}, node, duration, easing, callback).play();
	},

	hide: function(node, duration, easing, callback, explodeSrc){
		dojo.lfx.implode(node, explodeSrc||{x:0,y:0,width:0,height:0}, duration, easing, callback).play();
	}
}

dojo.provide("dojo.widget.HtmlWidget");








dojo.declare("dojo.widget.HtmlWidget", dojo.widget.DomWidget, {								 
	// summary
	//	Base class for all browser based widgets, or at least "html" widgets.
	//	The meaning of "html" has become unclear; in practice, all widgets derive from this class.
	
	// templateCssPath: String
	//	Path to CSS file for this widget
	templateCssPath: null,
	
	// templatePath: String
	//	Path to template (HTML file) for this widget
	templatePath: null,

	// lang: String
	//	Language to display this widget in (like en-us).
	//	Defaults to brower's specified preferred language (typically the language of the OS)
	lang: "",

	// toggle: String
	//	Controls animation effect for when show() and hide() (or toggle()) are called.
	//	Possible values: "plain", "wipe", "fade", "explode"
	toggle: "plain",

	// toggleDuration: Integer
	//	Number of milliseconds for toggle animation effect to complete
	toggleDuration: 150,

	initialize: function(args, frag){
		// summary: called after the widget is rendered; most subclasses won't override or call this function
	},

	postMixInProperties: function(args, frag){
		if(this.lang === ""){this.lang = null;}
		// now that we know the setting for toggle, get toggle object
		// (default to plain toggler if user specified toggler not present)
		this.toggleObj =
			dojo.lfx.toggle[this.toggle.toLowerCase()] || dojo.lfx.toggle.plain;
	},

	createNodesFromText: function(txt, wrap){
		return dojo.html.createNodesFromText(txt, wrap);
	},

	destroyRendering: function(finalize){
		try{
			if(this.bgIframe){
				this.bgIframe.remove();
				delete this.bgIframe;
			}
			if(!finalize && this.domNode){
				dojo.event.browser.clean(this.domNode);
			}
			dojo.widget.HtmlWidget.superclass.destroyRendering.call(this);
		}catch(e){ /* squelch! */ }
	},

	/////////////////////////////////////////////////////////
	// Displaying/hiding the widget
	/////////////////////////////////////////////////////////
	isShowing: function(){
		// summary
		//	Tests whether widget is set to show-mode or hide-mode (see show() and 
		//	hide() methods)
		//
		//	This function is poorly named.  Even if widget is in show-mode,
		//	if it's inside a container that's hidden
		//	(either a container widget, or just a domnode with display:none),
		//	then it won't be displayed
		return dojo.html.isShowing(this.domNode);	// Boolean
	},

	toggleShowing: function(){
		// summary: show or hide the widget, to switch it's state
		if(this.isShowing()){
			this.hide();
		}else{
			this.show();
		}
	},

	show: function(){
		// summary: show the widget
		if(this.isShowing()){ return; }
		this.animationInProgress=true;
		this.toggleObj.show(this.domNode, this.toggleDuration, null,
			dojo.lang.hitch(this, this.onShow), this.explodeSrc);
	},

	onShow: function(){
		// summary: called after the show() animation has completed
		this.animationInProgress=false;
		this.checkSize();
	},

	hide: function(){
		// summary: hide the widget (ending up with display:none)
		if(!this.isShowing()){ return; }
		this.animationInProgress = true;
		this.toggleObj.hide(this.domNode, this.toggleDuration, null,
			dojo.lang.hitch(this, this.onHide), this.explodeSrc);
	},

	onHide: function(){
		// summary: called after the hide() animation has completed
		this.animationInProgress=false;
	},

	//////////////////////////////////////////////////////////////////////////////
	// Sizing related methods
	//  If the parent changes size then for each child it should call either
	//   - resizeTo(): size the child explicitly
	//   - or checkSize(): notify the child the the parent has changed size
	//////////////////////////////////////////////////////////////////////////////

	_isResized: function(w, h){
		// summary
		//	Test if my size has changed.
		//	If width & height are specified then that's my new size; otherwise,
		//	query outerWidth/outerHeight of my domNode

		// If I'm not being displayed then disregard (show() must
		// check if the size has changed)
		if(!this.isShowing()){ return false; }

		// If my parent has been resized and I have style="height: 100%"
		// or something similar then my size has changed too.
		var wh = dojo.html.getMarginBox(this.domNode);
		var width=w||wh.width;
		var height=h||wh.height;
		if(this.width == width && this.height == height){ return false; }

		this.width=width;
		this.height=height;
		return true;
	},

	checkSize: function(){
		// summary
		//	Called when my parent has changed size, but my parent won't call resizeTo().
		//	This is useful if my size is height:100% or something similar.
		//	Also called whenever I am shown, because the first time I am shown I may need
		//	to do size calculations.
		if(!this._isResized()){ return; }
		this.onResized();
	},

	resizeTo: function(w, h){
		// summary: explicitly set this widget's size (in pixels).
		dojo.html.setMarginBox(this.domNode, { width: w, height: h });
		
		// can't do sizing if widget is hidden because referencing node.offsetWidth/node.offsetHeight returns 0.
		// do sizing on show() instead.
		if(this.isShowing()){
			this.onResized();
		}
	},

	resizeSoon: function(){
		// summary
		//	schedule onResized() to be called soon, after browser has had
		//	a little more time to calculate the sizes
		if(this.isShowing()){
			dojo.lang.setTimeout(this, this.onResized, 0);
		}
	},

	onResized: function(){
		// summary
		//	Called when my size has changed.
		//	Must notify children if their size has (possibly) changed.
		dojo.lang.forEach(this.children, function(child){ if(child.checkSize){child.checkSize();} });
	}
});

dojo.kwCompoundRequire({
	common: ["dojo.xml.Parse", 
			 "dojo.widget.Widget", 
			 "dojo.widget.Parse", 
			 "dojo.widget.Manager"],
	browser: ["dojo.widget.DomWidget",
			  "dojo.widget.HtmlWidget"],
	dashboard: ["dojo.widget.DomWidget",
			  "dojo.widget.HtmlWidget"],
	svg: 	 ["dojo.widget.SvgWidget"],
	rhino: 	 ["dojo.widget.SwtWidget"]
});
dojo.provide("dojo.widget.*");

dojo.provide("dojo.string");


dojo.provide("dojo.io.common");



/******************************************************************************
 *	Notes about dojo.io design:
 *	
 *	The dojo.io.* package has the unenviable task of making a lot of different
 *	types of I/O feel natural, despite a universal lack of good (or even
 *	reasonable!) I/O capability in the host environment. So lets pin this down
 *	a little bit further.
 *
 *	Rhino:
 *		perhaps the best situation anywhere. Access to Java classes allows you
 *		to do anything one might want in terms of I/O, both synchronously and
 *		async. Can open TCP sockets and perform low-latency client/server
 *		interactions. HTTP transport is available through Java HTTP client and
 *		server classes. Wish it were always this easy.
 *
 *	xpcshell:
 *		XPCOM for I/O.
 *
 *	spidermonkey:
 *		S.O.L.
 *
 *	Browsers:
 *		Browsers generally do not provide any useable filesystem access. We are
 *		therefore limited to HTTP for moving information to and from Dojo
 *		instances living in a browser.
 *
 *		XMLHTTP:
 *			Sync or async, allows reading of arbitrary text files (including
 *			JS, which can then be eval()'d), writing requires server
 *			cooperation and is limited to HTTP mechanisms (POST and GET).
 *
 *		<iframe> hacks:
 *			iframe document hacks allow browsers to communicate asynchronously
 *			with a server via HTTP POST and GET operations. With significant
 *			effort and server cooperation, low-latency data transit between
 *			client and server can be acheived via iframe mechanisms (repubsub).
 *
 *		SVG:
 *			Adobe's SVG viewer implements helpful primitives for XML-based
 *			requests, but receipt of arbitrary text data seems unlikely w/o
 *			<![CDATA[]]> sections.
 *
 *
 *	A discussion between Dylan, Mark, Tom, and Alex helped to lay down a lot
 *	the IO API interface. A transcript of it can be found at:
 *		http://dojotoolkit.org/viewcvs/viewcvs.py/documents/irc/irc_io_api_log.txt?rev=307&view=auto
 *	
 *	Also referenced in the design of the API was the DOM 3 L&S spec:
 *		http://www.w3.org/TR/2004/REC-DOM-Level-3-LS-20040407/load-save.html
 ******************************************************************************/

// a map of the available transport options. Transports should add themselves
// by calling add(name)
dojo.io.transports = [];
dojo.io.hdlrFuncNames = [ "load", "error", "timeout" ]; // we're omitting a progress() event for now

dojo.io.Request = function(/*String*/ url, /*String*/ mimetype, /*String*/ transport, /*String or Boolean*/ changeUrl){
// summary:
//		Constructs a Request object that is used by dojo.io.bind().
// description:
//		dojo.io.bind() will create one of these for you if
//		you call dojo.io.bind() with an plain object containing the bind parameters.
//		This method can either take the arguments specified, or an Object containing all of the parameters that you
//		want to use to create the dojo.io.Request (similar to how dojo.io.bind() is called.
//		The named parameters to this constructor represent the minimum set of parameters need
	if((arguments.length == 1)&&(arguments[0].constructor == Object)){
		this.fromKwArgs(arguments[0]);
	}else{
		this.url = url;
		if(mimetype){ this.mimetype = mimetype; }
		if(transport){ this.transport = transport; }
		if(arguments.length >= 4){ this.changeUrl = changeUrl; }
	}
}

dojo.lang.extend(dojo.io.Request, {

	/** The URL to hit */
	url: "",
	
	/** The mime type used to interrpret the response body */
	mimetype: "text/plain",
	
	/** The HTTP method to use */
	method: "GET",
	
	/** An Object containing key-value pairs to be included with the request */
	content: undefined, // Object
	
	/** The transport medium to use */
	transport: undefined, // String
	
	/** If defined the URL of the page is physically changed */
	changeUrl: undefined, // String
	
	/** A form node to use in the request */
	formNode: undefined, // HTMLFormElement
	
	/** Whether the request should be made synchronously */
	sync: false,
	
	bindSuccess: false,

	/** Cache/look for the request in the cache before attempting to request?
	 *  NOTE: this isn't a browser cache, this is internal and would only cache in-page
	 */
	useCache: false,

	/** Prevent the browser from caching this by adding a query string argument to the URL */
	preventCache: false,

	jsonFilter: function(value){
		if(	(this.mimetype == "text/json-comment-filtered")||
			(this.mimetype == "application/json-comment-filtered")
		){
			var cStartIdx = value.indexOf("\/*");
			var cEndIdx = value.lastIndexOf("*\/");
			if((cStartIdx == -1)||(cEndIdx == -1)){
				dojo.debug("your JSON wasn't comment filtered!"); // FIXME: throw exception instead?
				return "";
			}
			return value.substring(cStartIdx+2, cEndIdx);
		}
		dojo.debug("please consider using a mimetype of text/json-comment-filtered to avoid potential security issues with JSON endpoints");
		return value;
	},
	
	// events stuff
	load: function(/*String*/type, /*Object*/data, /*Object*/transportImplementation, /*Object*/kwArgs){
		// summary:
		//		Called on successful completion of a bind.
		//		type: String
		//				A string with value "load"
		//		data: Object
		//				The object representing the result of the bind. The actual structure
		//				of the data object will depend on the mimetype that was given to bind
		//				in the bind arguments.
		//		transportImplementation: Object
		//				The object that implements a particular transport. Structure is depedent
		//				on the transport. For XMLHTTPTransport (dojo.io.BrowserIO), it will be the
		//				XMLHttpRequest object from the browser.
		//		kwArgs: Object
		//				Object that contains the request parameters that were given to the
		//				bind call. Useful for storing and retrieving state from when bind
		//				was called.
	},
	error: function(/*String*/type, /*Object*/error, /*Object*/transportImplementation, /*Object*/kwArgs){
		// summary:
		//		Called when there is an error with a bind.
		//		type: String
		//				A string with value "error"
		//		error: Object
		//				The error object. Should be a dojo.io.Error object, but not guaranteed.
		//		transportImplementation: Object
		//				The object that implements a particular transport. Structure is depedent
		//				on the transport. For XMLHTTPTransport (dojo.io.BrowserIO), it will be the
		//				XMLHttpRequest object from the browser.
		//		kwArgs: Object
		//				Object that contains the request parameters that were given to the
		//				bind call. Useful for storing and retrieving state from when bind
		//				was called.
	},
	timeout: function(/*String*/type, /*Object*/empty, /*Object*/transportImplementation, /*Object*/kwArgs){
		// summary:
		//		Called when there is an error with a bind. Only implemented in certain transports at this time.
		//		type: String
		//				A string with value "timeout"
		//		empty: Object
		//				Should be null. Just a spacer argument so that load, error, timeout and handle have the
		//				same signatures.
		//		transportImplementation: Object
		//				The object that implements a particular transport. Structure is depedent
		//				on the transport. For XMLHTTPTransport (dojo.io.BrowserIO), it will be the
		//				XMLHttpRequest object from the browser. May be null for the timeout case for
		//				some transports.
		//		kwArgs: Object
		//				Object that contains the request parameters that were given to the
		//				bind call. Useful for storing and retrieving state from when bind
		//				was called.
	},
	handle: function(/*String*/type, /*Object*/data, /*Object*/transportImplementation, /*Object*/kwArgs){
		// summary:
		//		The handle method can be defined instead of defining separate load, error and timeout
		//		callbacks.
		//		type: String
		//				A string with the type of callback: "load", "error", or "timeout".
		//		data: Object
		//				See the above callbacks for what this parameter could be.
		//		transportImplementation: Object
		//				The object that implements a particular transport. Structure is depedent
		//				on the transport. For XMLHTTPTransport (dojo.io.BrowserIO), it will be the
		//				XMLHttpRequest object from the browser.
		//		kwArgs: Object
		//				Object that contains the request parameters that were given to the
		//				bind call. Useful for storing and retrieving state from when bind
		//				was called.	
	},

	//FIXME: change IframeIO.js to use timeouts?
	// The number of seconds to wait until firing a timeout callback.
	// If it is zero, that means, don't do a timeout check.
	timeoutSeconds: 0,
	
	// the abort method needs to be filled in by the transport that accepts the
	// bind() request
	abort: function(){ },
	
	// backButton: function(){ },
	// forwardButton: function(){ },

	fromKwArgs: function(/*Object*/ kwArgs){
		// summary:
		//		Creates a dojo.io.Request from a simple object (kwArgs object).

		// normalize args
		if(kwArgs["url"]){ kwArgs.url = kwArgs.url.toString(); }
		if(kwArgs["formNode"]) { kwArgs.formNode = dojo.byId(kwArgs.formNode); }
		if(!kwArgs["method"] && kwArgs["formNode"] && kwArgs["formNode"].method) {
			kwArgs.method = kwArgs["formNode"].method;
		}
		
		// backwards compatibility
		if(!kwArgs["handle"] && kwArgs["handler"]){ kwArgs.handle = kwArgs.handler; }
		if(!kwArgs["load"] && kwArgs["loaded"]){ kwArgs.load = kwArgs.loaded; }
		if(!kwArgs["changeUrl"] && kwArgs["changeURL"]) { kwArgs.changeUrl = kwArgs.changeURL; }

		// encoding fun!
		kwArgs.encoding = dojo.lang.firstValued(kwArgs["encoding"], djConfig["bindEncoding"], "");

		kwArgs.sendTransport = dojo.lang.firstValued(kwArgs["sendTransport"], djConfig["ioSendTransport"], false);

		var isFunction = dojo.lang.isFunction;
		for(var x=0; x<dojo.io.hdlrFuncNames.length; x++){
			var fn = dojo.io.hdlrFuncNames[x];
			if(kwArgs[fn] && isFunction(kwArgs[fn])){ continue; }
			if(kwArgs["handle"] && isFunction(kwArgs["handle"])){
				kwArgs[fn] = kwArgs.handle;
			}
			// handler is aliased above, shouldn't need this check
			/* else if(dojo.lang.isObject(kwArgs.handler)){
				if(isFunction(kwArgs.handler[fn])){
					kwArgs[fn] = kwArgs.handler[fn]||kwArgs.handler["handle"]||function(){};
				}
			}*/
		}
		dojo.lang.mixin(this, kwArgs);
	}

});

dojo.io.Error = function(/*String*/ msg, /*String*/ type, /*Number*/num){
	// summary:
	//		Constructs an object representing a bind error.
	this.message = msg;
	this.type =  type || "unknown"; // must be one of "io", "parse", "unknown"
	this.number = num || 0; // per-substrate error number, not normalized
}

dojo.io.transports.addTransport = function(/*String*/name){
	// summary:
	//		Used to register transports that can support bind calls.
	this.push(name);
	// FIXME: do we need to handle things that aren't direct children of the
	// dojo.io module? (say, dojo.io.foo.fooTransport?)
	this[name] = dojo.io[name];
}

// binding interface, the various implementations register their capabilities
// and the bind() method dispatches
dojo.io.bind = function(/*dojo.io.Request or Object*/request){
	// summary:
	//		Binding interface for IO. Loading different IO transports, like
	//		dojo.io.BrowserIO or dojo.io.IframeIO, will register with bind
	//		to handle particular types of bind calls.
	//		request: Object
	//				Object containing bind arguments. This object is converted to
	//				a dojo.io.Request object, and that request object is the return
	//				value for this method.
	if(!(request instanceof dojo.io.Request)){
		try{
			request = new dojo.io.Request(request);
		}catch(e){ dojo.debug(e); }
	}

	// if the request asks for a particular implementation, use it
	var tsName = "";
	if(request["transport"]){
		tsName = request["transport"];
		if(!this[tsName]){
			dojo.io.sendBindError(request, "No dojo.io.bind() transport with name '"
				+ request["transport"] + "'.");
			return request; //dojo.io.Request
		}
		if(!this[tsName].canHandle(request)){
			dojo.io.sendBindError(request, "dojo.io.bind() transport with name '"
				+ request["transport"] + "' cannot handle this type of request.");
			return request;	//dojo.io.Request
		}
	}else{
		// otherwise we do our best to auto-detect what available transports
		// will handle 
		for(var x=0; x<dojo.io.transports.length; x++){
			var tmp = dojo.io.transports[x];
			if((this[tmp])&&(this[tmp].canHandle(request))){
				tsName = tmp;
				break;
			}
		}
		if(tsName == ""){
			dojo.io.sendBindError(request, "None of the loaded transports for dojo.io.bind()"
				+ " can handle the request.");
			return request; //dojo.io.Request
		}
	}
	this[tsName].bind(request);
	request.bindSuccess = true;
	return request; //dojo.io.Request
}

dojo.io.sendBindError = function(/* Object */request, /* String */message){
	// summary:
	//		Used internally by dojo.io.bind() to return/raise a bind error.

	//Need to be careful since not all hostenvs support setTimeout.
	if((typeof request.error == "function" || typeof request.handle == "function")
		&& (typeof setTimeout == "function" || typeof setTimeout == "object")){
		var errorObject = new dojo.io.Error(message);
		setTimeout(function(){
			request[(typeof request.error == "function") ? "error" : "handle"]("error", errorObject, null, request);
		}, 50);
	}else{
		dojo.raise(message);
	}
}

dojo.io.queueBind = function(/*dojo.io.Request or Object*/request){
	// summary:
	//		queueBind will use dojo.io.bind() but guarantee that only one bind
	//		call is handled at a time.
	// description:
	//		If queueBind is called while a bind call
	//		is in process, it will queue up the other calls to bind and call them
	//		in order as bind calls complete.
	//		request: Object
	//			Same sort of request object as used for dojo.io.bind().
	if(!(request instanceof dojo.io.Request)){
		try{
			request = new dojo.io.Request(request);
		}catch(e){ dojo.debug(e); }
	}

	// make sure we get called if/when we get a response
	var oldLoad = request.load;
	request.load = function(){
		dojo.io._queueBindInFlight = false;
		var ret = oldLoad.apply(this, arguments);
		dojo.io._dispatchNextQueueBind();
		return ret;
	}

	var oldErr = request.error;
	request.error = function(){
		dojo.io._queueBindInFlight = false;
		var ret = oldErr.apply(this, arguments);
		dojo.io._dispatchNextQueueBind();
		return ret;
	}

	dojo.io._bindQueue.push(request);
	dojo.io._dispatchNextQueueBind();
	return request; //dojo.io.Request
}

dojo.io._dispatchNextQueueBind = function(){
	// summary:
	//	Private method used by dojo.io.queueBind().
	if(!dojo.io._queueBindInFlight){
		dojo.io._queueBindInFlight = true;
		if(dojo.io._bindQueue.length > 0){
			dojo.io.bind(dojo.io._bindQueue.shift());
		}else{
			dojo.io._queueBindInFlight = false;
		}
	}
}
dojo.io._bindQueue = [];
dojo.io._queueBindInFlight = false;

dojo.io.argsFromMap = function(/*Object*/map, /*String?*/encoding, /*String?*/last){
	// summary:
	//		Converts name/values pairs in the map object to an URL-encoded string
	//		with format of name1=value1&name2=value2...
	//		map: Object
	//			Object that has the contains the names and values.
	//		encoding: String?
	//			String to specify how to encode the name and value. If the encoding string
	//			contains "utf" (case-insensitive), then encodeURIComponent is used. Otherwise
	//			dojo.string.encodeAscii is used.
	//		last: String?
	//			The last parameter in the list. Helps with final string formatting?
	var enc = /utf/i.test(encoding||"") ? encodeURIComponent : dojo.string.encodeAscii;
	var mapped = [];
	var control = new Object();
	for(var name in map){
		var domap = function(elt){
			var val = enc(name)+"="+enc(elt);
			mapped[(last == name) ? "push" : "unshift"](val);
		}
		if(!control[name]){
			var value = map[name];
			// FIXME: should be isArrayLike?
			if (dojo.lang.isArray(value)){
				dojo.lang.forEach(value, domap);
			}else{
				domap(value);
			}
		}
	}
	return mapped.join("&"); //String
}

dojo.io.setIFrameSrc = function(/*DOMNode*/ iframe, /*String*/ src, /*Boolean*/ replace){
	//summary:
	//		Sets the URL that is loaded in an IFrame. The replace parameter indicates whether
	//		location.replace() should be used when changing the location of the iframe.
	try{
		var r = dojo.render.html;
		// dojo.debug(iframe);
		if(!replace){
			if(r.safari){
				iframe.location = src;
			}else{
				frames[iframe.name].location = src;
			}
		}else{
			// Fun with DOM 0 incompatibilities!
			var idoc;
			if(r.ie){
				idoc = iframe.contentWindow.document;
			}else if(r.safari){
				idoc = iframe.document;
			}else{ //  if(r.moz){
				idoc = iframe.contentWindow;
			}

			//For Safari (at least 2.0.3) and Opera, if the iframe
			//has just been created but it doesn't have content
			//yet, then iframe.document may be null. In that case,
			//use iframe.location and return.
			if(!idoc){
				iframe.location = src;
				return;
			}else{
				idoc.location.replace(src);
			}
		}
	}catch(e){ 
		dojo.debug(e); 
		dojo.debug("setIFrameSrc: "+e); 
	}
}

/*
dojo.io.sampleTranport = new function(){
	this.canHandle = function(kwArgs){
		// canHandle just tells dojo.io.bind() if this is a good transport to
		// use for the particular type of request.
		if(	
			(
				(kwArgs["mimetype"] == "text/plain") ||
				(kwArgs["mimetype"] == "text/html") ||
				(kwArgs["mimetype"] == "text/javascript")
			)&&(
				(kwArgs["method"] == "get") ||
				( (kwArgs["method"] == "post") && (!kwArgs["formNode"]) )
			)
		){
			return true;
		}

		return false;
	}

	this.bind = function(kwArgs){
		var hdlrObj = {};

		// set up a handler object
		for(var x=0; x<dojo.io.hdlrFuncNames.length; x++){
			var fn = dojo.io.hdlrFuncNames[x];
			if(typeof kwArgs.handler == "object"){
				if(typeof kwArgs.handler[fn] == "function"){
					hdlrObj[fn] = kwArgs.handler[fn]||kwArgs.handler["handle"];
				}
			}else if(typeof kwArgs[fn] == "function"){
				hdlrObj[fn] = kwArgs[fn];
			}else{
				hdlrObj[fn] = kwArgs["handle"]||function(){};
			}
		}

		// build a handler function that calls back to the handler obj
		var hdlrFunc = function(evt){
			if(evt.type == "onload"){
				hdlrObj.load("load", evt.data, evt);
			}else if(evt.type == "onerr"){
				var errObj = new dojo.io.Error("sampleTransport Error: "+evt.msg);
				hdlrObj.error("error", errObj);
			}
		}

		// the sample transport would attach the hdlrFunc() when sending the
		// request down the pipe at this point
		var tgtURL = kwArgs.url+"?"+dojo.io.argsFromMap(kwArgs.content);
		// sampleTransport.sendRequest(tgtURL, hdlrFunc);
	}

	dojo.io.transports.addTransport("sampleTranport");
}
*/

dojo.provide("dojo.undo.browser");


try{
	if((!djConfig["preventBackButtonFix"])&&(!dojo.hostenv.post_load_)){
		document.write("<iframe style='border: 0px; width: 1px; height: 1px; position: absolute; bottom: 0px; right: 0px; visibility: visible;' name='djhistory' id='djhistory' src='" + (djConfig["dojoIframeHistoryUrl"] || dojo.hostenv.getBaseScriptUri()+'iframe_history.html') + "'></iframe>");
	}
}catch(e){/* squelch */}

if(dojo.render.html.opera){
	dojo.debug("Opera is not supported with dojo.undo.browser, so back/forward detection will not work.");
}

dojo.undo.browser = {
	initialHref: (!dj_undef("window")) ? window.location.href : "",
	initialHash: (!dj_undef("window")) ? window.location.hash : "",

	moveForward: false,
	historyStack: [],
	forwardStack: [],
	historyIframe: null,
	bookmarkAnchor: null,
	locationTimer: null,

	/**
	 * 
	 */
	setInitialState: function(/*Object*/args){
		//summary: Sets the state object and back callback for the very first page that is loaded.
		//description: It is recommended that you call this method as part of an event listener that is registered via
		//dojo.addOnLoad().
		//args: Object
		//		See the addToHistory() function for the list of valid args properties.
		this.initialState = this._createState(this.initialHref, args, this.initialHash);
	},

	//FIXME: Would like to support arbitrary back/forward jumps. Have to rework iframeLoaded among other things.
	//FIXME: is there a slight race condition in moz using change URL with the timer check and when
	//       the hash gets set? I think I have seen a back/forward call in quick succession, but not consistent.
	addToHistory: function(args){
		//summary: adds a state object (args) to the history list. You must set
		//djConfig.preventBackButtonFix = false to use dojo.undo.browser.

		//args: Object
		//		args can have the following properties:
		//		To support getting back button notifications, the object argument should implement a
		//		function called either "back", "backButton", or "handle". The string "back" will be
		//		passed as the first and only argument to this callback.
		//		- To support getting forward button notifications, the object argument should implement a
		//		function called either "forward", "forwardButton", or "handle". The string "forward" will be
		//		passed as the first and only argument to this callback.
		//		- If you want the browser location string to change, define "changeUrl" on the object. If the
		//		value of "changeUrl" is true, then a unique number will be appended to the URL as a fragment
		//		identifier (http://some.domain.com/path#uniquenumber). If it is any other value that does
		//		not evaluate to false, that value will be used as the fragment identifier. For example,
		//		if changeUrl: 'page1', then the URL will look like: http://some.domain.com/path#page1
	 	//		Full example:
		//		dojo.undo.browser.addToHistory({
		//		  back: function() { alert('back pressed'); },
		//		  forward: function() { alert('forward pressed'); },
		//		  changeUrl: true
		//		});
		//
		//	BROWSER NOTES:
		//  Safari 1.2: 
		//	back button "works" fine, however it's not possible to actually
		//	DETECT that you've moved backwards by inspecting window.location.
		//	Unless there is some other means of locating.
		//	FIXME: perhaps we can poll on history.length?
		//	Safari 2.0.3+ (and probably 1.3.2+):
		//	works fine, except when changeUrl is used. When changeUrl is used,
		//	Safari jumps all the way back to whatever page was shown before
		//	the page that uses dojo.undo.browser support.
		//	IE 5.5 SP2:
		//	back button behavior is macro. It does not move back to the
		//	previous hash value, but to the last full page load. This suggests
		//	that the iframe is the correct way to capture the back button in
		//	these cases.
		//	Don't test this page using local disk for MSIE. MSIE will not create 
		//	a history list for iframe_history.html if served from a file: URL. 
		//	The XML served back from the XHR tests will also not be properly 
		//	created if served from local disk. Serve the test pages from a web 
		//	server to test in that browser.
		//	IE 6.0:
		//	same behavior as IE 5.5 SP2
		//	Firefox 1.0+:
		//	the back button will return us to the previous hash on the same
		//	page, thereby not requiring an iframe hack, although we do then
		//	need to run a timer to detect inter-page movement.

		//If addToHistory is called, then that means we prune the
		//forward stack -- the user went back, then wanted to
		//start a new forward path.
		this.forwardStack = []; 

		var hash = null;
		var url = null;
		if(!this.historyIframe){
			if(djConfig["useXDomain"] && !djConfig["dojoIframeHistoryUrl"]){
				dojo.debug("dojo.undo.browser: When using cross-domain Dojo builds,"
					+ " please save iframe_history.html to your domain and set djConfig.dojoIframeHistoryUrl"
					+ " to the path on your domain to iframe_history.html");
			}
			this.historyIframe = window.frames["djhistory"];
		}
		if(!this.bookmarkAnchor){
			this.bookmarkAnchor = document.createElement("a");
			dojo.body().appendChild(this.bookmarkAnchor);
			this.bookmarkAnchor.style.display = "none";
		}
		if(args["changeUrl"]){
			hash = "#"+ ((args["changeUrl"]!==true) ? args["changeUrl"] : (new Date()).getTime());
			
			//If the current hash matches the new one, just replace the history object with
			//this new one. It doesn't make sense to track different state objects for the same
			//logical URL. This matches the browser behavior of only putting in one history
			//item no matter how many times you click on the same #hash link, at least in Firefox
			//and Safari, and there is no reliable way in those browsers to know if a #hash link
			//has been clicked on multiple times. So making this the standard behavior in all browsers
			//so that dojo.undo.browser's behavior is the same in all browsers.
			if(this.historyStack.length == 0 && this.initialState.urlHash == hash){
				this.initialState = this._createState(url, args, hash);
				return;
			}else if(this.historyStack.length > 0 && this.historyStack[this.historyStack.length - 1].urlHash == hash){
				this.historyStack[this.historyStack.length - 1] = this._createState(url, args, hash);
				return;
			}

			this.changingUrl = true;
			setTimeout("window.location.href = '"+hash+"'; dojo.undo.browser.changingUrl = false;", 1);
			this.bookmarkAnchor.href = hash;
			
			if(dojo.render.html.ie){
				url = this._loadIframeHistory();

				var oldCB = args["back"]||args["backButton"]||args["handle"];

				//The function takes handleName as a parameter, in case the
				//callback we are overriding was "handle". In that case,
				//we will need to pass the handle name to handle.
				var tcb = function(handleName){
					if(window.location.hash != ""){
						setTimeout("window.location.href = '"+hash+"';", 1);
					}
					//Use apply to set "this" to args, and to try to avoid memory leaks.
					oldCB.apply(this, [handleName]);
				}
		
				//Set interceptor function in the right place.
				if(args["back"]){
					args.back = tcb;
				}else if(args["backButton"]){
					args.backButton = tcb;
				}else if(args["handle"]){
					args.handle = tcb;
				}
		
				var oldFW = args["forward"]||args["forwardButton"]||args["handle"];
		
				//The function takes handleName as a parameter, in case the
				//callback we are overriding was "handle". In that case,
				//we will need to pass the handle name to handle.
				var tfw = function(handleName){
					if(window.location.hash != ""){
						window.location.href = hash;
					}
					if(oldFW){ // we might not actually have one
						//Use apply to set "this" to args, and to try to avoid memory leaks.
						oldFW.apply(this, [handleName]);
					}
				}

				//Set interceptor function in the right place.
				if(args["forward"]){
					args.forward = tfw;
				}else if(args["forwardButton"]){
					args.forwardButton = tfw;
				}else if(args["handle"]){
					args.handle = tfw;
				}

			}else if(dojo.render.html.moz){
				// start the timer
				if(!this.locationTimer){
					this.locationTimer = setInterval("dojo.undo.browser.checkLocation();", 200);
				}
			}
		}else{
			url = this._loadIframeHistory();
		}

		this.historyStack.push(this._createState(url, args, hash));
	},

	checkLocation: function(){
		//summary: private method. Do not call this directly.
		if (!this.changingUrl){
			var hsl = this.historyStack.length;

			if((window.location.hash == this.initialHash||window.location.href == this.initialHref)&&(hsl == 1)){
				// FIXME: could this ever be a forward button?
				// we can't clear it because we still need to check for forwards. Ugg.
				// clearInterval(this.locationTimer);
				this.handleBackButton();
				return;
			}
			
			// first check to see if we could have gone forward. We always halt on
			// a no-hash item.
			if(this.forwardStack.length > 0){
				if(this.forwardStack[this.forwardStack.length-1].urlHash == window.location.hash){
					this.handleForwardButton();
					return;
				}
			}
	
			// ok, that didn't work, try someplace back in the history stack
			if((hsl >= 2)&&(this.historyStack[hsl-2])){
				if(this.historyStack[hsl-2].urlHash==window.location.hash){
					this.handleBackButton();
					return;
				}
			}
		}
	},

	iframeLoaded: function(evt, ifrLoc){
		//summary: private method. Do not call this directly.
		if(!dojo.render.html.opera){
			var query = this._getUrlQuery(ifrLoc.href);
			if(query == null){ 
				// alert("iframeLoaded");
				// we hit the end of the history, so we should go back
				if(this.historyStack.length == 1){
					this.handleBackButton();
				}
				return;
			}
			if(this.moveForward){
				// we were expecting it, so it's not either a forward or backward movement
				this.moveForward = false;
				return;
			}
	
			//Check the back stack first, since it is more likely.
			//Note that only one step back or forward is supported.
			if(this.historyStack.length >= 2 && query == this._getUrlQuery(this.historyStack[this.historyStack.length-2].url)){
				this.handleBackButton();
			}
			else if(this.forwardStack.length > 0 && query == this._getUrlQuery(this.forwardStack[this.forwardStack.length-1].url)){
				this.handleForwardButton();
			}
		}
	},

	handleBackButton: function(){
		//summary: private method. Do not call this directly.

		//The "current" page is always at the top of the history stack.
		var current = this.historyStack.pop();
		if(!current){ return; }
		var last = this.historyStack[this.historyStack.length-1];
		if(!last && this.historyStack.length == 0){
			last = this.initialState;
		}
		if (last){
			if(last.kwArgs["back"]){
				last.kwArgs["back"]();
			}else if(last.kwArgs["backButton"]){
				last.kwArgs["backButton"]();
			}else if(last.kwArgs["handle"]){
				last.kwArgs.handle("back");
			}
		}
		this.forwardStack.push(current);
	},

	handleForwardButton: function(){
		//summary: private method. Do not call this directly.

		var last = this.forwardStack.pop();
		if(!last){ return; }
		if(last.kwArgs["forward"]){
			last.kwArgs.forward();
		}else if(last.kwArgs["forwardButton"]){
			last.kwArgs.forwardButton();
		}else if(last.kwArgs["handle"]){
			last.kwArgs.handle("forward");
		}
		this.historyStack.push(last);
	},

	_createState: function(url, args, hash){
		//summary: private method. Do not call this directly.

		return {"url": url, "kwArgs": args, "urlHash": hash};	//Object
	},

	_getUrlQuery: function(url){
		//summary: private method. Do not call this directly.
		var segments = url.split("?");
		if (segments.length < 2){
			return null; //null
		}
		else{
			return segments[1]; //String
		}
	},
	
	_loadIframeHistory: function(){
		//summary: private method. Do not call this directly.
		var url = (djConfig["dojoIframeHistoryUrl"] || dojo.hostenv.getBaseScriptUri()+'iframe_history.html')
			+ "?" + (new Date()).getTime();
		this.moveForward = true;
		dojo.io.setIFrameSrc(this.historyIframe, url, false);	
		return url; //String
	}
}

dojo.provide("dojo.io.BrowserIO");








if(!dj_undef("window")) {

dojo.io.checkChildrenForFile = function(/*DOMNode*/node){
	//summary: Checks any child nodes of node for an input type="file" element.
	var hasFile = false;
	var inputs = node.getElementsByTagName("input");
	dojo.lang.forEach(inputs, function(input){
		if(hasFile){ return; }
		if(input.getAttribute("type")=="file"){
			hasFile = true;
		}
	});
	return hasFile; //boolean
}

dojo.io.formHasFile = function(/*DOMNode*/formNode){
	//summary: Just calls dojo.io.checkChildrenForFile().
	return dojo.io.checkChildrenForFile(formNode); //boolean
}

dojo.io.updateNode = function(/*DOMNode*/node, /*String or Object*/urlOrArgs){
	//summary: Updates a DOMnode with the result of a dojo.io.bind() call.
	//node: DOMNode
	//urlOrArgs: String or Object
	//		Either a String that has an URL, or an object containing dojo.io.bind()
	//		arguments.
	node = dojo.byId(node);
	var args = urlOrArgs;
	if(dojo.lang.isString(urlOrArgs)){
		args = { url: urlOrArgs };
	}
	args.mimetype = "text/html";
	args.load = function(t, d, e){
		while(node.firstChild){
			dojo.dom.destroyNode(node.firstChild);
		}
		node.innerHTML = d;
	};
	dojo.io.bind(args);
}

dojo.io.formFilter = function(/*DOMNode*/node) {
	//summary: Returns true if the node is an input element that is enabled, has
	//a name, and whose type is one of the following values: ["file", "submit", "image", "reset", "button"]
	var type = (node.type||"").toLowerCase();
	return !node.disabled && node.name
		&& !dojo.lang.inArray(["file", "submit", "image", "reset", "button"], type); //boolean
}

// TODO: Move to htmlUtils
dojo.io.encodeForm = function(/*DOMNode*/formNode, /*String?*/encoding, /*Function?*/formFilter){
	//summary: Converts the names and values of form elements into an URL-encoded
	//string (name=value&name=value...).
	//formNode: DOMNode
	//encoding: String?
	//		The encoding to use for the values. Specify a string that starts with
	//		"utf" (for instance, "utf8"), to use encodeURIComponent() as the encoding
	//		function. Otherwise, dojo.string.encodeAscii will be used.
	//formFilter: Function?
	//	A function used to filter out form elements. The element node will be passed
	//	to the formFilter function, and a boolean result is expected (true indicating
	//	indicating that the element should have its name/value included in the output).
	//	If no formFilter is specified, then dojo.io.formFilter() will be used.
	if((!formNode)||(!formNode.tagName)||(!formNode.tagName.toLowerCase() == "form")){
		dojo.raise("Attempted to encode a non-form element.");
	}
	if(!formFilter) { formFilter = dojo.io.formFilter; }
	var enc = /utf/i.test(encoding||"") ? encodeURIComponent : dojo.string.encodeAscii;
	var values = [];

	for(var i = 0; i < formNode.elements.length; i++){
		var elm = formNode.elements[i];
		if(!elm || elm.tagName.toLowerCase() == "fieldset" || !formFilter(elm)) { continue; }
		var name = enc(elm.name);
		var type = elm.type.toLowerCase();

		if(type == "select-multiple"){
			for(var j = 0; j < elm.options.length; j++){
				if(elm.options[j].selected) {
					values.push(name + "=" + enc(elm.options[j].value));
				}
			}
		}else if(dojo.lang.inArray(["radio", "checkbox"], type)){
			if(elm.checked){
				values.push(name + "=" + enc(elm.value));
			}
		}else{
			values.push(name + "=" + enc(elm.value));
		}
	}

	// now collect input type="image", which doesn't show up in the elements array
	var inputs = formNode.getElementsByTagName("input");
	for(var i = 0; i < inputs.length; i++) {
		var input = inputs[i];
		if(input.type.toLowerCase() == "image" && input.form == formNode
			&& formFilter(input)) {
			var name = enc(input.name);
			values.push(name + "=" + enc(input.value));
			values.push(name + ".x=0");
			values.push(name + ".y=0");
		}
	}
	return values.join("&") + "&"; //String
}

dojo.io.FormBind = function(/*DOMNode or Object*/args) {
	//summary: constructor for a dojo.io.FormBind object. See the Dojo Book for
	//some information on usage: http://manual.dojotoolkit.org/WikiHome/DojoDotBook/Book23
	//args: DOMNode or Object
	//		args can either be the DOMNode for a form element, or an object containing
	//		dojo.io.bind() arguments, one of which should be formNode with the value of
	//		a form element DOMNode.
	this.bindArgs = {};

	if(args && args.formNode) {
		this.init(args);
	} else if(args) {
		this.init({formNode: args});
	}
}
dojo.lang.extend(dojo.io.FormBind, {
	form: null,

	bindArgs: null,

	clickedButton: null,

	init: function(/*DOMNode or Object*/args) {
		//summary: Internal function called by the dojo.io.FormBind() constructor
		//do not call this method directly.
		var form = dojo.byId(args.formNode);

		if(!form || !form.tagName || form.tagName.toLowerCase() != "form") {
			throw new Error("FormBind: Couldn't apply, invalid form");
		} else if(this.form == form) {
			return;
		} else if(this.form) {
			throw new Error("FormBind: Already applied to a form");
		}

		dojo.lang.mixin(this.bindArgs, args);
		this.form = form;

		this.connect(form, "onsubmit", "submit");

		for(var i = 0; i < form.elements.length; i++) {
			var node = form.elements[i];
			if(node && node.type && dojo.lang.inArray(["submit", "button"], node.type.toLowerCase())) {
				this.connect(node, "onclick", "click");
			}
		}

		var inputs = form.getElementsByTagName("input");
		for(var i = 0; i < inputs.length; i++) {
			var input = inputs[i];
			if(input.type.toLowerCase() == "image" && input.form == form) {
				this.connect(input, "onclick", "click");
			}
		}
	},

	onSubmit: function(/*DOMNode*/form) {
		//summary: Function used to verify that the form is OK to submit.
		//Override this function if you want specific form validation done.
		return true; //boolean
	},

	submit: function(/*Event*/e) {
		//summary: internal function that is connected as a listener to the
		//form's onsubmit event.
		if(e)
         e.preventDefault();
		if(this.onSubmit(this.form)) {
			dojo.io.bind(dojo.lang.mixin(this.bindArgs, {
				formFilter: dojo.lang.hitch(this, "formFilter")
			}));
		}
	},

	click: function(/*Event*/e) {
		//summary: internal method that is connected as a listener to the
		//form's elements whose click event can submit a form.
		var node = e.currentTarget;
		if(node.disabled) { return; }
		this.clickedButton = node;
	},

	formFilter: function(/*DOMNode*/node) {
		//summary: internal function used to know which form element values to include
		//		in the dojo.io.bind() request.
		var type = (node.type||"").toLowerCase();
		var accept = false;
		if(node.disabled || !node.name) {
			accept = false;
		} else if(dojo.lang.inArray(["submit", "button", "image"], type)) {
			if(!this.clickedButton) { this.clickedButton = node; }
			accept = node == this.clickedButton;
		} else {
			accept = !dojo.lang.inArray(["file", "submit", "reset", "button"], type);
		}
		return accept; //boolean
	},

	// in case you don't have dojo.event.* pulled in
	connect: function(/*Object*/srcObj, /*Function*/srcFcn, /*Function*/targetFcn) {
		//summary: internal function used to connect event listeners to form elements
		//that trigger events. Used in case dojo.event is not loaded.
		if(dojo.evalObjPath("dojo.event.connect")) {
			dojo.event.connect(srcObj, srcFcn, this, targetFcn);
		} else {
			var fcn = dojo.lang.hitch(this, targetFcn);
			srcObj[srcFcn] = function(e) {
				if(!e) { e = window.event; }
				if(!e.currentTarget) { e.currentTarget = e.srcElement; }
				if(!e.preventDefault) { e.preventDefault = function() { window.event.returnValue = false; } }
				fcn(e);
			}
		}
	}
});

dojo.io.XMLHTTPTransport = new function(){
	//summary: The object that implements the dojo.io.bind transport for XMLHttpRequest.
	var _this = this;

	var _cache = {}; // FIXME: make this public? do we even need to?
	this.useCache = false; // if this is true, we'll cache unless kwArgs.useCache = false
	this.preventCache = false; // if this is true, we'll always force GET requests to cache

	// FIXME: Should this even be a function? or do we just hard code it in the next 2 functions?
	function getCacheKey(url, query, method) {
		return url + "|" + query + "|" + method.toLowerCase();
	}

	function addToCache(url, query, method, http) {
		_cache[getCacheKey(url, query, method)] = http;
	}

	function getFromCache(url, query, method) {
		return _cache[getCacheKey(url, query, method)];
	}

	this.clearCache = function() {
		_cache = {};
	}

	// moved successful load stuff here
	function doLoad(kwArgs, http, url, query, useCache) {
		if(	((http.status>=200)&&(http.status<300))|| 	// allow any 2XX response code
			(http.status==304)|| 						// get it out of the cache
			(http.status==1223)|| 						// Internet Explorer mangled the status code
			(location.protocol=="file:" && (http.status==0 || http.status==undefined))||
			(location.protocol=="chrome:" && (http.status==0 || http.status==undefined))
		){
			var ret;
			if(kwArgs.method.toLowerCase() == "head"){
				var headers = http.getAllResponseHeaders();
				ret = {};
				ret.toString = function(){ return headers; }
				var values = headers.split(/[\r\n]+/g);
				for(var i = 0; i < values.length; i++) {
					var pair = values[i].match(/^([^:]+)\s*:\s*(.+)$/i);
					if(pair) {
						ret[pair[1]] = pair[2];
					}
				}
			}else if(kwArgs.mimetype == "text/javascript"){
				try{
					ret = dj_eval(http.responseText);
				}catch(e){
					dojo.debug(e);
					dojo.debug(http.responseText);
					ret = null;
				}
			}else if(kwArgs.mimetype.substr(0, 9) == "text/json" || kwArgs.mimetype.substr(0, 16) == "application/json"){
				try{
					ret = dj_eval("("+kwArgs.jsonFilter(http.responseText)+")");
				}catch(e){
					dojo.debug(e);
					dojo.debug(http.responseText);
					ret = false;
				}
			}else if((kwArgs.mimetype == "application/xml")||
						(kwArgs.mimetype == "text/xml")){
				ret = http.responseXML;
				if(!ret || typeof ret == "string" || !http.getResponseHeader("Content-Type")) {
					ret = dojo.dom.createDocumentFromText(http.responseText);
				}
			}else{
				ret = http.responseText;
			}

			if(useCache){ // only cache successful responses
				addToCache(url, query, kwArgs.method, http);
			}
			kwArgs[(typeof kwArgs.load == "function") ? "load" : "handle"]("load", ret, http, kwArgs);
		}else{
			var errObj = new dojo.io.Error("XMLHttpTransport Error: "+http.status+" "+http.statusText);
			kwArgs[(typeof kwArgs.error == "function") ? "error" : "handle"]("error", errObj, http, kwArgs);
		}
	}

	// set headers (note: Content-Type will get overriden if kwArgs.contentType is set)
	function setHeaders(http, kwArgs){
		if(kwArgs["headers"]) {
			for(var header in kwArgs["headers"]) {
				if(header.toLowerCase() == "content-type" && !kwArgs["contentType"]) {
					kwArgs["contentType"] = kwArgs["headers"][header];
				} else {
					http.setRequestHeader(header, kwArgs["headers"][header]);
				}
			}
		}
	}

	this.inFlight = [];
	this.inFlightTimer = null;

	this.startWatchingInFlight = function(){
		//summary: internal method used to trigger a timer to watch all inflight
		//XMLHttpRequests.
		if(!this.inFlightTimer){
			// setInterval broken in mozilla x86_64 in some circumstances, see
			// https://bugzilla.mozilla.org/show_bug.cgi?id=344439
			// using setTimeout instead
			this.inFlightTimer = setTimeout("dojo.io.XMLHTTPTransport.watchInFlight();", 10);
		}
	}

	this.watchInFlight = function(){
		//summary: internal method that checks each inflight XMLHttpRequest to see
		//if it has completed or if the timeout situation applies.
		var now = null;
		// make sure sync calls stay thread safe, if this callback is called during a sync call
		// and this results in another sync call before the first sync call ends the browser hangs
		if(!dojo.hostenv._blockAsync && !_this._blockAsync){
			for(var x=this.inFlight.length-1; x>=0; x--){
				try{
					var tif = this.inFlight[x];
					if(!tif || tif.http._aborted || !tif.http.readyState){
						this.inFlight.splice(x, 1); continue; 
					}
					if(4==tif.http.readyState){
						// remove it so we can clean refs
						this.inFlight.splice(x, 1);
						doLoad(tif.req, tif.http, tif.url, tif.query, tif.useCache);
					}else if (tif.startTime){
						//See if this is a timeout case.
						if(!now){
							now = (new Date()).getTime();
						}
						if(tif.startTime + (tif.req.timeoutSeconds * 1000) < now){
							//Stop the request.
							if(typeof tif.http.abort == "function"){
								tif.http.abort();
							}
		
							// remove it so we can clean refs
							this.inFlight.splice(x, 1);
							tif.req[(typeof tif.req.timeout == "function") ? "timeout" : "handle"]("timeout", null, tif.http, tif.req);
						}
					}
				}catch(e){
					try{
						var errObj = new dojo.io.Error("XMLHttpTransport.watchInFlight Error: " + e);
						tif.req[(typeof tif.req.error == "function") ? "error" : "handle"]("error", errObj, tif.http, tif.req);
					}catch(e2){
						dojo.debug("XMLHttpTransport error callback failed: " + e2);
					}
				}
			}
		}

		clearTimeout(this.inFlightTimer);
		if(this.inFlight.length == 0){
			this.inFlightTimer = null;
			return;
		}
		this.inFlightTimer = setTimeout("dojo.io.XMLHTTPTransport.watchInFlight();", 10);
	}

	var hasXmlHttp = dojo.hostenv.getXmlhttpObject() ? true : false;
	this.canHandle = function(/*dojo.io.Request*/kwArgs){
		//summary: Tells dojo.io.bind() if this is a good transport to
		//use for the particular type of request. This type of transport cannot
		//handle forms that have an input type="file" element.

		// FIXME: we need to determine when form values need to be
		// multi-part mime encoded and avoid using this transport for those
		// requests.
		var mlc = kwArgs["mimetype"].toLowerCase()||"";
		return hasXmlHttp
			&& (
				(
					dojo.lang.inArray([
						"text/plain", "text/html", "application/xml", 
						"text/xml", "text/javascript"
						], mlc
					)
				) || (
					mlc.substr(0, 9) == "text/json" || mlc.substr(0, 16) == "application/json"
				)
			)
			&& !( kwArgs["formNode"] && dojo.io.formHasFile(kwArgs["formNode"]) ); //boolean
	}

	this.multipartBoundary = "45309FFF-BD65-4d50-99C9-36986896A96F";	// unique guid as a boundary value for multipart posts

	this.bind = function(/*dojo.io.Request*/kwArgs){
		//summary: function that sends the request to the server.

		//This function will attach an abort() function to the kwArgs dojo.io.Request object,
		//so if you need to abort the request, you can call that method on the request object.
		//The following are acceptable properties in kwArgs (in addition to the
		//normal dojo.io.Request object properties).
		//url: String: URL the server URL to use for the request.
		//method: String: the HTTP method to use (GET, POST, etc...).
		//mimetype: Specifies what format the result data should be given to the load/handle callback. Valid values are:
		//		text/javascript, text/json, application/json, application/xml, text/xml. Any other mimetype will give back a text
		//		string.
		//transport: String: specify "XMLHTTPTransport" to force the use of this XMLHttpRequest transport.
		//headers: Object: The object property names and values will be sent as HTTP request header
		//		names and values.
		//sendTransport: boolean: If true, then dojo.transport=xmlhttp will be added to the request.
		//encoding: String: The type of encoding to use when dealing with the content kwArgs property.
		//content: Object: The content object is converted into a name=value&name=value string, by
		//		using dojo.io.argsFromMap(). The encoding kwArgs property is passed to dojo.io.argsFromMap()
		//		for use in encoding the names and values. The resulting string is added to the request.
		//formNode: DOMNode: a form element node. This should not normally be used. Use new dojo.io.FormBind() instead.
		//		If formNode is used, then the names and values of the form elements will be converted
		//		to a name=value&name=value string and added to the request. The encoding kwArgs property is used
		//		to encode the names and values.
		//postContent: String: Raw name=value&name=value string to be included as part of the request.
		//back or backButton: Function: A function to be called if the back button is pressed. If this kwArgs property
		//		is used, then back button support via dojo.undo.browser will be used. See notes for dojo.undo.browser on usage.
		//		You need to set djConfig.preventBackButtonFix = false to enable back button support.
		//changeUrl: boolean or String: Used as part of back button support. See notes for dojo.undo.browser on usage.
		//user: String: The user name. Used in conjuction with password. Passed to XMLHttpRequest.open().
		//password: String: The user's password. Used in conjuction with user. Passed to XMLHttpRequest.open().
		//file: Object or Array of Objects: an object simulating a file to be uploaded. file objects should have the following properties:
		//		name or fileName: the name of the file
		//		contentType: the MIME content type for the file.
		//		content: the actual content of the file.
		//multipart: boolean: indicates whether this should be a multipart mime request. If kwArgs.file exists, then this
		//		property is set to true automatically.
		//sync: boolean: if true, then a synchronous XMLHttpRequest call is done,
		//		if false (the default), then an asynchronous call is used.
		//preventCache: boolean: If true, then a cache busting parameter is added to the request URL.
		//		default value is false.
		//useCache: boolean: If true, then XMLHttpTransport will keep an internal cache of the server
		//		response and use that response if a similar request is done again.
		//		A similar request is one that has the same URL, query string and HTTP method value.
		//		default is false.
		if(!kwArgs["url"]){
			// are we performing a history action?
			if( !kwArgs["formNode"]
				&& (kwArgs["backButton"] || kwArgs["back"] || kwArgs["changeUrl"] || kwArgs["watchForURL"])
				&& (!djConfig.preventBackButtonFix)) {
        dojo.deprecated("Using dojo.io.XMLHTTPTransport.bind() to add to browser history without doing an IO request",
        				"Use dojo.undo.browser.addToHistory() instead.", "0.4");
				dojo.undo.browser.addToHistory(kwArgs);
				return true;
			}
		}

		// build this first for cache purposes
		var url = kwArgs.url;
		var query = "";
		if(kwArgs["formNode"]){
			var ta = kwArgs.formNode.getAttribute("action");
			if((ta)&&(!kwArgs["url"])){ url = ta; }
			var tp = kwArgs.formNode.getAttribute("method");
			if((tp)&&(!kwArgs["method"])){ kwArgs.method = tp; }
			query += dojo.io.encodeForm(kwArgs.formNode, kwArgs.encoding, kwArgs["formFilter"]);
		}

		if(url.indexOf("#") > -1) {
			dojo.debug("Warning: dojo.io.bind: stripping hash values from url:", url);
			url = url.split("#")[0];
		}

		if(kwArgs["file"]){
			// force post for file transfer
			kwArgs.method = "post";
		}

		if(!kwArgs["method"]){
			kwArgs.method = "get";
		}

		// guess the multipart value
		if(kwArgs.method.toLowerCase() == "get"){
			// GET cannot use multipart
			kwArgs.multipart = false;
		}else{
			if(kwArgs["file"]){
				// enforce multipart when sending files
				kwArgs.multipart = true;
			}else if(!kwArgs["multipart"]){
				// default 
				kwArgs.multipart = false;
			}
		}

		if(kwArgs["backButton"] || kwArgs["back"] || kwArgs["changeUrl"]){
			dojo.undo.browser.addToHistory(kwArgs);
		}

		var content = kwArgs["content"] || {};

		if(kwArgs.sendTransport) {
			content["dojo.transport"] = "xmlhttp";
		}

		do { // break-block
			if(kwArgs.postContent){
				query = kwArgs.postContent;
				break;
			}

			if(content) {
				query += dojo.io.argsFromMap(content, kwArgs.encoding);
			}
			
			if(kwArgs.method.toLowerCase() == "get" || !kwArgs.multipart){
				break;
			}

			var	t = [];
			if(query.length){
				var q = query.split("&");
				for(var i = 0; i < q.length; ++i){
					if(q[i].length){
						var p = q[i].split("=");
						t.push(	"--" + this.multipartBoundary,
								"Content-Disposition: form-data; name=\"" + p[0] + "\"", 
								"",
								p[1]);
					}
				}
			}

			if(kwArgs.file){
				if(dojo.lang.isArray(kwArgs.file)){
					for(var i = 0; i < kwArgs.file.length; ++i){
						var o = kwArgs.file[i];
						t.push(	"--" + this.multipartBoundary,
								"Content-Disposition: form-data; name=\"" + o.name + "\"; filename=\"" + ("fileName" in o ? o.fileName : o.name) + "\"",
								"Content-Type: " + ("contentType" in o ? o.contentType : "application/octet-stream"),
								"",
								o.content);
					}
				}else{
					var o = kwArgs.file;
					t.push(	"--" + this.multipartBoundary,
							"Content-Disposition: form-data; name=\"" + o.name + "\"; filename=\"" + ("fileName" in o ? o.fileName : o.name) + "\"",
							"Content-Type: " + ("contentType" in o ? o.contentType : "application/octet-stream"),
							"",
							o.content);
				}
			}

			if(t.length){
				t.push("--"+this.multipartBoundary+"--", "");
				query = t.join("\r\n");
			}
		}while(false);

		// kwArgs.Connection = "close";

		var async = kwArgs["sync"] ? false : true;

		var preventCache = kwArgs["preventCache"] ||
			(this.preventCache == true && kwArgs["preventCache"] != false);
		var useCache = kwArgs["useCache"] == true ||
			(this.useCache == true && kwArgs["useCache"] != false );

		// preventCache is browser-level (add query string junk), useCache
		// is for the local cache. If we say preventCache, then don't attempt
		// to look in the cache, but if useCache is true, we still want to cache
		// the response
		if(!preventCache && useCache){
			var cachedHttp = getFromCache(url, query, kwArgs.method);
			if(cachedHttp){
				doLoad(kwArgs, cachedHttp, url, query, false);
				return;
			}
		}

		// much of this is from getText, but reproduced here because we need
		// more flexibility
		var http = dojo.hostenv.getXmlhttpObject(kwArgs);	
		var received = false;

		// build a handler function that calls back to the handler obj
		if(async){
			var startTime = 
			// FIXME: setting up this callback handler leaks on IE!!!
			this.inFlight.push({
				"req":		kwArgs,
				"http":		http,
				"url":	 	url,
				"query":	query,
				"useCache":	useCache,
				"startTime": kwArgs.timeoutSeconds ? (new Date()).getTime() : 0
			});
			this.startWatchingInFlight();
		}else{
			// block async callbacks until sync is in, needed in khtml, others?
			_this._blockAsync = true;
		}

		if(kwArgs.method.toLowerCase() == "post"){
			// FIXME: need to hack in more flexible Content-Type setting here!
			if (!kwArgs.user) {
				http.open("POST", url, async);
			}else{
        http.open("POST", url, async, kwArgs.user, kwArgs.password);
			}
			setHeaders(http, kwArgs);
			http.setRequestHeader("Content-Type", kwArgs.multipart ? ("multipart/form-data; boundary=" + this.multipartBoundary) : 
				(kwArgs.contentType || "application/x-www-form-urlencoded"));
			try{
				http.send(query);
			}catch(e){
				if(typeof http.abort == "function"){
					http.abort();
				}
				doLoad(kwArgs, {status: 404}, url, query, useCache);
			}
		}else{
			var tmpUrl = url;
			if(query != "") {
				tmpUrl += (tmpUrl.indexOf("?") > -1 ? "&" : "?") + query;
			}
			if(preventCache) {
				tmpUrl += (dojo.string.endsWithAny(tmpUrl, "?", "&")
					? "" : (tmpUrl.indexOf("?") > -1 ? "&" : "?")) + "dojo.preventCache=" + new Date().valueOf();
			}
			if (!kwArgs.user) {
				http.open(kwArgs.method.toUpperCase(), tmpUrl, async);
			}else{
				http.open(kwArgs.method.toUpperCase(), tmpUrl, async, kwArgs.user, kwArgs.password);
			}
			setHeaders(http, kwArgs);
			try {
				http.send(null);
			}catch(e)	{
				if(typeof http.abort == "function"){
					http.abort();
				}
				doLoad(kwArgs, {status: 404}, url, query, useCache);
			}
		}

		if( !async ) {
			doLoad(kwArgs, http, url, query, useCache);
			_this._blockAsync = false;
		}

		kwArgs.abort = function(){
			try{// khtml doesent reset readyState on abort, need this workaround
				http._aborted = true; 
			}catch(e){/*squelsh*/}
			return http.abort();
		}

		return;
	}
	dojo.io.transports.addTransport("XMLHTTPTransport");
}

}

dojo.provide("dojo.io.cookie");

dojo.io.cookie.setCookie = function(/*String*/name, /*String*/value, 
									/*Number?*/days, /*String?*/path, 
									/*String?*/domain, /*boolean?*/secure){
	//summary: sets a cookie.
	var expires = -1;
	if((typeof days == "number")&&(days >= 0)){
		var d = new Date();
		d.setTime(d.getTime()+(days*24*60*60*1000));
		expires = d.toGMTString();
	}
	value = escape(value);
	document.cookie = name + "=" + value + ";"
		+ (expires != -1 ? " expires=" + expires + ";" : "")
		+ (path ? "path=" + path : "")
		+ (domain ? "; domain=" + domain : "")
		+ (secure ? "; secure" : "");
}

dojo.io.cookie.set = dojo.io.cookie.setCookie;

dojo.io.cookie.getCookie = function(/*String*/name){
	//summary: Gets a cookie with the given name.

	// FIXME: Which cookie should we return?
	//        If there are cookies set for different sub domains in the current
	//        scope there could be more than one cookie with the same name.
	//        I think taking the last one in the list takes the one from the
	//        deepest subdomain, which is what we're doing here.
	var idx = document.cookie.lastIndexOf(name+'=');
	if(idx == -1) { return null; }
	var value = document.cookie.substring(idx+name.length+1);
	var end = value.indexOf(';');
	if(end == -1) { end = value.length; }
	value = value.substring(0, end);
	value = unescape(value);
	return value; //String
}

dojo.io.cookie.get = dojo.io.cookie.getCookie;

dojo.io.cookie.deleteCookie = function(/*String*/name){
	//summary: Deletes a cookie with the given name.
	dojo.io.cookie.setCookie(name, "-", 0);
}

dojo.io.cookie.setObjectCookie = function(	/*String*/name, /*Object*/obj, 
											/*Number?*/days, /*String?*/path, 
											/*String?*/domain, /*boolean?*/secure, 
											/*boolean?*/clearCurrent){
	//summary: Takes an object, serializes it to a cookie value, and either
	//sets a cookie with the serialized value.
	//description: If clearCurrent is true, then any current cookie value
	//for this object will be replaced with the the new serialized object value.
	//If clearCurrent is false, then the existing cookie value will be modified
	//with any changes from the new object value.
	//Objects must be simple name/value pairs where the value is either a string
	//or a number. Any other value will be ignored.
	if(arguments.length == 5){ // for backwards compat
		clearCurrent = domain;
		domain = null;
		secure = null;
	}
	var pairs = [], cookie, value = "";
	if(!clearCurrent){
		cookie = dojo.io.cookie.getObjectCookie(name);
	}
	if(days >= 0){
		if(!cookie){ cookie = {}; }
		for(var prop in obj){
			if(obj[prop] == null){
				delete cookie[prop];
			}else if((typeof obj[prop] == "string")||(typeof obj[prop] == "number")){
				cookie[prop] = obj[prop];
			}
		}
		prop = null;
		for(var prop in cookie){
			pairs.push(escape(prop) + "=" + escape(cookie[prop]));
		}
		value = pairs.join("&");
	}
	dojo.io.cookie.setCookie(name, value, days, path, domain, secure);
}

dojo.io.cookie.getObjectCookie = function(/*String*/name){
	//summary: Gets an object value for the given cookie name. The complement of
	//dojo.io.cookie.setObjectCookie().
	var values = null, cookie = dojo.io.cookie.getCookie(name);
	if(cookie){
		values = {};
		var pairs = cookie.split("&");
		for(var i = 0; i < pairs.length; i++){
			var pair = pairs[i].split("=");
			var value = pair[1];
			if( isNaN(value) ){ value = unescape(pair[1]); }
			values[ unescape(pair[0]) ] = value;
		}
	}
	return values;
}

dojo.io.cookie.isSupported = function(){
	//summary: Tests the browser to see if cookies are enabled.
	if(typeof navigator.cookieEnabled != "boolean"){
		dojo.io.cookie.setCookie("__TestingYourBrowserForCookieSupport__",
			"CookiesAllowed", 90, null);
		var cookieVal = dojo.io.cookie.getCookie("__TestingYourBrowserForCookieSupport__");
		navigator.cookieEnabled = (cookieVal == "CookiesAllowed");
		if(navigator.cookieEnabled){
			// FIXME: should we leave this around?
			this.deleteCookie("__TestingYourBrowserForCookieSupport__");
		}
	}
	return navigator.cookieEnabled; //boolean
}

// need to leave this in for backwards-compat from 0.1 for when it gets pulled in by dojo.io.*
if(!dojo.io.cookies){ dojo.io.cookies = dojo.io.cookie; }

dojo.kwCompoundRequire({
	common: ["dojo.io.common"],
	rhino: ["dojo.io.RhinoIO"],
	browser: ["dojo.io.BrowserIO", "dojo.io.cookie"],
	dashboard: ["dojo.io.BrowserIO", "dojo.io.cookie"]
});
dojo.provide("dojo.io.*");

dojo.provide("dojo.widget.ContentPane");









dojo.widget.defineWidget(
	"dojo.widget.ContentPane",
	dojo.widget.HtmlWidget,
	function(){
		// summary:
		//		A widget that can be used as a standalone widget 
		//		or as a baseclass for other widgets
		//		Handles replacement of document fragment using either external uri or javascript/java 
		//		generated markup or DomNode content, instanciating widgets within content and runs scripts.
		//		Dont confuse it with an iframe, it only needs document fragments.
		//		It's useful as a child of LayoutContainer, SplitContainer, or TabContainer.
		//		But note that those classes can contain any widget as a child.
		// scriptScope: Function
		//		reference holder to the inline scripts container, if scriptSeparation is true
		// bindArgs: String[]
		//		Send in extra args to the dojo.io.bind call
		
		// per widgetImpl variables
		this._styleNodes =  [];
		this._onLoadStack = [];
		this._onUnloadStack = [];
		this._callOnUnload = false;
		this._ioBindObj;
		//	Note:
		//		dont change this value externally
		this.scriptScope; // undefined for now

		// loading option
		//	example:
		//		bindArgs="preventCache:false;" overrides cacheContent
		this.bindArgs = {};

	
	}, {
		isContainer: true,

		// loading options
		// adjustPaths: Boolean
		//		adjust relative paths in markup to fit this page
		adjustPaths: true,

		// href: String
		//		The href of the content that displays now
		//		Set this at construction if you want to load externally,
		//		changing href after creation doesnt have any effect, see setUrl
		href: "",

		// extractContent Boolean: Extract visible content from inside of <body> .... </body>
		extractContent: true,

		// parseContent Boolean: Construct all widgets that is in content
		parseContent:	true,

		// cacheContent Boolean: Cache content retreived externally
		cacheContent:	true,

		// preload: Boolean
		//		Force load of data even if pane is hidden.
		// Note:
		//		In order to delay download you need to initially hide the node it constructs from
		preload: false,

		// refreshOnShow: Boolean
		//		Refresh (re-download) content when pane goes from hidden to shown
		refreshOnShow: false,

		// handler: String||Function
		//		Generate pane content from a java function
		//		The name of the java proxy function
		handler: "",

		// executeScripts: Boolean
		//		Run scripts within content, extractContent has NO effect on this.
		// Note:
		//		if true scripts in content will be evaled after content is innerHTML'ed
		executeScripts: false,

		// scriptSeparation: Boolean
		//		Run scripts in a separate scope, unique for each ContentPane
		scriptSeparation: true,

		// loadingMessage: String
		//		Message that shows while downloading
		loadingMessage: "Loading...",

		// isLoaded: Boolean
		//		Tells loading status
		isLoaded: false,

		postCreate: function(args, frag, parentComp){
			if (this.handler!==""){
				this.setHandler(this.handler);
			}
			if(this.isShowing() || this.preload){
				this.loadContents(); 
			}
		},
	
		show: function(){
			// if refreshOnShow is true, reload the contents every time; otherwise, load only the first time
			if(this.refreshOnShow){
				this.refresh();
			}else{
				this.loadContents();
			}
			dojo.widget.ContentPane.superclass.show.call(this);
		},
	
		refresh: function(){
			// summary:
			//		Force a refresh (re-download) of content, be sure to turn of cache
			this.isLoaded=false;
			this.loadContents();
		},
	
		loadContents: function() {
			// summary:
			//		Download if isLoaded is false, else ignore
			if ( this.isLoaded ){
				return;
			}
			if ( dojo.lang.isFunction(this.handler)) {
				this._runHandler();
			} else if ( this.href != "" ) {
				this._downloadExternalContent(this.href, this.cacheContent && !this.refreshOnShow);
			}
		},
		
		setUrl: function(/*String||dojo.uri.Uri*/ url) {
			// summary:
			//		Reset the (external defined) content of this pane and replace with new url

			//	Note:
			//		It delays the download until widget is shown if preload is false
			this.href = url;
			this.isLoaded = false;
			if ( this.preload || this.isShowing() ){
				this.loadContents();
			}
		},

		abort: function(){
			// summary
			//		Aborts a inflight download of content
			var bind = this._ioBindObj;
			if(!bind || !bind.abort){ return; }
			bind.abort();
			delete this._ioBindObj;
		},
	
		_downloadExternalContent: function(url, useCache) {
			this.abort();
			this._handleDefaults(this.loadingMessage, "onDownloadStart");
			var self = this;
			this._ioBindObj = dojo.io.bind(
				this._cacheSetting({
					url: url,
					mimetype: "text/html",
					handler: function(type, data, xhr){
						delete self._ioBindObj; // makes sure abort doesnt clear cache
						if(type=="load"){
							self.onDownloadEnd.call(self, url, data);
						}else{
							// XHR isnt a normal JS object, IE doesnt have prototype on XHR so we cant extend it or shallowCopy it
							var e = {
								responseText: xhr.responseText,
								status: xhr.status,
								statusText: xhr.statusText,
								responseHeaders: xhr.getAllResponseHeaders(),
								text: "Error loading '" + url + "' (" + xhr.status + " "+  xhr.statusText + ")"
							};
							self._handleDefaults.call(self, e, "onDownloadError");
							self.onLoad();
						}
					}
				}, useCache)
			);
		},
	
		_cacheSetting: function(bindObj, useCache){
			for(var x in this.bindArgs){
				if(dojo.lang.isUndefined(bindObj[x])){
					bindObj[x] = this.bindArgs[x];
				}
			}

			if(dojo.lang.isUndefined(bindObj.useCache)){ bindObj.useCache = useCache; }
			if(dojo.lang.isUndefined(bindObj.preventCache)){ bindObj.preventCache = !useCache; }
			if(dojo.lang.isUndefined(bindObj.mimetype)){ bindObj.mimetype = "text/html"; }
			return bindObj;
		},

		onLoad: function(e){
			// summary:
			//		Event hook, is called after everything is loaded and widgetified 
			this._runStack("_onLoadStack");
			this.isLoaded=true;
		},
	
		onUnLoad: function(e){
			// summary:
			//		Deprecated, use onUnload (lowercased load)
			dojo.deprecated(this.widgetType+".onUnLoad, use .onUnload (lowercased load)", 0.5);
		},

		onUnload: function(e){
			// summary:
			//		Event hook, is called before old content is cleared
			this._runStack("_onUnloadStack");
			delete this.scriptScope;
			// FIXME: remove for 0.5 along with onUnLoad
			if(this.onUnLoad !== dojo.widget.ContentPane.prototype.onUnLoad){
				this.onUnLoad.apply(this, arguments);
			}
		},
	
		_runStack: function(stName){
			var st = this[stName]; var err = "";
			var scope = this.scriptScope || window;
			for(var i = 0;i < st.length; i++){
				try{
					st[i].call(scope);
				}catch(e){ 
					err += "\n"+st[i]+" failed: "+e.description;
				}
			}
			this[stName] = [];
	
			if(err.length){
				var name = (stName== "_onLoadStack") ? "addOnLoad" : "addOnUnLoad";
				this._handleDefaults(name+" failure\n "+err, "onExecError", "debug");
			}
		},
	
		addOnLoad: function(obj, func){
			// summary
			//		Stores function refs and calls them one by one in the order they came in
			//		when load event occurs.
			//	obj: Function||Object?
			//		holder object
			//	func: Function
			//		function that will be called 
			this._pushOnStack(this._onLoadStack, obj, func);
		},
	
		addOnUnload: function(obj, func){
			// summary
			//		Stores function refs and calls them one by one in the order they came in
			//		when unload event occurs.
			//	obj: Function||Object
			//		holder object
			//	func: Function
			//		function that will be called 
			this._pushOnStack(this._onUnloadStack, obj, func);
		},

		addOnUnLoad: function(){
			// summary:
			//		Deprecated use addOnUnload (lower cased load)
			dojo.deprecated(this.widgetType + ".addOnUnLoad, use addOnUnload instead. (lowercased Load)", 0.5);
			this.addOnUnload.apply(this, arguments);
		},
	
		_pushOnStack: function(stack, obj, func){
			if(typeof func == 'undefined') {
				stack.push(obj);
			}else{
				stack.push(function(){ obj[func](); });
			}
		},
	
		destroy: function(){
			// make sure we call onUnload
			this.onUnload();
			dojo.widget.ContentPane.superclass.destroy.call(this);
		},
 
		onExecError: function(/*Object*/e){
			// summary:
			//		called when content script eval error or Java error occurs, preventDefault-able
			//		default is to debug not alert as in 0.3.1
		},
	
		onContentError: function(/*Object*/e){
			// summary: 
			//		called on DOM faults, require fault etc in content, preventDefault-able
			//		default is to display errormessage inside pane
		},
	
		onDownloadError: function(/*Object*/e){
			// summary: 
			//		called when download error occurs, preventDefault-able
			//		default is to display errormessage inside pane
		},
	
		onDownloadStart: function(/*Object*/e){
			// summary:
			//		called before download starts, preventDefault-able
			//		default is to display loadingMessage inside pane
			//		by changing e.text in your event handler you can change loading message
		},
	
		// 
		onDownloadEnd: function(url, data){
			// summary:
			//		called when download is finished
			//
			//	url String: url that downloaded data
			//	data String: the markup that was downloaded
			data = this.splitAndFixPaths(data, url);
			this.setContent(data);
		},
	
		// useful if user wants to prevent default behaviour ie: _setContent("Error...")
		_handleDefaults: function(e, handler, messType){
			if(!handler){ handler = "onContentError"; }

			if(dojo.lang.isString(e)){ e = {text: e}; }

			if(!e.text){ e.text = e.toString(); }

			e.toString = function(){ return this.text; };

			if(typeof e.returnValue != "boolean"){
				e.returnValue = true; 
			}
			if(typeof e.preventDefault != "function"){
				e.preventDefault = function(){ this.returnValue = false; };
			}
			// call our handler
			this[handler](e);
			if(e.returnValue){
				switch(messType){
					case true: // fallthrough, old compat
					case "alert":
						alert(e.toString()); break;
					case "debug":
						dojo.debug(e.toString()); break;
					default:
					// makes sure scripts can clean up after themselves, before we setContent
					if(this._callOnUnload){ this.onUnload(); } 
					// makes sure we dont try to call onUnLoad again on this event,
					// ie onUnLoad before 'Loading...' but not before clearing 'Loading...'
					this._callOnUnload = false;

					// we might end up in a endless recursion here if domNode cant append content
					if(arguments.callee._loopStop){
						dojo.debug(e.toString());
					}else{
						arguments.callee._loopStop = true;
						this._setContent(e.toString());
					}
				}
			}
			arguments.callee._loopStop = false;
		},
	
		// pathfixes, require calls, css stuff and neccesary content clean
		splitAndFixPaths: function(s, url){
			// summary:
			// 		adjusts all relative paths in (hopefully) all cases, images, remote scripts, links etc.
			// 		splits up content in different pieces, scripts, title, style, link and whats left becomes .xml
			//	s String:	The markup in string
			//	url (String||dojo.uri.Uri?) url that pulled in markup

			var titles = [], scripts = [],tmp = [];// init vars
			var match = [], requires = [], attr = [], styles = [];
			var str = '', path = '', fix = '', tagFix = '', tag = '', origPath = '';
	
			if(!url) { url = "./"; } // point to this page if not set

			if(s){ // make sure we dont run regexes on empty content

				/************** <title> ***********/
				// khtml is picky about dom faults, you can't attach a <style> or <title> node as child of body
				// must go into head, so we need to cut out those tags
				var regex = /<title[^>]*>([\s\S]*?)<\/title>/i;
				while(match = regex.exec(s)){
					titles.push(match[1]);
					s = s.substring(0, match.index) + s.substr(match.index + match[0].length);
				};
		
				/************** adjust paths *****************/
				if(this.adjustPaths){
					// attributepaths one tag can have multiple paths example:
					// <input src="..." style="url(..)"/> or <a style="url(..)" href="..">
					// strip out the tag and run fix on that.
					// this guarantees that we won't run replace on another tag's attribute + it was easier do
					var regexFindTag = /<[a-z][a-z0-9]*[^>]*\s(?:(?:src|href|style)=[^>])+[^>]*>/i;
					var regexFindAttr = /\s(src|href|style)=(['"]?)([\w()\[\]\/.,\\'"-:;#=&?\s@]+?)\2/i;
					// these are the supported protocols, all other is considered relative
					var regexProtocols = /^(?:[#]|(?:(?:https?|ftps?|file|javascript|mailto|news):))/;
		
					while(tag = regexFindTag.exec(s)){
						str += s.substring(0, tag.index);
						s = s.substring((tag.index + tag[0].length), s.length);
						tag = tag[0];
			
						// loop through attributes
						tagFix = '';
						while(attr = regexFindAttr.exec(tag)){
							path = ""; origPath = attr[3];
							switch(attr[1].toLowerCase()){
								case "src":// falltrough
								case "href":
									if(regexProtocols.exec(origPath)){
										path = origPath;
									} else {
										path = (new dojo.uri.Uri(url, origPath).toString());
									}
									break;
								case "style":// style
									path = dojo.html.fixPathsInCssText(origPath, url);
									break;
								default:
									path = origPath;
							}
							fix = " " + attr[1] + "=" + attr[2] + path + attr[2];
							// slices up tag before next attribute check
							tagFix += tag.substring(0, attr.index) + fix;
							tag = tag.substring((attr.index + attr[0].length), tag.length);
						}
						str += tagFix + tag; //dojo.debug(tagFix + tag);
					}
					s = str+s;
				}

				/****************  cut out all <style> and <link rel="stylesheet" href=".."> **************/
				regex = /(?:<(style)[^>]*>([\s\S]*?)<\/style>|<link ([^>]*rel=['"]?stylesheet['"]?[^>]*)>)/i;
				while(match = regex.exec(s)){
					if(match[1] && match[1].toLowerCase() == "style"){
						styles.push(dojo.html.fixPathsInCssText(match[2],url));
					}else if(attr = match[3].match(/href=(['"]?)([^'">]*)\1/i)){
						styles.push({path: attr[2]});
					}
					s = s.substring(0, match.index) + s.substr(match.index + match[0].length);
				};

				/***************** cut out all <script> tags, push them into scripts array ***************/
				var regex = /<script([^>]*)>([\s\S]*?)<\/script>/i;
				var regexSrc = /src=(['"]?)([^"']*)\1/i;
				var regexDojoJs = /.*(\bdojo\b\.js(?:\.uncompressed\.js)?)$/;
				var regexInvalid = /(?:var )?\bdjConfig\b(?:[\s]*=[\s]*\{[^}]+\}|\.[\w]*[\s]*=[\s]*[^;\n]*)?;?|dojo\.hostenv\.writeIncludes\(\s*\);?/g;
				var regexRequires = /dojo\.(?:(?:require(?:After)?(?:If)?)|(?:widget\.(?:manager\.)?registerWidgetPackage)|(?:(?:hostenv\.)?setModulePrefix|registerModulePath)|defineNamespace)\((['"]).*?\1\)\s*;?/;

				while(match = regex.exec(s)){
					if(this.executeScripts && match[1]){
						if(attr = regexSrc.exec(match[1])){
							// remove a dojo.js or dojo.js.uncompressed.js from remoteScripts
							// we declare all files named dojo.js as bad, regardless of path
							if(regexDojoJs.exec(attr[2])){
								dojo.debug("Security note! inhibit:"+attr[2]+" from  being loaded again.");
							}else{
								scripts.push({path: attr[2]});
							}
						}
					}
					if(match[2]){
						// remove all invalid variables etc like djConfig and dojo.hostenv.writeIncludes()
						var sc = match[2].replace(regexInvalid, "");
						if(!sc){ continue; }
		
						// cut out all dojo.require (...) calls, if we have execute 
						// scripts false widgets dont get there require calls
						// takes out possible widgetpackage registration as well
						while(tmp = regexRequires.exec(sc)){
							requires.push(tmp[0]);
							sc = sc.substring(0, tmp.index) + sc.substr(tmp.index + tmp[0].length);
						}
						if(this.executeScripts){
							scripts.push(sc);
						}
					}
					s = s.substr(0, match.index) + s.substr(match.index + match[0].length);
				}

				/********* extract content *********/
				if(this.extractContent){
					match = s.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
					if(match) { s = match[1]; }
				}
	
				/*** replace scriptScope prefix in html Event handler
				* working order: find tags with scriptScope in a tag attribute
				* then replace all standalone scriptScope occurencies with reference to to this widget
				* valid onClick="scriptScope.func()" or onClick="scriptScope['func']();scriptScope.i++"
				* not valid onClick="var.scriptScope.ref" nor onClick="var['scriptScope'].ref" */
				if(this.executeScripts && this.scriptSeparation){
					var regex = /(<[a-zA-Z][a-zA-Z0-9]*\s[^>]*?\S=)((['"])[^>]*scriptScope[^>]*>)/;
					var regexAttr = /([\s'";:\(])scriptScope(.*)/; // we rely on that attribute begins ' or "
					str = ""; 
					while(tag = regex.exec(s)){
						tmp = ((tag[3]=="'") ? '"': "'");fix= "";
						str += s.substring(0, tag.index) + tag[1];
						while(attr = regexAttr.exec(tag[2])){
							tag[2] = tag[2].substring(0, attr.index) + attr[1] + "dojo.widget.byId("+ tmp + this.widgetId + tmp + ").scriptScope" + attr[2];
						}
						str += tag[2];
						s = s.substr(tag.index + tag[0].length);
					}
					s = str + s;
				}
	 		}

			return {"xml": 		s, // Object
				"styles":		styles,
				"titles": 		titles,
				"requires": 	requires,
				"scripts": 		scripts,
				"url": 			url};
		},
	
		
		_setContent: function(cont){
			this.destroyChildren();
	
			// remove old stylenodes from HEAD
			for(var i = 0; i < this._styleNodes.length; i++){
				if(this._styleNodes[i] && this._styleNodes[i].parentNode){
					this._styleNodes[i].parentNode.removeChild(this._styleNodes[i]);
				}
			}
			this._styleNodes = [];

			try{
				var node = this.containerNode || this.domNode;
				while(node.firstChild){
					dojo.html.destroyNode(node.firstChild);
				}
				if(typeof cont != "string"){
					node.appendChild(cont);
				}else{
					node.innerHTML = cont;
				}
			}catch(e){
				e.text = "Couldn't load content:"+e.description;
				this._handleDefaults(e, "onContentError");
			}
		},
	
		setContent: function(data){
			// summary:
			//		Replaces old content with data content, include style classes from old content
			//	data String||DomNode:	new content, be it Document fragment or a DomNode chain
			//			If data contains style tags, link rel=stylesheet it inserts those styles into DOM
			this.abort();
			if(this._callOnUnload){ this.onUnload(); }// this tells a remote script clean up after itself
			this._callOnUnload = true;
	
			if(!data || dojo.html.isNode(data)){
				// if we do a clean using setContent(""); or setContent(#node) bypass all parsing, extractContent etc
				this._setContent(data);
				this.onResized();
				this.onLoad();
			}else{
				// need to run splitAndFixPaths? ie. manually setting content
				// adjustPaths is taken care of inside splitAndFixPaths
				if(typeof data.xml != "string"){ 
					this.href = ""; // so we can refresh safely
					data = this.splitAndFixPaths(data); 
				}

				this._setContent(data.xml);

				// insert styles from content (in same order they came in)
				for(var i = 0; i < data.styles.length; i++){
					if(data.styles[i].path){
						this._styleNodes.push(dojo.html.insertCssFile(data.styles[i].path, dojo.doc(), false, true));
					}else{
						this._styleNodes.push(dojo.html.insertCssText(data.styles[i]));
					}
				}
	
				if(this.parseContent){
					for(var i = 0; i < data.requires.length; i++){
						try{
							eval(data.requires[i]);
						} catch(e){
							e.text = "ContentPane: error in package loading calls, " + (e.description||e);
							this._handleDefaults(e, "onContentError", "debug");
						}
					}
				}
				// need to allow async load, Xdomain uses it
				// is inline function because we cant send args to dojo.addOnLoad
				var _self = this;
				function asyncParse(){
					if(_self.executeScripts){
						_self._executeScripts(data.scripts);
					}
	
					if(_self.parseContent){
						var node = _self.containerNode || _self.domNode;
						var parser = new dojo.xml.Parse();
						var frag = parser.parseElement(node, null, true);
						// createSubComponents not createComponents because frag has already been created
						dojo.widget.getParser().createSubComponents(frag, _self);
					}
	
					_self.onResized();
					_self.onLoad();
				}
				// try as long as possible to make setContent sync call
				if(dojo.hostenv.isXDomain && data.requires.length){
					dojo.addOnLoad(asyncParse);
				}else{
					asyncParse();
				}
			}
		},

		setHandler: function(/*Function*/ handler) {
			// summary:
			//		Generate pane content from given java function
			var fcn = dojo.lang.isFunction(handler) ? handler : window[handler];
			if(!dojo.lang.isFunction(fcn)) {
				// FIXME: needs testing! somebody with java knowledge needs to try this
				this._handleDefaults("Unable to set handler, '" + handler + "' not a function.", "onExecError", true);
				return;
			}
			this.handler = function() {
				return fcn.apply(this, arguments);
			}
		},
	
		_runHandler: function() {
			var ret = true;
			if(dojo.lang.isFunction(this.handler)) {
				this.handler(this, this.domNode);
				ret = false;
			}
			this.onLoad();
			return ret;
		},
	
		_executeScripts: function(scripts) {
			// loop through the scripts in the order they came in
			var self = this;
			var tmp = "", code = "";
			for(var i = 0; i < scripts.length; i++){
				if(scripts[i].path){ // remotescript
					dojo.io.bind(this._cacheSetting({
						"url": 		scripts[i].path,
						"load":     function(type, scriptStr){
								dojo.lang.hitch(self, tmp = ";"+scriptStr);
						},
						"error":    function(type, error){
								error.text = type + " downloading remote script";
								self._handleDefaults.call(self, error, "onExecError", "debug");
						},
						"mimetype": "text/plain",
						"sync":     true
					}, this.cacheContent));
					code += tmp;
				}else{
					code += scripts[i];
				}
			}


			try{
				if(this.scriptSeparation){
					// initialize a new anonymous container for our script, dont make it part of this widgets scope chain
					// instead send in a variable that points to this widget, useful to connect events to onLoad, onUnload etc..
					delete this.scriptScope;
					this.scriptScope = new (new Function('_container_', code+'; return this;'))(self);
				}else{
					// exec in global, lose the _container_ feature
					var djg = dojo.global();
					if(djg.execScript){
						djg.execScript(code);
					}else{
						var djd = dojo.doc();
						var sc = djd.createElement("script");
						sc.appendChild(djd.createTextNode(code));
						(this.containerNode||this.domNode).appendChild(sc);
					}
				}
			}catch(e){
				e.text = "Error running scripts from content:\n"+e.description;
				this._handleDefaults(e, "onExecError", "debug");
			}
		}
	}
);

dojo.provide("dojo.html.iframe");


// thanks burstlib!
dojo.html.iframeContentWindow = function(/* HTMLIFrameElement */iframe_el) {
	//	summary
	//	returns the window reference of the passed iframe
	var win = dojo.html.getDocumentWindow(dojo.html.iframeContentDocument(iframe_el)) ||
		// Moz. TODO: is this available when defaultView isn't?
		dojo.html.iframeContentDocument(iframe_el).__parent__ ||
		(iframe_el.name && document.frames[iframe_el.name]) || null;
	return win;	//	Window
}

dojo.html.iframeContentDocument = function(/* HTMLIFrameElement */iframe_el){
	//	summary
	//	returns a reference to the document object inside iframe_el
	var doc = iframe_el.contentDocument // W3
		|| ((iframe_el.contentWindow)&&(iframe_el.contentWindow.document))	// IE
		|| ((iframe_el.name)&&(document.frames[iframe_el.name])&&(document.frames[iframe_el.name].document)) 
		|| null;
	return doc;	//	HTMLDocument
}

dojo.html.BackgroundIframe = function(/* HTMLElement */node) {
	//	summary
	//	For IE z-index schenanigans
	//	Two possible uses:
	//	1. new dojo.html.BackgroundIframe(node)
	//		Makes a background iframe as a child of node, that fills area (and position) of node
	//	2. new dojo.html.BackgroundIframe()
	//		Attaches frame to dojo.body().  User must call size() to set size.
	if(dojo.render.html.ie55 || dojo.render.html.ie60) {
		var html="<iframe src='javascript:false'"
			+ " style='position: absolute; left: 0px; top: 0px; width: 100%; height: 100%;"
			+ "z-index: -1; filter:Alpha(Opacity=\"0\");' "
			+ ">";
		this.iframe = dojo.doc().createElement(html);
		this.iframe.tabIndex = -1; // Magic to prevent iframe from getting focus on tab keypress - as style didnt work.
		if(node){
			node.appendChild(this.iframe);
			this.domNode=node;
		}else{
			dojo.body().appendChild(this.iframe);
			this.iframe.style.display="none";
		}
	}
}
dojo.lang.extend(dojo.html.BackgroundIframe, {
	iframe: null,
	onResized: function(){
		//	summary
		//	Resize event handler.
		// TODO: this function shouldn't be necessary but setting width=height=100% doesn't work!
		if(this.iframe && this.domNode && this.domNode.parentNode){ // No parentElement if onResized() timeout event occurs on a removed domnode
			var outer = dojo.html.getMarginBox(this.domNode);
			if (outer.width  == 0 || outer.height == 0 ){
				dojo.lang.setTimeout(this, this.onResized, 100);
				return;
			}
			this.iframe.style.width = outer.width + "px";
			this.iframe.style.height = outer.height + "px";
		}
	},

	size: function(/* HTMLElement */node) {
		// summary:
		//		Call this function if the iframe is connected to dojo.body()
		//		rather than the node being shadowed 

		//	(TODO: erase)
		if(!this.iframe){ return; }
		var coords = dojo.html.toCoordinateObject(node, true, dojo.html.boxSizing.BORDER_BOX);
		with(this.iframe.style){
			width = coords.width + "px";
			height = coords.height + "px";
			left = coords.left + "px";
			top = coords.top + "px";
		}
	},

	setZIndex: function(/* HTMLElement */node){
		//	summary
		//	Sets the z-index of the background iframe.
		if(!this.iframe){ return; }
		if(dojo.dom.isNode(node)){
			this.iframe.style.zIndex = dojo.html.getStyle(node, "z-index") - 1;
		}else if(!isNaN(node)){
			this.iframe.style.zIndex = node;
		}
	},

	show: function(){
		//	summary:
		//		show the iframe
		if(this.iframe){ 
			this.iframe.style.display = "block";
		}
	},

	hide: function(){
		//	summary:
		//		hide the iframe
		if(this.iframe){ 
			this.iframe.style.display = "none";
		}
	},

	remove: function(){
		//	summary:
		//		remove the iframe
		if(this.iframe){
			dojo.html.removeNode(this.iframe, true);
			delete this.iframe;
			this.iframe=null;
		}
	}
});

dojo.provide("dojo.widget.Dialog");









dojo.declare(
	"dojo.widget.ModalDialogBase", 
	null,
	{
		// summary
		//	Mixin for widgets implementing a modal dialog

		isContainer: true,

		// focusElement: String
		//	provide a focusable element or element id if you need to
		//	work around FF's tendency to send focus into outer space on hide
		focusElement: "",

		// bgColor: String
		//	color of viewport when displaying a dialog
		bgColor: "black",
		
		// bgOpacity: Number
		//	opacity (0~1) of viewport color (see bgColor attribute)
		bgOpacity: 0.4,

		// followScroll: Boolean
		//	if true, readjusts the dialog (and dialog background) when the user moves the scrollbar
		followScroll: true,

		// closeOnBackgroundClick: Boolean
		//	clicking anywhere on the background will close the dialog
		closeOnBackgroundClick: false,

		trapTabs: function(/*Event*/ e){
			// summary
			//	callback on focus
			if(e.target == this.tabStartOuter) {
				if(this._fromTrap) {
					this.tabStart.focus();
					this._fromTrap = false;
				} else {
					this._fromTrap = true;
					this.tabEnd.focus();
				}
			} else if (e.target == this.tabStart) {
				if(this._fromTrap) {
					this._fromTrap = false;
				} else {
					this._fromTrap = true;
					this.tabEnd.focus();
				}
			} else if(e.target == this.tabEndOuter) {
				if(this._fromTrap) {
					this.tabEnd.focus();
					this._fromTrap = false;
				} else {
					this._fromTrap = true;
					this.tabStart.focus();
				}
			} else if(e.target == this.tabEnd) {
				if(this._fromTrap) {
					this._fromTrap = false;
				} else {
					this._fromTrap = true;
					this.tabStart.focus();
				}
			}
		},

		clearTrap: function(/*Event*/ e) {
			// summary
			//	callback on blur
			var _this = this;
			setTimeout(function() {
				_this._fromTrap = false;
			}, 100);
		},

		postCreate: function() {
			// summary
			//	if the target mixin class already defined postCreate,
			//	dojo.widget.ModalDialogBase.prototype.postCreate.call(this)
			//	should be called in its postCreate()
			with(this.domNode.style){
				position = "absolute";
				zIndex = 999;
				display = "none";
				overflow = "visible";
			}
			var b = dojo.body();
			b.appendChild(this.domNode);

			// make background (which sits behind the dialog but above the normal text)
			this.bg = document.createElement("div");
			this.bg.className = "dialogUnderlay";
			with(this.bg.style){
				position = "absolute";
				left = top = "0px";
				zIndex = 998;
				display = "none";
			}
			b.appendChild(this.bg);
			this.setBackgroundColor(this.bgColor);

			this.bgIframe = new dojo.html.BackgroundIframe();
            if(this.bgIframe.iframe){
				with(this.bgIframe.iframe.style){
					position = "absolute";
					left = top = "0px";
					zIndex = 90;
					display = "none";
				}
			}

			if(this.closeOnBackgroundClick){
				dojo.event.kwConnect({srcObj: this.bg, srcFunc: "onclick",
					adviceObj: this, adviceFunc: "onBackgroundClick", once: true});
			}
		},

		uninitialize: function(){
			this.bgIframe.remove();
			dojo.html.removeNode(this.bg, true);
		},

		setBackgroundColor: function(/*String*/ color) {
			// summary
			//	changes background color specified by "bgColor" parameter
			//	usage:
			//		setBackgroundColor("black");
			//		setBackgroundColor(0xff, 0xff, 0xff);
			if(arguments.length >= 3) {
				color = new dojo.gfx.color.Color(arguments[0], arguments[1], arguments[2]);
			} else {
				color = new dojo.gfx.color.Color(color);
			}
			this.bg.style.backgroundColor = color.toString();
			return this.bgColor = color;	// String: the color
		},

		setBackgroundOpacity: function(/*Number*/ op) {
			// summary
			//	changes background opacity set by "bgOpacity" parameter
			if(arguments.length == 0) { op = this.bgOpacity; }
			dojo.html.setOpacity(this.bg, op);
			try {
				this.bgOpacity = dojo.html.getOpacity(this.bg);
			} catch (e) {
				this.bgOpacity = op;
			}
			return this.bgOpacity;	// Number: the opacity
		},

		_sizeBackground: function() {
			if(this.bgOpacity > 0) {
				
				var viewport = dojo.html.getViewport();
				var h = viewport.height;
				var w = viewport.width;
				with(this.bg.style){
					width = w + "px";
					height = h + "px";
				}
				var scroll_offset = dojo.html.getScroll().offset;
				this.bg.style.top = scroll_offset.y + "px";
				this.bg.style.left = scroll_offset.x + "px";
				// process twice since the scroll bar may have been removed
				// by the previous resizing
				var viewport = dojo.html.getViewport();
				if (viewport.width != w) { this.bg.style.width = viewport.width + "px"; }
				if (viewport.height != h) { this.bg.style.height = viewport.height + "px"; }
			}
			this.bgIframe.size(this.bg);
		},

		_showBackground: function() {
			if(this.bgOpacity > 0) {
				this.bg.style.display = "block";
			}
			if(this.bgIframe.iframe){
				this.bgIframe.iframe.style.display = "block";
			}
		},

		placeModalDialog: function() {
			// summary: position modal dialog in center of screen

			var scroll_offset = dojo.html.getScroll().offset;
			var viewport_size = dojo.html.getViewport();
			
			// find the size of the dialog (dialog needs to be showing to get the size)
			var mb;
			if(this.isShowing()){
				mb = dojo.html.getMarginBox(this.domNode);
			}else{
				dojo.html.setVisibility(this.domNode, false);
				dojo.html.show(this.domNode);
				mb = dojo.html.getMarginBox(this.domNode);
				dojo.html.hide(this.domNode);
				dojo.html.setVisibility(this.domNode, true);
			}
			
			var x = scroll_offset.x + (viewport_size.width - mb.width)/2;
			var y = scroll_offset.y + (viewport_size.height - mb.height)/2;
			with(this.domNode.style){
				left = x + "px";
				top = y + "px";
			}
		},

		_onKey: function(/*Event*/ evt){
			if (evt.key){
				// see if the key is for the dialog
				var node = evt.target;
				while (node != null){
					if (node == this.domNode){
						return; // yes, so just let it go
					}
					node = node.parentNode;
				}
				// this key is for the disabled document window
				if (evt.key != evt.KEY_TAB){ // allow tabbing into the dialog for a11y
					dojo.event.browser.stopEvent(evt);
				// opera won't tab to a div
				}else if (!dojo.render.html.opera){
					try {
						this.tabStart.focus(); 
					} catch(e){}
				}
			}
		},

		showModalDialog: function() {
			// summary
			//	call this function in show() of subclass before calling superclass.show()
			if (this.followScroll && !this._scrollConnected){
				this._scrollConnected = true;
				dojo.event.connect(window, "onscroll", this, "_onScroll");
			}
			dojo.event.connect(document.documentElement, "onkey", this, "_onKey");

			this.placeModalDialog();
			this.setBackgroundOpacity();
			this._sizeBackground();
			this._showBackground();
			this._fromTrap = true; 

			// set timeout to allow the browser to render dialog 
			setTimeout(dojo.lang.hitch(this, function(){
				try{
					this.tabStart.focus();
				}catch(e){}
			}), 50);

		},

		hideModalDialog: function(){
			// summary
			//	call this function in hide() of subclass

			// workaround for FF focus going into outer space
			if (this.focusElement) {
				dojo.byId(this.focusElement).focus(); 
				dojo.byId(this.focusElement).blur();
			}

			this.bg.style.display = "none";
			this.bg.style.width = this.bg.style.height = "1px";
            if(this.bgIframe.iframe){
				this.bgIframe.iframe.style.display = "none";
			}

			dojo.event.disconnect(document.documentElement, "onkey", this, "_onKey");
			if (this._scrollConnected){
				this._scrollConnected = false;
				dojo.event.disconnect(window, "onscroll", this, "_onScroll");
			}
		},

		_onScroll: function(){
			var scroll_offset = dojo.html.getScroll().offset;
			this.bg.style.top = scroll_offset.y + "px";
			this.bg.style.left = scroll_offset.x + "px";
			this.placeModalDialog();
		},

		checkSize: function() {
			if(this.isShowing()){
				this._sizeBackground();
				this.placeModalDialog();
				this.onResized();
			}
		},
		
		onBackgroundClick: function(){
			// summary
			//		Callback on background click.
			//		Clicking anywhere on the background will close the dialog, but only
			//		if the dialog doesn't have an explicit close button, and only if
			//		the dialog doesn't have a blockDuration.
			if(this.lifetime - this.timeRemaining >= this.blockDuration){ return; }
			this.hide();
		}
	});

dojo.widget.defineWidget(
	"dojo.widget.Dialog",
	[dojo.widget.ContentPane, dojo.widget.ModalDialogBase],
	{
		// summary
		//	Pops up a modal dialog window, blocking access to the screen and also graying out the screen
		//	Dialog is extended from ContentPane so it supports all the same parameters (href, etc.)

		templatePath: dojo.uri.moduleUri("dojo.widget", "templates/Dialog.html"),

		// blockDuration: Integer
		//	number of seconds for which the user cannot dismiss the dialog
		blockDuration: 0,
		
		// lifetime: Integer
		//	if set, this controls the number of seconds the dialog will be displayed before automatically disappearing
		lifetime: 0,

		// closeNode: String
		//	Id of button or other dom node to click to close this dialog
		closeNode: "",

		postMixInProperties: function(){
			dojo.widget.Dialog.superclass.postMixInProperties.apply(this, arguments);
			if(this.closeNode){
				this.setCloseControl(this.closeNode);
			}
		},

		postCreate: function(){
			dojo.widget.Dialog.superclass.postCreate.apply(this, arguments);
			dojo.widget.ModalDialogBase.prototype.postCreate.apply(this, arguments);
		},

		show: function() {
			if(this.lifetime){
				this.timeRemaining = this.lifetime;
				if(this.timerNode){
					this.timerNode.innerHTML = Math.ceil(this.timeRemaining/1000);
				}
				if(this.blockDuration && this.closeNode){
					if(this.lifetime > this.blockDuration){
						this.closeNode.style.visibility = "hidden";
					}else{
						this.closeNode.style.display = "none";
					}
				}
				if (this.timer) {
					clearInterval(this.timer);
				}
				this.timer = setInterval(dojo.lang.hitch(this, "_onTick"), 100);
			}

			this.showModalDialog();
			dojo.widget.Dialog.superclass.show.call(this);
		},

		onLoad: function(){
			// when href is specified we need to reposition
			// the dialog after the data is loaded
			this.placeModalDialog();
			dojo.widget.Dialog.superclass.onLoad.call(this);
		},
		
		fillInTemplate: function(){
			// dojo.event.connect(this.domNode, "onclick", this, "killEvent");
		},

		hide: function(){
			this.hideModalDialog();
			dojo.widget.Dialog.superclass.hide.call(this);

			if(this.timer){
				clearInterval(this.timer);
			}
		},
		
		setTimerNode: function(node){
			// summary
			//	specify into which node to write the remaining # of seconds
			// TODO: make this a parameter too
			this.timerNode = node;
		},

		setCloseControl: function(/*String|DomNode*/ node) {
			// summary
			//	Specify which node is the close button for this dialog.
			//	If no close node is specified then clicking anywhere on the screen will close the dialog.
			this.closeNode = dojo.byId(node);
			dojo.event.connect(this.closeNode, "onclick", this, "hide");
		},

		setShowControl: function(/*String|DomNode*/ node) {
			// summary
			//	when specified node is clicked, show this dialog
			// TODO: make this a parameter too
			node = dojo.byId(node);
			dojo.event.connect(node, "onclick", this, "show");
		},

		_onTick: function(){
			// summary
			//	callback every second that the timer clicks
			if(this.timer){
				this.timeRemaining -= 100;
				if(this.lifetime - this.timeRemaining >= this.blockDuration){
					// TODO: this block of code is executing over and over again, rather than just once
					if(this.closeNode){
						this.closeNode.style.visibility = "visible";
					}
				}
				if(!this.timeRemaining){
					clearInterval(this.timer);
					this.hide();
				}else if(this.timerNode){
					this.timerNode.innerHTML = Math.ceil(this.timeRemaining/1000);
				}
			}
		}
	}
);


dojo.provide("dojo.html.selection");




/**
 * type of selection
**/
dojo.html.selectionType = {
	NONE : 0, //selection is empty
	TEXT : 1, //selection contains text (may also contains CONTROL objects)
	CONTROL : 2 //only one element is selected (such as img, table etc)
};

dojo.html.clearSelection = function(){
	// summary: deselect the current selection to make it empty
	var _window = dojo.global();
	var _document = dojo.doc();
	try{
		if(_window["getSelection"]){ 
			if(dojo.render.html.safari){
				// pulled from WebCore/ecma/kjs_window.cpp, line 2536
				_window.getSelection().collapse();
			}else{
				_window.getSelection().removeAllRanges();
			}
		}else if(_document.selection){
			if(_document.selection.empty){
				_document.selection.empty();
			}else if(_document.selection.clear){
				_document.selection.clear();
			}
		}
		return true;
	}catch(e){
		dojo.debug(e);
		return false;
	}
}

dojo.html.disableSelection = function(/*DomNode*/element){
	// summary: disable selection on a node
	element = dojo.byId(element)||dojo.body();
	var h = dojo.render.html;
	
	if(h.mozilla){
		element.style.MozUserSelect = "none";
	}else if(h.safari){
		element.style.KhtmlUserSelect = "none"; 
	}else if(h.ie){
		element.unselectable = "on";
	}else{
		return false;
	}
	return true;
}

dojo.html.enableSelection = function(/*DomNode*/element){
	// summary: enable selection on a node
	element = dojo.byId(element)||dojo.body();
	
	var h = dojo.render.html;
	if(h.mozilla){ 
		element.style.MozUserSelect = ""; 
	}else if(h.safari){
		element.style.KhtmlUserSelect = "";
	}else if(h.ie){
		element.unselectable = "off";
	}else{
		return false;
	}
	return true;
}

dojo.html.selectElement = function(/*DomNode*/element){
	dojo.deprecated("dojo.html.selectElement", "replaced by dojo.html.selection.selectElementChildren", 0.5);
}

dojo.html.selectInputText = function(/*DomNode*/element){
	// summary: select all the text in an input element
	var _window = dojo.global();
	var _document = dojo.doc();
	element = dojo.byId(element);
	if(_document["selection"] && dojo.body()["createTextRange"]){ // IE
		var range = element.createTextRange();
		range.moveStart("character", 0);
		range.moveEnd("character", element.value.length);
		range.select();
	}else if(_window["getSelection"]){
		var selection = _window.getSelection();
		// FIXME: does this work on Safari?
		element.setSelectionRange(0, element.value.length);
	}
	element.focus();
}


dojo.html.isSelectionCollapsed = function(){
	dojo.deprecated("dojo.html.isSelectionCollapsed", "replaced by dojo.html.selection.isCollapsed", 0.5);
	return dojo.html.selection.isCollapsed();
}

dojo.lang.mixin(dojo.html.selection, {
	getType: function() {
		// summary: Get the selection type (like document.select.type in IE).
		if(dojo.doc()["selection"]){ //IE
			return dojo.html.selectionType[dojo.doc().selection.type.toUpperCase()];
		}else{
			var stype = dojo.html.selectionType.TEXT;
	
			// Check if the actual selection is a CONTROL (IMG, TABLE, HR, etc...).
			var oSel;
			try {oSel = dojo.global().getSelection();}
			catch (e) {}
			
			if(oSel && oSel.rangeCount==1){
				var oRange = oSel.getRangeAt(0);
				if (oRange.startContainer == oRange.endContainer && (oRange.endOffset - oRange.startOffset) == 1
					&& oRange.startContainer.nodeType != dojo.dom.TEXT_NODE) {
					stype = dojo.html.selectionType.CONTROL;
				}
			}
			return stype;
		}
	},
	isCollapsed: function() {
		// summary: return whether the current selection is empty
		var _window = dojo.global();
		var _document = dojo.doc();
		if(_document["selection"]){ // IE
			return _document.selection.createRange().text == "";
		}else if(_window["getSelection"]){
			var selection = _window.getSelection();
			if(dojo.lang.isString(selection)){ // Safari
				return selection == "";
			}else{ // Mozilla/W3
				return selection.isCollapsed || selection.toString() == "";
			}
		}
	},
	getSelectedElement: function() {
		// summary: 
		//		Retrieves the selected element (if any), just in the case that a single
		//		element (object like and image or a table) is selected.
		if ( dojo.html.selection.getType() == dojo.html.selectionType.CONTROL ){
			if(dojo.doc()["selection"]){ //IE
				var range = dojo.doc().selection.createRange();
		
				if ( range && range.item ){
					return dojo.doc().selection.createRange().item(0);
				}
			}else{
				var selection = dojo.global().getSelection();
				return selection.anchorNode.childNodes[ selection.anchorOffset ];
			}
		}
	},
	getParentElement: function() {
		// summary: 
		//		Get the parent element of the current selection
		if(dojo.html.selection.getType() == dojo.html.selectionType.CONTROL){
			var p = dojo.html.selection.getSelectedElement();
			if(p){ return p.parentNode; }
		}else{
			if(dojo.doc()["selection"]){ //IE
				return dojo.doc().selection.createRange().parentElement();
			}else{
				var selection = dojo.global().getSelection();
				if(selection){
					var node = selection.anchorNode;
		
					while ( node && node.nodeType != dojo.dom.ELEMENT_NODE ){
						node = node.parentNode;
					}
		
					return node;
				}
			}
		}
	},
	getSelectedText: function(){
		// summary:
		//		Return the text (no html tags) included in the current selection or null if no text is selected
		if(dojo.doc()["selection"]){ //IE
			if(dojo.html.selection.getType() == dojo.html.selectionType.CONTROL){
				return null;
			}
			return dojo.doc().selection.createRange().text;
		}else{
			var selection = dojo.global().getSelection();
			if(selection){
				return selection.toString();
			}
		}
	},
	getSelectedHtml: function(){
		// summary:
		//		Return the html of the current selection or null if unavailable
		if(dojo.doc()["selection"]){ //IE
			if(dojo.html.selection.getType() == dojo.html.selectionType.CONTROL){
				return null;
			}
			return dojo.doc().selection.createRange().htmlText;
		}else{
			var selection = dojo.global().getSelection();
			if(selection && selection.rangeCount){
				var frag = selection.getRangeAt(0).cloneContents();
				var div = document.createElement("div");
				div.appendChild(frag);
				return div.innerHTML;
			}
			return null;
		}
	},
	hasAncestorElement: function(/*String*/tagName /* ... */){
		// summary: 
		// 		Check whether current selection has a  parent element which is of type tagName (or one of the other specified tagName)
		return (dojo.html.selection.getAncestorElement.apply(this, arguments) != null);
	},
	getAncestorElement: function(/*String*/tagName /* ... */){
		// summary:
		//		Return the parent element of the current selection which is of type tagName (or one of the other specified tagName)
		var node = dojo.html.selection.getSelectedElement() || dojo.html.selection.getParentElement();
		while(node /*&& node.tagName.toLowerCase() != 'body'*/){
			if(dojo.html.selection.isTag(node, arguments).length>0){
				return node;
			}
			node = node.parentNode;
		}
		return null;
	},
	//modified from dojo.html.isTag to take an array as second parameter
	isTag: function(/*DomNode*/node, /*Array*/tags) {
		if(node && node.tagName) {
			for (var i=0; i<tags.length; i++){
				if (node.tagName.toLowerCase()==String(tags[i]).toLowerCase()){
					return String(tags[i]).toLowerCase();
				}
			}
		}
		return "";
	},
	selectElement: function(/*DomNode*/element) {
		// summary: clear previous selection and select element (including all its children)
		var _window = dojo.global();
		var _document = dojo.doc();
		element = dojo.byId(element);
		if(_document.selection && dojo.body().createTextRange){ // IE
			try{
				var range = dojo.body().createControlRange();
				range.addElement(element);
				range.select();
			}catch(e){
				dojo.html.selection.selectElementChildren(element);
			}
		}else if(_window["getSelection"]){
			var selection = _window.getSelection();
			// FIXME: does this work on Safari?
			if(selection["removeAllRanges"]){ // Mozilla
				var range = _document.createRange() ;
				range.selectNode(element) ;
				selection.removeAllRanges() ;
				selection.addRange(range) ;
			}
		}
	},
	selectElementChildren: function(/*DomNode*/element){
		// summary: clear previous selection and select the content of the node (excluding the node itself)
		var _window = dojo.global();
		var _document = dojo.doc();
		element = dojo.byId(element);
		if(_document.selection && dojo.body().createTextRange){ // IE
			var range = dojo.body().createTextRange();
			range.moveToElementText(element);
			range.select();
		}else if(_window["getSelection"]){
			var selection = _window.getSelection();
			if(selection["setBaseAndExtent"]){ // Safari
				selection.setBaseAndExtent(element, 0, element, element.innerText.length - 1);
			} else if(selection["selectAllChildren"]){ // Mozilla
				selection.selectAllChildren(element);
			}
		}
	},
	getBookmark: function(){
		// summary: Retrieves a bookmark that can be used with moveToBookmark to return to the same range
		var bookmark;
		var _document = dojo.doc();
		if(_document["selection"]){ // IE
			var range = _document.selection.createRange();
			bookmark = range.getBookmark();
		}else{
			var selection;
			try {selection = dojo.global().getSelection();}
			catch (e) {}
			if(selection){
				var range = selection.getRangeAt(0);
				bookmark = range.cloneRange();
			}else{
				dojo.debug("No idea how to store the current selection for this browser!");
			}
		}
		return bookmark;
	},
	moveToBookmark: function(/*Object*/bookmark){
		// summary: Moves current selection to a bookmark
		// bookmark: this should be a returned object from dojo.html.selection.getBookmark()
		var _document = dojo.doc();
		if(_document["selection"]){ // IE
			var range = _document.selection.createRange();
			 range.moveToBookmark(bookmark);
			 range.select();
		}else{ //Moz/W3C
			var selection;
			try {selection = dojo.global().getSelection();}
			catch (e) {}
			if(selection && selection['removeAllRanges']){
				selection.removeAllRanges() ;
				selection.addRange(bookmark) ;
			}else{
				dojo.debug("No idea how to restore selection for this browser!");
			}
		}
	},
	collapse: function(/*Boolean*/beginning) {
		// summary: clear current selection
		if(dojo.global()['getSelection']){
			var selection = dojo.global().getSelection();
			if(selection.removeAllRanges){ // Mozilla
				if(beginning){
					selection.collapseToStart();
				}else{
					selection.collapseToEnd();
				}
			}else{ // Safari
				// pulled from WebCore/ecma/kjs_window.cpp, line 2536
				 dojo.global().getSelection().collapse(beginning);
			}
		}else if(dojo.doc().selection){ // IE
			var range = dojo.doc().selection.createRange();
			range.collapse(beginning);
			range.select();
		}
	},
	remove: function() {
		// summary: delete current selection
		if(dojo.doc().selection) { //IE
			var selection = dojo.doc().selection;

			if ( selection.type.toUpperCase() != "NONE" ){
				selection.clear();
			}
		
			return selection;
		}else{
			var selection = dojo.global().getSelection();

			for ( var i = 0; i < selection.rangeCount; i++ ){
				selection.getRangeAt(i).deleteContents();
			}
		
			return selection;
		}
	}
});

dojo.provide("dojo.lfx.shadow");




dojo.lfx.shadow = function(/* HTMLElement */node) {
	//	summary
	//	creates a shadow underneath node.
	this.shadowPng = dojo.uri.moduleUri("dojo.html", "images/shadow");
	this.shadowThickness = 8;
	this.shadowOffset = 15;
	this.init(node);
}

dojo.extend(dojo.lfx.shadow, {
	init: function(/* HTMLElement */node){
		//	summary
		//	Initializes the shadow.
		this.node=node;

		// make all the pieces of the shadow, and position/size them as much
		// as possible (but a lot of the coordinates are set in sizeShadow
		this.pieces={};
		var x1 = -1 * this.shadowThickness;
		var y0 = this.shadowOffset;
		var y1 = this.shadowOffset + this.shadowThickness;
		this._makePiece("tl", "top", y0, "left", x1);
		this._makePiece("l", "top", y1, "left", x1, "scale");
		this._makePiece("tr", "top", y0, "left", 0);
		this._makePiece("r", "top", y1, "left", 0, "scale");
		this._makePiece("bl", "top", 0, "left", x1);
		this._makePiece("b", "top", 0, "left", 0, "crop");
		this._makePiece("br", "top", 0, "left", 0);
	},

	_makePiece: function(name, vertAttach, vertCoord, horzAttach, horzCoord, sizing){
		var img;
		var url = this.shadowPng + name.toUpperCase() + ".png";
		if(dojo.render.html.ie55 || dojo.render.html.ie60){
			img=dojo.doc().createElement("div");
			img.style.filter="progid:DXImageTransform.Microsoft.AlphaImageLoader(src='"+url+"'"+
			(sizing?", sizingMethod='"+sizing+"'":"") + ")";
		}else{
			img=dojo.doc().createElement("img");
			img.src=url;
		}
		img.style.position="absolute";
		img.style[vertAttach]=vertCoord+"px";
		img.style[horzAttach]=horzCoord+"px";
		img.style.width=this.shadowThickness+"px";
		img.style.height=this.shadowThickness+"px";
		this.pieces[name]=img;
		this.node.appendChild(img);
	},

	size: function(/* int */width, /* int */height){
		//	summary
		//	Resizes the shadow based on width and height.
		var sideHeight = height - (this.shadowOffset+this.shadowThickness+1);
		if (sideHeight < 0) { sideHeight = 0; }
		if (height < 1) { height = 1; }
		if (width < 1) { width = 1; }
		with(this.pieces){
			l.style.height = sideHeight+"px";
			r.style.height = sideHeight+"px";
			b.style.width = (width-1)+"px";
			bl.style.top = (height-1)+"px";
			b.style.top = (height-1)+"px";
			br.style.top = (height-1)+"px";
			tr.style.left = (width-1)+"px";
			r.style.left = (width-1)+"px";
			br.style.left = (width-1)+"px";
		}
	}
});


dojo.provide("dojo.widget.html.layout");






dojo.widget.html.layout = function(/*DomNode*/ container, /*Object[]*/ children, /*String*/ layoutPriority) {
	/**
	 * summary
	 *		Layout a bunch of child dom nodes within a parent dom node
	 * container:
	 *		parent node
	 * layoutPriority:
	 *		"top-bottom" or "left-right"
	 * children:
	 *		an array like [ {domNode: foo, layoutAlign: "bottom" }, {domNode: bar, layoutAlign: "client"} ]
	 */

	dojo.html.addClass(container, "dojoLayoutContainer");

	// Copy children array and remove elements w/out layout.
	// Also record each child's position in the input array, for sorting purposes.
	children = dojo.lang.filter(children, function(child, idx){
		child.idx = idx;
		return dojo.lang.inArray(["top","bottom","left","right","client","flood"], child.layoutAlign)
	});

	// Order the children according to layoutPriority.
	// Multiple children w/the same layoutPriority will be sorted by their position in the input array.
	if(layoutPriority && layoutPriority!="none"){
		var rank = function(child){
			switch(child.layoutAlign){
				case "flood":
					return 1;
				case "left":
				case "right":
					return (layoutPriority=="left-right") ? 2 : 3;
				case "top":
				case "bottom":
					return (layoutPriority=="left-right") ? 3 : 2;
				default:
					return 4;
			}
		};
		children.sort(function(a,b){
			return (rank(a)-rank(b)) || (a.idx - b.idx);
		});
	}

	// remaining space (blank area where nothing has been written)
	var f={
		top: dojo.html.getPixelValue(container, "padding-top", true),
		left: dojo.html.getPixelValue(container, "padding-left", true)
	};
	dojo.lang.mixin(f, dojo.html.getContentBox(container));

	// set positions/sizes
	dojo.lang.forEach(children, function(child){
		var elm=child.domNode;
		var pos=child.layoutAlign;
		// set elem to upper left corner of unused space; may move it later
		with(elm.style){
			left = f.left+"px";
			top = f.top+"px";
			bottom = "auto";
			right = "auto";
		}
		dojo.html.addClass(elm, "dojoAlign" + dojo.string.capitalize(pos));

		// set size && adjust record of remaining space.
		// note that setting the width of a <div> may affect it's height.
		// TODO: same is true for widgets but need to implement API to support that
		if ( (pos=="top")||(pos=="bottom") ) {
			dojo.html.setMarginBox(elm, { width: f.width });
			var h = dojo.html.getMarginBox(elm).height;
			f.height -= h;
			if(pos=="top"){
				f.top += h;
			}else{
				elm.style.top = f.top + f.height + "px";
			}
			// TODO: for widgets I want to call resizeTo(), but I can't because
			// I only want to set the width, and have the height determined
			// dynamically.  (The thinner you make a div, the more height it consumes.)
			if(child.onResized){
				child.onResized();
			}
		}else if(pos=="left" || pos=="right"){
			var w = dojo.html.getMarginBox(elm).width;

			// TODO: I only want to set the height, not the width, but see bug#941 (FF),
			// and also the resizeTo() function demands both height and width arguments
			if(child.resizeTo){
				child.resizeTo(w, f.height);
			}else{
				dojo.html.setMarginBox(elm, { width: w, height: f.height });
			}	

			f.width -= w;
			if(pos=="left"){
				f.left += w;
			}else{
				elm.style.left = f.left + f.width + "px";
			}
		} else if(pos=="flood" || pos=="client"){
			if(child.resizeTo){
				child.resizeTo(f.width, f.height);
			}else{
				dojo.html.setMarginBox(elm, { width: f.width, height: f.height });
			}
		}
	});
};

// This is essential CSS to make layout work (it isn't "styling" CSS)
// make sure that the position:absolute in dojoAlign* overrides other classes
dojo.html.insertCssText(
	".dojoLayoutContainer{ position: relative; display: block; overflow: hidden; }\n" +
	"body .dojoAlignTop, body .dojoAlignBottom, body .dojoAlignLeft, body .dojoAlignRight { position: absolute; overflow: hidden; }\n" +
	"body .dojoAlignClient { position: absolute }\n" +
	".dojoAlignClient { overflow: auto; }\n"
);




dojo.provide("dojo.dnd.DragAndDrop");

// summary:
//		Core "interfaces" for the participants in all DnD operations.
//		Subclasses implement all of the actions outlined by these APIs, with
//		most of the ones you probably care about being defined in
//		HtmlDragAndDrop.js, which will be automatically included should you
//		.
//
//		In addition to the various actor classes, a global manager will be
//		created/installed at dojo.dnd.dragManager. This manager object is of
//		type dojo.dnd.DragManager and will be replaced by environment-specific
//		managers.
//
// 		The 3 object types involved in any Drag and Drop operation are:
//			* DragSource
//				This is the item that can be selected for dragging. Drag
//				sources can have "types" to help mediate whether or not various
//				DropTargets will accept (or reject them). Most dragging actions
//				are handled by the DragObject which the DragSource generates
//				from its onDragStart method.
//			* DragObject
//				This, along with the manger, does most of the hard work of DnD.
//				Implementations may rely on DragObject instances to implement
//				"shadowing", "movement", or other kinds of DnD variations that
//				affect the visual representation of the drag operation.
//			* DropTarget
//				Represents some section of the screen that can accept drag
//				and drop events. DropTargets keep a list of accepted types
//				which is checked agains the types of the respective DragSource
//				objects that pass over it. DropTargets may implement behaviors
//				that respond to drop events to take application-level actions.

dojo.declare("dojo.dnd.DragSource", null, {
	// String: 
	//		what kind of drag source are we? Used to determine if we can be
	//		dropped on a given DropTarget
	type: "",

	onDragEnd: function(/*dojo.dnd.DragEvent*/evt){
		// summary:
		//		stub handler that is called when dragging finishes.
	},

	onDragStart: function(/*dojo.dnd.DragEvent*/evt){ // dojo.dnd.DragObject
		// summary:
		//		stub handler that is called when dragging starts. Subclasses
		//		should ensure that onDragStart *always* returns a
		//		dojo.dnd.DragObject instance.
	},

	onSelected: function(/*dojo.dnd.DragEvent*/evt){
		// summary:
		//		This function gets called when the DOM element was selected for
		//		dragging by the HtmlDragAndDropManager.
	},

	unregister: function(){
		// summary: remove this drag source from the manager
		dojo.dnd.dragManager.unregisterDragSource(this);
	},

	reregister: function(){
		// summary: add this drag source to the manager
		dojo.dnd.dragManager.registerDragSource(this);
	}
});

dojo.declare("dojo.dnd.DragObject", null, {
	// String: 
	//		what kind of drag object are we? Used to determine if we can be
	//		dropped on a given DropTarget
	type: "",
	
	register: function(){
		// summary: register this DragObject with the manager
		var dm = dojo.dnd.dragManager;
		if(dm["registerDragObject"]){ // side-effect prevention
			dm.registerDragObject(this);
		}
	},

	onDragStart: function(/*dojo.dnd.DragEvent*/evt){
		// summary:
		// 		over-ridden by subclasses. Gets called directly after being
		// 		created by the DragSource default action is to clone self as
		// 		icon
	},

	onDragMove: function(/*dojo.dnd.DragEvent*/evt){
		// summary: 
		//		Implemented by subclasses. Should change the UI for the drag
		//		icon i.e., "it moves itself"
	},

	onDragOver: function(/*dojo.dnd.DragEvent*/evt){
		// summary:
		//		stub handler that is called when the DragObject instance is
		//		"over" a DropTarget.
	},

	onDragOut: function(/*dojo.dnd.DragEvent*/evt){
		// summary:
		//		stub handler that is called when the DragObject instance leaves
		//		a DropTarget.
	},

	onDragEnd: function(/*dojo.dnd.DragEvent*/evt){
		// summary:
		//		stub handler that is called when dragging ends, either through
		//		dropping or cancelation.
	},

	// normal aliases
	onDragLeave: dojo.lang.forward("onDragOut"),
	onDragEnter: dojo.lang.forward("onDragOver"),

	// non-camel aliases
	ondragout: dojo.lang.forward("onDragOut"),
	ondragover: dojo.lang.forward("onDragOver")
});

dojo.declare("dojo.dnd.DropTarget", null, {

	acceptsType: function(/*String*/type){
		// summary: 
		//		determines whether or not this DropTarget will accept the given
		//		type. The default behavior is to consult this.acceptedTypes and
		//		if "*" is a member, to always accept the type.
		if(!dojo.lang.inArray(this.acceptedTypes, "*")){ // wildcard
			if(!dojo.lang.inArray(this.acceptedTypes, type)) { return false; } // Boolean
		}
		return true; // Boolean
	},

	accepts: function(/*Array*/dragObjects){
		// summary: 
		//		determines if we'll accept all members of the passed array of
		//		dojo.dnd.DragObject instances
		if(!dojo.lang.inArray(this.acceptedTypes, "*")){ // wildcard
			for (var i = 0; i < dragObjects.length; i++) {
				if (!dojo.lang.inArray(this.acceptedTypes,
					dragObjects[i].type)) { return false; } // Boolean
			}
		}
		return true; // Boolean
	},

	unregister: function(){
		// summary: remove from the drag manager
		dojo.dnd.dragManager.unregisterDropTarget(this);
	},

	onDragOver: function(/*dojo.dnd.DragEvent*/evt){
		// summary:
		//		stub handler that is called when DragObject instances are
		//		"over" this DropTarget.
	},

	onDragOut: function(/*dojo.dnd.DragEvent*/evt){
		// summary:
		//		stub handler that is called when DragObject instances are
		//		"leave" this DropTarget.
	},

	onDragMove: function(/*dojo.dnd.DragEvent*/evt){
		// summary:
		//		stub handler that is called when DragObject instances are
		//		moved across this DropTarget. May fire many times in the course
		//		of the drag operation but will end after onDragOut
	},

	onDropStart: function(/*dojo.dnd.DragEvent*/evt){ // Boolean
		// summary:
		//		stub handler that is called when DragObject instances are
		//		dropped on this target. If true is returned from onDropStart,
		//		dropping proceeds, otherwise it's cancled.
	},

	onDrop: function(/*dojo.dnd.DragEvent*/evt){
		// summary: we're getting dropped on!
	},

	onDropEnd: function(){
		// summary: dropping is over
	}
}, function(){
	this.acceptedTypes = [];
});

// NOTE: this interface is defined here for the convenience of the DragManager
// implementor. It is expected that in most cases it will be satisfied by
// extending a native event (DOM event in HTML and SVG).
dojo.dnd.DragEvent = function(){
	this.dragSource = null;
	this.dragObject = null;
	this.target = null;
	this.eventStatus = "success";
	//
	// can be one of:
	//	[	"dropSuccess", "dropFailure", "dragMove",
	//		"dragStart", "dragEnter", "dragLeave"]
	//
}
/*
 *	The DragManager handles listening for low-level events and dispatching
 *	them to higher-level primitives like drag sources and drop targets. In
 *	order to do this, it must keep a list of the items.
 */
dojo.declare("dojo.dnd.DragManager", null, {
	// Array: an array of currently selected DragSource objects
	selectedSources: [],
	// Array: all DragObjects we know about
	dragObjects: [],
	// Array: all DragSources we know about
	dragSources: [],
	registerDragSource: function(/*dojo.dnd.DragSource*/ source){
		// summary: called by DragSource class constructor
	},
	// Array: all DropTargets we know about
	dropTargets: [],
	registerDropTarget: function(/*dojo.dnd.DropTarget*/ target){
		// summary: called by DropTarget class constructor
	},
	// dojo.dnd.DropTarget:
	//		what was the last DropTarget instance we left in the drag phase?
	lastDragTarget: null,
	// dojo.dnd.DropTarget:
	//		the DropTarget the mouse is currently over
	currentDragTarget: null,
	onKeyDown: function(){
		// summary: generic handler called by low-level events
	},
	onMouseOut: function(){
		// summary: generic handler called by low-level events
	},
	onMouseMove: function(){
		// summary: generic handler called by low-level events
	},
	onMouseUp: function(){
		// summary: generic handler called by low-level events
	}
});

// NOTE: despite the existance of the DragManager class, there will be a
// singleton drag manager provided by the renderer-specific D&D support code.
// It is therefore sane for us to assign instance variables to the DragManager
// prototype

// The renderer-specific file will define the following object:
// dojo.dnd.dragManager = null;

dojo.provide("dojo.dnd.HtmlDragManager");






// NOTE: there will only ever be a single instance of HTMLDragManager, so it's
// safe to use prototype properties for book-keeping.
dojo.declare("dojo.dnd.HtmlDragManager", dojo.dnd.DragManager, {
	/**
	 * There are several sets of actions that the DnD code cares about in the
	 * HTML context:
	 *	1.) mouse-down ->
	 *			(draggable selection)
	 *			(dragObject generation)
	 *		mouse-move ->
	 *			(draggable movement)
	 *			(droppable detection)
	 *			(inform droppable)
	 *			(inform dragObject)
	 *		mouse-up
	 *			(inform/destroy dragObject)
	 *			(inform draggable)
	 *			(inform droppable)
	 *	2.) mouse-down -> mouse-down
	 *			(click-hold context menu)
	 *	3.) mouse-click ->
	 *			(draggable selection)
	 *		shift-mouse-click ->
	 *			(augment draggable selection)
	 *		mouse-down ->
	 *			(dragObject generation)
	 *		mouse-move ->
	 *			(draggable movement)
	 *			(droppable detection)
	 *			(inform droppable)
	 *			(inform dragObject)
	 *		mouse-up
	 *			(inform draggable)
	 *			(inform droppable)
	 *	4.) mouse-up
	 *			(clobber draggable selection)
	 */
	disabled: false, // to kill all dragging!
	nestedTargets: false,
	mouseDownTimer: null, // used for click-hold operations
	dsCounter: 0,
	dsPrefix: "dojoDragSource",

	// dimension calculation cache for use durring drag
	dropTargetDimensions: [],

	currentDropTarget: null,
	// currentDropTargetPoints: null,
	previousDropTarget: null,
	_dragTriggered: false,

	selectedSources: [],
	dragObjects: [],
	dragSources: [],
	dropTargets: [],

	// mouse position properties
	currentX: null,
	currentY: null,
	lastX: null,
	lastY: null,
	mouseDownX: null,
	mouseDownY: null,
	threshold: 7,

	dropAcceptable: false,

	cancelEvent: function(e){ e.stopPropagation(); e.preventDefault();},

	// method over-rides
	registerDragSource: function(ds){
		//dojo.profile.start("register DragSource");

		if(ds["domNode"]){
			// FIXME: dragSource objects SHOULD have some sort of property that
			// references their DOM node, we shouldn't just be passing nodes and
			// expecting it to work.
			//dojo.profile.start("register DragSource 1");
			var dp = this.dsPrefix;
			var dpIdx = dp+"Idx_"+(this.dsCounter++);
			ds.dragSourceId = dpIdx;
			this.dragSources[dpIdx] = ds;
			ds.domNode.setAttribute(dp, dpIdx);
			//dojo.profile.end("register DragSource 1");

			//dojo.profile.start("register DragSource 2");

			// so we can drag links
			if(dojo.render.html.ie){
				//dojo.profile.start("register DragSource IE");
				
				dojo.event.browser.addListener(ds.domNode, "ondragstart", this.cancelEvent);
				// terribly slow
				//dojo.event.connect(ds.domNode, "ondragstart", this.cancelEvent);
				//dojo.profile.end("register DragSource IE");

			}
			//dojo.profile.end("register DragSource 2");

		}
		//dojo.profile.end("register DragSource");
	},

	unregisterDragSource: function(ds){
		if (ds["domNode"]){
			var dp = this.dsPrefix;
			var dpIdx = ds.dragSourceId;
			delete ds.dragSourceId;
			delete this.dragSources[dpIdx];
			ds.domNode.setAttribute(dp, null);
			if(dojo.render.html.ie){
				dojo.event.browser.removeListener(ds.domNode, "ondragstart", this.cancelEvent);			
			}
		}
	},

	registerDropTarget: function(dt){
		this.dropTargets.push(dt);
	},

	unregisterDropTarget: function(dt){
		var index = dojo.lang.find(this.dropTargets, dt, true);
		if (index>=0) {
			this.dropTargets.splice(index, 1);
		}
	},

	/**
	* Get the DOM element that is meant to drag.
	* Loop through the parent nodes of the event target until
	* the element is found that was created as a DragSource and 
	* return it.
	*
	* @param event object The event for which to get the drag source.
	*/
	getDragSource: function(e){
		var tn = e.target;
		if(tn === dojo.body()){ return; }
		var ta = dojo.html.getAttribute(tn, this.dsPrefix);
		while((!ta)&&(tn)){
			tn = tn.parentNode;
			if((!tn)||(tn === dojo.body())){ return; }
			ta = dojo.html.getAttribute(tn, this.dsPrefix);
		}
		return this.dragSources[ta];
	},

	onKeyDown: function(e){
	},

	onMouseDown: function(e){
		if(this.disabled) { return; }

		// only begin on left click
		if(dojo.render.html.ie) {
			if(e.button != 1) { return; }
		} else if(e.which != 1) {
			return;
		}

		var target = e.target.nodeType == dojo.html.TEXT_NODE ?
			e.target.parentNode : e.target;

		// do not start drag involvement if the user is interacting with
		// a form element.
		if(dojo.html.isTag(target, "button", "textarea", "input", "select", "option")) {
			return;
		}

		// find a selection object, if one is a parent of the source node
		var ds = this.getDragSource(e);
		
		// this line is important.  if we aren't selecting anything then
		// we need to return now, so preventDefault() isn't called, and thus
		// the event is propogated to other handling code
		if(!ds){ return; }

		if(!dojo.lang.inArray(this.selectedSources, ds)){
			this.selectedSources.push(ds);
			ds.onSelected();
		}

 		this.mouseDownX = e.pageX;
 		this.mouseDownY = e.pageY;

		// Must stop the mouse down from being propogated, or otherwise can't
		// drag links in firefox.
		// WARNING: preventing the default action on all mousedown events
		// prevents user interaction with the contents.
		e.preventDefault();

		dojo.event.connect(document, "onmousemove", this, "onMouseMove");
	},

	onMouseUp: function(e, cancel){
		// if we aren't dragging then ignore the mouse-up
		// (in particular, don't call preventDefault(), because other
		// code may need to process this event)
		if(this.selectedSources.length==0){
			return;
		}

		this.mouseDownX = null;
		this.mouseDownY = null;
		this._dragTriggered = false;
 		// e.preventDefault();
		e.dragSource = this.dragSource;
		// let ctrl be used for multiselect or another action
		// if I use same key to trigger treeV3 node selection and here,
		// I have bugs with drag'n'drop. why ?? no idea..
		if((!e.shiftKey)&&(!e.ctrlKey)){ 
		//if(!e.shiftKey){
			if(this.currentDropTarget) {
				this.currentDropTarget.onDropStart();
			}
			dojo.lang.forEach(this.dragObjects, function(tempDragObj){
				var ret = null;
				if(!tempDragObj){ return; }
				if(this.currentDropTarget) {
					e.dragObject = tempDragObj;

					// NOTE: we can't get anything but the current drop target
					// here since the drag shadow blocks mouse-over events.
					// This is probelematic for dropping "in" something
					var ce = this.currentDropTarget.domNode.childNodes;
					if(ce.length > 0){
						e.dropTarget = ce[0];
						while(e.dropTarget == tempDragObj.domNode){
							e.dropTarget = e.dropTarget.nextSibling;
						}
					}else{
						e.dropTarget = this.currentDropTarget.domNode;
					}
					if(this.dropAcceptable){
						ret = this.currentDropTarget.onDrop(e);
					}else{
						 this.currentDropTarget.onDragOut(e);
					}
				}

				e.dragStatus = this.dropAcceptable && ret ? "dropSuccess" : "dropFailure";
				// decouple the calls for onDragEnd, so they don't block the execution here
				// ie. if the onDragEnd would call an alert, the execution here is blocked until the
				// user has confirmed the alert box and then the rest of the dnd code is executed
				// while the mouse doesnt "hold" the dragged object anymore ... and so on
				dojo.lang.delayThese([
					function() {
						// in FF1.5 this throws an exception, see 
						// http://dojotoolkit.org/pipermail/dojo-interest/2006-April/006751.html
						try{
							tempDragObj.dragSource.onDragEnd(e)
						} catch(err) {
							// since the problem seems passing e, we just copy all 
							// properties and try the copy ...
							var ecopy = {};
							for (var i in e) {
								if (i=="type") { // the type property contains the exception, no idea why...
									ecopy.type = "mouseup";
									continue;
								}
								ecopy[i] = e[i];
							}
							tempDragObj.dragSource.onDragEnd(ecopy);
						}
					}
					, function() {tempDragObj.onDragEnd(e)}]);
			}, this);

			this.selectedSources = [];
			this.dragObjects = [];
			this.dragSource = null;
			if(this.currentDropTarget) {
				this.currentDropTarget.onDropEnd();
			}
		} else {
			//dojo.debug("special click");
		}

		dojo.event.disconnect(document, "onmousemove", this, "onMouseMove");
		this.currentDropTarget = null;
	},

	onScroll: function(){
		//dojo.profile.start("DNDManager updateoffset");
		for(var i = 0; i < this.dragObjects.length; i++) {
			if(this.dragObjects[i].updateDragOffset) {
				this.dragObjects[i].updateDragOffset();
			}
		}
		//dojo.profile.end("DNDManager updateoffset");

		// TODO: do not recalculate, only adjust coordinates
		if (this.dragObjects.length) {
			this.cacheTargetLocations();
		}
	},

	_dragStartDistance: function(x, y){
		if((!this.mouseDownX)||(!this.mouseDownX)){
			return;
		}
		var dx = Math.abs(x-this.mouseDownX);
		var dx2 = dx*dx;
		var dy = Math.abs(y-this.mouseDownY);
		var dy2 = dy*dy;
		return parseInt(Math.sqrt(dx2+dy2), 10);
	},

	cacheTargetLocations: function(){
		dojo.profile.start("cacheTargetLocations");

		this.dropTargetDimensions = [];
		dojo.lang.forEach(this.dropTargets, function(tempTarget){
			var tn = tempTarget.domNode;
			//only cache dropTarget which can accept current dragSource
			if(!tn || !tempTarget.accepts([this.dragSource])){ return; }
			var abs = {x:0,y:0};
			try{
				abs = dojo.html.getAbsolutePosition(tn, true);
			}
			catch(e){
				//IE has an issue in that the above method fails for empty elements. 
				//This is a workaround for that.
			}
			var bb = dojo.html.getBorderBox(tn);
			this.dropTargetDimensions.push([
				[abs.x, abs.y],	// upper-left
				// lower-right
				[ abs.x+bb.width, abs.y+bb.height ],
				tempTarget
			]);
			//dojo.debug("Cached for "+tempTarget)
		}, this);

		dojo.profile.end("cacheTargetLocations");

		//dojo.debug("Cache locations")
	},

	onMouseMove: function(e){
		if((dojo.render.html.ie)&&(e.button != 1)){
			// Oooops - mouse up occurred - e.g. when mouse was not over the
			// window. I don't think we can detect this for FF - but at least
			// we can be nice in IE.
			this.currentDropTarget = null;
			this.onMouseUp(e, true);
			return;
		}

		// if we've got some sources, but no drag objects, we need to send
		// onDragStart to all the right parties and get things lined up for
		// drop target detection

		if(	(this.selectedSources.length)&&
			(!this.dragObjects.length) ){
			var dx;
			var dy;
			if(!this._dragTriggered){
				this._dragTriggered = (this._dragStartDistance(e.pageX, e.pageY) > this.threshold);
				if(!this._dragTriggered){ return; }
				dx = e.pageX - this.mouseDownX;
				dy = e.pageY - this.mouseDownY;
			}

			// the first element is always our dragSource, if there are multiple
			// selectedSources (elements that move along) then the first one is the master
			// and for it the events will be fired etc.
			this.dragSource = this.selectedSources[0];
			
			dojo.lang.forEach(this.selectedSources, function(tempSource){
				if(!tempSource){ return; }
				var tdo = tempSource.onDragStart(e);
				if(tdo){
					tdo.onDragStart(e);

					// "bump" the drag object to account for the drag threshold
					tdo.dragOffset.y += dy;
					tdo.dragOffset.x += dx;
					tdo.dragSource = tempSource;

					this.dragObjects.push(tdo);
				}
			}, this);

			/* clean previous drop target in dragStart */
			this.previousDropTarget = null;

			this.cacheTargetLocations();
		}

		// FIXME: we need to add dragSources and dragObjects to e
		dojo.lang.forEach(this.dragObjects, function(dragObj){
			if(dragObj){ dragObj.onDragMove(e); }
		});

		// if we have a current drop target, check to see if we're outside of
		// it. If so, do all the actions that need doing.
		if(this.currentDropTarget){
			//dojo.debug(dojo.html.hasParent(this.currentDropTarget.domNode))
			var c = dojo.html.toCoordinateObject(this.currentDropTarget.domNode, true);
			//		var dtp = this.currentDropTargetPoints;
			var dtp = [
				[c.x,c.y], [c.x+c.width, c.y+c.height]
			];
		}

		if((!this.nestedTargets)&&(dtp)&&(this.isInsideBox(e, dtp))){
			if(this.dropAcceptable){
				this.currentDropTarget.onDragMove(e, this.dragObjects);
			}
		}else{
			// FIXME: need to fix the event object!
			// see if we can find a better drop target
			var bestBox = this.findBestTarget(e);

			if(bestBox.target === null){
				if(this.currentDropTarget){
					this.currentDropTarget.onDragOut(e);
					this.previousDropTarget = this.currentDropTarget;
					this.currentDropTarget = null;
					// this.currentDropTargetPoints = null;
				}
				this.dropAcceptable = false;
				return;
			}

			if(this.currentDropTarget !== bestBox.target){
				if(this.currentDropTarget){
					this.previousDropTarget = this.currentDropTarget;
					this.currentDropTarget.onDragOut(e);
				}
				this.currentDropTarget = bestBox.target;
				// this.currentDropTargetPoints = bestBox.points;
				e.dragObjects = this.dragObjects;
				this.dropAcceptable = this.currentDropTarget.onDragOver(e);

			}else{
				if(this.dropAcceptable){
					this.currentDropTarget.onDragMove(e, this.dragObjects);
				}
			}
		}
	},

	findBestTarget: function(e) {
		var _this = this;
		var bestBox = new Object();
		bestBox.target = null;
		bestBox.points = null;
		dojo.lang.every(this.dropTargetDimensions, function(tmpDA) {
			if(!_this.isInsideBox(e, tmpDA)){
				return true;
			}

			bestBox.target = tmpDA[2];
			bestBox.points = tmpDA;
			// continue iterating only if _this.nestedTargets == true
			return Boolean(_this.nestedTargets);
		});

		return bestBox;
	},

	isInsideBox: function(e, coords){
		if(	(e.pageX > coords[0][0])&&
			(e.pageX < coords[1][0])&&
			(e.pageY > coords[0][1])&&
			(e.pageY < coords[1][1]) ){
			return true;
		}
		return false;
	},

	onMouseOver: function(e){
	},

	onMouseOut: function(e){
	}
});

dojo.dnd.dragManager = new dojo.dnd.HtmlDragManager();

// global namespace protection closure
(function(){
	var d = document;
	var dm = dojo.dnd.dragManager;
	//TODO: when focus manager is ready, dragManager should be rewritten to use it
	// set up event handlers on the document (or no?)
	dojo.event.connect(d, "onkeydown", dm, "onKeyDown");
	dojo.event.connect(d, "onmouseover", dm, "onMouseOver");
	dojo.event.connect(d, "onmouseout", dm, "onMouseOut");
	dojo.event.connect(d, "onmousedown", dm, "onMouseDown");
	dojo.event.connect(d, "onmouseup", dm, "onMouseUp");
	// TODO: process scrolling of elements, not only window (focus manager would 
	// probably come to rescue here as well)
	dojo.event.connect(window, "onscroll", dm, "onScroll");
})();

dojo.provide("dojo.dnd.HtmlDragAndDrop");













dojo.declare("dojo.dnd.HtmlDragSource", dojo.dnd.DragSource, {
		dragClass: "", // CSS classname(s) applied to node when it is being dragged

		onDragStart: function(){
			var dragObj = new dojo.dnd.HtmlDragObject(this.dragObject, this.type);
			if(this.dragClass){
				dragObj.dragClass = this.dragClass;
			}

			if(this.constrainToContainer){
				dragObj.constrainTo(this.constrainingContainer || this.domNode.parentNode);
			}

			return dragObj;
		},

		setDragHandle: function(node){
			node = dojo.byId(node);
			dojo.dnd.dragManager.unregisterDragSource(this);
			this.domNode = node;
			dojo.dnd.dragManager.registerDragSource(this);
		},

		setDragTarget: function(node){
			this.dragObject = node;
		},

		constrainTo: function(container){
			this.constrainToContainer = true;
			if(container){
				this.constrainingContainer = container;
			}
		},
		
		/*
		*
		* see dojo.dnd.DragSource.onSelected
		*/
		onSelected: function(){
			for(var i=0; i<this.dragObjects.length; i++){
				dojo.dnd.dragManager.selectedSources.push(new dojo.dnd.HtmlDragSource(this.dragObjects[i]));
			}
		},

		/**
		* Register elements that should be dragged along with
		* the actual DragSource.
		*
		* Example usage:
		* 	var dragSource = new dojo.dnd.HtmlDragSource(...);
		*	// add a single element
		*	dragSource.addDragObjects(dojo.byId('id1'));
		*	// add multiple elements to drag along
		*	dragSource.addDragObjects('id2', dojo.byId('id3'));
		*
		* el A dom node to add to the drag list.
		*/
		addDragObjects: function(/*DOMNode*/ el){
			for(var i=0; i<arguments.length; i++){
				this.dragObjects.push(dojo.byId(arguments[i]));
			}
		}
	}, 

	function(node, type){
		node = dojo.byId(node);
		this.dragObjects = [];
		this.constrainToContainer = false;
		if(node){
			this.domNode = node;
			this.dragObject = node;
			// set properties that might have been clobbered by the mixin
			this.type = (type)||(this.domNode.nodeName.toLowerCase());
			dojo.dnd.DragSource.prototype.reregister.call(this);
		}
	}
);

dojo.declare("dojo.dnd.HtmlDragObject", 
	dojo.dnd.DragObject, 
	{
		dragClass: "",
		opacity: 0.5,
		createIframe: true,		// workaround IE6 bug

		// if true, node will not move in X and/or Y direction
		disableX: false,
		disableY: false,

		createDragNode: function() {
			var node = this.domNode.cloneNode(true);
			if(this.dragClass) { dojo.html.addClass(node, this.dragClass); }
			if(this.opacity < 1) { dojo.html.setOpacity(node, this.opacity); }
			var ltn = node.tagName.toLowerCase();
			var isTr = (ltn == "tr");
			if((isTr)||(ltn == "tbody")){
				// dojo.debug("Dragging table row")
				// Create a table for the cloned row
				var doc = this.domNode.ownerDocument;
				var table = doc.createElement("table");
				if(isTr){
					var tbody = doc.createElement("tbody");
					table.appendChild(tbody);
					tbody.appendChild(node);
				}else{
					table.appendChild(node);
				}

				// Set a fixed width to the cloned TDs
				var tmpSrcTr = ((isTr) ? this.domNode : this.domNode.firstChild);
				var tmpDstTr = ((isTr) ? node : node.firstChild);
				var domTds = tmpSrcTr.childNodes;
				var cloneTds = tmpDstTr.childNodes;
				for(var i = 0; i < domTds.length; i++){
					if((cloneTds[i])&&(cloneTds[i].style)){
						cloneTds[i].style.width = dojo.html.getContentBox(domTds[i]).width + "px";
					}
				}
				node = table;
			}

			if((dojo.render.html.ie55||dojo.render.html.ie60) && this.createIframe){
				with(node.style) {
					top="0px";
					left="0px";
				}
				var outer = document.createElement("div");
				outer.appendChild(node);
				this.bgIframe = new dojo.html.BackgroundIframe(outer);
				outer.appendChild(this.bgIframe.iframe);
				node = outer;
			}
			node.style.zIndex = 999;

			return node;
		},

		onDragStart: function(e){
			dojo.html.clearSelection();

			this.scrollOffset = dojo.html.getScroll().offset;
			this.dragStartPosition = dojo.html.getAbsolutePosition(this.domNode, true);

			this.dragOffset = {y: this.dragStartPosition.y - e.pageY,
				x: this.dragStartPosition.x - e.pageX};

			this.dragClone = this.createDragNode();

			this.containingBlockPosition = this.domNode.offsetParent ? 
				dojo.html.getAbsolutePosition(this.domNode.offsetParent, true) : {x:0, y:0};

			if(this.constrainToContainer){
				this.constraints = this.getConstraints();
			}

			// set up for dragging
			with(this.dragClone.style){
				position = "absolute";
				top = this.dragOffset.y + e.pageY + "px";
				left = this.dragOffset.x + e.pageX + "px";
			}

			dojo.body().appendChild(this.dragClone);

			dojo.event.topic.publish('dragStart', { source: this } );
		},

		/** Return min/max x/y (relative to document.body) for this object) **/
		getConstraints: function(){
			if(this.constrainingContainer.nodeName.toLowerCase() == 'body'){
				var viewport = dojo.html.getViewport();
				var width = viewport.width;
				var height = viewport.height;
				var scroll = dojo.html.getScroll().offset;
				var x = scroll.x;
				var y = scroll.y;
			}else{
				var content = dojo.html.getContentBox(this.constrainingContainer);
				width = content.width;
				height = content.height;
				x =
					this.containingBlockPosition.x +
					dojo.html.getPixelValue(this.constrainingContainer, "padding-left", true) +
					dojo.html.getBorderExtent(this.constrainingContainer, "left");
				y =
					this.containingBlockPosition.y +
					dojo.html.getPixelValue(this.constrainingContainer, "padding-top", true) +
					dojo.html.getBorderExtent(this.constrainingContainer, "top");
			}

			// TODO: should handle left/top/right/bottom margin separately; left/top should affect minX/minY
			var mb = dojo.html.getMarginBox(this.domNode);
			return {
				minX: x,
				minY: y,
				maxX: x + width - mb.width,
				maxY: y + height - mb.height
			}
		},

		updateDragOffset: function(){
			var scroll = dojo.html.getScroll().offset;
			if(scroll.y != this.scrollOffset.y){
				var diff = scroll.y - this.scrollOffset.y;
				this.dragOffset.y += diff;
				this.scrollOffset.y = scroll.y;
			}
			if(scroll.x != this.scrollOffset.x){
				var diff = scroll.x - this.scrollOffset.x;
				this.dragOffset.x += diff;
				this.scrollOffset.x = scroll.x;
			}
		},

		/** Moves the node to follow the mouse */
		onDragMove: function(e){
			this.updateDragOffset();
			var x = this.dragOffset.x + e.pageX;
			var y = this.dragOffset.y + e.pageY;

			if (this.constrainToContainer) {
				if (x < this.constraints.minX) { x = this.constraints.minX; }
				if (y < this.constraints.minY) { y = this.constraints.minY; }
				if (x > this.constraints.maxX) { x = this.constraints.maxX; }
				if (y > this.constraints.maxY) { y = this.constraints.maxY; }
			}

			this.setAbsolutePosition(x, y);

			dojo.event.topic.publish('dragMove', { source: this } );
		},

		/**
		 * Set the position of the drag clone.  (x,y) is relative to <body>.
		 */
		setAbsolutePosition: function(x, y){
			// The drag clone is attached to document.body so this is trivial
			if(!this.disableY) { this.dragClone.style.top = y + "px"; }
			if(!this.disableX) { this.dragClone.style.left = x + "px"; }
		},


		/**
		 * If the drag operation returned a success we remove the clone of
		 * ourself from the original position. If the drag operation returned
		 * failure we slide back over to where we came from and end the operation
		 * with a little grace.
		 */
		onDragEnd: function(e){
			switch(e.dragStatus){

				case "dropSuccess":
					dojo.html.removeNode(this.dragClone);
					this.dragClone = null;
					break;

				case "dropFailure": // slide back to the start
					var startCoords = dojo.html.getAbsolutePosition(this.dragClone, true);
					// offset the end so the effect can be seen
					var endCoords = { left: this.dragStartPosition.x + 1,
						top: this.dragStartPosition.y + 1};

					// animate
					var anim = dojo.lfx.slideTo(this.dragClone, endCoords, 300);
					var dragObject = this;
					dojo.event.connect(anim, "onEnd", function(e){
						// pause for a second (not literally) and disappear
						// dojo.lang.setTimeout(function() {
								dojo.html.removeNode(dragObject.dragClone);
								// Allow drag clone to be gc'ed
								dragObject.dragClone = null;
						// 	},
						// 	50);
					});
					anim.play();
					break;
			}

			dojo.event.topic.publish('dragEnd', { source: this } );
		},

		constrainTo: function(container){
			this.constrainToContainer=true;
			if(container){
				this.constrainingContainer = container;
			}else{
				this.constrainingContainer = this.domNode.parentNode;
			}
		}
	}, 
	function(node, type){
		this.domNode = dojo.byId(node);
		this.type = type;
		this.constrainToContainer = false;
		this.dragSource = null;
		// this.register();
		dojo.dnd.DragObject.prototype.register.call(this);
	}
);

dojo.declare("dojo.dnd.HtmlDropTarget", 
	dojo.dnd.DropTarget, 
	{
		vertical: false,
		onDragOver: function(e){
			if(!this.accepts(e.dragObjects)){ return false; }

			// cache the positions of the child nodes
			this.childBoxes = [];
			for(var i = 0, child; i < this.domNode.childNodes.length; i++){
				child = this.domNode.childNodes[i];
				if(child.nodeType != dojo.html.ELEMENT_NODE){ continue; }
				var pos = dojo.html.getAbsolutePosition(child, true);
				var inner = dojo.html.getBorderBox(child);
				this.childBoxes.push({top: pos.y, bottom: pos.y+inner.height,
					left: pos.x, right: pos.x+inner.width, height: inner.height, 
					width: inner.width, node: child});
			}

			// TODO: use dummy node

			return true;
		},

		_getNodeUnderMouse: function(e){
			// find the child
			for(var i = 0, child; i < this.childBoxes.length; i++){
				with(this.childBoxes[i]){
					if (e.pageX >= left && e.pageX <= right &&
						e.pageY >= top && e.pageY <= bottom){ return i; }
				}
			}

			return -1;
		},

		createDropIndicator: function(){
			this.dropIndicator = document.createElement("div");
			with(this.dropIndicator.style){
				position = "absolute";
				zIndex = 999;
				if(this.vertical){
					borderLeftWidth = "1px";
					borderLeftColor = "black";
					borderLeftStyle = "solid";
					height = dojo.html.getBorderBox(this.domNode).height + "px";
					top = dojo.html.getAbsolutePosition(this.domNode, true).y + "px";
				}else{
					borderTopWidth = "1px";
					borderTopColor = "black";
					borderTopStyle = "solid";
					width = dojo.html.getBorderBox(this.domNode).width + "px";
					left = dojo.html.getAbsolutePosition(this.domNode, true).x + "px";
				}
			}
		},

		onDragMove: function(e, dragObjects){
			var i = this._getNodeUnderMouse(e);

			if(!this.dropIndicator){
				this.createDropIndicator();
			}

			var gravity = this.vertical ? dojo.html.gravity.WEST : dojo.html.gravity.NORTH;
			var hide = false;
			if(i < 0){
				if(this.childBoxes.length){
					var before = (dojo.html.gravity(this.childBoxes[0].node, e) & gravity);
					if(before){ hide = true; }
				}else{
					var before = true;
				}
			}else{
				var child = this.childBoxes[i];
				var before = (dojo.html.gravity(child.node, e) & gravity);
				if(child.node === dragObjects[0].dragSource.domNode){
					hide = true;
				}else{
					var currentPosChild = before ? 
							(i>0?this.childBoxes[i-1]:child) : 
							(i<this.childBoxes.length-1?this.childBoxes[i+1]:child);
					if(currentPosChild.node === dragObjects[0].dragSource.domNode){
						hide = true;
					}
				}
			}

			if(hide){
				this.dropIndicator.style.display="none";
				return;
			}else{
				this.dropIndicator.style.display="";
			}

			this.placeIndicator(e, dragObjects, i, before);

			if(!dojo.html.hasParent(this.dropIndicator)) {
				dojo.body().appendChild(this.dropIndicator);
			}
		},

		/**
		 * Position the horizontal line that indicates "insert between these two items"
		 */
		placeIndicator: function(e, dragObjects, boxIndex, before) {
			var targetProperty = this.vertical ? "left" : "top";
			var child;
			if(boxIndex < 0){
				if(this.childBoxes.length){
					child = before ? this.childBoxes[0]
						: this.childBoxes[this.childBoxes.length - 1];
				}else{
					this.dropIndicator.style[targetProperty] = dojo.html.getAbsolutePosition(this.domNode, true)[this.vertical?"x":"y"] + "px";
				}
			}else{
				child = this.childBoxes[boxIndex];
			}
			if(child){
				this.dropIndicator.style[targetProperty] = (before ? child[targetProperty] : child[this.vertical?"right":"bottom"]) + "px";
				if(this.vertical){
					this.dropIndicator.style.height = child.height + "px";
					this.dropIndicator.style.top = child.top + "px";
				}else{
					this.dropIndicator.style.width = child.width + "px";
					this.dropIndicator.style.left = child.left + "px";
				}
			}
		},

		onDragOut: function(e) {
			if(this.dropIndicator) {
				dojo.html.removeNode(this.dropIndicator);
				delete this.dropIndicator;
			}
		},

		/**
		 * Inserts the DragObject as a child of this node relative to the
		 * position of the mouse.
		 *
		 * @return true if the DragObject was inserted, false otherwise
		 */
		onDrop: function(e){
			this.onDragOut(e);

			var i = this._getNodeUnderMouse(e);

			var gravity = this.vertical ? dojo.html.gravity.WEST : dojo.html.gravity.NORTH;
			if(i < 0){
				if(this.childBoxes.length){
					if(dojo.html.gravity(this.childBoxes[0].node, e) & gravity){
						return this.insert(e, this.childBoxes[0].node, "before");
					}else{
						return this.insert(e, this.childBoxes[this.childBoxes.length-1].node, "after");
					}
				}
				return this.insert(e, this.domNode, "append");
			}

			var child = this.childBoxes[i];
			if(dojo.html.gravity(child.node, e) & gravity){
				return this.insert(e, child.node, "before");
			}else{
				return this.insert(e, child.node, "after");
			}
		},

		insert: function(e, refNode, position){
			var node = e.dragObject.domNode;

			if(position == "before"){
				return dojo.html.insertBefore(node, refNode);
			}else if(position == "after"){
				return dojo.html.insertAfter(node, refNode);
			}else if(position == "append"){
				refNode.appendChild(node);
				return true;
			}

			return false;
		}
	}, 

	function(node, types){
		if(arguments.length == 0){ return; }
		this.domNode = dojo.byId(node);
		dojo.dnd.DropTarget.call(this);
		if(types && dojo.lang.isString(types)) {
			types = [types];
		}
		this.acceptedTypes = types || [];
		dojo.dnd.dragManager.registerDropTarget(this);
	}
);

dojo.kwCompoundRequire({
	common: ["dojo.dnd.DragAndDrop"],
	browser: ["dojo.dnd.HtmlDragAndDrop"],
	dashboard: ["dojo.dnd.HtmlDragAndDrop"]
});
dojo.provide("dojo.dnd.*");

dojo.provide("dojo.dnd.HtmlDragMove");


dojo.declare("dojo.dnd.HtmlDragMoveSource", dojo.dnd.HtmlDragSource, {
	onDragStart: function(){
		var dragObj =  new dojo.dnd.HtmlDragMoveObject(this.dragObject, this.type);
		if (this.constrainToContainer) {
			dragObj.constrainTo(this.constrainingContainer);
		}
		return dragObj;
	},
	/*
	 * see dojo.dnd.HtmlDragSource.onSelected
	 */
	onSelected: function() {
		for (var i=0; i<this.dragObjects.length; i++) {
			dojo.dnd.dragManager.selectedSources.push(new dojo.dnd.HtmlDragMoveSource(this.dragObjects[i]));
		}
	}
});

dojo.declare("dojo.dnd.HtmlDragMoveObject", dojo.dnd.HtmlDragObject, {
	onDragStart: function(e){
		dojo.html.clearSelection();

		this.dragClone = this.domNode;

		// Record drag start position, where "position" is simply the top/left style values for
		// the node (the meaning of top/left is dependent on whether node is position:absolute or
		// position:relative, and also on the container).
		// Not sure if we should support moving nodes that aren't position:absolute,
		// but supporting it for now
		if(dojo.html.getComputedStyle(this.domNode, 'position') != 'absolute'){
			this.domNode.style.position = "relative";
		}
		var left = parseInt(dojo.html.getComputedStyle(this.domNode, 'left'));
		var top = parseInt(dojo.html.getComputedStyle(this.domNode, 'top'));
		this.dragStartPosition = {
			x: isNaN(left) ? 0 : left,
			y: isNaN(top) ? 0 : top
		};

		this.scrollOffset = dojo.html.getScroll().offset;

		// used to convert mouse position into top/left value for node
		this.dragOffset = {y: this.dragStartPosition.y - e.pageY,
			x: this.dragStartPosition.x - e.pageX};

		// since the DragObject's position is relative to the containing block, for our purposes
		// the containing block's position is just (0,0)
		this.containingBlockPosition = {x:0, y:0};

		if (this.constrainToContainer) {
			this.constraints = this.getConstraints();
		}

		// shortly the browser will fire an onClick() event,
		// but since this was really a drag, just squelch it
		dojo.event.connect(this.domNode, "onclick", this, "_squelchOnClick");
	},

	onDragEnd: function(e){
	},

	setAbsolutePosition: function(x, y){
		// summary: Set the top & left style attributes of the drag node (TODO: function is poorly named)
		if(!this.disableY) { this.domNode.style.top = y + "px"; }
		if(!this.disableX) { this.domNode.style.left = x + "px"; }
	},

	_squelchOnClick: function(e){
		// summary
		//	this function is called to squelch this onClick() event because
		//	it's the result of a drag (ie, it's not a real click)

		dojo.event.browser.stopEvent(e);
		dojo.event.disconnect(this.domNode, "onclick", this, "_squelchOnClick");
	}
});

dojo.provide("dojo.widget.ResizeHandle");





dojo.widget.defineWidget(
	"dojo.widget.ResizeHandle",
	dojo.widget.HtmlWidget,
{
	// summary
	//	The handle on the bottom-right corner of FloatingPane or other widgets that allows
	//	the widget to be resized.
	//	Typically not used directly.

	// targetElmId: String
	//	id of the Widget OR DomNode that I will size
	targetElmId: '',

	templateCssPath: dojo.uri.moduleUri("dojo.widget", "templates/ResizeHandle.css"),
	templateString: '<div class="dojoHtmlResizeHandle"><div></div></div>',

	postCreate: function(){
		dojo.event.connect(this.domNode, "onmousedown", this, "_beginSizing");
	},

	_beginSizing: function(/*Event*/ e){
		if (this._isSizing){ return false; }

		// get the target dom node to adjust.  targetElmId can refer to either a widget or a simple node
		this.targetWidget = dojo.widget.byId(this.targetElmId);
		this.targetDomNode = this.targetWidget ? this.targetWidget.domNode : dojo.byId(this.targetElmId);
		if (!this.targetDomNode){ return; }

		this._isSizing = true;
		this.startPoint  = {'x':e.clientX, 'y':e.clientY};
		var mb = dojo.html.getMarginBox(this.targetDomNode);
		this.startSize  = {'w':mb.width, 'h':mb.height};

		dojo.event.kwConnect({
			srcObj: dojo.body(), 
			srcFunc: "onmousemove",
			targetObj: this,
			targetFunc: "_changeSizing",
			rate: 25
		});
		dojo.event.connect(dojo.body(), "onmouseup", this, "_endSizing");

		e.preventDefault();
	},

	_changeSizing: function(/*Event*/ e){
		// On IE, if you move the mouse above/to the left of the object being resized,
		// sometimes clientX/Y aren't set, apparently.  Just ignore the event.
		try{
			if(!e.clientX  || !e.clientY){ return; }
		}catch(e){
			// sometimes you get an exception accessing above fields...
			return;
		}
		var dx = this.startPoint.x - e.clientX;
		var dy = this.startPoint.y - e.clientY;
		
		var newW = this.startSize.w - dx;
		var newH = this.startSize.h - dy;

		// minimum size check
		if (this.minSize) {
			var mb = dojo.html.getMarginBox(this.targetDomNode);
			if (newW < this.minSize.w) {
				newW = mb.width;
			}
			if (newH < this.minSize.h) {
				newH = mb.height;
			}
		}
		
		if(this.targetWidget){
			this.targetWidget.resizeTo(newW, newH);
		}else{
			dojo.html.setMarginBox(this.targetDomNode, { width: newW, height: newH});
		}
		
		e.preventDefault();
	},

	_endSizing: function(/*Event*/ e){
		dojo.event.disconnect(dojo.body(), "onmousemove", this, "_changeSizing");
		dojo.event.disconnect(dojo.body(), "onmouseup", this, "_endSizing");

		this._isSizing = false;
	}


});

dojo.provide("dojo.widget.FloatingPane");











		// for ModalFloatingPane


dojo.declare(
	"dojo.widget.FloatingPaneBase",
	null,
	{
		// summary
		//	Base class for FloatingPane, ModalFloatingPane

		// title: String
		//	text to display in floating pane's title bar (ex: "My Window")
		title: '',

		// iconSrc: String
		//	path of icon to display in floating pane's title bar
		iconSrc: '',

		// hasShadow: Boolean
		//	if true, display a shadow behind the floating pane
		hasShadow: false,

		// constrainToContainer: Boolean
		//	if true, and the floating pane is inside another container (ContentPane, another FloatingPane, etc.),
		//	then don't allow the floating pane to be dragged outside of it's container
		constrainToContainer: false,

		// taskBarId: String
		//	widget id of TaskBar widget;
		//	if specified, then an icon for this FloatingPane will be added to the specified TaskBar
		taskBarId: "",

		// resizable: Boolean
		//	if true, allow user to resize floating pane
		resizable: true,

		// titleBarDisplay: Boolean
		//	if true, display title bar for this floating pane
		titleBarDisplay: true,

		// windowState: String
		//	controls whether window is initially not displayed ("minimized"), displayed full screen ("maximized"),
		//	or just displayed normally ("normal").
		// Values
		//	"normal", "maximized", "minimized"
		windowState: "normal",

		// displayCloseAction: Boolean
		//	display button to close window
		displayCloseAction: false,

		// displayMinimizeAction: Boolean
		//	display button to minimize window (ie, window disappears so only the taskbar item remains)
		displayMinimizeAction: false,

		// displayMaximizeAction: Boolean
		//	display button to maximize window (ie, to take up the full screen)
		displayMaximizeAction: false,

		// Related to connecting to taskbar
		// TODO: use topics rather than repeated connect attempts?
		_max_taskBarConnectAttempts: 5,
		_taskBarConnectAttempts: 0,

		templatePath: dojo.uri.moduleUri("dojo.widget", "templates/FloatingPane.html"),
		templateCssPath: dojo.uri.moduleUri("dojo.widget", "templates/FloatingPane.css"),

		fillInFloatingPaneTemplate: function(args, frag){
			// summary: this should be called by fillInTemplate() of the widget that I'm mixed into

			// Copy style info from input node to output node
			var source = this.getFragNodeRef(frag);
			dojo.html.copyStyle(this.domNode, source);

			// necessary for safari, khtml (for computing width/height)
			dojo.body().appendChild(this.domNode);

			// if display:none then state=minimized, otherwise state=normal
			if(!this.isShowing()){
				this.windowState="minimized";
			}

			// <img src=""> can hang IE!  better get rid of it
			if(this.iconSrc==""){
				dojo.html.removeNode(this.titleBarIcon);
			}else{
				this.titleBarIcon.src = this.iconSrc.toString();// dojo.uri.Uri obj req. toString()
			}

			if(this.titleBarDisplay){
				this.titleBar.style.display="";
				dojo.html.disableSelection(this.titleBar);

				this.titleBarIcon.style.display = (this.iconSrc=="" ? "none" : "");

				this.minimizeAction.style.display = (this.displayMinimizeAction ? "" : "none");
				this.maximizeAction.style.display=
					(this.displayMaximizeAction && this.windowState!="maximized" ? "" : "none");
				this.restoreAction.style.display=
					(this.displayMaximizeAction && this.windowState=="maximized" ? "" : "none");
				this.closeAction.style.display= (this.displayCloseAction ? "" : "none");

				this.drag = new dojo.dnd.HtmlDragMoveSource(this.domNode);
				if (this.constrainToContainer) {
					this.drag.constrainTo();
				}
				this.drag.setDragHandle(this.titleBar);

				var self = this;

				dojo.event.topic.subscribe("dragMove",
					function (info){
						if (info.source.domNode == self.domNode){
							dojo.event.topic.publish('floatingPaneMove', { source: self } );
						}
					}
				);
			}

			if(this.resizable){
				this.resizeBar.style.display="";
				this.resizeHandle = dojo.widget.createWidget("ResizeHandle", {targetElmId: this.widgetId, id:this.widgetId+"_resize"});
				this.resizeBar.appendChild(this.resizeHandle.domNode);
			}

			// add a drop shadow
			if(this.hasShadow){
				this.shadow=new dojo.lfx.shadow(this.domNode);
			}

			// Prevent IE bleed-through problem
			this.bgIframe = new dojo.html.BackgroundIframe(this.domNode);

			if( this.taskBarId ){
				this._taskBarSetup();
			}

			// counteract body.appendChild above
			dojo.body().removeChild(this.domNode);
		},

		postCreate: function(){
			if (dojo.hostenv.post_load_) {
				this._setInitialWindowState();
			} else {
				dojo.addOnLoad(this, "_setInitialWindowState");
			}
		},

		maximizeWindow: function(/*Event*/ evt) {
			// summary: maximize the window
			var mb = dojo.html.getMarginBox(this.domNode);
			this.previous={
				width: mb.width || this.width,
				height: mb.height || this.height,
				left: this.domNode.style.left,
				top: this.domNode.style.top,
				bottom: this.domNode.style.bottom,
				right: this.domNode.style.right
			};
			if(this.domNode.parentNode.style.overflow.toLowerCase() != 'hidden'){
				this.parentPrevious={
					overflow: this.domNode.parentNode.style.overflow
				};
				dojo.debug(this.domNode.parentNode.style.overflow);
				this.domNode.parentNode.style.overflow = 'hidden';
			}

			this.domNode.style.left =
				dojo.html.getPixelValue(this.domNode.parentNode, "padding-left", true) + "px";
			this.domNode.style.top =
				dojo.html.getPixelValue(this.domNode.parentNode, "padding-top", true) + "px";

			if ((this.domNode.parentNode.nodeName.toLowerCase() == 'body')) {
				var viewport = dojo.html.getViewport();
				var padding = dojo.html.getPadding(dojo.body());
				this.resizeTo(viewport.width-padding.width, viewport.height-padding.height);
			} else {
				var content = dojo.html.getContentBox(this.domNode.parentNode);
				this.resizeTo(content.width, content.height);
			}
			this.maximizeAction.style.display="none";
			this.restoreAction.style.display="";

			//disable resize and drag
			if(this.resizeHandle){
				this.resizeHandle.domNode.style.display="none";
			}
			this.drag.setDragHandle(null);

			this.windowState="maximized";
		},

		minimizeWindow: function(/*Event*/ evt) {
			// summary: hide the window so that only the icon in the taskbar is shown
			this.hide();
			for(var attr in this.parentPrevious){
				this.domNode.parentNode.style[attr] = this.parentPrevious[attr];
			}
			this.lastWindowState = this.windowState;
			this.windowState = "minimized";
		},

		restoreWindow: function(/*Event*/ evt) {
			// summary: set the winow to normal size (neither maximized nor minimized)
			if (this.windowState=="minimized") {
				this.show();
				if(this.lastWindowState == "maximized"){
					this.domNode.parentNode.style.overflow = 'hidden';
					this.windowState="maximized";
				}else{ //normal
					this.windowState="normal";
				}
			} else if (this.windowState=="maximized"){
				for(var attr in this.previous){
					this.domNode.style[attr] = this.previous[attr];
				}
				for(var attr in this.parentPrevious){
					this.domNode.parentNode.style[attr] = this.parentPrevious[attr];
				}
				this.resizeTo(this.previous.width, this.previous.height);
				this.previous=null;
				this.parentPrevious=null;

				this.restoreAction.style.display="none";
				this.maximizeAction.style.display=this.displayMaximizeAction ? "" : "none";

				if(this.resizeHandle){
					this.resizeHandle.domNode.style.display="";
				}
				this.drag.setDragHandle(this.titleBar);
				this.windowState="normal";
			} else { //normal
				// do nothing
			}
		},

		toggleDisplay: function(){
			// summary: switch between hidden mode and displayed mode (either maximized or normal, depending on state before window was minimized)
			if(this.windowState=="minimized"){
				this.restoreWindow();
			}else{
				this.minimizeWindow();
			}
		},

		closeWindow: function(/*Event*/ evt) {
			// summary: destroy this window
			dojo.html.removeNode(this.domNode);
			this.destroy();
		},

		onMouseDown: function(/*Event*/ evt) {
			// summary: callback when user clicks anywhere on the floating pane
			this.bringToTop();
		},

		bringToTop: function() {
			// summary
			//	all the floating panes are stacked in z-index order; bring this floating pane to the top of that stack,
			//	so that it's displayed in front of all the other floating panes
			var floatingPanes= dojo.widget.manager.getWidgetsByType(this.widgetType);
			var windows = [];
			for (var x=0; x<floatingPanes.length; x++) {
				if (this.widgetId != floatingPanes[x].widgetId) {
						windows.push(floatingPanes[x]);
				}
			}

			windows.sort(function(a,b) {
				return a.domNode.style.zIndex - b.domNode.style.zIndex;
			});

			windows.push(this);

			var floatingPaneStartingZ = 100;
			for (x=0; x<windows.length;x++) {
				windows[x].domNode.style.zIndex = floatingPaneStartingZ + x*2;
			}
		},

		_setInitialWindowState: function() {
			if(this.isShowing()){
				this.width=-1;	// force resize
				var mb = dojo.html.getMarginBox(this.domNode);
				this.resizeTo(mb.width, mb.height);
			}
			if (this.windowState == "maximized") {
				this.maximizeWindow();
				this.show();
				return;
			}

			if (this.windowState=="normal") {
				this.show();
				return;
			}

			if (this.windowState=="minimized") {
				this.hide();
				return;
			}

			this.windowState="minimized";
		},

		_taskBarSetup: function() {
			// summary: add icon to task bar, connected to me
			var taskbar = dojo.widget.getWidgetById(this.taskBarId);
			if (!taskbar){
				if (this._taskBarConnectAttempts <  this._max_taskBarConnectAttempts) {
					dojo.lang.setTimeout(this, this._taskBarSetup, 50);
					this._taskBarConnectAttempts++;
				} else {
					dojo.debug("Unable to connect to the taskBar");
				}
				return;
			}
			taskbar.addChild(this);
		},

		showFloatingPane: function(){
			// summary:
			//	bring this floating pane to the top
			this.bringToTop();
		},

		onFloatingPaneShow: function(){
			// summary: callback for when someone calls FloatingPane.show
			var mb = dojo.html.getMarginBox(this.domNode);
			this.resizeTo(mb.width, mb.height);
		},

		// summary: set the floating pane to the given size
		resizeTo: function(/*Integer*/ width, /*Integer*/ height){
			dojo.html.setMarginBox(this.domNode, { width: width, height: height });

			dojo.widget.html.layout(this.domNode,
				[
				  {domNode: this.titleBar, layoutAlign: "top"},
				  {domNode: this.resizeBar, layoutAlign: "bottom"},
				  {domNode: this.containerNode, layoutAlign: "client"}
				] );

			// If any of the children have layoutAlign specified, obey it
			dojo.widget.html.layout(this.containerNode, this.children, "top-bottom");

			this.bgIframe.onResized();
			if(this.shadow){ this.shadow.size(width, height); }
			this.onResized();
		},

		checkSize: function() {
			// summary
			//	checkSize() is called when the user has resized the browser window,
			// 	but that doesn't affect this widget (or this widget's children)
			// 	so it can be safely ignored...
			// TODO: unless we are maximized.  then we should resize ourself.
		},
		destroyFloatingPane: function() {
			if(this.resizeHandle){
				this.resizeHandle.destroy();
				this.resizeHandle = null;
			}
		}
	}
);

dojo.widget.defineWidget(
	"dojo.widget.FloatingPane",
	[dojo.widget.ContentPane, dojo.widget.FloatingPaneBase],
{
	// summary
	//	A non-modal floating window.
	//	Attaches to a Taskbar which has an icon for each window.
	//	Must specify size (like style="width: 500px; height: 500px;"),

	fillInTemplate: function(args, frag){
		this.fillInFloatingPaneTemplate(args, frag);
		dojo.widget.FloatingPane.superclass.fillInTemplate.call(this, args, frag);
	},
	postCreate: function(){
		dojo.widget.FloatingPaneBase.prototype.postCreate.apply(this, arguments);
		dojo.widget.FloatingPane.superclass.postCreate.apply(this, arguments);
	},
	show: function(){
		dojo.widget.FloatingPane.superclass.show.apply(this, arguments);
		this.showFloatingPane();
	},
	onShow: function(){
		dojo.widget.FloatingPane.superclass.onShow.call(this);
		this.onFloatingPaneShow();
	},
	destroy: function(){
		this.destroyFloatingPane();
		dojo.widget.FloatingPane.superclass.destroy.apply(this, arguments);
	}
});


dojo.widget.defineWidget(
	"dojo.widget.ModalFloatingPane",
	[dojo.widget.FloatingPane, dojo.widget.ModalDialogBase],
	{
		// summary
		//	A modal floating window.
		//	This widget is similar to the Dialog widget, but the window, unlike the Dialog, can be moved.
		//	Must specify size (like style="width: 500px; height: 500px;"),

		windowState: "minimized",
		displayCloseAction: true,
		postCreate: function(){
			dojo.widget.ModalDialogBase.prototype.postCreate.call(this);
			dojo.widget.ModalFloatingPane.superclass.postCreate.call(this);
		},
		show: function(){
			this.showModalDialog();
			dojo.widget.ModalFloatingPane.superclass.show.apply(this, arguments);
			//place the background div under this modal pane
			this.bg.style.zIndex = this.domNode.style.zIndex-1;
		},
		hide: function(){
			this.hideModalDialog();
			dojo.widget.ModalFloatingPane.superclass.hide.apply(this, arguments);
		},
		closeWindow: function(){
			this.hide();
			dojo.widget.ModalFloatingPane.superclass.closeWindow.apply(this, arguments);
		}
	}
);

dojo.provide("dojo.widget.PopupContainer");









dojo.declare(
	"dojo.widget.PopupContainerBase",
	null,
	function(){
		this.queueOnAnimationFinish = [];
	},
{
	// summary:
	//		PopupContainerBase is the mixin class which provide popup behaviors:
	//		it can open in a given position x,y or around a given node.
	//		In addition, it handles animation and IE bleed through workaround.
	// description:
	//		This class can not be used standalone: it should be mixed-in to a
	//		dojo.widget.HtmlWidget. Use PopupContainer instead if you want a
	//		a standalone popup widget

	// isShowingNow: Boolean: whether this popup is shown
	isShowingNow: false,

	// currentSubpopup: Widget: the shown sub popup if any
	currentSubpopup: null,

	// beginZIndex: Integer: the minimal popup zIndex
	beginZIndex: 1000,

	// parentPopup: Widget: parent popup widget
	parentPopup: null,

	// parent: Widget: the widget that caused me to be displayed; the logical parent.
	parent: null,

	// popupIndex: Integer: level of sub popup
	popupIndex: 0,

	// aroundBox: dojo.html.boxSizing: which bounding box to use for open aroundNode. By default use BORDER box of the aroundNode
	aroundBox: dojo.html.boxSizing.BORDER_BOX,

	// openedForWindow: Object: in which window the open() is triggered
	openedForWindow: null,

	processKey: function(/*Event*/evt){
		// summary: key event handler
		return false;
	},

	applyPopupBasicStyle: function(){
		// summary: apply necessary css rules to the top domNode
		// description:
		//		this function should be called in sub class where a custom
		//		templateString/templateStringPath is used (see Tooltip widget)
		with(this.domNode.style){
			display = 'none';
			position = 'absolute';
		}
	},

	aboutToShow: function() {
		// summary: connect to this stub to modify the content of the popup
	},

	open: function(/*Integer*/x, /*Integer*/y, /*DomNode*/parent, /*Object*/explodeSrc, /*String?*/orient, /*Array?*/padding){
		// summary:
		//		Open the popup at position (x,y), relative to dojo.body()
	 	//		Or open(node, parent, explodeSrc, aroundOrient) to open
	 	//		around node
		if (this.isShowingNow){ return; }

		// if I click right button and menu is opened, then it gets 2 commands: close -> open
		// so close enables animation and next "open" is put to queue to occur at new location
		if(this.animationInProgress){
			this.queueOnAnimationFinish.push(this.open, arguments);
			return;
		}

		this.aboutToShow();

		var around = false, node, aroundOrient;
		if(typeof x == 'object'){
			node = x;
			aroundOrient = explodeSrc;
			explodeSrc = parent;
			parent = y;
			around = true;
		}

		// save this so that the focus can be returned
		this.parent = parent;

		// for unknown reasons even if the domNode is attached to the body in postCreate(),
		// it's not attached here, so have to attach it here.
		dojo.body().appendChild(this.domNode);

		// if explodeSrc isn't specified then explode from my parent widget
		explodeSrc = explodeSrc || parent["domNode"] || [];

		//keep track of parent popup to decided whether this is a top level popup
		var parentPopup = null;
		this.isTopLevel = true;
		while(parent){
			if(parent !== this && (parent.setOpenedSubpopup != undefined && parent.applyPopupBasicStyle != undefined)){
				parentPopup = parent;
				this.isTopLevel = false;
				parentPopup.setOpenedSubpopup(this);
				break;
			}
			parent = parent.parent;
		}

		this.parentPopup = parentPopup;
		this.popupIndex = parentPopup ? parentPopup.popupIndex + 1 : 1;

		if(this.isTopLevel){
			var button = dojo.html.isNode(explodeSrc) ? explodeSrc : null;
			dojo.widget.PopupManager.opened(this, button);
		}

		//Store the current selection and restore it before the action for a menu item
		//is executed. This is required as clicking on an menu item deselects current selection
		if(this.isTopLevel && !dojo.withGlobal(this.openedForWindow||dojo.global(), dojo.html.selection.isCollapsed)){
			this._bookmark = dojo.withGlobal(this.openedForWindow||dojo.global(), dojo.html.selection.getBookmark);
		}else{
			this._bookmark = null;
		}

		//convert explodeSrc from format [x, y] to
		//{left: x, top: y, width: 0, height: 0} which is the new
		//format required by dojo.html.toCoordinateObject
		if(explodeSrc instanceof Array){
			explodeSrc = {left: explodeSrc[0], top: explodeSrc[1], width: 0, height: 0};
		}

		// display temporarily, and move into position, then hide again
		with(this.domNode.style){
			display="";
			zIndex = this.beginZIndex + this.popupIndex;
		}

		if(around){
			this.move(node, padding, aroundOrient);
		}else{
			this.move(x, y, padding, orient);
		}
		this.domNode.style.display="none";

		this.explodeSrc = explodeSrc;

		// then use the user defined method to display it
		this.show();

		this.isShowingNow = true;
	},

	// TODOC: move(node, padding, aroundOrient) how to do this?
	move: function(/*Int*/x, /*Int*/y, /*Integer?*/padding, /*String?*/orient){
		// summary: calculate where to place the popup

		var around = (typeof x == "object");
		if(around){
			var aroundOrient=padding;
			var node=x;
			padding=y;
			if(!aroundOrient){ //By default, attempt to open above the aroundNode, or below
				aroundOrient = {'BL': 'TL', 'TL': 'BL'};
			}
			dojo.html.placeOnScreenAroundElement(this.domNode, node, padding, this.aroundBox, aroundOrient);
		}else{
			if(!orient){ orient = 'TL,TR,BL,BR';}
			dojo.html.placeOnScreen(this.domNode, x, y, padding, true, orient);
		}
	},

	close: function(/*Boolean?*/force){
		// summary: hide the popup
		if(force){
			this.domNode.style.display="none";
		}

		// If we are in the process of opening the menu and we are asked to close it
		if(this.animationInProgress){
			this.queueOnAnimationFinish.push(this.close, []);
			return;
		}

		this.closeSubpopup(force);
		this.hide();
		if(this.bgIframe){
			this.bgIframe.hide();
			this.bgIframe.size({left: 0, top: 0, width: 0, height: 0});
		}
		if(this.isTopLevel){
			dojo.widget.PopupManager.closed(this);
		}
		this.isShowingNow = false;
		// return focus to the widget that opened the menu

		if(this.parent){
			setTimeout(
				dojo.lang.hitch(this, 
					function(){
						try{
							if(this.parent['focus']){
								this.parent.focus();
							}else{
								this.parent.domNode.focus(); 
							}
						}catch(e){dojo.debug("No idea how to focus to parent", e);}
					}
				),
				10
			);
		}


		//do not need to restore if current selection is not empty
		//(use keyboard to select a menu item)
		if(this._bookmark && dojo.withGlobal(this.openedForWindow||dojo.global(), dojo.html.selection.isCollapsed)){
			if(this.openedForWindow){
				this.openedForWindow.focus()
			}
			try{
				dojo.withGlobal(this.openedForWindow||dojo.global(), "moveToBookmark", dojo.html.selection, [this._bookmark]);
			}catch(e){
				/*squelch IE internal error, see http://trac.dojotoolkit.org/ticket/1984 */
			}
		}
		this._bookmark = null;
	},

	closeAll: function(/*Boolean?*/force){
		// summary: hide all popups including sub ones
		if (this.parentPopup){
			this.parentPopup.closeAll(force);
		}else{
			this.close(force);
		}
	},

	setOpenedSubpopup: function(/*Widget*/popup) {
		// summary: used by sub popup to set currentSubpopup in the parent popup
		this.currentSubpopup = popup;
	},

	closeSubpopup: function(/*Boolean?*/force) {
		// summary: close opened sub popup
		if(this.currentSubpopup == null){ return; }

		this.currentSubpopup.close(force);
		this.currentSubpopup = null;
	},

	onShow: function() {
		dojo.widget.PopupContainer.superclass.onShow.apply(this, arguments);
		// With some animation (wipe), after close, the size of the domnode is 0
		// and next time when shown, the open() function can not determine
		// the correct place to popup, so we store the opened size here and
		// set it after close (in function onHide())
		this.openedSize={w: this.domNode.style.width, h: this.domNode.style.height};
		// prevent IE bleed through
		if(dojo.render.html.ie){
			if(!this.bgIframe){
				this.bgIframe = new dojo.html.BackgroundIframe();
				this.bgIframe.setZIndex(this.domNode);
			}

			this.bgIframe.size(this.domNode);
			this.bgIframe.show();
		}
		this.processQueue();
	},

	processQueue: function() {
		// summary: do events from queue
		if (!this.queueOnAnimationFinish.length) return;

		var func = this.queueOnAnimationFinish.shift();
		var args = this.queueOnAnimationFinish.shift();

		func.apply(this, args);
	},

	onHide: function() {
		dojo.widget.HtmlWidget.prototype.onHide.call(this);

		//restore size of the domnode, see comment in
		//function onShow()
		if(this.openedSize){
			with(this.domNode.style){
				width=this.openedSize.w;
				height=this.openedSize.h;
			}
		}

		this.processQueue();
	}
});

dojo.widget.defineWidget(
	"dojo.widget.PopupContainer",
	[dojo.widget.HtmlWidget, dojo.widget.PopupContainerBase], {
		// summary: dojo.widget.PopupContainer is the widget version of dojo.widget.PopupContainerBase
		isContainer: true,
		fillInTemplate: function(){
			this.applyPopupBasicStyle();
			dojo.widget.PopupContainer.superclass.fillInTemplate.apply(this, arguments);
		}
	});


dojo.widget.PopupManager = new function(){
	// summary:
	//		the popup manager makes sure we don't have several popups
	//		open at once. the root popup in an opening sequence calls
	//		opened(). when a root menu closes it calls closed(). then
	//		everything works. lovely.

	this.currentMenu = null;
	this.currentButton = null;		// button that opened current menu (if any)
	this.currentFocusMenu = null;	// the (sub)menu which receives key events
	this.focusNode = null;
	this.registeredWindows = [];

	this.registerWin = function(/*Window*/win){
		// summary: register a window so that when clicks/scroll in it, the popup can be closed automatically
		if(!win.__PopupManagerRegistered)
		{
			dojo.event.connect(win.document, 'onmousedown', this, 'onClick');
			dojo.event.connect(win, "onscroll", this, "onClick");
			dojo.event.connect(win.document, "onkey", this, 'onKey');
			win.__PopupManagerRegistered = true;
			this.registeredWindows.push(win);
		}
	};

	/*

	*/
	this.registerAllWindows = function(/*Window*/targetWindow){
		// summary:
		//		This function register all the iframes and the top window,
		//		so that whereever the user clicks in the page, the popup
		//		menu will be closed
		//		In case you add an iframe after onload event, please call
		//		dojo.widget.PopupManager.registerWin manually

		//starting from window.top, clicking everywhere in this page
		//should close popup menus
		if(!targetWindow) { //see comment below
			targetWindow = dojo.html.getDocumentWindow(window.top && window.top.document || window.document);
		}

		this.registerWin(targetWindow);

		for (var i = 0; i < targetWindow.frames.length; i++){
			try{
				//do not remove  dojo.html.getDocumentWindow, see comment in it
				var win = dojo.html.getDocumentWindow(targetWindow.frames[i].document);
				if(win){
					this.registerAllWindows(win);
				}
			}catch(e){ /* squelch error for cross domain iframes */ }
		}
	};

	this.unRegisterWin = function(/*Window*/win){
		// summary: remove listeners on the registered window
		if(win.__PopupManagerRegistered)
		{
			dojo.event.disconnect(win.document, 'onmousedown', this, 'onClick');
			dojo.event.disconnect(win, "onscroll", this, "onClick");
			dojo.event.disconnect(win.document, "onkey", this, 'onKey');
			win.__PopupManagerRegistered = false;
		}
	};

	this.unRegisterAllWindows = function(){
		// summary: remove listeners on all the registered windows
		for(var i=0;i<this.registeredWindows.length;++i){
			this.unRegisterWin(this.registeredWindows[i]);
		}
		this.registeredWindows = [];
	};

	dojo.addOnLoad(this, "registerAllWindows");
	dojo.addOnUnload(this, "unRegisterAllWindows");

	this.closed = function(/*Widget*/menu){
		// summary: notify the manager that menu is closed
		if (this.currentMenu == menu){
			this.currentMenu = null;
			this.currentButton = null;
			this.currentFocusMenu = null;
		}
	};

	this.opened = function(/*Widget*/menu, /*DomNode*/button){
		// summary: sets the current opened popup
		if (menu == this.currentMenu){ return; }

		if (this.currentMenu){
			this.currentMenu.close();
		}

		this.currentMenu = menu;
		this.currentFocusMenu = menu;
		this.currentButton = button;
	};

	this.setFocusedMenu = function(/*Widget*/menu){
		// summary:
		// 		Set the current focused popup, This is used by popups which supports keyboard navigation
		this.currentFocusMenu = menu;
	};

	this.onKey = function(/*Event*/e){
		if (!e.key) { return; }
		if(!this.currentMenu || !this.currentMenu.isShowingNow){ return; }

		// loop from child menu up ancestor chain, ending at button that spawned the menu
		var m = this.currentFocusMenu;
		while (m){
			if(m.processKey(e)){
				e.preventDefault();
				e.stopPropagation();
				break;
			}
			m = m.parentPopup || m.parentMenu;
		}		
	},

	this.onClick = function(/*Event*/e){
		if (!this.currentMenu){ return; }

		var scrolloffset = dojo.html.getScroll().offset;

		// starting from the base menu, perform a hit test
		// and exit when one succeeds

		var m = this.currentMenu;

		while (m){
			if(dojo.html.overElement(m.domNode, e) || dojo.html.isDescendantOf(e.target, m.domNode)){
				return;
			}
			m = m.currentSubpopup;
		}

		// Also, if user clicked the button that opened this menu, then
		// that button will send the menu a close() command, so this code
		// shouldn't try to close the menu.  Closing twice messes up animation.
		if (this.currentButton && dojo.html.overElement(this.currentButton, e)){
			return;
		}

		// the click didn't fall within the open menu tree
		// so close it

		this.currentMenu.closeAll(true);
	};
}

dojo.provide("dojo.widget.Menu2");



dojo.declare(
	"dojo.widget.MenuBase",
	null,
	function(){
		// summary
		//		Base class for PopupMenu and MenuBar

		this.eventNames =  {
			open: ""
		};
	},
{
	isContainer: true,

	isMenu: true,

	// eventNaming: String
	//	if "default" event names are based on widget id, otherwise user must define
	//	TODO: write real documentation about the events
	eventNaming: "default",

	templateCssPath: dojo.uri.moduleUri("dojo.widget", "templates/Menu2.css"),

	// submenuDelay: Integer
	//	number of milliseconds before hovering (without clicking) causes the submenu to automatically open
	submenuDelay: 500,
	
	initialize: function(args, frag) {
		if (this.eventNaming == "default") {
			for (var eventName in this.eventNames) {
				this.eventNames[eventName] = this.widgetId+"/"+eventName;
			}
		}
	},

	_moveToNext: function(/*Event*/ evt){
		this._highlightOption(1);
		return true; //do not pass to parent menu
	},

	_moveToPrevious: function(/*Event*/ evt){
		this._highlightOption(-1);
		return true; //do not pass to parent menu
	},

	_moveToParentMenu: function(/*Event*/ evt){
		if(this._highlighted_option && this.parentMenu){
			//only process event in the focused menu
			//and its immediate parentPopup to support
			//MenuBar2
			if(evt._menu2UpKeyProcessed){
				return true; //do not pass to parent menu
			}else{
				this._highlighted_option.onUnhover();
				this.closeSubmenu();
				evt._menu2UpKeyProcessed = true;
			}
		}
		return false;
	},

	_moveToChildMenu: function(/*Event*/ evt){
		if(this._highlighted_option && this._highlighted_option.submenuId){
			this._highlighted_option._onClick(true);
			return true; //do not pass to parent menu
		}
		return false;
	},

	_selectCurrentItem: function(/*Event*/ evt){
		if(this._highlighted_option){
			this._highlighted_option._onClick();
			return true;
		}
		return false;
	},

	processKey: function(/*Event*/ evt){
		// summary
		//	callback to process key strokes
		//	return true to stop the event being processed by the
		//	parent popupmenu

		if(evt.ctrlKey || evt.altKey || !evt.key){ return false; }

		var rval = false;
		switch(evt.key){
 			case evt.KEY_DOWN_ARROW:
				rval = this._moveToNext(evt);
				break;
			case evt.KEY_UP_ARROW:
				rval = this._moveToPrevious(evt);
				break;
			case evt.KEY_RIGHT_ARROW:
				rval = this._moveToChildMenu(evt);
				break;
			case evt.KEY_LEFT_ARROW:
				rval = this._moveToParentMenu(evt);
				break;
			case " ": //fall through
			case evt.KEY_ENTER: 
				if(rval = this._selectCurrentItem(evt)){
					break;
				}
				//fall through
			case evt.KEY_ESCAPE:
			case evt.KEY_TAB:
				this.close(true);
				rval = true;
				break;
		}

		return rval;
	},

	_findValidItem: function(dir, curItem){
		if(curItem){
			curItem = dir>0 ? curItem.getNextSibling() : curItem.getPreviousSibling();
		}

		for(var i=0; i < this.children.length; ++i){
			if(!curItem){
				curItem = dir>0 ? this.children[0] : this.children[this.children.length-1];
			}
			//find next/previous visible menu item, not including separators
			if(curItem.onHover && curItem.isShowing()){
				return curItem;
			}
			curItem = dir>0 ? curItem.getNextSibling() : curItem.getPreviousSibling();
		}
	},
	
	_highlightOption: function(dir){
		var item;
		// || !this._highlighted_option.parentNode
		if((!this._highlighted_option)){
			item = this._findValidItem(dir);
		}else{
			item = this._findValidItem(dir, this._highlighted_option);
		}
		if(item){
			if(this._highlighted_option) {
				this._highlighted_option.onUnhover();
			}
			item.onHover();
			dojo.html.scrollIntoView(item.domNode);
			// navigate into the item table and select the first caption tag
			try {
				var node = dojo.html.getElementsByClass("dojoMenuItem2Label", item.domNode)[0];
				node.focus();
			} catch(e) { }
		}
	},

	onItemClick: function(/*Widget*/ item) {
		// summary: user defined function to handle clicks on an item
	},

	closeSubmenu: function(force){
		// summary: close the currently displayed submenu
		if (this.currentSubmenu == null){ return; }

		this.currentSubmenu.close(force);
		this.currentSubmenu = null;

		this.currentSubmenuTrigger.is_open = false;
		this.currentSubmenuTrigger._closedSubmenu(force);
		this.currentSubmenuTrigger = null;
	}

});

dojo.widget.defineWidget(
	"dojo.widget.PopupMenu2",
	[dojo.widget.HtmlWidget, dojo.widget.PopupContainerBase, dojo.widget.MenuBase],
	function(){
		// targetNodeIds: String[]
		//	Array of dom node ids of nodes to attach to.
		//	Fill this with nodeIds upon widget creation and it becomes context menu for those nodes.
		this.targetNodeIds = [];
	},
{
	// summary
	//	provides a menu that can be used as a context menu (typically shown by right-click),
	//	or as the drop down on a DropDownButton, ComboButton, etc.

	templateString: 
						'<table class="dojoPopupMenu2" border=0 cellspacing=0 cellpadding=0 style="display: none; position: absolute;">' +
							'<tbody dojoAttachPoint="containerNode"></tbody>'+
						'</table>' ,

	// submenuOverlap: Integer
	//	a submenu usually appears to the right, but slightly overlapping, it's parent menu;
	//	this controls the number of pixels the two menus overlap.
	submenuOverlap: 5,
	
	// contextMenuForWindow: Boolean
	//	if true, right clicking anywhere on the window will cause this context menu to open;
	//	if false, must specify targetNodeIds
	contextMenuForWindow: false,

	// parentMenu: Widget
	// pointer to menu that displayed me
	parentMenu: null,

	postCreate: function(){
		if (this.contextMenuForWindow){
			var doc = dojo.body();
			this.bindDomNode(doc);
		} else if ( this.targetNodeIds.length > 0 ){
			dojo.lang.forEach(this.targetNodeIds, this.bindDomNode, this);
		}

		this._subscribeSubitemsOnOpen();
	},

	_subscribeSubitemsOnOpen: function() {
		var subItems = this.getChildrenOfType(dojo.widget.MenuItem2);

		for(var i=0; i<subItems.length; i++) {
			dojo.event.topic.subscribe(this.eventNames.open, subItems[i], "menuOpen")
		}
	},

	getTopOpenEvent: function() {
		// summary: get event that initially caused current chain of menus to open
		var menu = this;
		while (menu.parentMenu){ menu = menu.parentMenu; }
		return menu.openEvent;	// Event
	},

	bindDomNode: function(/*String|DomNode*/ node){
		// summary: attach menu to given node
		node = dojo.byId(node);

		var win = dojo.html.getElementWindow(node);
		if(dojo.html.isTag(node,'iframe') == 'iframe'){
			win = dojo.html.iframeContentWindow(node);
			node = dojo.withGlobal(win, dojo.body);
		}
		// fixes node so that it supports oncontextmenu if not natively supported, Konqueror, Opera more?
		dojo.widget.Menu2.OperaAndKonqFixer.fixNode(node);

		dojo.event.kwConnect({
			srcObj:     node,
			srcFunc:    "oncontextmenu",
			targetObj:  this,
			targetFunc: "onOpen",
			once:       true
		});

		//normal connect does not work if document.designMode is on in FF, use addListener instead
		if(dojo.render.html.moz && win.document.designMode.toLowerCase() == 'on'){
			dojo.event.browser.addListener(node, "contextmenu", dojo.lang.hitch(this, "onOpen"));
		}
		dojo.widget.PopupManager.registerWin(win);
	},

	unBindDomNode: function(/*String|DomNode*/ nodeName){
		// summary: detach menu from given node
		var node = dojo.byId(nodeName);
		dojo.event.kwDisconnect({
			srcObj:     node,
			srcFunc:    "oncontextmenu",
			targetObj:  this,
			targetFunc: "onOpen",
			once:       true
		});

		// cleans a fixed node, konqueror and opera
		dojo.widget.Menu2.OperaAndKonqFixer.cleanNode(node);
	},

	_openAsSubmenu: function(/*Widget|DomNode*/parent, /*Object*/explodeSrc, /*String?*/orient){
		// summary:
		//		Open this menu as a child to specified parent, which is a MenuBar, Menu, or Button
		// parent:
		//		The parent menu or button
		// explodeSrc:
		//		Typically the MenuItem.domNode that the user clicked
		// orient:
		//		Location to place ourselves relative to explodeSrc
		if (this.isShowingNow){ return; }
		this.parentMenu = parent;
		this.open(explodeSrc, parent, explodeSrc, orient);
	},

	close: function(/*Boolean*/ force){
		// summary: close this menu
		if(this.animationInProgress){
			dojo.widget.PopupContainerBase.prototype.close.call(this, force);
			return;
		}

		if(this._highlighted_option){
			this._highlighted_option.onUnhover();
		}

		dojo.widget.PopupContainerBase.prototype.close.call(this, force);
		
		this.parentMenu = null;
	},

	closeAll: function(/*Boolean?*/force){
		// summary: close all popups in the chain
		if (this.parentMenu){
			this.parentMenu.closeAll(force);
		}else{
			this.close(force);
		}
	},
	
	_openSubmenu: function(submenu, from_item){
		// summary: open the submenu to the right of the current menu item
		submenu._openAsSubmenu(this, from_item.arrow, {'TR': 'TL', 'TL': 'TR'});

		this.currentSubmenu = submenu;
		this.currentSubmenuTrigger = from_item;
		this.currentSubmenuTrigger.is_open = true;
	},

	focus: function(){
		if(this.currentSubmenuTrigger){
			if(this.currentSubmenuTrigger.caption){
				try{ this.currentSubmenuTrigger.caption.focus(); } catch(e) { };
			}else{
				try{ this.currentSubmenuTrigger.domNode.focus(); } catch(e) { };
			}
		}
	},

	onOpen: function(/*Event*/ e){
		// summary: callback when menu is opened
		this.openEvent = e;
		if(e["target"]){
			this.openedForWindow = dojo.html.getElementWindow(e.target);
		}else{
			this.openedForWindow = null;
		}
		var x = e.pageX, y = e.pageY;

		var win = dojo.html.getElementWindow(e.target);
		var iframe = win._frameElement || win.frameElement;
		if(iframe){
			var cood = dojo.html.abs(iframe, true);
			x += cood.x - dojo.withGlobal(win, dojo.html.getScroll).left;
			y += cood.y - dojo.withGlobal(win, dojo.html.getScroll).top;
		}
		this.open(x, y, null, [x, y]);

		dojo.event.browser.stopEvent(e);
	}
}
);

dojo.widget.defineWidget(
	"dojo.widget.MenuItem2",
	dojo.widget.HtmlWidget,
	function(){
		this.eventNames = {
			engage: ""
		};
	},
{
	// summary
	//	A line item in a Menu2

	// Make 4 columns
	//   icon, label, accelerator-key, and right-arrow indicating sub-menu
	templateString:
		 '<tr class="dojoMenuItem2" dojoAttachEvent="onMouseOver: onHover; onMouseOut: onUnhover; onClick: _onClick; onKey:onKey;">'
		+'<td><div class="${this.iconClass}" style="${this.iconStyle}"></div></td>'
		+'<td tabIndex="-1" class="dojoMenuItem2Label" dojoAttachPoint="caption">${this.caption}</td>'
		+'<td class="dojoMenuItem2Accel">${this.accelKey}</td>'
		+'<td><div class="dojoMenuItem2Submenu" style="display:${this.arrowDisplay};" dojoAttachPoint="arrow"></div></td>'
		+'</tr>',

	//
	// internal settings
	//

	is_hovering: false,
	hover_timer: null,
	is_open: false,
	topPosition: 0,

	//
	// options
	//

	// caption: String
	//	text of the menu item
	caption: 'Untitled',
	
	// accelKey: String
	//	accelerator key (not supported yet!)
	accelKey: '',
	
	// iconSrc: String
	//	path to icon to display to the left of the menu text
	iconSrc: '',
	
	// disabledClass: String
	//  CSS class for disabled nodes
	disabledClass: 'dojoMenuItem2Disabled',
	
	// iconClass: String
	//	CSS class name to use for menu item (if CSS class specifies a background image then iconSrc is not necessary)
	iconClass: 'dojoMenuItem2Icon',
	
	// submenuId: String
	//	widget ID of Menu2 widget to open when this menu item is clicked
	submenuId: '',
	
	// eventNaming: String
	//	event names for announcing when menu item is clicked.
	//	if "default", then use the default name, based on the widget ID
	eventNaming: "default",
	
	// highlightClass: String
	//	CSS class for menu item when it's hovered over
	highlightClass: 'dojoMenuItem2Hover',

	postMixInProperties: function(){
		this.iconStyle="";
		if (this.iconSrc){
			if ((this.iconSrc.toLowerCase().substring(this.iconSrc.length-4) == ".png") && (dojo.render.html.ie55 || dojo.render.html.ie60)){
				this.iconStyle="filter: progid:DXImageTransform.Microsoft.AlphaImageLoader(src='"+this.iconSrc+"', sizingMethod='image')";
			}else{
				this.iconStyle="background-image: url("+this.iconSrc+")";
			}
		}
		this.arrowDisplay = this.submenuId ? 'block' : 'none';
		dojo.widget.MenuItem2.superclass.postMixInProperties.apply(this, arguments);
	},

	fillInTemplate: function(){
		dojo.html.disableSelection(this.domNode);

		if (this.disabled){
			this.setDisabled(true);
		}

		if (this.eventNaming == "default") {
			for (var eventName in this.eventNames) {
				this.eventNames[eventName] = this.widgetId+"/"+eventName;
			}
		}
	},

	onHover: function(){
		// summary: callback when mouse is moved onto menu item

		//this is to prevent some annoying behavior when both mouse and keyboard are used
		this.onUnhover();

		if (this.is_hovering){ return; }
		if (this.is_open){ return; }

		if(this.parent._highlighted_option){
			this.parent._highlighted_option.onUnhover();
		}
		this.parent.closeSubmenu();
		this.parent._highlighted_option = this;
		dojo.widget.PopupManager.setFocusedMenu(this.parent);

		this._highlightItem();

		if (this.is_hovering){ this._stopSubmenuTimer(); }
		this.is_hovering = true;
		this._startSubmenuTimer();
	},

	onUnhover: function(){
		// summary: callback when mouse is moved off of menu item
		if(!this.is_open){ this._unhighlightItem(); }

		this.is_hovering = false;

		this.parent._highlighted_option = null;

		if(this.parent.parentMenu){
			dojo.widget.PopupManager.setFocusedMenu(this.parent.parentMenu);
		}

		this._stopSubmenuTimer();
	},

	_onClick: function(focus){
		// summary: internal function for clicks
		var displayingSubMenu = false;
		if (this.disabled){ return false; }

		if (this.submenuId){
			if (!this.is_open){
				this._stopSubmenuTimer();
				this._openSubmenu();
			}
			displayingSubMenu = true;
		}else{
			// for some browsers the onMouseOut doesn't get called (?), so call it manually
			this.onUnhover(); //only onUnhover when no submenu is available
			this.parent.closeAll(true);
		}

		// user defined handler for click
		this.onClick();

		dojo.event.topic.publish(this.eventNames.engage, this);

		if(displayingSubMenu && focus){
			dojo.widget.getWidgetById(this.submenuId)._highlightOption(1);
		}
		return;
	},

	onClick: function() {
		// summary
		//	User defined function to handle clicks
		//	this default function call the parent
		//	menu's onItemClick
		this.parent.onItemClick(this);
	},

	_highlightItem: function(){
		dojo.html.addClass(this.domNode, this.highlightClass);
	},

	_unhighlightItem: function(){
		dojo.html.removeClass(this.domNode, this.highlightClass);
	},

	_startSubmenuTimer: function(){
		this._stopSubmenuTimer();

		if (this.disabled){ return; }

		var self = this;
		var closure = function(){ return function(){ self._openSubmenu(); } }();

		this.hover_timer = dojo.lang.setTimeout(closure, this.parent.submenuDelay);
	},

	_stopSubmenuTimer: function(){
		if (this.hover_timer){
			dojo.lang.clearTimeout(this.hover_timer);
			this.hover_timer = null;
		}
	},

	_openSubmenu: function(){
		if (this.disabled){ return; }

		// first close any other open submenu
		this.parent.closeSubmenu();

		var submenu = dojo.widget.getWidgetById(this.submenuId);
		if (submenu){
			this.parent._openSubmenu(submenu, this);
		}
	},

	_closedSubmenu: function(){
		this.onUnhover();
	},

	setDisabled: function(/*Boolean*/ value){
		// summary: enable or disable this menu item
		this.disabled = value;

		if (this.disabled){
			dojo.html.addClass(this.domNode, this.disabledClass);
		}else{
			dojo.html.removeClass(this.domNode, this.disabledClass);
		}
	},

	enable: function(){
		// summary: enable this menu item so user can click it
		this.setDisabled(false);
	},

	disable: function(){
		// summary: disable this menu item so user can't click it
		this.setDisabled(true);
	},

	menuOpen: function(message) {
		// summary: callback when menu is opened
		// TODO: I don't see anyone calling this menu item
	}

});

dojo.widget.defineWidget(
	"dojo.widget.MenuSeparator2",
	dojo.widget.HtmlWidget,
{
	// summary
	//	A line between two menu items

	templateString: '<tr class="dojoMenuSeparator2"><td colspan=4>'
			+'<div class="dojoMenuSeparator2Top"></div>'
			+'<div class="dojoMenuSeparator2Bottom"></div>'
			+'</td></tr>',

	postCreate: function(){
		dojo.html.disableSelection(this.domNode);
	}
});

dojo.widget.defineWidget(
	"dojo.widget.MenuBar2",
	[dojo.widget.HtmlWidget, dojo.widget.MenuBase],
{
	// summary
	//	A menu bar, listing menu choices horizontally, like the "File" menu in most desktop applications

	menuOverlap: 2,

	templateString: '<div class="dojoMenuBar2" dojoAttachPoint="containerNode" tabIndex="0"></div>',

	close: function(force){
		if(this._highlighted_option){
			this._highlighted_option.onUnhover();
		}
		this.closeSubmenu(force);
	},

	closeAll: function(force){
		this.close(force);
	},

	processKey: function(/*Event*/ evt){
		if(evt.ctrlKey || evt.altKey){ return false; }

		var rval = false;

		switch(evt.key){
 			case evt.KEY_DOWN_ARROW:
				rval = this._moveToChildMenu(evt);
				break;
			case evt.KEY_UP_ARROW:
				rval = this._moveToParentMenu(evt);
				break;
			case evt.KEY_RIGHT_ARROW:
				rval = this._moveToNext(evt);
				break;
			case evt.KEY_LEFT_ARROW:
				rval = this._moveToPrevious(evt);
				break;
			default:
				rval = 	dojo.widget.MenuBar2.superclass.processKey.apply(this, arguments);
				break;
		}

		return rval;
	},

	postCreate: function(){
		dojo.widget.MenuBar2.superclass.postCreate.apply(this, arguments);
		this.isShowingNow = true;
	},

	_openSubmenu: function(submenu, from_item){
		// summary: open the specified menu below this node (rather than to our right)
		// submenu: Widget
		// from_item: Widget
		submenu._openAsSubmenu(this, from_item.domNode, {'BL': 'TL', 'TL': 'BL'});

		this.currentSubmenu = submenu;
		this.currentSubmenuTrigger = from_item;
		this.currentSubmenuTrigger.is_open = true;
	}
});

// summary
//	Item in a Menu2Bar
dojo.widget.defineWidget(
	"dojo.widget.MenuBarItem2",
	dojo.widget.MenuItem2,
{
	templateString:
		'<span class="dojoMenuItem2" dojoAttachEvent="onMouseOver: onHover; onMouseOut: onUnhover; onClick: _onClick;">${this.caption}</span>'
});


// summary
//	Internal class to make contextmenu work in konqueror and opera
dojo.widget.Menu2.OperaAndKonqFixer = new function(){
 	var implement = true;
 	var delfunc = false;

 	/** 	dom event check
 	*
 	*	make a event and dispatch it and se if it calls function below,
 	*	if it indeed is supported and we dont need to implement our own
 	*/

 	// gets called if we have support for oncontextmenu
 	if (!dojo.lang.isFunction(dojo.doc().oncontextmenu)){
 		dojo.doc().oncontextmenu = function(){
 			implement = false;
 			delfunc = true;
 		}
 	}

 	if (dojo.doc().createEvent){ // moz, safari has contextmenu event, need to do livecheck on this env.
 		try {
 			var e = dojo.doc().createEvent("MouseEvents");
 			e.initMouseEvent("contextmenu", 1, 1, dojo.global(), 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, null);
 			dojo.doc().dispatchEvent(e);
 		} catch (e) {/* assume not supported */}
 	} else {
 		// IE no need to implement custom contextmenu
 		implement = false;
 	}

 	// clear this one if it wasn't there before
 	if (delfunc){
 		delete dojo.doc().oncontextmenu;
 	}
 	/***** end dom event check *****/


 	/**
 	*	this fixes a dom node by attaching a custom oncontextmenu function that gets called when apropriate
 	*	@param	node	a dom node
 	*
 	*	no returns
 	*/
 	this.fixNode = function(node){
 		if (implement){
 			// attach stub oncontextmenu function
 			if (!dojo.lang.isFunction(node.oncontextmenu)){
 				node.oncontextmenu = function(e){/*stub*/}
 			}

 			// attach control function for oncontextmenu
 			if (dojo.render.html.opera){
 				// opera
 				// listen to ctrl-click events
 				node._menufixer_opera = function(e){
 					if (e.ctrlKey){
 						this.oncontextmenu(e);
 					}
 				};

 				dojo.event.connect(node, "onclick", node, "_menufixer_opera");

 			} else {
 				// konqueror
 				// rightclick, listen to mousedown events
 				node._menufixer_konq = function(e){
 					if (e.button==2 ){
 						e.preventDefault(); // need to prevent browsers menu
 						this.oncontextmenu(e);
 					}
 				};

 				dojo.event.connect(node, "onmousedown", node, "_menufixer_konq");
 			}
 		}
 	}

 	/**
 	*	this cleans up a fixed node, prevent memoryleak?
 	*	@param node	node to clean
 	*
 	*	no returns
 	*/
 	this.cleanNode = function(node){
 		if (implement){
 			// checks needed if we gets a non fixed node
 			if (node._menufixer_opera){
 				dojo.event.disconnect(node, "onclick", node, "_menufixer_opera");
 				delete node._menufixer_opera;
 			} else if(node._menufixer_konq){
 				dojo.event.disconnect(node, "onmousedown", node, "_menufixer_konq");
 				delete node._menufixer_konq;
 			}
 			if (node.oncontextmenu){
 				delete node.oncontextmenu;
 			}
 		}
 	}
};

dojo.provide("dojo.widget.SplitContainer");

//
// TODO
// make it prettier
// active dragging upwards doesn't always shift other bars (direction calculation is wrong in this case)
//









dojo.widget.defineWidget(
	"dojo.widget.SplitContainer",
	dojo.widget.HtmlWidget,
	function(){
		this.sizers = [];
	},
{
	// summary
	//		Contains multiple children widgets, all of which are displayed side by side
	//		(either horizontally or vertically); there's a bar between each of the children,
	//		and you can adjust the relative size of each child by dragging the bars.
	//
	//		You must specify a size (width and height) for the SplitContainer.

	isContainer: true,

	templateCssPath: dojo.uri.moduleUri("dojo.widget", "templates/SplitContainer.css"),

	// activeSizing: Boolean
	//		If true, the children's size changes as you drag the bar;
	//		otherwise, the sizes don't change until you drop the bar (by mouse-up)
	activeSizing: false,
	
	// sizerWidget: Integer
	//		Size in pixels of the bar between each child
	sizerWidth: 15,
	
	// orientation: String
	//		either 'horizontal' or vertical; indicates whether the children are
	//		arranged side-by-side or up/down.
	orientation: 'horizontal',
	
	// persist: Boolean
	//		Save splitter positions in a cookie
	persist: true,

	postMixInProperties: function(){
		dojo.widget.SplitContainer.superclass.postMixInProperties.apply(this, arguments);
		this.isHorizontal = (this.orientation == 'horizontal');
	},

	fillInTemplate: function(){
		dojo.widget.SplitContainer.superclass.fillInTemplate.apply(this, arguments);
		dojo.html.addClass(this.domNode, "dojoSplitContainer");
		// overflow has to be explicitly hidden for splitContainers using gekko (trac #1435)
		// to keep other combined css classes from inadvertantly making the overflow visible
		if (dojo.render.html.moz) {
		        this.domNode.style.overflow = '-moz-scrollbars-none'; // hidden doesn't work
		}
		
		var content = dojo.html.getContentBox(this.domNode);
		this.paneWidth = content.width;
		this.paneHeight = content.height;
	},

	onResized: function(e){
		var content = dojo.html.getContentBox(this.domNode);
		this.paneWidth = content.width;
		this.paneHeight = content.height;
		this._layoutPanels();
	},

	postCreate: function(args, fragment, parentComp){
		dojo.widget.SplitContainer.superclass.postCreate.apply(this, arguments);
		// attach the children and create the draggers
		for(var i=0; i<this.children.length; i++){
            with(this.children[i].domNode.style){
                position = "absolute";
            }
            dojo.html.addClass(this.children[i].domNode,
                "dojoSplitPane");

            if(i == this.children.length-1){
                break;
            }

            this._addSizer();
		}

		// create the fake dragger
		if (typeof this.sizerWidth == "object") { 
			try {
				this.sizerWidth = parseInt(this.sizerWidth.toString()); 
			} catch(e) { this.sizerWidth = 15; }
		}
		this.virtualSizer = document.createElement('div');
		this.virtualSizer.style.position = 'absolute';
		this.virtualSizer.style.display = 'none';
		//this.virtualSizer.style.backgroundColor = 'lime';
		this.virtualSizer.style.zIndex = 10;
		this.virtualSizer.className = this.isHorizontal ? 'dojoSplitContainerVirtualSizerH' : 'dojoSplitContainerVirtualSizerV';
		this.domNode.appendChild(this.virtualSizer);

		dojo.html.disableSelection(this.virtualSizer);

		if(this.persist){
			this._restoreState();
		}

		// size the panels once the browser has caught up
		this.resizeSoon();
	},

    _injectChild: function(child) {
        with(child.domNode.style){
            position = "absolute";
        }
        dojo.html.addClass(child.domNode,
            "dojoSplitPane");
    },

    _addSizer: function() {
        var i = this.sizers.length;

        this.sizers[i] = document.createElement('div');
        this.sizers[i].style.position = 'absolute';
        this.sizers[i].className = this.isHorizontal ? 'dojoSplitContainerSizerH' : 'dojoSplitContainerSizerV';

        var self = this;
        var handler = (function(){ var sizer_i = i; return function(e){ self.beginSizing(e, sizer_i); } })();
        dojo.event.connect(this.sizers[i], "onmousedown", handler);

        this.domNode.appendChild(this.sizers[i]);
        dojo.html.disableSelection(this.sizers[i]);
    },

    removeChild: function(widget){
        // Remove sizer, but only if widget is really our child and
        // we have at least one sizer to throw away
        if (this.sizers.length > 0) {
            for(var x=0; x<this.children.length; x++){
                if(this.children[x] === widget){
                    var i = this.sizers.length - 1;
                    this.domNode.removeChild(this.sizers[i]);
                    this.sizers.length = i;
                    break;
                }
            }
        }

        // Remove widget and repaint
        dojo.widget.SplitContainer.superclass.removeChild.call(this, widget, arguments);
        this.onResized();
    },

    addChild: function(widget){
        dojo.widget.SplitContainer.superclass.addChild.apply(this, arguments);
        this._injectChild(widget);

        if (this.children.length > 1) {
            this._addSizer();
        }

        this._layoutPanels();
    },

    _layoutPanels: function(){
        if (this.children.length == 0){ return; }

		//
		// calculate space
		//

		var space = this.isHorizontal ? this.paneWidth : this.paneHeight;
		if (this.children.length > 1){
			space -= this.sizerWidth * (this.children.length - 1);
		}


		//
		// calculate total of SizeShare values
		//

		var out_of = 0;
		for(var i=0; i<this.children.length; i++){
			out_of += this.children[i].sizeShare;
		}


		//
		// work out actual pixels per sizeshare unit
		//

		var pix_per_unit = space / out_of;


		//
		// set the SizeActual member of each pane
		//

		var total_size = 0;

		for(var i=0; i<this.children.length-1; i++){
			var size = Math.round(pix_per_unit * this.children[i].sizeShare);
			this.children[i].sizeActual = size;
			total_size += size;
		}
		this.children[this.children.length-1].sizeActual = space - total_size;

		//
		// make sure the sizes are ok
		//

		this._checkSizes();


		//
		// now loop, positioning each pane and letting children resize themselves
		//

		var pos = 0;
		var size = this.children[0].sizeActual;
		this._movePanel(this.children[0], pos, size);
		this.children[0].position = pos;
		pos += size;

		for(var i=1; i<this.children.length; i++){

			// first we position the sizing handle before this pane
			this._moveSlider(this.sizers[i-1], pos, this.sizerWidth);
			this.sizers[i-1].position = pos;
			pos += this.sizerWidth;

			size = this.children[i].sizeActual;
			this._movePanel(this.children[i], pos, size);
			this.children[i].position = pos;
			pos += size;
		}
	},

	_movePanel: function(/*Widget*/ panel, pos, size){
		if (this.isHorizontal){
			panel.domNode.style.left = pos + 'px';
			panel.domNode.style.top = 0;
			panel.resizeTo(size, this.paneHeight);
		}else{
			panel.domNode.style.left = 0;
			panel.domNode.style.top = pos + 'px';
			panel.resizeTo(this.paneWidth, size);
		}
	},

	_moveSlider: function(/*DomNode*/ slider, pos, size){
		if (this.isHorizontal){
			slider.style.left = pos + 'px';
			slider.style.top = 0;
			dojo.html.setMarginBox(slider, { width: size, height: this.paneHeight });
		}else{
			slider.style.left = 0;
			slider.style.top = pos + 'px';
			dojo.html.setMarginBox(slider, { width: this.paneWidth, height: size });
		}
	},

	_growPane: function(growth, pane){
		if (growth > 0){
			if (pane.sizeActual > pane.sizeMin){
				if ((pane.sizeActual - pane.sizeMin) > growth){

					// stick all the growth in this pane
					pane.sizeActual = pane.sizeActual - growth;
					growth = 0;
				}else{
					// put as much growth in here as we can
					growth -= pane.sizeActual - pane.sizeMin;
					pane.sizeActual = pane.sizeMin;
				}
			}
		}
		return growth;
	},

	_checkSizes: function(){

		var total_min_size = 0;
		var total_size = 0;

		for(var i=0; i<this.children.length; i++){

			total_size += this.children[i].sizeActual;
			total_min_size += this.children[i].sizeMin;
		}

		// only make adjustments if we have enough space for all the minimums

		if (total_min_size <= total_size){

			var growth = 0;

			for(var i=0; i<this.children.length; i++){

				if (this.children[i].sizeActual < this.children[i].sizeMin){

					growth += this.children[i].sizeMin - this.children[i].sizeActual;
					this.children[i].sizeActual = this.children[i].sizeMin;
				}
			}

			if (growth > 0){
				if (this.isDraggingLeft){
					for(var i=this.children.length-1; i>=0; i--){
						growth = this._growPane(growth, this.children[i]);
					}
				}else{
					for(var i=0; i<this.children.length; i++){
						growth = this._growPane(growth, this.children[i]);
					}
				}
			}
		}else{

			for(var i=0; i<this.children.length; i++){
				this.children[i].sizeActual = Math.round(total_size * (this.children[i].sizeMin / total_min_size));
			}
		}
	},

	beginSizing: function(e, i){
		this.paneBefore = this.children[i];
		this.paneAfter = this.children[i+1];

		this.isSizing = true;
		this.sizingSplitter = this.sizers[i];
		this.originPos = dojo.html.getAbsolutePosition(this.children[0].domNode, true, dojo.html.boxSizing.MARGIN_BOX);
		if (this.isHorizontal){
			var client = (e.layerX ? e.layerX : e.offsetX);
			var screen = e.pageX;
			this.originPos = this.originPos.x;
		}else{
			var client = (e.layerY ? e.layerY : e.offsetY);
			var screen = e.pageY;
			this.originPos = this.originPos.y;
		}
		this.startPoint = this.lastPoint = screen;
		this.screenToClientOffset = screen - client;
		this.dragOffset = this.lastPoint - this.paneBefore.sizeActual - this.originPos - this.paneBefore.position;

		if (!this.activeSizing){
			this._showSizingLine();
		}

		//
		// attach mouse events
		//

		dojo.event.connect(document.documentElement, "onmousemove", this, "changeSizing");
		dojo.event.connect(document.documentElement, "onmouseup", this, "endSizing");
		dojo.event.browser.stopEvent(e);
	},

	changeSizing: function(e){
		this.lastPoint = this.isHorizontal ? e.pageX : e.pageY;
		if (this.activeSizing){
			this.movePoint();
			this._updateSize();
		}else{
			this.movePoint();
			this._moveSizingLine();
		}
		dojo.event.browser.stopEvent(e);
	},

	endSizing: function(e){

		if (!this.activeSizing){
			this._hideSizingLine();
		}

		this._updateSize();

		this.isSizing = false;

		dojo.event.disconnect(document.documentElement, "onmousemove", this, "changeSizing");
		dojo.event.disconnect(document.documentElement, "onmouseup", this, "endSizing");
		
		if(this.persist){
			this._saveState(this);
		}
	},

	movePoint: function(){

		// make sure lastPoint is a legal point to drag to
		var p = this.lastPoint - this.screenToClientOffset;

		var a = p - this.dragOffset;
		a = this.legaliseSplitPoint(a);
		p = a + this.dragOffset;

		this.lastPoint = p + this.screenToClientOffset;
	},

	legaliseSplitPoint: function(a){

		a += this.sizingSplitter.position;

		this.isDraggingLeft = (a > 0) ? true : false;

		if (!this.activeSizing){

			if (a < this.paneBefore.position + this.paneBefore.sizeMin){

				a = this.paneBefore.position + this.paneBefore.sizeMin;
			}

			if (a > this.paneAfter.position + (this.paneAfter.sizeActual - (this.sizerWidth + this.paneAfter.sizeMin))){

				a = this.paneAfter.position + (this.paneAfter.sizeActual - (this.sizerWidth + this.paneAfter.sizeMin));
			}
		}

		a -= this.sizingSplitter.position;

		this._checkSizes();

		return a;
	},

	_updateSize: function(){
		var pos = this.lastPoint - this.dragOffset - this.originPos;

		var start_region = this.paneBefore.position;
		var end_region   = this.paneAfter.position + this.paneAfter.sizeActual;

		this.paneBefore.sizeActual = pos - start_region;
		this.paneAfter.position    = pos + this.sizerWidth;
		this.paneAfter.sizeActual  = end_region - this.paneAfter.position;

		for(var i=0; i<this.children.length; i++){

			this.children[i].sizeShare = this.children[i].sizeActual;
		}

		this._layoutPanels();
	},

	_showSizingLine: function(){

		this._moveSizingLine();

		if (this.isHorizontal){
			dojo.html.setMarginBox(this.virtualSizer, { width: this.sizerWidth, height: this.paneHeight });
		}else{
			dojo.html.setMarginBox(this.virtualSizer, { width: this.paneWidth, height: this.sizerWidth });
		}

		this.virtualSizer.style.display = 'block';
	},

	_hideSizingLine: function(){
		this.virtualSizer.style.display = 'none';
	},

	_moveSizingLine: function(){
		var pos = this.lastPoint - this.startPoint + this.sizingSplitter.position;
		if (this.isHorizontal){
			this.virtualSizer.style.left = pos + 'px';
		}else{
			var pos = (this.lastPoint - this.startPoint) + this.sizingSplitter.position;
			this.virtualSizer.style.top = pos + 'px';
		}

	},
	
	_getCookieName: function(i) {
		return this.widgetId + "_" + i;
	},

	_restoreState: function () {
		for(var i=0; i<this.children.length; i++) {
			var cookieName = this._getCookieName(i);
			var cookieValue = dojo.io.cookie.getCookie(cookieName);
			if (cookieValue != null) {
				var pos = parseInt(cookieValue);
				if (typeof pos == "number") {
					this.children[i].sizeShare=pos;
				}
			}
		}
	},

	_saveState: function (){
		for(var i=0; i<this.children.length; i++) {
			var cookieName = this._getCookieName(i);
			dojo.io.cookie.setCookie(cookieName, this.children[i].sizeShare, null, null, null, null);
		}
	}
});

// These arguments can be specified for the children of a SplitContainer.
// Since any widget can be specified as a SplitContainer child, mix them
// into the base widget class.  (This is a hack, but it's effective.)
dojo.lang.extend(dojo.widget.Widget, {
	// sizeMin: Integer
	//	Minimum size (width or height) of a child of a SplitContainer.
	//	The value is relative to other children's sizeShare properties.
	sizeMin: 10,

	// sizeShare: Integer
	//	Size (width or height) of a child of a SplitContainer.
	//	The value is relative to other children's sizeShare properties.
	//	For example, if there are two children and each has sizeShare=10, then
	//	each takes up 50% of the available space.
	sizeShare: 10
});

// Deprecated class for split pane children.
// Actually any widget can be the child of a split pane
dojo.widget.defineWidget(
	"dojo.widget.SplitContainerPanel",
	dojo.widget.ContentPane,
	{}
);



dojo.provide("dojo.widget.TreeCommon");
 // for dojo.widget.manager

dojo.declare(
	"dojo.widget.TreeCommon",
	null,
{
	listenTreeEvents: [],
	listenedTrees: {},
	
	/**
	 * evaluates to false => skip unlistening nodes
	 * provided => use it
	 */	
	listenNodeFilter: null,
	
	listenTree: function(tree) {
		
		//dojo.debug("listenTree in "+this+" tree "+tree);
		
		var _this = this;
		
		if (this.listenedTrees[tree.widgetId]) {
			return; // already listening
		}
		
		dojo.lang.forEach(this.listenTreeEvents, function(event) {
			var eventHandler =  "on" + event.charAt(0).toUpperCase() + event.substr(1);
			//dojo.debug("subscribe: event "+tree.eventNames[event]+" widget "+_this+" handler "+eventHandler);
			dojo.event.topic.subscribe(tree.eventNames[event], _this, eventHandler);
		});
		
		
		var filter;
		
		if (this.listenNodeFilter) {			
			this.processDescendants(tree, this.listenNodeFilter, this.listenNode, true);
		}
		
		/**
		 * remember that I listen to this tree. No unbinding/binding/deselection
		 * needed when transfer between listened trees
		 */
		this.listenedTrees[tree.widgetId] = true;
		
	},			
	
	// interface functions
	listenNode: function() {},	
	unlistenNode: function() {},
			
	unlistenTree: function(tree, nodeFilter) {
		
		var _this = this;
	
		if (!this.listenedTrees[tree.widgetId]) {
			return; 
		}
		
		dojo.lang.forEach(this.listenTreeEvents, function(event) {
			var eventHandler =  "on" + event.charAt(0).toUpperCase() + event.substr(1);
			dojo.event.topic.unsubscribe(tree.eventNames[event], _this, eventHandler);
		});
		
		
		if (this.listenNodeFilter) {
			this.processDescendants(tree, this.listenNodeFilter, this.unlistenNode, true);
		}
		
		delete this.listenedTrees[tree.widgetId];
		
	},
	
	
	/**
	 * check condition for node.domNode -> .. -> any node chain
	 */
	checkPathCondition: function(domElement, condition) {
		
		while (domElement && !domElement.widgetId) {
			if (condition.call(null, domElement)) {
				return true;
			}
			
			domElement = domElement.parentNode;
		}
		
		return false;
	},
		
	
	/**
	 * get node widget id by its descendant dom node
	 */
	domElement2TreeNode: function(domElement) {
		
		while (domElement && !domElement.widgetId) {
			domElement = domElement.parentNode;
		}
		
		if (!domElement) {
			return null;
		}
		
		var widget = dojo.widget.byId(domElement.widgetId);
		
		if (!widget.isTreeNode) {
			return null;
		}
		
		return widget;
	},
	
	/**
	 * it is here, not in Widget, because mostly tree needs it
	 */
	processDescendants: function(elem, filter, func, skipFirst) {
		
		var _this = this;
		
		if (!skipFirst) {
			if (!filter.call(_this,elem)) {
				return;
			}
			func.call(_this,elem);	        
		}
		
		
		var stack = [elem];
		while (elem = stack.pop()) {
			dojo.lang.forEach(elem.children, function(elem) {
				if (filter.call(_this, elem)) {		
					func.call(_this, elem);
					stack.push(elem);
				}
			});
		}
    }
});



dojo.provide("dojo.widget.TreeWithNode");

dojo.declare(
	"dojo.widget.TreeWithNode",
	null,
	function(){ },
{
	/*
	 * dynamic loading-related stuff. 
	 * When an empty folder node appears, it is "UNCHECKED" first,
	 * then after Rpc call it becomes LOADING and, finally LOADED
	 *
	 * tree may be dynamically loaded also
	 */
	loadStates: {
		UNCHECKED: "UNCHECKED",
    	LOADING: "LOADING",
    	LOADED: "LOADED"
	},
	
	state: "UNCHECKED",  // after creation will change to loadStates: "loaded/loading/unchecked"

    //RpcUrl: "", // user can override rpc url for specific nodes

	objectId: "", // the widget represents an object


	// I need this to parse children
	isContainer: true,
	
	lockLevel: 0, // lock ++ unlock --, so nested locking works fine
	
	lock: function() {
		this.lockLevel++;
	},
	unlock: function() {
		if (!this.lockLevel) {
			//dojo.debug((new Error()).stack);
			dojo.raise(this.widgetType+" unlock: not locked");
		}
		this.lockLevel--;
	},
	
	
	expandLevel: 0, // expand to level automatically
	loadLevel: 0, // load to level automatically
		
	hasLock: function() {
		return this.lockLevel>0;
	},

	isLocked: function() {
		var node = this;
		while (true) {
			if (node.lockLevel) {
				return true;
			}
			if (!node.parent || node.isTree) {
				break;
			}
			
			node = node.parent;
			
		}

		return false;
	},

	
	flushLock: function() {
		this.lockLevel = 0;
		//this.unMarkLoading();
	},
	
	
	actionIsDisabled: function(action) {
		var disabled = false;

		if (dojo.lang.inArray(this.actionsDisabled, action)) {
			disabled = true;
		}


		//dojo.debug("Check "+this+" "+disabled)
		
		
		if (this.isTreeNode) {
			if (!this.tree.allowAddChildToLeaf && action == this.actions.ADDCHILD && !this.isFolder) {
				disabled = true;
			}
		}
		return disabled;
	},
		
	actionIsDisabledNow: function(action) {
		return this.actionIsDisabled(action) || this.isLocked();
	},
	
	
	/**
	 * childrenArray is array of Widgets or array of Objects
	 * widgets may be both attached and detached
	 *
	 * Use Cases
	 * 1) lots of widgets are packed and passed in.
	 *  - widgets are created
	 *  - widgets have no parent (detached or not attached yet)
	 *
	 * 2) array of widgets and data objects passed in with flag makeWidgetsFromChildren
	 *  - some widgets are not created
	 *  - all objects have no parent
	 *
	 * 3) expand is called with makeWidgetsFromChildren=true
	 *  - some objects need to be turned into widgets
	 *  - some widgets have parent (e.g markup), some widgets and objects do not
	 *
	 *  Will folderize a node as side-effect.
	 */
	setChildren: function(childrenArray) {
		//dojo.profile.start("setChildren "+this);
		//dojo.debug("setChildren in "+this);
		
		
		if (this.isTreeNode && !this.isFolder) {
			//dojo.debug("folder parent "+parent+ " isfolder "+parent.isFolder);
			this.setFolder();
		} else if (this.isTreeNode) {
			this.state = this.loadStates.LOADED;
		}
		
		var hadChildren = this.children.length > 0;
		
        if (hadChildren && childrenArray){
            // perf: most of time setChildren used for empty nodes, so save function call
            this.destroyChildren()
        }
        
		if (childrenArray) {
			this.children = childrenArray;
		}
		


		var hasChildren = this.children.length > 0;
		if (this.isTreeNode && hasChildren != hadChildren) {
			// call only when hasChildren state changes
			this.viewSetHasChildren();
		}
		


		for(var i=0; i<this.children.length; i++) {
			var child = this.children[i];
			
			//dojo.profile.start("setChildren - create "+this);
			
			if (!(child instanceof dojo.widget.Widget)) {
				
				child = this.children[i] = this.tree.createNode(child);
				var childWidgetCreated = true;	
				//dojo.debugShallow(child)
				
				//dojo.debug("setChildren creates node "+child);
			} else {
				var childWidgetCreated = false;
			}
			
			//dojo.profile.end("setChildren - create "+this);

			//dojo.profile.start("setChildren - attach "+this);

			if (!child.parent) { // detached child
				
				//dojo.debug("detached child "+child);
				
				child.parent = this;

				//dojo.profile.start("setChildren - updateTree "+this);
				
				if (this.tree !== child.tree) {				
					child.updateTree(this.tree);
				}
				//dojo.profile.end("setChildren - updateTree "+this);

			
				//dojo.debug("Add layout for "+child);
				child.viewAddLayout();
				this.containerNode.appendChild(child.domNode);
					
				var message = {
					child: child,
					index: i,
					parent: this,
					childWidgetCreated: childWidgetCreated
				}
			
				delete dojo.widget.manager.topWidgets[child.widgetId];
		

				//dojo.profile.start("setChildren - event "+this);
				//dojo.debug("publish "+this.tree.eventNames.afterAddChild)
				dojo.event.topic.publish(this.tree.eventNames.afterAddChild, message);

				//dojo.profile.end("setChildren - event "+this);

			}
			
			if (this.tree.eagerWidgetInstantiation) {
				dojo.lang.forEach(this.children, function(child) {
					child.setChildren();
				});
			}

			//dojo.profile.end("setChildren - attach "+this);

		
		}
		


		//dojo.profile.end("setChildren "+this);
		
	},	
	
	
	doAddChild: function(child, index) {
		return this.addChild(child, index, true);
	},
		
	addChild: function(child, index, dontPublishEvent) {
		if (dojo.lang.isUndefined(index)) {
			index = this.children.length;
		}
		
		//dojo.debug("doAddChild "+index+" called for "+this+" child "+child+" existing children "+(this.children.length ? this.children : "<no children>"));
				
		if (!child.isTreeNode){
			dojo.raise("You can only add TreeNode widgets to a "+this.widgetType+" widget!");
			return;
		}
			
		this.children.splice(index, 0, child);
		child.parent = this;
				
		child.addedTo(this, index, dontPublishEvent);
		
		// taken from DomWidget.registerChild
		// delete from widget list that are notified on resize etc (no parent)
		delete dojo.widget.manager.topWidgets[child.widgetId];
				
	},
	
	 /**
     * does not inform children about resize (skips onShow),
     * because on large trees that's slow
     */
    onShow: function() {        
        this.animationInProgress=false;
    },
    
    onHide: function() {        
        this.animationInProgress=false;
    }
	
});

dojo.provide("dojo.widget.TreeNodeV3");






dojo.widget.defineWidget(
	"dojo.widget.TreeNodeV3",
	[dojo.widget.HtmlWidget, dojo.widget.TreeWithNode],
	function() {
		this.actionsDisabled = [];
	        this.object = {};
	},
{
	tryLazyInit: true,

	/*
	 * Basic actions one can perform on nodes and, some(addchild) on trees
	 */
	actions: {
		MOVE: "MOVE",
    	DETACH: "DETACH",
    	EDIT: "EDIT",
    	ADDCHILD: "ADDCHILD",
		SELECT: "SELECT"
	},
	
	
	labelClass: "",
	contentClass: "",

	expandNode: null,
	labelNode: null,
		
    /**
     *	can't call it nodeType cause of IE problems
     */
	nodeDocType: "",
    selected: false,
	
	getnodeDocType: function() {
		return this.nodeDocType;
	},
	
	cloneProperties: ["actionsDisabled","tryLazyInit","nodeDocType","objectId","object",
		   "title","isFolder","isExpanded","state"],
	
	
	/**
	 * copy cloneProperties with recursion into them
	 * contains "copy constructor"
	 */
	clone: function(deep) {
		var ret = new this.constructor();
		
		//dojo.debug("start cloning props "+this);
		
		for(var i=0; i<this.cloneProperties.length; i++) {
			var prop = this.cloneProperties[i];
			//dojo.debug("cloning "+prop+ ":" +this[prop]);
			ret[prop] = dojo.lang.shallowCopy(this[prop], true);			
		}
		
		if (this.tree.unsetFolderOnEmpty && !deep && this.isFolder) {
			ret.isFolder = false;
		}
		
		//dojo.debug("cloned props "+this);
		
		ret.toggleObj = this.toggleObj;
		
		dojo.widget.manager.add(ret);
		
		ret.tree = this.tree;
		ret.buildRendering({},{});
		ret.initialize({},{});
				
		if (deep && this.children.length) {
			//dojo.debug("deeper copy start");
			for(var i=0; i<this.children.length; i++) {
				var child = this.children[i];
				//dojo.debug("copy child "+child);
				if (child.clone) {
					ret.children.push(child.clone(deep));
				} else {
					ret.children.push(dojo.lang.shallowCopy(child, deep));
				}
			}
			//dojo.debug("deeper copy end");
			ret.setChildren();
		}
		
		
				
		return ret;
	},
				
			
	markProcessing: function() {
		this.markProcessingSavedClass = dojo.html.getClass(this.expandNode);
		dojo.html.setClass(this.expandNode, this.tree.classPrefix+'ExpandLoading');			
	},
	
	unmarkProcessing: function() {
		dojo.html.setClass(this.expandNode, this.markProcessingSavedClass);			
	},
	
	
	
	
	/**
	 * get information from args & parent, then build rendering
	 */
	buildRendering: function(args, fragment, parent) {
		//dojo.debug("Build for "+args.toSource());
		
		if (args.tree) {
			this.tree = dojo.lang.isString(args.tree) ? dojo.widget.manager.getWidgetById(args.tree) : args.tree;			
		} else if (parent && parent.tree) {
			this.tree = parent.tree;
		} 
		
		if (!this.tree) {
			dojo.raise("Can't evaluate tree from arguments or parent");
		}
		
		
		//dojo.profile.start("buildRendering - cloneNode");
		
		this.domNode = this.tree.nodeTemplate.cloneNode(true);
		this.expandNode = this.domNode.firstChild;
		this.contentNode = this.domNode.childNodes[1];
		this.labelNode = this.contentNode.firstChild;
		
		if (this.labelClass) {
			dojo.html.addClass(this.labelNode, this.labelClass);
		}
		
		if (this.contentClass) {
			dojo.html.addClass(this.contentNode, this.contentClass);
		}
		
		
		//dojo.profile.end("buildRendering - cloneNode");
		
		
		this.domNode.widgetId = this.widgetId;
		
		//dojo.profile.start("buildRendering - innerHTML");
		this.labelNode.innerHTML = this.title;
		//dojo.profile.end("buildRendering - innerHTML");
		
	},
	

	isTreeNode: true,

	
	object: {},

	title: "",
	
	isFolder: null, // set by widget depending on children/args

	contentNode: null, // the item label
	
	expandClass: "",


	isExpanded: false,
	

	containerNode: null,

	
	getInfo: function() {
		// No title here (title may be widget)
		var info = {
			widgetId: this.widgetId,
			objectId: this.objectId,
			index: this.getParentIndex()
		}

		return info;
	},
	
	setFolder: function() {
		//dojo.debug("SetFolder in "+this);
		this.isFolder = true;
		this.viewSetExpand();
		if (!this.containerNode) { // maybe this node was unfolderized and still has container
			this.viewAddContainer(); // all folders have container.
		}
		//dojo.debug("publish "+this.tree.eventNames.setFolder);
		dojo.event.topic.publish(this.tree.eventNames.afterSetFolder, { source: this });
	},
	
	
	
	initialize: function(args, frag, parent) {
		
		//dojo.profile.start("initialize");
		
		/**
		 * first we populate current widget from args,
		 * then use its data to initialize
		 * args may be empty, all data inside widget for copy constructor
		 */
		if (args.isFolder) {
			this.isFolder = true;
		}
		
		if (this.children.length || this.isFolder) {
			//dojo.debug("children found");
			//dojo.debug(this.children);
			//dojo.debug("isFolder "+args.isFolder);
			
			// viewSetExpand for Folder is set here also
			this.setFolder();			
		} else {
			// set expandicon for leaf 	
			this.viewSetExpand();
		}
		
		for(var i=0; i<this.actionsDisabled.length;i++) {
			this.actionsDisabled[i] = this.actionsDisabled[i].toUpperCase();
		}
		//dojo.debug("publish "+this.tree.eventNames.changeTree);
		
		        

		dojo.event.topic.publish(this.tree.eventNames.afterChangeTree, {oldTree:null, newTree:this.tree, node:this} );
		
		
		//dojo.profile.end("initialize");
		
		//dojo.debug("initialize out "+this);
		//dojo.debug(this+" parent "+parent);
	},
		
	unsetFolder: function() {
		this.isFolder = false;
		this.viewSetExpand();		
		dojo.event.topic.publish(this.tree.eventNames.afterUnsetFolder, { source: this });
	},
	
	
	insertNode: function(parent, index) {
		
		if (!index) index = 0;
		//dojo.debug("insertNode "+this+" parent "+parent+" before "+index);
		
		if (index==0) {
			dojo.html.prependChild(this.domNode, parent.containerNode);
		} else {
			dojo.html.insertAfter(this.domNode, parent.children[index-1].domNode);
		}
	},
	
	updateTree: function(newTree) {

		if (this.tree === newTree) {
			return;
		}
		
		var oldTree = this.tree;
		
		
		dojo.lang.forEach(this.getDescendants(),
			function(elem) {			
				elem.tree = newTree;			
		});
		
		/**
		 * UNTESTED
		 * changes class prefix for all domnodes when moving between trees
		 */
		if (oldTree.classPrefix != newTree.classPrefix) {
			var stack = [this.domNode]
			var elem;
			var reg = new RegExp("(^|\\s)"+oldTree.classPrefix, "g");
			
			while (elem = stack.pop()) {
				for(var i=0; i<elem.childNodes.length; i++) {
					var childNode = elem.childNodes[i]
					if (childNode.nodeDocType != 1) continue;
					// change prefix for classes
					dojo.html.setClass(childNode, dojo.html.getClass(childNode).replace(reg, '$1'+newTree.classPrefix));
					stack.push(childNode);
				}
			}
			
		}
		
		var message = {oldTree:oldTree, newTree:newTree, node:this}
		
		dojo.event.topic.publish(this.tree.eventNames.afterChangeTree, message );		
		dojo.event.topic.publish(newTree.eventNames.afterChangeTree, message );
			
				
	},
	
	
	/**
	 * called every time the widget is added with createWidget or created wia markup
	 * from addChild -> registerChild or from postInitialize->registerChild
	 * not called in batch procession
	 * HTML & widget.createWidget only
	 * Layout MUST be removed when node is detached
	 * 
	 */
	addedTo: function(parent, index, dontPublishEvent) {
		//dojo.profile.start("addedTo");
		//dojo.debug(this + " addedTo "+parent+" index "+index);
		//dojo.debug(parent.children);
		//dojo.debug(parent.containerNode.innerHTML);
		
		//dojo.debug((new Error()).stack);
					
				
		if (this.tree !== parent.tree) {
			this.updateTree(parent.tree);
		}
		
		if (parent.isTreeNode) {
			if (!parent.isFolder) {
				//dojo.debug("folderize parent "+parent);
				parent.setFolder();
				parent.state = parent.loadStates.LOADED;
			}
		}
		
		
		var siblingsCount = parent.children.length;
		
		// setFolder works BEFORE insertNode
		this.insertNode(parent, index);
		
		
		this.viewAddLayout();
	
		
		//dojo.debug("siblings "+parent.children);
		
		if (siblingsCount > 1) {
			if (index == 0 && parent.children[1] instanceof dojo.widget.Widget) {
				parent.children[1].viewUpdateLayout();				
			}
			if (index == siblingsCount-1 && parent.children[siblingsCount-2] instanceof dojo.widget.Widget) {
				parent.children[siblingsCount-2].viewUpdateLayout();			
			}
		} else if (parent.isTreeNode) {
			// added as the first child
			//dojo.debug("added as first");
			parent.viewSetHasChildren();
		}
		
		if (!dontPublishEvent) {

			var message = {
				child: this,
				index: index,
				parent: parent
			}
				
			dojo.event.topic.publish(this.tree.eventNames.afterAddChild, message);
		}

		//dojo.profile.end("addedTo");
		
				
	},
	
	/**
	 * Fast program-only hacky creation of widget
	 * 	
	 */
	createSimple: function(args, parent) {
		// I pass no args and ignore default controller
		//dojo.profile.start(this.widgetType+" createSimple");
		//dojo.profile.start(this.widgetType+" createSimple constructor");
		if (args.tree) {
			var tree = args.tree;
		} else if (parent) {
			var tree = parent.tree;
		} else {
			dojo.raise("createSimple: can't evaluate tree");
		}
		tree = dojo.widget.byId(tree);
		
		//dojo.debug(tree);
		
		var treeNode = new tree.defaultChildWidget(); 
		//dojo.profile.end(this.widgetType+" createSimple constructor");
		
		//dojo.profile.start(this.widgetType+" createSimple mixin");		
		for(var x in args){ // fastMixIn			
			treeNode[x] = args[x];
		}
		
		
		//dojo.profile.end(this.widgetType+" createSimple mixin");
		
				
		// HtmlWidget.postMixIn 
		treeNode.toggleObj = dojo.lfx.toggle[treeNode.toggle.toLowerCase()] || dojo.lfx.toggle.plain;

		//dojo.profile.start(this.widgetType + " manager");
		dojo.widget.manager.add(treeNode);
		//dojo.profile.end(this.widgetType + " manager");
		
		//dojo.profile.start(this.widgetType + " buildRendering");
		treeNode.buildRendering(args, {}, parent);		
		//dojo.profile.end(this.widgetType + " buildRendering");
		
		treeNode.initialize(args, {}, parent);
		
		//dojo.profile.end(this.widgetType+"createSimple");
		if (treeNode.parent) {
			delete dojo.widget.manager.topWidgets[treeNode.widgetId];
		}
		
		return treeNode;
	},
	
	
	
	// can override e.g for case of div with +- text inside
	viewUpdateLayout: function() {
		//dojo.profile.start("viewUpdateLayout");
		//dojo.debug("UpdateLayout in "+this);

		this.viewRemoveLayout();
		this.viewAddLayout();
		//dojo.profile.end("viewUpdateLayout");	
	},
	
	
	viewAddContainer: function() {
		// make controller only if children exist
		this.containerNode = this.tree.containerNodeTemplate.cloneNode(true);
		this.domNode.appendChild(this.containerNode);
	},
	/*
	viewRemoveContainer: function() {
		// make controller only if children exist
		this.domNode.removeChild(this.containerNode);
		this.containerNode = null;
	},
	*/
	
	viewAddLayout: function() {
		//dojo.profile.start("viewAddLayout");
		//dojo.debug("viewAddLayout in "+this);
		
		if (this.parent["isTree"]) {
			//dojo.debug("Parent isTree => add isTreeRoot");
			
			// use setClass, not addClass for speed
			dojo.html.setClass(this.domNode, dojo.html.getClass(this.domNode) + ' '+this.tree.classPrefix+'IsRoot')
		}
		//dojo.debug(this.parent.children.length);
		//dojo.debug(this.parent.children[this.parent.children.length-1]);
		if (this.isLastChild()) {
			//dojo.debug("Checked last node for "+this);
			//dojo.debug("Parent last is "+this.parent.children[this.parent.children.length-1]);
			//dojo.debug("last node => add isTreeLast for "+this);
			dojo.html.setClass(this.domNode, dojo.html.getClass(this.domNode) + ' '+this.tree.classPrefix+'IsLast')			
		}
		//dojo.profile.end("viewAddLayout");
		//dojo.debug("viewAddLayout out");
		
	},
	
	
	viewRemoveLayout: function() {		
		//dojo.debug("viewRemoveLayout in "+this);
		//dojo.profile.start("viewRemoveLayout");
		//dojo.debug((new Error()).stack);
		dojo.html.removeClass(this.domNode, this.tree.classPrefix+"IsRoot");
		dojo.html.removeClass(this.domNode, this.tree.classPrefix+"IsLast");
		//dojo.profile.end("viewRemoveLayout");
	},
		
	viewGetExpandClass: function() {
		if (this.isFolder) {			
			return this.isExpanded ? "ExpandOpen" : "ExpandClosed";
		} else {
			return "ExpandLeaf";
		}
	},
	
	viewSetExpand: function() {
		//dojo.profile.start("viewSetExpand");
		
		//dojo.debug("viewSetExpand in "+this);
		
		var expand = this.tree.classPrefix+this.viewGetExpandClass();
		var reg = new RegExp("(^|\\s)"+this.tree.classPrefix+"Expand\\w+",'g');			
			
		dojo.html.setClass(this.domNode, dojo.html.getClass(this.domNode).replace(reg,'') + ' '+expand);
		
		//dojo.debug(dojo.html.getClass(this.domNode))
		//dojo.profile.end("viewSetExpand");
		this.viewSetHasChildrenAndExpand();
	},	

	viewGetChildrenClass: function() {
		return 'Children'+(this.children.length ? 'Yes' : 'No');
	},
	
	viewSetHasChildren: function() {		
		//dojo.debug(this+' '+this.children.length)
		
		var clazz = this.tree.classPrefix+this.viewGetChildrenClass();

		var reg = new RegExp("(^|\\s)"+this.tree.classPrefix+"Children\\w+",'g');			
		
		dojo.html.setClass(this.domNode, dojo.html.getClass(this.domNode).replace(reg,'') + ' '+clazz);
		
		this.viewSetHasChildrenAndExpand();
	},
	
	/**
	 * set TreeStateChildrenYes-ExpandClosed pair
	 * needed for IE, because IE reads only last class from .TreeChildrenYes.TreeExpandClosed pair
	 */
	viewSetHasChildrenAndExpand: function() {
		var clazz = this.tree.classPrefix+'State'+this.viewGetChildrenClass()+'-'+this.viewGetExpandClass();
		
		var reg = new RegExp("(^|\\s)"+this.tree.classPrefix+"State[\\w-]+",'g');			
		
		dojo.html.setClass(this.domNode, dojo.html.getClass(this.domNode).replace(reg,'') + ' '+clazz);		
	},
		
	viewUnfocus: function() {
		dojo.html.removeClass(this.labelNode, this.tree.classPrefix+"LabelFocused");
	},
	
	viewFocus: function() {
		dojo.html.addClass(this.labelNode, this.tree.classPrefix+"LabelFocused");
	},
    
    viewEmphasize: function() {
        dojo.html.clearSelection(this.labelNode);
        
		dojo.html.addClass(this.labelNode, this.tree.classPrefix+'NodeEmphasized');
    },
    
    viewUnemphasize: function() {
        dojo.html.removeClass(this.labelNode, this.tree.classPrefix+'NodeEmphasized');
    },
	
	
// ================================ detach from parent ===================================

	detach: function() {
		if (!this.parent) return;

		var parent = this.parent;
		var index = this.getParentIndex();

		this.doDetach.apply(this, arguments);

		dojo.event.topic.publish(this.tree.eventNames.afterDetach,
			{ child: this, parent: parent, index:index }
		);
		
	},
	

	/* node does not leave tree */
	doDetach: function() {
		//dojo.debug("doDetach in "+this+" parent "+this.parent+" class "+dojo.html.getClass(this.domNode));
				
		var parent = this.parent;
		
		//dojo.debug(parent.containerNode.style.display)
		
		if (!parent) return;
		
		var index = this.getParentIndex();
		
		
		this.viewRemoveLayout();
		
		dojo.widget.DomWidget.prototype.removeChild.call(parent, this);
		
		var siblingsCount = parent.children.length;
		
		//dojo.debug("siblingsCount "+siblingsCount);
		
		if (siblingsCount > 0) {
			if (index == 0) {	// deleted first node => update new first
				parent.children[0].viewUpdateLayout();		
			}
			if (index == siblingsCount) { // deleted last node
				parent.children[siblingsCount-1].viewUpdateLayout();		
			}
		} else {
			if (parent.isTreeNode) {
				parent.viewSetHasChildren();
			}
		}
				
		if (this.tree.unsetFolderOnEmpty && !parent.children.length && parent.isTreeNode) {
			parent.unsetFolder();
		}		
		
		//dojo.debug(parent.containerNode.style.display)
		
		this.parent = null;
	},
	
	
	/**
	 * publish destruction event so that controller may unregister/unlisten
	 */
	destroy: function() {
		
		dojo.event.topic.publish(this.tree.eventNames.beforeNodeDestroy, { source: this } );
		
		this.detach();		

		return dojo.widget.HtmlWidget.prototype.destroy.apply(this, arguments);
	},
	
	
	expand: function(){
        		
		if (this.isExpanded) return;


		//dojo.profile.start("expand "+this);
		
		//dojo.debug("expand in "+this);
		
		//dojo.profile.start("expand - lazy init "+this);
		if (this.tryLazyInit) {
			this.setChildren();
			this.tryLazyInit = false;
		}
		
		//dojo.profile.end("expand - lazy init "+this);
		
		
		this.isExpanded = true;

		this.viewSetExpand();

		//dojo.profile.start("expand - showChildren "+this);
		
		/**
		 * no matter if I have children or not. need to show/hide container anyway.
		 * use case: empty folder is expanded => then child is added, container already shown all fine
		 */
		this.showChildren();
		
		//dojo.profile.end("expand - showChildren "+this);
						
		
		//dojo.profile.end("expand "+this);
	},


	collapse: function(){
						
		if (!this.isExpanded) return;
		
		this.isExpanded = false;
		
		this.hideChildren();
	},


	hideChildren: function(){
		this.tree.toggleObj.hide(
			this.containerNode, this.tree.toggleDuration, this.explodeSrc, dojo.lang.hitch(this, "onHideChildren")
		);
	},


	showChildren: function(){
		//dojo.profile.start("showChildren"+this);
        
		this.tree.toggleObj.show(
			this.containerNode, this.tree.toggleDuration, this.explodeSrc, dojo.lang.hitch(this, "onShowChildren")
		);
        
		//dojo.profile.end("showChildren"+this);
	},
	 
    
    
	onShowChildren: function() {
        
		//dojo.profile.start("onShowChildren"+this);
        
        this.onShow();
        
		//dojo.profile.end("onShowChildren"+this);
        
		dojo.event.topic.publish(this.tree.eventNames.afterExpand, {source: this} );		
	},
	
	onHideChildren: function() {

		this.viewSetExpand();
		this.onHide();
		dojo.event.topic.publish(this.tree.eventNames.afterCollapse, {source: this} );
	},

	/* Edit current node : change properties and update contents */
	setTitle: function(title) {
		var oldTitle = this.title;
		
		this.labelNode.innerHTML = this.title = title;
				
		dojo.event.topic.publish(this.tree.eventNames.afterSetTitle, { source: this, oldTitle:oldTitle });

	},


	toString: function() {
		return '['+this.widgetType+', '+this.title+']';
	}


});

/**
 * Tree model does all the drawing, visual node management etc.
 * Throws events about clicks on it, so someone may catch them and process
 * Tree knows nothing about DnD stuff, covered in TreeDragAndDrop and (if enabled) attached by controller
*/

/**
 * TODO: use domNode.cloneNode instead of createElement for grid
 * Should be faster (lyxsus)
 */
dojo.provide("dojo.widget.TreeV3");








dojo.widget.defineWidget(
	"dojo.widget.TreeV3",
	[dojo.widget.HtmlWidget, dojo.widget.TreeWithNode],
	function() {
		this.eventNames = {};
		
		this.DndAcceptTypes = [];
		this.actionsDisabled = [];
		
		this.listeners = [];
		
		this.tree = this;
	},
{
	DndMode: "",

	/**
	 * factory to generate default widgets
	 */
	defaultChildWidget: null,
	
	defaultChildTitle: "New Node", // for editing
	
	
	eagerWidgetInstantiation: false,
	
	eventNamesDefault: {

		// tree created.. Perform tree-wide actions if needed
		afterTreeCreate: "afterTreeCreate",
		beforeTreeDestroy: "beforeTreeDestroy",
		/* can't name it "beforeDestroy", because such name causes memleaks in IE */
		beforeNodeDestroy: "beforeNodeDestroy",
		afterChangeTree: "afterChangeTree",

		afterSetFolder: "afterSetFolder",
		afterUnsetFolder: "afterUnsetFolder",		
		beforeMoveFrom: "beforeMoveFrom",
		beforeMoveTo: "beforeMoveTo",
		afterMoveFrom: "afterMoveFrom",
		afterMoveTo: "afterMoveTo",
		afterAddChild: "afterAddChild",
		afterDetach: "afterDetach",
		afterExpand: "afterExpand",
		beforeExpand: "beforeExpand",
		afterSetTitle: "afterSetTitle",		
		afterCollapse: "afterCollapse",	
		beforeCollapse: "beforeCollapse"
	},

	classPrefix: "Tree",
	
	style: "",
	
	/**
	 * is it possible to add a new child to leaf ?
	 */	
	allowAddChildToLeaf: true,
	
	/**
	 * when last children is removed from node should it stop being a "folder" ?
	 */
	unsetFolderOnEmpty: true,


	DndModes: {
		BETWEEN: 1,
		ONTO: 2
	},

	DndAcceptTypes: "",

    // will have cssRoot before it 
	templateCssPath: dojo.uri.moduleUri("dojo.widget", "templates/TreeV3.css"),

	templateString: '<div style="${this.style}">\n</div>',

	isExpanded: true, // consider this "root node" to be always expanded

	isTree: true,
	
	

	createNode: function(data) {
			
		data.tree = this.widgetId;		
		
		if (data.widgetName) {
			// TODO: check if such widget has createSimple			
			return dojo.widget.createWidget(data.widgetName, data);		
		} else if (this.defaultChildWidget.prototype.createSimple) {			
			return this.defaultChildWidget.prototype.createSimple(data);					
		} else {
			var ns = this.defaultChildWidget.prototype.ns; 
			var wt = this.defaultChildWidget.prototype.widgetType; 

			return dojo.widget.createWidget(ns + ":" + wt, data); 
		}
 	    	
	},
				

	// expandNode has +- CSS background. Not img.src for performance, background src string resides in single place.
	// selection in KHTML/Mozilla disabled treewide, IE requires unselectable for every node
	// you can add unselectable if you want both in postCreate of tree and in this template

	// create new template and put into prototype
	makeNodeTemplate: function() {
		
		var domNode = document.createElement("div");
		dojo.html.setClass(domNode, this.classPrefix+"Node "+this.classPrefix+"ExpandLeaf "+this.classPrefix+"ChildrenNo");		
		this.nodeTemplate = domNode;
		
		var expandNode = document.createElement("div");
		var clazz = this.classPrefix+"Expand";
		if (dojo.render.html.ie) {
			clazz = clazz + ' ' + this.classPrefix+"IEExpand";
		}
		dojo.html.setClass(expandNode, clazz);
		
		this.expandNodeTemplate = expandNode;

		// need <span> inside <div>
		// div for multiline support, span for styling exactly the text, not whole line
		var labelNode = document.createElement("span");
		dojo.html.setClass(labelNode, this.classPrefix+"Label");
		this.labelNodeTemplate = labelNode;
		
		var contentNode = document.createElement("div");
		var clazz = this.classPrefix+"Content";
		
		/**
		 * IE<7 does not support min-height properly so I have to rely
		 * on this hack
		 * FIXME: do it in CSS only
		 */
		if (dojo.render.html.ie && !dojo.render.html.ie70) {
			clazz = clazz + ' ' + this.classPrefix+"IEContent";
		}	
		
				
		dojo.html.setClass(contentNode, clazz);
		
		this.contentNodeTemplate = contentNode;
		
		domNode.appendChild(expandNode);
		domNode.appendChild(contentNode);
		contentNode.appendChild(labelNode);
		
		
	},

	makeContainerNodeTemplate: function() {
		
		var div = document.createElement('div');
		div.style.display = 'none';			
		dojo.html.setClass(div, this.classPrefix+"Container");
		
		this.containerNodeTemplate = div;
		
	},

	
	actions: {
    	ADDCHILD: "ADDCHILD"
	},


	getInfo: function() {
		var info = {
			widgetId: this.widgetId,
			objectId: this.objectId
		}

		return info;
	},

	adjustEventNames: function() {
		
		for(var name in this.eventNamesDefault) {
			if (dojo.lang.isUndefined(this.eventNames[name])) {
				this.eventNames[name] = this.widgetId+"/"+this.eventNamesDefault[name];
			}
		}
	},

	
	adjustDndMode: function() {
		var _this = this;
		
		
		var DndMode = 0;
		dojo.lang.forEach(this.DndMode.split(';'),
			function(elem) {
				var mode = _this.DndModes[dojo.string.trim(elem).toUpperCase()];
				if (mode) DndMode = DndMode | mode;
			}
		 );
	
		
		this.DndMode = DndMode;

	},
	
	/**
	 * publish destruction event so that any listeners should stop listening
	 */
	destroy: function() {
		dojo.event.topic.publish(this.tree.eventNames.beforeTreeDestroy, { source: this } );

		return dojo.widget.HtmlWidget.prototype.destroy.apply(this, arguments);
	},

	initialize: function(args){
		
		this.domNode.widgetId = this.widgetId;
		
		for(var i=0; i<this.actionsDisabled.length;i++) {
			this.actionsDisabled[i] = this.actionsDisabled[i].toUpperCase();
		}
		
		//dojo.debug(args.defaultChildWidget ? true : false)
		
		if (!args.defaultChildWidget) {
			this.defaultChildWidget = dojo.widget.TreeNodeV3;
		} else {
			this.defaultChildWidget = dojo.lang.getObjPathValue(args.defaultChildWidget);
		}
		
		this.adjustEventNames();
		this.adjustDndMode();

		this.makeNodeTemplate();
		this.makeContainerNodeTemplate();
		
		this.containerNode = this.domNode;
		
		dojo.html.setClass(this.domNode, this.classPrefix+"Container");
		
		var _this = this;
			
		//dojo.html.disableSelection(this.domNode)
				
		dojo.lang.forEach(this.listeners,
			function(elem) {
				var t = dojo.lang.isString(elem) ? dojo.widget.byId(elem) : elem;
				t.listenTree(_this)				
			}
		);
		

		
		

	},

	
	postCreate: function() {						
		dojo.event.topic.publish(this.eventNames.afterTreeCreate, { source: this } );
	},
	
	
	/**
	 * Move child to newParent as last child
	 * redraw tree and update icons.
	 *
	 * Called by target, saves source in event.
	 * events are published for BOTH trees AFTER update.
	*/
	move: function(child, newParent, index) {
		
		if (!child.parent) {
			dojo.raise(this.widgetType+": child can be moved only while it's attached");
		}
		
		var oldParent = child.parent;
		var oldTree = child.tree;
		var oldIndex = child.getParentIndex();
		var newTree = newParent.tree;
		var newParent = newParent;
		var newIndex = index;

		var message = {
				oldParent: oldParent, oldTree: oldTree, oldIndex: oldIndex,
				newParent: newParent, newTree: newTree, newIndex: newIndex,
				child: child
		};

		dojo.event.topic.publish(oldTree.eventNames.beforeMoveFrom, message);
		dojo.event.topic.publish(newTree.eventNames.beforeMoveTo, message);
		
		this.doMove.apply(this, arguments);

		
		/* publish events here about structural changes for both source and target trees */
		dojo.event.topic.publish(oldTree.eventNames.afterMoveFrom, message);
		dojo.event.topic.publish(newTree.eventNames.afterMoveTo, message);

	},


	/* do actual parent change here. Write remove child first */
	doMove: function(child, newParent, index) {
		//dojo.debug("MOVE "+child+" to "+newParent+" at "+index);

		//var parent = child.parent;
		child.doDetach();

		//dojo.debug("addChild "+child+" to "+newParent+" at "+index);

		newParent.doAddChild(child, index);
	},

	toString: function() {
		return "["+this.widgetType+" ID:"+this.widgetId	+"]"
	}

});


dojo.provide("dojo.widget.TreeTimeoutIterator");








/**
 * Iterates the tree processNext
 * filterFunc/filterObj called to determine if I need to pass the node
 * 
 * callFunc/callObj called to process the node
 *    callObj.callFunc(elem, iterator) should call iterator.forward() to go on
 *    callFunc may change elem to another object (e.g create widget from it),
 *       keeping its parent and parent position are untouched *
 *
 * finishFunc/finishObj called at the end
 *
 * TODO: it should work only sync-way to solve CPU-hungry tasks 
 */
 dojo.declare(
 	"dojo.widget.TreeTimeoutIterator",
 	null,
 	
function(elem, callFunc, callObj) {
	var _this = this;
	
	this.currentParent = elem;
	
	this.callFunc = callFunc;
	this.callObj = callObj ? callObj: this;
	this.stack = [];	
},

{
	// public
	maxStackDepth: Number.POSITIVE_INFINITY,
	
	stack: null,
	currentParent: null,
		
	currentIndex: 0,
	
	filterFunc: function() { return true },
	
	finishFunc: function() { return true },
	
	
	setFilter: function(func, obj) {
		this.filterFunc = func;
		this.filterObj = obj;
	},
	
	
	setMaxLevel: function(level) {
		this.maxStackDepth = level-2;
	},
	
	forward: function(timeout) {
		var _this = this;
		
		if (this.timeout) { // if timeout required between forwards
			// tid will be assigned at the end of outer func execution
			var tid = setTimeout(function() {_this.processNext(); clearTimeout(tid); }, _this.timeout);
		} else {
			return this.processNext();
		}
	},
	
	start: function(processFirst) {
		if (processFirst) {			
			return this.callFunc.call(this.callObj, this.currentParent, this);			
		}
				
		return this.processNext();
	},
	
	/**
	 * @private
	 * find next node, move current parent to it if possible & process
	 */
	processNext: function() {
				
		//dojo.debug("processNext with currentParent "+this.currentParent+" index "+this.currentIndex);
		var handler;
		
		var _this = this;
		
		var found;
		
		var next;
			
		if (this.maxStackDepth == -2) {   
			return; // process only first cause level=0, do not process children
		}
		
		while (true) {
			var children = this.currentParent.children;
		
			if (children && children.length) {
		
				// look for a node that can be the next target
				do {					
					next = children[this.currentIndex];
					//dojo.debug("check "+next);
				} while (this.currentIndex++ < children.length && !(found = this.filterFunc.call(this.filterObj,next)));
			
			
				if (found) {
					//dojo.debug("found "+next);
					// move to next node as new parent if depth is fine
					// I can't check current children to decide whether to move it or not,
					// because expand may populate children					
					if (next.isFolder && this.stack.length <= this.maxStackDepth) {
						this.moveParent(next,0);
					}
					//dojo.debug("Run callFunc on "+next);
					return this.callFunc.call(this.callObj, next, this);					
				}
			}
				
			if (this.stack.length) {
				this.popParent();
				continue;
			}
			
			break;
		}

		/**
		 * couldn't find next node to process, finish here
		 */
		return this.finishFunc.call(this.finishObj);

	},
	
	setFinish: function(func, obj) {
		this.finishFunc = func;
		this.finishObj = obj;
	},
		
	popParent: function() {
		var p = this.stack.pop();
		//dojo.debug("Pop "+p[0]+":"+p[1]);		
		this.currentParent = p[0];
		this.currentIndex = p[1];
	},
	
	moveParent: function(nextParent, nextIndex) {
		//dojo.debug("Move from "+this.currentParent+":"+this.currentIndex+" to "+nextParent+":"+nextIndex);
		this.stack.push([this.currentParent, this.currentIndex]);
		this.currentParent = nextParent;
		this.currentIndex = nextIndex;
	}

});


dojo.provide("dojo.widget.TreeBasicControllerV3");








dojo.widget.defineWidget(
	"dojo.widget.TreeBasicControllerV3",
	[dojo.widget.HtmlWidget, dojo.widget.TreeCommon],
	function(){
		this.listenedTrees = {};
	},
{
	// TODO: do something with addChild / setChild, so that RpcController become able
	// to hook on this and report to server
	
	// TODO: make sure keyboard control stuff works when node is moved between trees
	// node should be unfocus()'ed when it its ancestor is moved and tree,lastFocus - cleared

	/**
	 * TreeCommon.listenTree will attach listeners to these events
	 *
	 * The logic behind the naming:
	 * 1. (after|before)
	 * 2. if an event refers to tree, then add "Tree"
	 * 3. add action
	 */
	listenTreeEvents: ["afterSetFolder", "afterTreeCreate", "beforeTreeDestroy"],
	listenNodeFilter: function(elem) { return elem instanceof dojo.widget.Widget},	
		
		
	editor: null,

	
	initialize: function(args) {
		if (args.editor) {
			this.editor = dojo.widget.byId(args.editor);
			this.editor.controller = this;
		}
		
	},
		
	
	getInfo: function(elem) {
		return elem.getInfo();
	},

	onBeforeTreeDestroy: function(message) {
                this.unlistenTree(message.source);
	},

	onAfterSetFolder: function(message) {
		
		//dojo.profile.start("onTreeChange");
        
		if (message.source.expandLevel > 0) {
			this.expandToLevel(message.source, message.source.expandLevel);				
		}
		if (message.source.loadLevel > 0) {
			this.loadToLevel(message.source, message.source.loadLevel);				
		}
			
		
		//dojo.profile.end("onTreeChange");
	},
	

	// down arrow
	_focusNextVisible: function(nodeWidget) {
		
		// if this is an expanded folder, get the first child
		if (nodeWidget.isFolder && nodeWidget.isExpanded && nodeWidget.children.length > 0) {
			returnWidget = nodeWidget.children[0];			
		} else {
			// find a parent node with a sibling
			while (nodeWidget.isTreeNode && nodeWidget.isLastChild()) {
				nodeWidget = nodeWidget.parent;
			}
			
			if (nodeWidget.isTreeNode) {
				var returnWidget = nodeWidget.parent.children[nodeWidget.getParentIndex()+1];				
			}
			
		}
				
		if (returnWidget && returnWidget.isTreeNode) {
			this._focusLabel(returnWidget);
			return returnWidget;
		}
		
	},
	
	// up arrow
	_focusPreviousVisible: function(nodeWidget) {
		var returnWidget = nodeWidget;
		
		// if younger siblings		
		if (!nodeWidget.isFirstChild()) {
			var previousSibling = nodeWidget.parent.children[nodeWidget.getParentIndex()-1]

			nodeWidget = previousSibling;
			// if the previous nodeWidget is expanded, dive in deep
			while (nodeWidget.isFolder && nodeWidget.isExpanded && nodeWidget.children.length > 0) {
				returnWidget = nodeWidget;
				// move to the last child
				nodeWidget = nodeWidget.children[nodeWidget.children.length-1];
			}
		} else {
			// if this is the first child, return the parent
			nodeWidget = nodeWidget.parent;
		}
		
		if (nodeWidget && nodeWidget.isTreeNode) {
			returnWidget = nodeWidget;
		}
		
		if (returnWidget && returnWidget.isTreeNode) {
			this._focusLabel(returnWidget);
			return returnWidget;
		}
		
	},
	
	// right arrow
	_focusZoomIn: function(nodeWidget) {
		var returnWidget = nodeWidget;
		
		// if not expanded, expand, else move to 1st child
		if (nodeWidget.isFolder && !nodeWidget.isExpanded) {
			this.expand(nodeWidget);
		}else if (nodeWidget.children.length > 0) {
			nodeWidget = nodeWidget.children[0];
		}
		
		if (nodeWidget && nodeWidget.isTreeNode) {
			returnWidget = nodeWidget;
		}
		
		if (returnWidget && returnWidget.isTreeNode) {
			this._focusLabel(returnWidget);
			return returnWidget;
		}
		
	},
	
	// left arrow
	_focusZoomOut: function(node) {
		
		var returnWidget = node;
		
		// if not expanded, expand, else move to 1st child
		if (node.isFolder && node.isExpanded) {
			this.collapse(node);
		} else {
			node = node.parent;
		}
		if (node && node.isTreeNode) {
			returnWidget = node;
		}
		
		if (returnWidget && returnWidget.isTreeNode) {
			this._focusLabel(returnWidget);
			return returnWidget;
		}
		
	},
	
	onFocusNode: function(e) {
		var node = this.domElement2TreeNode(e.target);
		
		if (node) {
			node.viewFocus();			
			dojo.event.browser.stopEvent(e);
		}
	},
	
	onBlurNode: function(e) {
		var node = this.domElement2TreeNode(e.target);
		
		if (!node) {
			return;
		}
		
		var labelNode = node.labelNode;
		
		labelNode.setAttribute("tabIndex", "-1");
		node.viewUnfocus();		
		dojo.event.browser.stopEvent(e);
		
		// this could have been set to -1 by the shift+TAB processing
		node.tree.domNode.setAttribute("tabIndex", "0");
		
	},
	
	
	_focusLabel: function(node) {
		//dojo.debug((new Error()).stack)		
		var lastFocused = node.tree.lastFocused;
		var labelNode;
		
		if (lastFocused && lastFocused.labelNode) {
			labelNode = lastFocused.labelNode;
			// help Opera out with blur events
			dojo.event.disconnect(labelNode, "onblur", this, "onBlurNode");
			labelNode.setAttribute("tabIndex", "-1");
			dojo.html.removeClass(labelNode, "TreeLabelFocused");
		}
		
		// set tabIndex so that the tab key can find this node
		labelNode = node.labelNode;
		labelNode.setAttribute("tabIndex", "0");
		node.tree.lastFocused = node;
		
		// add an outline - this helps opera a lot
		dojo.html.addClass(labelNode, "TreeLabelFocused");
		dojo.event.connectOnce(labelNode, "onblur", this, "onBlurNode");
		// prevent the domNode from seeing the focus event
		dojo.event.connectOnce(labelNode, "onfocus", this, "onFocusNode");
		// set focus so that the label wil be voiced using screen readers
		labelNode.focus();
			
	},
	
	onKey: function(e) {
		if (!e.key || e.ctrkKey || e.altKey) { return; }
		// pretend the key was directed toward the current focused node (helps opera out)
		
		var nodeWidget = this.domElement2TreeNode(e.target);
		if (!nodeWidget) {
			return;
		}
		
		var treeWidget = nodeWidget.tree;
		
		if (treeWidget.lastFocused && treeWidget.lastFocused.labelNode) {
			nodeWidget = treeWidget.lastFocused;
		}
		
		switch(e.key) {
			case e.KEY_TAB:
				if (e.shiftKey) {
					// we're moving backwards so don't tab to the domNode
					// it'll be added back in onBlurNode
					treeWidget.domNode.setAttribute("tabIndex", "-1");
				}
				break;
			case e.KEY_RIGHT_ARROW:
				this._focusZoomIn(nodeWidget);
				dojo.event.browser.stopEvent(e);
				break;
			case e.KEY_LEFT_ARROW:
				this._focusZoomOut(nodeWidget);
				dojo.event.browser.stopEvent(e);
				break;
			case e.KEY_UP_ARROW:
				this._focusPreviousVisible(nodeWidget);
				dojo.event.browser.stopEvent(e);
				break;
			case e.KEY_DOWN_ARROW:
				this._focusNextVisible(nodeWidget);
				dojo.event.browser.stopEvent(e);
				break;
		}
	},
	
	
	onFocusTree: function(e) {
		if (!e.currentTarget) { return; }
		try {
			var treeWidget = this.getWidgetByNode(e.currentTarget);
			if (!treeWidget || !treeWidget.isTree) { return; }
			// on first focus, choose the root node
			var nodeWidget = this.getWidgetByNode(treeWidget.domNode.firstChild);
			if (nodeWidget && nodeWidget.isTreeNode) {
				if (treeWidget.lastFocused && treeWidget.lastFocused.isTreeNode) { // onClick could have chosen a non-root node
					nodeWidget = treeWidget.lastFocused;
				}
				this._focusLabel(nodeWidget);
			}
		}
		catch(e) {}
	},

	// perform actions-initializers for tree
	onAfterTreeCreate: function(message) {
		var tree = message.source;
		dojo.event.browser.addListener(tree.domNode, "onKey", dojo.lang.hitch(this, this.onKey));
		dojo.event.browser.addListener(tree.domNode, "onmousedown", dojo.lang.hitch(this, this.onTreeMouseDown));
		dojo.event.browser.addListener(tree.domNode, "onclick", dojo.lang.hitch(this, this.onTreeClick));
		dojo.event.browser.addListener(tree.domNode, "onfocus", dojo.lang.hitch(this, this.onFocusTree));
		tree.domNode.setAttribute("tabIndex", "0");
		
		if (tree.expandLevel) {								
			this.expandToLevel(tree, tree.expandLevel)
		}
		if (tree.loadLevel) {
			this.loadToLevel(tree, tree.loadLevel);
		}
	},

    onTreeMouseDown: function(e) {
    },

	onTreeClick: function(e){
		//dojo.profile.start("onTreeClick");
		
		var domElement = e.target;
		//dojo.debug('click')
		// find node
        var node = this.domElement2TreeNode(domElement);		
		if (!node || !node.isTreeNode) {
			return;
		}
		
		
		var checkExpandClick = function(el) {
			return el === node.expandNode;
		}
		
		if (this.checkPathCondition(domElement, checkExpandClick)) {
			this.processExpandClick(node);			
		}
		
		this._focusLabel(node);
		
		//dojo.profile.end("onTreeClick");
		
	},
	
	processExpandClick: function(node){
		
		//dojo.profile.start("processExpandClick");
		
		if (node.isExpanded){
			this.collapse(node);
		} else {
			this.expand(node);
		}
		
		//dojo.profile.end("processExpandClick");
	},
		
	
	
	/**
	 * time between expand calls for batch operations
	 * @see expandToLevel
	 */
	batchExpandTimeout: 20,
	
	
	expandAll: function(nodeOrTree) {		
		return this.expandToLevel(nodeOrTree, Number.POSITIVE_INFINITY);
		
	},
	
	
	collapseAll: function(nodeOrTree) {
		var _this = this;
		
		var filter = function(elem) {
			return (elem instanceof dojo.widget.Widget) && elem.isFolder && elem.isExpanded;
		}
		
		if (nodeOrTree.isTreeNode) {		
			this.processDescendants(nodeOrTree, filter, this.collapse);
		} else if (nodeOrTree.isTree) {
			dojo.lang.forEach(nodeOrTree.children,function(c) { _this.processDescendants(c, filter, _this.collapse) });
		}
	},
	
	/**
	 * expand tree to specific node
	 */
	expandToNode: function(node, withSelected) {
		n = withSelected ? node : node.parent
		s = []
		while (!n.isExpanded) {
			s.push(n)
			n = n.parent
		}
				
		dojo.lang.forEach(s, function(n) { n.expand() })
	},
		
	/**
	 * walk a node in time, forward order, with pauses between expansions
	 */
	expandToLevel: function(nodeOrTree, level) {
		
		
		var _this = this;
		var filterFunc = function(elem) {
			var res = elem.isFolder || elem.children && elem.children.length;
			//dojo.debug("Filter "+elem+ " result:"+res);
			return res;
		};
		var callFunc = function(node, iterator) {			
			 _this.expand(node, true);
			 iterator.forward();
		}
			
		var iterator = new dojo.widget.TreeTimeoutIterator(nodeOrTree, callFunc, this);
		iterator.setFilter(filterFunc);
		
		
		iterator.timeout = this.batchExpandTimeout;
		
		//dojo.debug("here "+nodeOrTree+" level "+level);
		
		iterator.setMaxLevel(nodeOrTree.isTreeNode ? level-1 : level);
		
		
		return iterator.start(nodeOrTree.isTreeNode);
	},
	

	getWidgetByNode: function(node) {
		var widgetId;
		var newNode = node;
		while (! (widgetId = newNode.widgetId) ) {
			newNode = newNode.parentNode;
			if (newNode == null) { break; }
		}
		if (widgetId) { return dojo.widget.byId(widgetId); }
		else if (node == null) { return null; }
		else{ return dojo.widget.manager.byNode(node); }
	},



	/**
	 * callout activated even if node is expanded already
	 */
	expand: function(node) {
		
		//dojo.profile.start("expand");
		
		//dojo.debug("Expand "+node.isFolder);
		
		if (node.isFolder) {			
			node.expand(); // skip trees or non-folders
		}		
		
		//dojo.profile.end("expand");
				
	},

	/**
	 * safe to call on tree and non-folder
	 */
	collapse: function(node) {
		if (node.isFolder) {
			node.collapse();
		}
	},
	
	
	// -------------------------- TODO: Inline edit node ---------------------
	canEditLabel: function(node) {
		if (node.actionIsDisabledNow(node.actions.EDIT)) return false;

		return true;
	},
	
		
	editLabelStart: function(node) {		
		if (!this.canEditLabel(node)) {
			return false;
		}
		
		if (!this.editor.isClosed()) {
			//dojo.debug("editLabelStart editor open");
			this.editLabelFinish(this.editor.saveOnBlur);			
		}
				
		this.doEditLabelStart(node);
		
	
	},
	
	
	editLabelFinish: function(save) {
		this.doEditLabelFinish(save);		
	},
	
	
	doEditLabelStart: function(node) {
		if (!this.editor) {
			dojo.raise(this.widgetType+": no editor specified");
		}
		
		//dojo.debug("editLabelStart editor open "+node);
		
		this.editor.open(node);
	},
	
	doEditLabelFinish: function(save, server_data) {
		//dojo.debug("Finish "+save);
		//dojo.debug((new Error()).stack)
		if (!this.editor) {
			dojo.raise(this.widgetType+": no editor specified");
		}

		var node = this.editor.node;	
		var editorTitle = this.editor.getContents();
		
		this.editor.close(save);

		if (save) {
			var data = {title:editorTitle};
			
			if (server_data) { // may be undefined
				dojo.lang.mixin(data, server_data);
			}
			
			
			if (node.isPhantom) {			
				// I can't just set node phantom's title, because widgetId/objectId/widgetName...
				// may be provided by server
				var parent = node.parent;
				var index = node.getParentIndex();				
				node.destroy();
				// new node was added!
				dojo.widget.TreeBasicControllerV3.prototype.doCreateChild.call(this, parent, index, data);
			} else {
				var title = server_data && server_data.title ? server_data.title : editorTitle;
				// use special method to make sure everything updated and event sent
				node.setTitle(title); 
			}
		} else {
			//dojo.debug("Kill phantom on cancel");
			if (node.isPhantom) {
				node.destroy();
			}
		}
	},
	
	
		
	makeDefaultNode: function(parent, index) {
		var data = {title:parent.tree.defaultChildTitle};
		return dojo.widget.TreeBasicControllerV3.prototype.doCreateChild.call(this,parent,index,data);
	},
	
	/**
	 * check that something is possible
	 * run maker to do it
	 * run exposer to expose result to visitor immediatelly
	 *   exposer does not affect result
	 */
	runStages: function(check, prepare, make, finalize, expose, args) {
		
		if (check && !check.apply(this, args)) {
			return false;
		}
		
		if (prepare && !prepare.apply(this, args)) {
			return false;
		}
		
		var result = make.apply(this, args);
		
		
		if (finalize) {
			finalize.apply(this,args);			
		}
			
		if (!result) {
			return result;
		}
		
			
		if (expose) {
			expose.apply(this, args);
		}
		
		return result;
	}
});


// create and edit
dojo.lang.extend(dojo.widget.TreeBasicControllerV3, {
		
	createAndEdit: function(parent, index) {
		var data = {title:parent.tree.defaultChildTitle};
		
		if (!this.canCreateChild(parent, index, data)) {
			return false;
		}
		
		var child = this.doCreateChild(parent, index, data);
		if (!child) return false;
		this.exposeCreateChild(parent, index, data);
		
		child.isPhantom = true;
		
		if (!this.editor.isClosed()) {
			//dojo.debug("editLabelStart editor open");
			this.editLabelFinish(this.editor.saveOnBlur);			
		}
		
		
				
		this.doEditLabelStart(child);		
	
	}
	
});


// =============================== clone ============================
dojo.lang.extend(dojo.widget.TreeBasicControllerV3, {
	
	canClone: function(child, newParent, index, deep){
		return true;
	},
	
	
	clone: function(child, newParent, index, deep) {
		return this.runStages(
			this.canClone, this.prepareClone, this.doClone, this.finalizeClone, this.exposeClone, arguments
		);			
	},

	exposeClone: function(child, newParent) {
		if (newParent.isTreeNode) {
			this.expand(newParent);
		}
	},

	doClone: function(child, newParent, index, deep) {
		//dojo.debug("Clone "+child);
		var cloned = child.clone(deep);
		newParent.addChild(cloned, index);
				
		return cloned;
	}
	

});

// =============================== detach ============================

dojo.lang.extend(dojo.widget.TreeBasicControllerV3, {
	canDetach: function(child) {
		if (child.actionIsDisabledNow(child.actions.DETACH)) {
			return false;
		}

		return true;
	},


	detach: function(node) {
		return this.runStages(
			this.canDetach, this.prepareDetach, this.doDetach, this.finalizeDetach, this.exposeDetach, arguments
		);			
	},


	doDetach: function(node, callObj, callFunc) {
		node.detach();
	}
	
});


// =============================== destroy ============================
dojo.lang.extend(dojo.widget.TreeBasicControllerV3, {

	canDestroyChild: function(child) {
		
		if (child.parent && !this.canDetach(child)) {
			return false;
		}
		return true;
	},


	destroyChild: function(node) {
		return this.runStages(
			this.canDestroyChild, this.prepareDestroyChild, this.doDestroyChild, this.finalizeDestroyChild, this.exposeDestroyChild, arguments
		);			
	},


	doDestroyChild: function(node) {
		node.destroy();
	}
	
});



// =============================== move ============================

dojo.lang.extend(dojo.widget.TreeBasicControllerV3, {

	/**
	 * check for non-treenodes
	 */
	canMoveNotANode: function(child, parent) {
		if (child.treeCanMove) {
			return child.treeCanMove(parent);
		}
		
		return true;
	},

	/**
	 * Checks whether it is ok to change parent of child to newParent
	 * May incur type checks etc
	 *
	 * It should check only hierarchical possibility w/o index, etc
	 * because in onDragOver event for Between Dnd mode we can't calculate index at once on onDragOVer.
	 * index changes as client moves mouse up-down over the node
	 */
	canMove: function(child, newParent){
		if (!child.isTreeNode) {
			return this.canMoveNotANode(child, newParent);
		}
						
		if (child.actionIsDisabledNow(child.actions.MOVE)) {
			return false;
		}

		// if we move under same parent then no matter if ADDCHILD disabled for him
		// but if we move to NEW parent then check if action is disabled for him
		// also covers case for newParent being a non-folder in strict mode etc
		if (child.parent !== newParent && newParent.actionIsDisabledNow(newParent.actions.ADDCHILD)) {
			return false;
		}

		// Can't move parent under child. check whether new parent is child of "child".
		var node = newParent;
		while(node.isTreeNode) {
			//dojo.debugShallow(node.title)
			if (node === child) {
				// parent of newParent is child
				return false;
			}
			node = node.parent;
		}

		return true;
	},


	move: function(child, newParent, index/*,...*/) {
		return this.runStages(this.canMove, this.prepareMove, this.doMove, this.finalizeMove, this.exposeMove, arguments);			
	},

	doMove: function(child, newParent, index) {
		//dojo.debug("MOVE "+child);
		child.tree.move(child, newParent, index);

		return true;
	},
	
	exposeMove: function(child, newParent) {		
		if (newParent.isTreeNode) {
			this.expand(newParent);
		}
	}
		

});

dojo.lang.extend(dojo.widget.TreeBasicControllerV3, {

	// -----------------------------------------------------------------------------
	//                             Create node stuff
	// -----------------------------------------------------------------------------


	canCreateChild: function(parent, index, data) {
		if (parent.actionIsDisabledNow(parent.actions.ADDCHILD)) {
			return false;
		}

		return true;
	},


	/* send data to server and add child from server */
	/* data may contain an almost ready child, or anything else, suggested to server */
	/*in Rpc controllers server responds with child data to be inserted */
	createChild: function(parent, index, data) {
		if(!data) {
			data = {title:parent.tree.defaultChildTitle};
		}
		return this.runStages(this.canCreateChild, this.prepareCreateChild, this.doCreateChild, this.finalizeCreateChild, this.exposeCreateChild,
			[parent, index, data]);		
	},

	prepareCreateChild: function() { return true; },
	finalizeCreateChild: function() {},

	doCreateChild: function(parent, index, data) {
		//dojo.debug("doCreateChild parent "+parent+" index "+index+" data "+data);
		
		var newChild = parent.tree.createNode(data); 
		//var newChild = dojo.widget.createWidget(widgetType, data);

		parent.addChild(newChild, index);

		return newChild;
	},
	
	exposeCreateChild: function(parent) {
		return this.expand(parent);
	}


});


dojo.provide("dojo.widget.TreeSelectorV3");




dojo.widget.defineWidget(
	"dojo.widget.TreeSelectorV3",
	[dojo.widget.HtmlWidget, dojo.widget.TreeCommon],
	function() {
		this.eventNames = {};
		this.listenedTrees = {};
		this.selectedNodes = [];
		this.lastClicked = {}
	},
{
	// TODO: add multiselect

	listenTreeEvents: ["afterTreeCreate","afterCollapse","afterChangeTree", "afterDetach", "beforeTreeDestroy"],
	listenNodeFilter: function(elem) { return elem instanceof dojo.widget.Widget},	
	
	allowedMulti: true,
	
	/**
	* if time between clicks < dblselectTimeout => its dblselect
	*/
	dblselectTimeout: 300,
	
	eventNamesDefault: {
		select : "select",
		deselect : "deselect",
		dblselect: "dblselect" // select already selected node.. Edit or whatever
	},

	onAfterTreeCreate: function(message) {
		var tree = message.source;
		dojo.event.browser.addListener(tree.domNode, "onclick", dojo.lang.hitch(this, this.onTreeClick));
		if (dojo.render.html.ie) {
			dojo.event.browser.addListener(tree.domNode, "ondblclick", dojo.lang.hitch(this, this.onTreeDblClick));
		}
		dojo.event.browser.addListener(tree.domNode, "onKey", dojo.lang.hitch(this, this.onKey));
		
	},
	
	
	onKey: function(e) {
		if (!e.key || e.ctrkKey || e.altKey) { return; }
		
		switch(e.key) {
			case e.KEY_ENTER:
				var node = this.domElement2TreeNode(e.target);
				if (node) {
					this.processNode(node, e);
				}
		
		}
	},
	
	
		
	onAfterChangeTree: function(message) {
		
		if (!message.oldTree && message.node.selected) {
			this.select(message.node);
		}
		
		if (!message.newTree || !this.listenedTrees[message.newTree.widgetId]) {
			// moving from our trfee to new one that we don't listen
			
			if (this.selectedNode && message.node.children) {
				this.deselectIfAncestorMatch(message.node);
			}						
			
		}
		
		
	},
		
		
		
	initialize: function(args) {

		for(var name in this.eventNamesDefault) {
			if (dojo.lang.isUndefined(this.eventNames[name])) {
				this.eventNames[name] = this.widgetId+"/"+this.eventNamesDefault[name];
			}
		}
				
	},

	onBeforeTreeDestroy: function(message) {
		this.unlistenTree(message.source);
	},

	// deselect node if ancestor is collapsed
	onAfterCollapse: function(message) {		
		this.deselectIfAncestorMatch(message.source);		
	},

	// IE will throw select -> dblselect. Need to transform to select->select
	onTreeDblClick: function(event) {
		this.onTreeClick(event);			
	},		
		
	checkSpecialEvent: function(event) {		
		return event.shiftKey || event.ctrlKey;
	},
	
	
	onTreeClick: function(event) {		
		
		var node = this.domElement2TreeNode(event.target);
				
		if (!node) {
			return;
		}
		
		
		
		var checkLabelClick = function(domElement) {
			return domElement === node.labelNode;
		}
		
		if (this.checkPathCondition(event.target, checkLabelClick)) {
			this.processNode(node, event);			
		}
		
		
	},
	
	
	/**
	 * press on selected with ctrl => deselect it
	 * press on selected w/o ctrl => dblselect it and deselect all other
	 *
	 * press on unselected with ctrl => add it to selection
	 *
	 * event may be both mouse & keyboard enter
	 */
	processNode: function(node, event) {
		
		if (node.actionIsDisabled(node.actions.SELECT)) {
			return;
		}
		
		//dojo.debug("click "+node+ "special "+this.checkSpecialEvent(event));		
		
		if (dojo.lang.inArray(this.selectedNodes, node)) {
				
			if(this.checkSpecialEvent(event)){				
				// If the node is currently selected, and they select it again while holding
				// down a meta key, it deselects it
				this.deselect(node);
				return;
			}
			
			var _this = this;
			var i=0;
			var selectedNode;
			
			/* remove all nodes from selection excepts this one */
			while(this.selectedNodes.length > i) {
				selectedNode = this.selectedNodes[i];
				if (selectedNode !== node) {
					//dojo.debug("Deselect "+selectedNode);
					this.deselect(selectedNode);
					continue;
				}
			
				i++; // skip the doubleclicked node
			}
		
			/* lastClicked.node may be undefined if node was selected(before) programmatically */
			var wasJustClicked = this.checkRecentClick(node)
			
			eventName = wasJustClicked ? this.eventNames.dblselect : this.eventNames.select;
			if (wasJustClicked) {
				eventName = this.eventNames.dblselect;
				/* after dblselect, next select is usual select */
				this.forgetLastClicked();
			} else {
				eventName = this.eventNames.select;
				this.setLastClicked(node)
			}
			
			dojo.event.topic.publish(eventName, { node: node });
			
			return;
		}
		
		/* if unselected node..	*/
		
		this.deselectIfNoMulti(event);
		
		//dojo.debug("select");
		
		this.setLastClicked(node);
		
		this.select(node);

	},
	
	forgetLastClicked: function() {
		this.lastClicked = {}
	},
	
	setLastClicked: function(node) {
		this.lastClicked.date = new Date();	
		this.lastClicked.node = node;
	},
	
	checkRecentClick: function(node) {
		var diff = new Date() - this.lastClicked.date;
		//dojo.debug(new Date())
		//dojo.debug("check old "+this.lastClicked.node+" now "+(new Date())+" diff "+diff)
		if (this.lastClicked.node && diff < this.dblselectTimeout) {
			return true;
		} else {
			return false;
		}
	},
	
	// deselect all if no meta key or disallowed
	deselectIfNoMulti: function(event) {
		if (!this.checkSpecialEvent(event) || !this.allowedMulti) {
			//dojo.debug("deselect All");
			this.deselectAll();
		}
	},

	deselectIfAncestorMatch: function(ancestor) {
		/* deselect all nodes with this ancestor */
		var _this = this;
		dojo.lang.forEach(this.selectedNodes, function(node) {
			var selectedNode = node;
			node = node.parent
			while (node && node.isTreeNode) {
				//dojo.debug("ancestor try "+node);
				
				if (node === ancestor) {
					_this.deselect(selectedNode); 
					return;					
				}
				node = node.parent;
			}
		});
	},
	
			


	onAfterDetach: function(message) {
		this.deselectIfAncestorMatch(message.child);		
	},


	select: function(node) {

		var index = dojo.lang.find(this.selectedNodes, node, true);
		
		if (index >=0 ) {
			return; // already selected
		}
				
		//dojo.debug("select "+node);
		this.selectedNodes.push(node);
						
		dojo.event.topic.publish(this.eventNames.select, {node: node} );
	},


	deselect: function(node){
		var index = dojo.lang.find(this.selectedNodes, node, true);
		if (index < 0) {
			//dojo.debug("not selected");
			return; // not selected
		}
		
		//dojo.debug("deselect "+node);
		//dojo.debug((new Error()).stack);
		
		this.selectedNodes.splice(index, 1);
		dojo.event.topic.publish(this.eventNames.deselect, {node: node} );
		//dojo.debug("deselect");

	},
	
	deselectAll: function() {
		//dojo.debug("deselect all "+this.selectedNodes);
		while (this.selectedNodes.length) {
			this.deselect(this.selectedNodes[0]);
		}
	}

});





dojo.provide("dojo.widget.TreeEmphasizeOnSelect");





// selector extension to emphasize node

dojo.widget.defineWidget(
	"dojo.widget.TreeEmphasizeOnSelect",
	dojo.widget.HtmlWidget,
{
	selector: "",
	
	initialize: function() {
		this.selector = dojo.widget.byId(this.selector);
		
		dojo.event.topic.subscribe(this.selector.eventNames.select, this, "onSelect");
		dojo.event.topic.subscribe(this.selector.eventNames.deselect, this, "onDeselect");	
	},

	
	onSelect: function(message) {
		message.node.viewEmphasize()		
	},
	
	onDeselect: function(message) {
		message.node.viewUnemphasize()
	}
	

});

dojo.provide("dojo.Deferred");


dojo.Deferred = function(/*Function?*/ canceller){
	/*
	NOTE: this namespace and documentation are imported wholesale 
		from MochiKit

	Encapsulates a sequence of callbacks in response to a value that
	may not yet be available.  This is modeled after the Deferred class
	from Twisted <http://twistedmatrix.com>.

	Why do we want this?  JavaScript has no threads, and even if it did,
	threads are hard.  Deferreds are a way of abstracting non-blocking
	events, such as the final response to an XMLHttpRequest.

	The sequence of callbacks is internally represented as a list
	of 2-tuples containing the callback/errback pair.  For example,
	the following call sequence::

		var d = new Deferred();
		d.addCallback(myCallback);
		d.addErrback(myErrback);
		d.addBoth(myBoth);
		d.addCallbacks(myCallback, myErrback);

	is translated into a Deferred with the following internal
	representation::

		[
			[myCallback, null],
			[null, myErrback],
			[myBoth, myBoth],
			[myCallback, myErrback]
		]

	The Deferred also keeps track of its current status (fired).
	Its status may be one of three things:

		-1: no value yet (initial condition)
		0: success
		1: error

	A Deferred will be in the error state if one of the following
	three conditions are met:

		1. The result given to callback or errback is "instanceof" Error
		2. The previous callback or errback raised an exception while
		   executing
		3. The previous callback or errback returned a value "instanceof"
			Error

	Otherwise, the Deferred will be in the success state.  The state of
	the Deferred determines the next element in the callback sequence to
	run.

	When a callback or errback occurs with the example deferred chain,
	something equivalent to the following will happen (imagine that
	exceptions are caught and returned)::

		// d.callback(result) or d.errback(result)
		if(!(result instanceof Error)){
			result = myCallback(result);
		}
		if(result instanceof Error){
			result = myErrback(result);
		}
		result = myBoth(result);
		if(result instanceof Error){
			result = myErrback(result);
		}else{
			result = myCallback(result);
		}

	The result is then stored away in case another step is added to the
	callback sequence.	Since the Deferred already has a value available,
	any new callbacks added will be called immediately.

	There are two other "advanced" details about this implementation that
	are useful:

	Callbacks are allowed to return Deferred instances themselves, so you
	can build complicated sequences of events with ease.

	The creator of the Deferred may specify a canceller.  The canceller
	is a function that will be called if Deferred.cancel is called before
	the Deferred fires.	 You can use this to implement clean aborting of
	an XMLHttpRequest, etc.	 Note that cancel will fire the deferred with
	a CancelledError (unless your canceller returns another kind of
	error), so the errbacks should be prepared to handle that error for
	cancellable Deferreds.

	*/
	
	this.chain = [];
	this.id = this._nextId();
	this.fired = -1;
	this.paused = 0;
	this.results = [null, null];
	this.canceller = canceller;
	this.silentlyCancelled = false;
};

dojo.lang.extend(dojo.Deferred, {
	getFunctionFromArgs: function(){
		var a = arguments;
		if((a[0])&&(!a[1])){
			if(dojo.lang.isFunction(a[0])){
				return a[0];
			}else if(dojo.lang.isString(a[0])){
				return dj_global[a[0]];
			}
		}else if((a[0])&&(a[1])){
			return dojo.lang.hitch(a[0], a[1]);
		}
		return null;
	},

	makeCalled: function() {
		var deferred = new dojo.Deferred();
		deferred.callback();
		return deferred;
	},

	repr: function(){
		var state;
		if(this.fired == -1){
			state = 'unfired';
		}else if(this.fired == 0){
			state = 'success';
		} else {
			state = 'error';
		}
		return 'Deferred(' + this.id + ', ' + state + ')';
	},

	toString: dojo.lang.forward("repr"),

	_nextId: (function(){
		var n = 1;
		return function(){ return n++; };
	})(),

	cancel: function(){
		// summary:	Cancels a Deferred that has not yet received a value, or is
		//		waiting on another Deferred as its value.
		// description:
		//		If a canceller is defined, the canceller is called. If the
		//		canceller did not return an error, or there was no canceller,
		//		then the errback chain is started with CancelledError.
		if(this.fired == -1){
			if (this.canceller){
				this.canceller(this);
			}else{
				this.silentlyCancelled = true;
			}
			if(this.fired == -1){
				this.errback(new Error(this.repr()));
			}
		}else if(	(this.fired == 0)&&
					(this.results[0] instanceof dojo.Deferred)){
			this.results[0].cancel();
		}
	},
			

	_pause: function(){
		// summary: Used internally to signal that it's waiting on another Deferred
		this.paused++;
	},

	_unpause: function(){
		// summary: Used internally to signal that it's no longer waiting on
		// another Deferred.
		this.paused--;
		if ((this.paused == 0) && (this.fired >= 0)) {
			this._fire();
		}
	},

	_continue: function(res){
		// summary: Used internally when a dependent deferred fires.
		this._resback(res);
		this._unpause();
	},

	_resback: function(res){
		// The primitive that means either callback or errback
		this.fired = ((res instanceof Error) ? 1 : 0);
		this.results[this.fired] = res;
		this._fire();
	},

	_check: function(){
		if(this.fired != -1){
			if(!this.silentlyCancelled){
				dojo.raise("already called!");
			}
			this.silentlyCancelled = false;
			return;
		}
	},

	callback: function(res){
		// summary:	Begin the callback sequence with a non-error value.
		
		/*
		callback or errback should only be called once on a given
		Deferred.
		*/
		this._check();
		this._resback(res);
	},

	errback: function(res){
		// summary: Begin the callback sequence with an error result.
		this._check();
		if(!(res instanceof Error)){
			res = new Error(res);
		}
		this._resback(res);
	},

	addBoth: function(cb, cbfn){
		/* summary
		Add the same function as both a callback and an errback as the
		next element on the callback sequence.	This is useful for code
		that you want to guarantee to run, e.g. a finalizer.
		*/
		var enclosed = this.getFunctionFromArgs(cb, cbfn);
		if(arguments.length > 2){
			enclosed = dojo.lang.curryArguments(null, enclosed, arguments, 2);
		}
		return this.addCallbacks(enclosed, enclosed);
	},

	addCallback: function(cb, cbfn){
		// summary: Add a single callback to the end of the callback sequence.
		var enclosed = this.getFunctionFromArgs(cb, cbfn);
		if(arguments.length > 2){
			enclosed = dojo.lang.curryArguments(null, enclosed, arguments, 2);
		}
		return this.addCallbacks(enclosed, null);
	},

	addErrback: function(cb, cbfn){
		// summary: Add a single callback to the end of the callback sequence.
		var enclosed = this.getFunctionFromArgs(cb, cbfn);
		if(arguments.length > 2){
			enclosed = dojo.lang.curryArguments(null, enclosed, arguments, 2);
		}
		return this.addCallbacks(null, enclosed);
		return this.addCallbacks(null, cbfn);
	},

	addCallbacks: function (cb, eb) {
		// summary: Add separate callback and errback to the end of the callback
		// sequence.
		this.chain.push([cb, eb])
		if (this.fired >= 0) {
			this._fire();
		}
		return this;
	},

	_fire: function(){
		// summary: Used internally to exhaust the callback sequence when a result
		// is available.
		var chain = this.chain;
		var fired = this.fired;
		var res = this.results[fired];
		var self = this;
		var cb = null;
		while (chain.length > 0 && this.paused == 0) {
			// Array
			var pair = chain.shift();
			var f = pair[fired];
			if (f == null) {
				continue;
			}
			try {
				res = f(res);
				fired = ((res instanceof Error) ? 1 : 0);
				if(res instanceof dojo.Deferred) {
					cb = function(res){
						self._continue(res);
					}
					this._pause();
				}
			}catch(err){
				fired = 1;
				res = err;
			}
		}
		this.fired = fired;
		this.results[fired] = res;
		if((cb)&&(this.paused)){
			// this is for "tail recursion" in case the dependent
			// deferred is already fired
			res.addBoth(cb);
		}
	}
});

/**
 * TreeDrag* specialized on managing subtree drags
 * It selects nodes and visualises what's going on,
 * but delegates real actions upon tree to the controller
 *
 * This code is considered a part of controller
*/

dojo.provide("dojo.dnd.TreeDragAndDropV3");








// FIXME: if controller can't move then skip node on move start
dojo.dnd.TreeDragSourceV3 = function(node, syncController, type, treeNode){
	//dojo.profile.start("TreeDragSourceV3 "+treeNode);
	this.controller = syncController;
	this.treeNode = treeNode;

	dojo.dnd.HtmlDragSource.call(this, node, type);
	//dojo.profile.end("TreeDragSourceV3 "+treeNode);
}

dojo.inherits(dojo.dnd.TreeDragSourceV3, dojo.dnd.HtmlDragSource);


// .......................................

dojo.dnd.TreeDropTargetV3 = function(domNode, controller, type, treeNode){

	this.treeNode = treeNode;
	this.controller = controller; // I will sync-ly process drops
	
	dojo.dnd.HtmlDropTarget.call(this, domNode, type);
}

dojo.inherits(dojo.dnd.TreeDropTargetV3, dojo.dnd.HtmlDropTarget);

dojo.lang.extend(dojo.dnd.TreeDropTargetV3, {

	autoExpandDelay: 1500,
	autoExpandTimer: null,


	position: null,

	indicatorStyle: "2px black groove",

	showIndicator: function(position) {

		// do not change style too often, cause of blinking possible
		if (this.position == position) {
			return;
		}

		//dojo.debug("set position for "+this.treeNode)

		this.hideIndicator();

		this.position = position;
		
		var node = this.treeNode;
			
		
		node.contentNode.style.width = dojo.html.getBorderBox(node.labelNode).width + "px";

		if (position == "onto") {					
			node.contentNode.style.border = this.indicatorStyle;
		} else {
			// FIXME: bottom-top or highlight should cover ONLY top/bottom or div itself,
			// not span whole line (try Dnd)
			// FAILURE: Can't put span inside div: multiline bottom-top will span multiple lines
			if (position == "before") {
				node.contentNode.style.borderTop = this.indicatorStyle;
			} else if (position == "after") {
				node.contentNode.style.borderBottom = this.indicatorStyle;
			}									
		}  
	},

	hideIndicator: function() {
		this.treeNode.contentNode.style.borderBottom = "";
		this.treeNode.contentNode.style.borderTop = "";
		this.treeNode.contentNode.style.border = "";
		this.treeNode.contentNode.style.width=""
		this.position = null;
	},



	// is the target possibly ok ?
	// This function is run on dragOver, but drop possibility is also determined by position over node
	// that's why acceptsWithPosition is called
	// doesnt take index into account ( can change while moving mouse w/o changing target )
	/**
	 * Coarse (tree-level) access check.
	 * We can't determine real accepts status w/o position
	*/
	onDragOver: function(e){
		//dojo.debug("onDragOver for "+e);

		var accepts = dojo.dnd.HtmlDropTarget.prototype.onDragOver.apply(this, arguments);

		//dojo.debug("TreeDropTarget.onDragOver accepts:"+accepts)

		if (accepts && this.treeNode.isFolder && !this.treeNode.isExpanded) {
			this.setAutoExpandTimer();
		}
		
		if (accepts) {
			this.cacheNodeCoords();
		}


		return accepts;
	},

	/* Parent.onDragOver calls this function to get accepts status */
	accepts: function(dragObjects) {

		var accepts = dojo.dnd.HtmlDropTarget.prototype.accepts.apply(this, arguments);

		//dojo.debug("accepts "+accepts);

		if (!accepts) return false;

		for(var i=0; i<dragObjects.length; i++) {
			// there may be NO treeNode
			var sourceTreeNode = dragObjects[i].treeNode;
			
			if (sourceTreeNode === this.treeNode) return false;
		}

		return true;
	},



	setAutoExpandTimer: function() {
		// set up autoexpand timer
		var _this = this;

		var autoExpand = function () {
			if (dojo.dnd.dragManager.currentDropTarget === _this) {
				_this.controller.expand(_this.treeNode);
				// SLOW. Coordinates will not be recalculated if collapse occurs, or
				// other (generic) resize. So that's a kind of hack.
				dojo.dnd.dragManager.cacheTargetLocations();
			}
		}

		this.autoExpandTimer = dojo.lang.setTimeout(autoExpand, _this.autoExpandDelay);
	},

		

	getAcceptPosition: function(e, dragObjects) {


		var DndMode = this.treeNode.tree.DndMode;

		// disable ONTO mode possibility if impossible 
		if (DndMode & dojo.widget.TreeV3.prototype.DndModes.ONTO &&
			// check if ONTO is allowed localy
			// check dynamically cause may change w/o regeneration of dropTarget
			this.treeNode.actionIsDisabledNow(this.treeNode.actions.ADDCHILD) 
		) {
			// disable ONTO if can't move
			DndMode &= ~dojo.widget.TreeV3.prototype.DndModes.ONTO;
		}
		

		var position = this.getPosition(e, DndMode);

		//dojo.debug(DndMode & +" : "+position);


		// if onto is here => it was allowed before, no accept check is needed
		if (position=="onto") {
			return position;
		}
		
		for(var i=0; i<dragObjects.length; i++) {
			var source = dragObjects[i].dragSource;
			if (source.treeNode && this.isAdjacentNode(source.treeNode, position)) { // skip check if same parent
				continue;
			}		
						
			if (!this.controller.canMove(source.treeNode ? source.treeNode : source, this.treeNode.parent)) {
				return false;
			}
		}
		
		return position;
	
	},

	

	onDropEnd: function(e) {
		this.clearAutoExpandTimer();

		this.hideIndicator();
	},


	onDragOut: function(e) {
		this.clearAutoExpandTimer();

		this.hideIndicator();
	},

	clearAutoExpandTimer: function() {
		if (this.autoExpandTimer) {
			clearTimeout(this.autoExpandTimer);
			this.autoExpandTimer = null;
		}
	},



	onDragMove: function(e, dragObjects){
		
		var position = this.getAcceptPosition(e, dragObjects);

		if (position) {
			this.showIndicator(position);
		}

	},

	isAdjacentNode: function(sourceNode, position) {

		if (sourceNode === this.treeNode) return true;
		if (sourceNode.getNextSibling() === this.treeNode && position=="before") return true;
		if (sourceNode.getPreviousSibling() === this.treeNode && position=="after") return true;

		return false;
	},


	/**
	 * cache node coordinates to speed up onDragMove
	 */
	cacheNodeCoords: function() {
		var node = this.treeNode.contentNode;
		
		this.cachedNodeY = dojo.html.getAbsolutePosition(node).y;
		this.cachedNodeHeight = dojo.html.getBorderBox(node).height;
	},
	
	

	/* get DndMode and see which position e fits */
	getPosition: function(e, DndMode) {
		var mousey = e.pageY || e.clientY + dojo.body().scrollTop;
		
		var relY = mousey - this.cachedNodeY;
		var p = relY / this.cachedNodeHeight;

		var position = ""; // "" <=> forbidden
		if (DndMode & dojo.widget.TreeV3.prototype.DndModes.ONTO
		  && DndMode & dojo.widget.TreeV3.prototype.DndModes.BETWEEN) {
			//dojo.debug("BOTH");
			if (p<=0.33) {
				position = "before";
				// if children are expanded then I ignore understrike, cause it is confusing with firstChild
				// but for last nodes I put understrike there
			} else if (p<=0.66 || this.treeNode.isExpanded && this.treeNode.children.length && !this.treeNode.isLastChild()) {
				position = "onto";
			} else {
				position = "after";
			}
		} else if (DndMode & dojo.widget.TreeV3.prototype.DndModes.BETWEEN) {
			//dojo.debug("BETWEEN");
			if (p<=0.5 || this.treeNode.isExpanded && this.treeNode.children.length && !this.treeNode.isLastChild()) {
				position = "before";
			} else {
				position = "after";
			}
		}
		else if (DndMode & dojo.widget.TreeV3.prototype.DndModes.ONTO) {
			//dojo.debug("ONTO");
			position = "onto";
		}

		//dojo.debug(position);

		return position;
	},



	getTargetParentIndex: function(source, position) {

		var index = position == "before" ? this.treeNode.getParentIndex() : this.treeNode.getParentIndex()+1;
		if (source.treeNode
		  && this.treeNode.parent === source.treeNode.parent
		  && this.treeNode.getParentIndex() > source.treeNode.getParentIndex()) {
		  	index--;  // dragging a node is different for simple move bacause of before-after issues
		}

		return index;
	},


	onDrop: function(e) {
		// onDropEnd will clean position

		
		var position = this.position;

//dojo.debug(position);
		var source = e.dragObject.dragSource;
		
		//dojo.debug("onDrop "+source.treeNode+" " + position + " "+this.treeNode);


		var targetParent, targetIndex;
		if (position == "onto") {
			targetParent = this.treeNode;
			targetIndex = 0;
		} else {
			targetIndex = this.getTargetParentIndex(source, position);
			targetParent = this.treeNode.parent;
		}
		
		//dojo.profile.start("onDrop "+sourceTreeNode);
		var r = this.getDropHandler(e, source, targetParent, targetIndex)();
		
		//dojo.profile.end("onDrop "+sourceTreeNode);
			
		return r;

	},
	
	/**
	 * determine, which action I should perform with nodes
	 * e.g move, clone..
	 */
	getDropHandler: function(e, source, targetParent, targetIndex) {
		var handler;
		var _this = this;
		handler = function () {
			var result;
			
			//dojo.debug("Move "+source.treeNode+" to parent "+targetParent+":"+targetIndex);
			if (source.treeNode) {
				result = _this.controller.move(source.treeNode, targetParent, targetIndex, true);
				//dojo.debug("moved "+result);
			} else {
				if (dojo.lang.isFunction(source.onDrop)) {
					source.onDrop(targetParent, targetIndex);
				}
				
				var treeNode = source.getTreeNode();
				if (treeNode) {
					result = _this.controller.createChild(targetParent, targetIndex, treeNode, true);
				} else {
					result = true;
				}
			}
			
			if (result instanceof dojo.Deferred) {
				// this Deferred is always sync
				var isSuccess = result.fired == 0;
				if (!isSuccess) {
					_this.handleDropError(source, targetParent, targetIndex, result);
				}
				
				return isSuccess;				
				
			} else {
				return result;
			}
		}
		
		return handler;
	},
	
	
	handleDropError: function(source, parent, index, result) {
		dojo.debug("TreeDropTargetV3.handleDropError: DND error occured");
		dojo.debugShallow(result);
	}


});


dojo.provide("dojo.experimental");

dojo.experimental = function(/* String */ moduleName, /* String? */ extra){
	// summary: Marks code as experimental.
	// description: 
	//    This can be used to mark a function, file, or module as experimental.
	//    Experimental code is not ready to be used, and the APIs are subject
	//    to change without notice.  Experimental code may be completed deleted
	//    without going through the normal deprecation process.
	// moduleName: The name of a module, or the name of a module file or a specific function
	// extra: some additional message for the user
	
	// examples:
	//    dojo.experimental("dojo.data.Result");
	//    dojo.experimental("dojo.weather.toKelvin()", "PENDING approval from NOAA");
	var message = "EXPERIMENTAL: " + moduleName;
	message += " -- Not yet ready for use.  APIs subject to change without notice.";
	if(extra){ message += " " + extra; }
	dojo.debug(message);
}


dojo.provide("dojo.widget.TreeExtension");




dojo.widget.defineWidget(
	"dojo.widget.TreeExtension",
	[dojo.widget.HtmlWidget, dojo.widget.TreeCommon],
	function() {
		this.listenedTrees = {};
	},
	{}
);


dojo.provide("dojo.widget.TreeDocIconExtension");




// selector extension to emphasize node

dojo.widget.defineWidget(
	"dojo.widget.TreeDocIconExtension",
	[dojo.widget.TreeExtension],
{
	/**
	 * can't unlisten
	 */
	
	templateCssPath: dojo.uri.moduleUri("dojo.widget", "templates/TreeDocIcon.css"),

	
	listenTreeEvents: ["afterChangeTree","afterSetFolder","afterUnsetFolder"],
	
	listenNodeFilter: function(elem) { return elem instanceof dojo.widget.Widget },
	
	getnodeDocType: function(node) {
		var nodeDocType = node.getnodeDocType();
		if (!nodeDocType) { // set default type
			nodeDocType = node.isFolder ? "Folder" : "Document";
		}
		return nodeDocType;
	},
	
	setnodeDocTypeClass: function(node) {
		
		var reg = new RegExp("(^|\\s)"+node.tree.classPrefix+"Icon\\w+",'g');			
				
		var clazz = dojo.html.getClass(node.iconNode).replace(reg,'') + ' ' + node.tree.classPrefix+'Icon'+this.getnodeDocType(node);
		dojo.html.setClass(node.iconNode, clazz);		
	},
		
		
	onAfterSetFolder: function(message) {
		//dojo.debug("FOLDER");
		if (message.source.iconNode) {
			// on node-initialize time when folder is set there is no iconNode
			// this case will be processed in treeChange anyway			
			this.setnodeDocTypeClass(message.source);
		}
	},
	
	
	onAfterUnsetFolder: function(message) {
		this.setnodeDocTypeClass(message.source);
	},
		
	
	listenNode: function(node) {
		/**
		 * add node with document type icon to node template and Tree.iconNodeTemplate
		 * it will be set to TreeNode.iconNode on node creation
		 * we do not assign document type yet, its node specific
		 */
		//dojo.debug("listenNode in "+node);
			
		node.contentIconNode = document.createElement("div");
		var clazz = node.tree.classPrefix+"IconContent";
		if (dojo.render.html.ie) {
			clazz = clazz+' '+ node.tree.classPrefix+"IEIconContent";
		}
		dojo.html.setClass(node.contentIconNode, clazz);
		
		node.contentNode.parentNode.replaceChild(node.contentIconNode, node.expandNode);
									  
	  	node.iconNode = document.createElement("div");
		dojo.html.setClass(node.iconNode, node.tree.classPrefix+"Icon"+' '+node.tree.classPrefix+'Icon'+this.getnodeDocType(node));
		
		node.contentIconNode.appendChild(node.expandNode);
		node.contentIconNode.appendChild(node.iconNode);
		
		dojo.dom.removeNode(node.contentNode);
		node.contentIconNode.appendChild(node.contentNode);
		
	
		
		//dojo.html.insertAfter(node.iconNode, node.expandNode);
		
		//dojo.debug("listenNode out "+node);
		
	},
			
	
	onAfterChangeTree: function(message) {
		var _this = this;
		
		//dojo.debug(message.node)
		
		if (!message.oldTree || !this.listenedTrees[message.oldTree.widgetId]) {			
			// moving from old tree to our tree
			this.processDescendants(message.node,
				this.listenNodeFilter,
				this.listenNode
			);
		}
		
	}
	

});

if(!this["dojo"]){
	alert("\"dojo/__package__.js\" is now located at \"dojo/dojo.js\". Please update your includes accordingly");
}

/******************************************************************************
 *
 * [ ps.aa.js ]
 *
 * COPYRIGHT (c) 1999 - 2006 by Percussion Software, Inc., Woburn, MA USA.
 * All rights reserved. This material contains unpublished, copyrighted
 * work including confidential and proprietary information of Percussion.
 *
 *****************************************************************************/

dojo.provide("ps.aa");




// call the ps.aa.controller.init() after dojo has passed the HTML content
dojo.event.connect(dojo, "loaded", init);

function init()
{
   djConfig.isDebug = true;
   djConfig.debugAtAllCosts = true;
   if(window.__isAa){
      ps.aa.controller.init();
   }
}

/**
 * The constructor and the place holder for the singleton ps object.
 */
ps = new function(){}

/**
 * The constructor for the singleton ps.aa object.
 */
ps.aa = new function()
{
   /**
    * The 'class' attribute for a page node.
    */
   this.PAGE_CLASS = "PsAaPage";

   /**
    * The 'class' attribute for a slot node
    */
   this.SLOT_CLASS = "PsAaSlot";

   /**
    * The 'class' attribute for a snippet node.
    */
   this.SNIPPET_CLASS = "PsAaSnippet";

   /**
    * The 'class' attribute for a field node
    */
   this.FIELD_CLASS = "PsAaField";

   /**
    * The name of the attribute of <a> tag element that has the object id.
    */
   this.OBJECTID_ATTR = "PsAaObjectId";
}

/**
 * Constructs an object from a JSON string.
 * 
 * @param {String} idString The JSON string which is created by 
 *    {@link com.percussion.content.ui.aa.PSAAObjectId} on the server side.
 *    It is an array of pre-defined values, some like:
 *       '["2","372","3","503","301",null,"0","0","311","0","518","1728",null]'
 */
ps.aa.ObjectId = function(idString)
{

   /**
    * widget flag. This is used to see if the objectId 
    * is created from a widget or image.
    */
    this.widget = null;
    
   /**
    * Stores the id in serialized format as in 'string'
    */
    //FIXME: make this more generic.
   this.idString = idString;
   // gets the real id if has image marker.
   if (dojo.string.startsWith(idString, ps.aa.ObjectId.IMG_PREFIX, false)) 
   {
      this.idString = idString.substring(ps.aa.ObjectId.IMG_PREFIX.length, 
         idString.length);
      this.widget = ps.aa.ObjectId.IMG_PREFIX;
   }
   else if (dojo.string.startsWith(idString, 
            ps.aa.ObjectId.TREE_NODE_WIDGET, false)) 
   {
      this.idString = idString.substring(ps.aa.ObjectId.TREE_NODE_WIDGET.length, 
      idString.length);
      this.widget = ps.aa.ObjectId.TREE_NODE_WIDGET;
      
   }
    
   /**
    * Stores the list of values into array.
    */
   this.idobj = dojo.json.evalJson(this.idString);
   
   /**
    * Determines if the specified object equals this object.
    * 
    * @param {ps.aa.ObjectId} other The object in question.
    * 
    * @return 'true' if both objects have the same value; 'false' otherwise.
    */
   this.equals = function(other)
   {
      if ((typeof other == 'undefined') || other == null)
         return false;
      else
         return this.idString == other.idString;
   }
   
   /**
    * Convert this object to a JSON string. It is the reverse operation of the
    * constructor.
    */
   this.serialize = function ()
   {
      return this.idString;
   }
   
   /**
    * Clones the object id.
    * @return a deep copy of the current object id
    */
   this.clone = function ()
   {
      return new ps.aa.ObjectId(this.serialize());
   }
   
   /**
    * Call this.serialize()
    */
   this.toString = function ()
   {
      return this.serialize();
   }
   
   /**
    * Determines the specified object id belongs to the same item as this one.
    * Both ids should be slot ids.
    *
    * @param {ps.aa.ObjectId} otherId the object id in question.
    * Not null.
    * 
    * @return 'true' if both ids describe objects belonging to the same item.
    */
   this.belongsToTheSameItem = function (otherId)
   {
      dojo.lang.assertType(otherId, ps.aa.ObjectId);
      dojo.lang.assert(otherId.isSlotNode(),
            "Expected slot node, but got " + otherId);
      dojo.lang.assert(this.isSlotNode(),
            "Can be called only on a slot node, not on " + this);

      return this.getRelationshipId() || otherId.getRelationshipId()
            ? this.getRelationshipId() === otherId.getRelationshipId()
            : this.getContentId() === otherId.getContentId();
   }
   
   this.isPageNode = function()
   {
      return this.idobj[ps.aa.ObjectId.NODE_TYPE] == 0;
   }

   this.isSlotNode = function()
   {
      return this.idobj[ps.aa.ObjectId.NODE_TYPE] == 1;
   }

   this.isSnippetNode = function()
   {
      return this.idobj[ps.aa.ObjectId.NODE_TYPE] == 2;
   }
   
   /**
    * Indicates that this id is a snippet id.
    * After this method is called {@link #isSnippetNode} will return
    * <code>true</code>.
    */
   this.setSnippetNode = function()
   {
      this.idobj[ps.aa.ObjectId.NODE_TYPE] = 2;
      this._resetIdString();
   }
   
   this.isFieldNode = function()
   {
      return this.idobj[ps.aa.ObjectId.NODE_TYPE] == 3;
   }

   this.isCheckout = function()
   {
      if (this.idobj[ps.aa.ObjectId.CHECKOUT_STATUS] != "0")
         return true;
      return false;
   }

   this.isCheckoutByMe = function()
   {
      return this.idobj[ps.aa.ObjectId.CHECKOUT_STATUS] == "1";
   }

   this.getContentId = function()
   {
      return this.idobj[ps.aa.ObjectId.CONTENT_ID];
   }
   
   this.setContentId = function(id)
   {
      this.idobj[ps.aa.ObjectId.CONTENT_ID] = id;
      this._resetIdString();
   }

   /**
    * Sets the checkout status to the specified value.
    * 
    * @param {Number} status the new status, which must be 0, 1, or 2.
    */
   this.setCheckoutStatus = function(status)
   {
      dojo.lang.assert((status === "0" || status === "1" || status === "2"), "status must be 0, 1, or 2");
      this.idobj[ps.aa.ObjectId.CHECKOUT_STATUS] = status;
      this._resetIdString();
   }
   
   /**
    * Gets the checkout status.
    * 
    * @return {Number} 
    */
   this.getCheckoutStatus = function(status)
   {
      return this.idobj[ps.aa.ObjectId.CHECKOUT_STATUS];
   }

   this.getTemplateId = function()
   {
      return this.idobj[ps.aa.ObjectId.TEMPLATE_ID];
   }

   this.setTemplateId = function(templateId)
   {
      this.idobj[ps.aa.ObjectId.TEMPLATE_ID] = templateId;
      this._resetIdString();
   }

   this.getSlotId = function()
   {
      return this.idobj[ps.aa.ObjectId.SLOT_ID];
   }
   
   this.setSlotId = function(slotId)
   {
      this.idobj[ps.aa.ObjectId.SLOT_ID] = slotId;
      this._resetIdString();
   }

   this._resetIdString = function ()
   {
      this.idString = dojo.json.serialize(this.idobj);      
   }   

   this.getRelationshipId = function()
   {
      return this.idobj[ps.aa.ObjectId.RELATIONSHIP_ID];
   }

   this.getContext = function()
   {
      return this.idobj[ps.aa.ObjectId.CONTEXT];
   }

   this.getAuthType = function()
   {
      return this.idobj[ps.aa.ObjectId.AUTHTYPE];
   }

   this.getSiteId = function()
   {
      return this.idobj[ps.aa.ObjectId.SITE_ID];
   }

   this.setSiteId = function(id)
   {
      this.idobj[ps.aa.ObjectId.SITE_ID] = id;
	  this._resetIdString();
   }

   this.getFolderId = function()
   {
      return this.idobj[ps.aa.ObjectId.FOLDER_ID];
   }

   this.setFolderId = function(id)
   {
      this.idobj[ps.aa.ObjectId.FOLDER_ID] = id;
	  this._resetIdString();
   }

   this.getContentTypeId = function()
   {
      return this.idobj[ps.aa.ObjectId.CONTENTTYPE_ID];
   }
   
   this.getFieldName = function()
   {
      return this.idobj[ps.aa.ObjectId.FIELD_NAME];
   }
   
   this.getFieldLabel = function()
   {
      return this.idobj[ps.aa.ObjectId.FIELD_LABEL];
   }
   
   /**
    * Sort rank of the object in its container.
    * Can be null.
    */
   this.getSortRank = function()
   {
      return this.idobj[ps.aa.ObjectId.SORT_RANK];
   }

   this.setSortRank = function(sortRank)
   {
      this.idobj[ps.aa.ObjectId.SORT_RANK] = sortRank + "";
      this._resetIdString();
   }

   /**
    * @return {int} the content id of the parent. It may be null if not defined.
    */
   this.getParentId = function()
   {
      return this.idobj[ps.aa.ObjectId.PARENT_ID];
   }
   
   /**
    * Gets the dojo widget id of the node in the aa tree corresponding
    * to this object .
    * @return {string} dojo widget id.
    */
   this.getTreeNodeWidgetId = function ()
   {
      return ps.aa.ObjectId.TREE_NODE_WIDGET + this.serialize();
   }
   
   /**
    * Build the image path according to the rules below:
    * 
    * 1. If supplied path is null make treat it as empty string.
    * 2. Pick image file name for appropriate for the object class that is page, 
    *    snippet, slot or field.
    * 3. Build the result by concatenating
    *    1. the path from step1
    *    2. image name from step 2
    *    3. '_'
    *    4. check out status
    *    5. ".gif".
    *
    * @param path path relative to the server root or absolute path, may be 
    * null in which case it is treated as empty string. Please note that it 
    * makes sure a "/" exists before the file name. If you want the image path 
    * to be relative to current location, supply path as ".".
    * @return image path as mentioned above, never null or empty. The return 
    * value will be something like "../sys_resources/images/slot0.gif";
    */
   this.getImagePath = function(path)
   {
      if(path == null)
         path = "";
      
      if(path.substring(path.length-1)!='/')
         path = path+'/';
      var objClass;
      if(this.isPageNode())
      {
         objClass = ps.aa.PAGE_CLASS;
      }
      else if(this.isSnippetNode())
      {
         objClass = ps.aa.SNIPPET_CLASS;
      }
      else if(this.isSlotNode())
      {
         objClass = ps.aa.SLOT_CLASS;
      }
      else if(this.isFieldNode())
      {
         objClass = ps.aa.FIELD_CLASS;
      }
      return path + ps.aa.ObjectId.ImageNames[objClass] + "_" + 
         this.idobj[ps.aa.ObjectId.CHECKOUT_STATUS] + ".gif"; 
   }
   
   /**
    * 
    */
   this.getAnchorId = function()
   {
      return "img." + this.serialize();
   }
}

/**
 * The index of the Active Assembly node type
 *  0 - parent page node.
 *  1 - slot node.
 *  2 - snippet node.
 *  3 - field node.
 */
ps.aa.ObjectId.NODE_TYPE = 0;

/**
 * The index of the 'content id' of the node. It is null if not defined.
 */
ps.aa.ObjectId.CONTENT_ID = 1;

/**
 * The index of the 'template id' of the node. It is null if not defined.
 */
ps.aa.ObjectId.TEMPLATE_ID = 2;

/**
 * The index of the 'site id' of the node. It is null if not defined.
 */
ps.aa.ObjectId.SITE_ID = 3;

/**
 * The index of the 'folder id' of the node. It is null if not defined.
 */
ps.aa.ObjectId.FOLDER_ID = 4;

/**
 * The index of the 'context' used for the node. It is null if not defined.
 */
ps.aa.ObjectId.CONTEXT = 5;

/**
 * The index of the 'authtype' used for the node. It is null if not defined.
 */
ps.aa.ObjectId.AUTHTYPE = 6;

/**
 * The index of the 'content type id' of the node. It is null if not defined.
 */
ps.aa.ObjectId.CONTENTTYPE_ID = 7;

/**
 * The index of the 'check out status' of the node. It is null if not defined.
 *  0 - if the item is not checked out by any user.
 *  1 - if the item is checked out by the current user.
 *  2 - if the item is checked by a user than current user
 */
ps.aa.ObjectId.CHECKOUT_STATUS = 8;

/**
 * The index of the 'slot id' of the node. It is null if not defined.
 */
ps.aa.ObjectId.SLOT_ID = 9;

/**
 * The index of the 'relationship id' of the node.  It is null if not defined.
 */
ps.aa.ObjectId.RELATIONSHIP_ID = 10;

/**
 * The index of the 'field name' of the node. It is null if not defined.
 */
ps.aa.ObjectId.FIELD_NAME = 11;

/**
 * The index of the 'parent content id' of the node. It is null if not defined.
 */
ps.aa.ObjectId.PARENT_ID = 12;

/**
 * The index of the 'field label' of the node. It is null if not defined.
 */
ps.aa.ObjectId.FIELD_LABEL = 13;

/**
 * The index of the 'sort rank' of the node. It is null if not defined.
 */
ps.aa.ObjectId.SORT_RANK = 14;

/**
 * The prefix to be attached to the objectId.toString()
 */
ps.aa.ObjectId.TREE_NODE_WIDGET = 'aatree_';

/**
 * The prefix of the id for the anchor element that contains a managed node, 
 * slot, snippet or field.
 */
ps.aa.ObjectId.IMG_PREFIX = 'img.';

/**
 * Icon names. These are pure names only without any path or extension.
 */
ps.aa.ObjectId.ImageNames = new Object();
ps.aa.ObjectId.ImageNames[ps.aa.PAGE_CLASS] = "page";
ps.aa.ObjectId.ImageNames[ps.aa.SNIPPET_CLASS] = "snippet";
ps.aa.ObjectId.ImageNames[ps.aa.SLOT_CLASS] = "slot";
ps.aa.ObjectId.ImageNames[ps.aa.FIELD_CLASS] = "field";

/******************************************************************************
 *
 * [ ps.aa.dnd.js ]
 *
 * COPYRIGHT (c) 1999 - 2007 by Percussion Software, Inc., Woburn, MA USA.
 * All rights reserved. This material contains unpublished, copyrighted
 * work including confidential and proprietary information of Percussion.
 *
 *****************************************************************************/

dojo.provide("ps.aa.dnd");



/**
 * The Drag and Drop (view) controller.
 * Provides DnD functionality to Assembly Page.
 */
ps.aa.dnd = new function ()
{
   /**
    * Configured page drag and drop.
    */
   this.init = function ()
   {
      dojo.dnd.dragManager.nestedTargets = true;
      dojo.event.connect(ps.aa.controller.treeModel, "onBeforeDomChange",
            this, "_onBeforeDomChange");
      dojo.event.connect(ps.aa.controller.treeModel, "onDomChanged",
            this, "_onDomChanged");

      this._onDomChanged(ps.aa.controller.pageId);
   }

   /**
    * Unregisters the dom nodes which are about to change from DnD.
    * A listener on {@link ps.aa.Tree#onBeforeDomChange}.
    */
   this._onBeforeDomChange = function (id)
   {
      dojo.lang.assertType(id, ps.aa.ObjectId);

      // unregisters old sources and targets
      function unregisterAll(ids, objects)
      {
         dojo.lang.forEach(ids, function (id)
         {
            dojo.lang.assert(id.serialize() in objects,
                 "Following id is not registered: " + id.serialize());
            objects[id.serialize()].unregister();
            delete objects[id.serialize()];
         });
      }

      unregisterAll(this._getSnippetIds(id), this.dragSources);
      unregisterAll(this._getSlotIds(id), this.dropTargets);
   }

   /**
    * Registers the changed dom nodes for DnD.
    * A listener on {@link ps.aa.Tree#onDomChanged}.
    */
   this._onDomChanged = function (id)
   {
      dojo.lang.assertType(id, ps.aa.ObjectId);
      var _this = this;

      // drag sources
      dojo.lang.forEach(this._getSnippetIds(id), function (id)
      {
         dojo.lang.assert(!(id.serialize() in _this.dragSources));
         var node = ps.aa.Page.getElement(id);
         var source = new dojo.dnd.HtmlDragSource(node, ps.aa.SNIPPET_CLASS);
         _this.dragSources[id.serialize()] = source;
      });

      // drop targets
      dojo.lang.forEach(this._getSlotIds(id), function (id)
      {
         dojo.lang.assert(!(id.serialize() in _this.dropTargets));
         var node = ps.aa.Page.getElement(id);
         var target = new dojo.dnd.HtmlDropTarget(node, ps.aa.SNIPPET_CLASS);
         _this.dropTargets[id.serialize()] = target;

         dojo.event.connectAround(target, "onDragMove",
               _this, "_resetDropTargetVertical");

         dojo.event.connectAround(target, "onDragOver", _this, "_onDragOver");
         dojo.lang.assert(target.insert);
         dojo.event.connectAround(target, "insert", _this, "_dropTargetInsert");
         dojo.event.connectAround(target, "createDropIndicator",
               _this, "_createDropIndicator");

         dojo.event.connect(target, "onDropEnd", _this, "_onDropEnd");
      });
   }

   /**
    * An around advice for the "onDragOver" method of a drop target handler.
    * @param invocation the original "onDragOver" event handler.
    * @return <code>true</code> if the drop operation was successful.
    */
   this._onDragOver = function (invocation)
   {
      dojo.lang.assert(invocation, "Invocation must be defined");

      if (!invocation.proceed())
      {
         return false;
      }

      var event = invocation.args[0];
      dojo.lang.assert(event, "Event must be specified.");
      
      var dragObject = event.dragObjects[0];
      var slotId = this._getParentSlotId(dragObject.domNode);
      var dropTarget = invocation.object;

      var targetSlotId = this._getDropTargetId(dropTarget);
      dojo.lang.assert(slotId);
      dojo.lang.assert(targetSlotId);
      
      if (!slotId.belongsToTheSameItem(targetSlotId))
      {
         return false;
      }
      
      this._resetTargetChildBoxes(dropTarget);
      dropTarget.vertical = this._isDropIndicatorVertical(dropTarget);
      return true;
   }
   
   /**
    * An around advice for the drop target methods, setting correct slot
    * layout direction.
    * @param invocation the original call. Not null.
    * @return <code>true</code> if the drop operation was successful.
    */
   this._resetDropTargetVertical = function (invocation)
   {
      var dropTarget = invocation.object;
      var slotId = this._getDropTargetId(dropTarget);
      dojo.lang.assert(slotId,
            "Object id should be specified on the drop target");
      dropTarget.vertical = this._isDropIndicatorVertical(dropTarget);
      return invocation.proceed();
   }

   /**
    * Drop target maintains a array of child boxes. The target "onDragOver"
    * method fills up this array with data for the drop target direct children.
    * This method instead fills up the array with the snippet nodes data,
    * because snippet nodes could be nested deeper than the next level.
    * @param dropTarget the current drop target. Not null.
    */
   this._resetTargetChildBoxes = function (dropTarget)
   {
      dojo.lang.assert(dropTarget, "Drop target expected");

      var boxes = dropTarget.childBoxes;
      
      // do nothing if there is no child nodes - the slot is empty
      if (!boxes || boxes.length === 0)
      {
         return;
      }

      var targetSlotId = this._getDropTargetId(dropTarget);

      // exclude snippets inside of snippets
      var snippetIds = dojo.lang.filter(
            this._getSnippetIds(targetSlotId),
            function (id)
            {
               return id.getSlotId() === targetSlotId.getSlotId();
            });
      var snippetIdStrings = dojo.lang.map(snippetIds,
            function (id) {return id.serialize();});

      var divs = dropTarget.domNode.getElementsByTagName("div");
      var snippetNodes = dojo.lang.filter(divs, function (div)
      {
         return div.id && div.className == ps.aa.SNIPPET_CLASS
               && dojo.lang.inArray(snippetIdStrings, div.id);
      });

      // sort the snippet nodes by the snippet order
      snippetNodes.sort(function (n1, n2)
      {
         var id1 = new ps.aa.ObjectId(n1.id);
         var id2 = new ps.aa.ObjectId(n2.id);
         return id1.getSortRank() - id2.getSortRank();
      });

      boxes.length = 0;
      var _this = this;
      dojo.lang.forEach(snippetNodes, function(child)
      {
         boxes.push(_this._getDropTargetChildBox(child));
      });
      this._fillDropTargetChildBoxesGaps(boxes);
   }

   /**
    * Because we manually select drop target children, we skip the elements
    * we are not interested in. As result the generated boxes do not cover the
    * whole drop target.
    * This method resizes the boxes to the right and down, so their borders
    * touch and all the gaps are closed.
    */
   this._fillDropTargetChildBoxesGaps = function (boxes)
   {
      dojo.lang.forEach(boxes, function(box)
      {
         var leftmost = null;
         var topmost = null;
         dojo.lang.forEach(boxes, function(box2)
         {
            // skip itself
            if (box === box2)
            {
               return;
            }

            // if box and box2 overlap vertically, box2 is to the right of box
            if (Math.max(box.top, box2.top) < Math.min(box.bottom, box2.bottom)
                 && box2.right > box.right)
            {
               if (!leftmost || leftmost > box2.left)
               {
                  leftmost = box2.left;
               }
            }

            // if box and box2 overlap horizontally, box2 is under box
            if (Math.max(box.left, box2.left) < Math.min(box.right, box2.right)
                 && box2.bottom > box.bottom)
            {
               if (!topmost || topmost > box2.top)
               {
                  topmost = box2.top;
               }
            }
         });
         if (leftmost && leftmost > box.right + 1)
         {
            box.right = leftmost - 1;
         }
         if (topmost && topmost > box.bottom + 1)
         {
            box.bottom = topmost - 1;
         }
      });
   }

   /**
    * An around advice for the "insert" method of a drop target handler.
    * Parameters for the advised invocation:
    * @param {dojo.dnd.DragEvent} e the drag event.
    * Not <code>null</code>.
    * @param refNode the node relative to which the insert is done.
    * Not <code>null</code>.
    * @param position where relative to refNode the new node should be inserted.
    * One of {@link #POS_BEFORE}, {@link #POS_AFTER}, and {@link #POS_APPEND}.
    * Not <code>null</code>.
    * @return <code>true</code> if the drop operation was successful.
    */
   this._dropTargetInsert = function (invocation)
   {
      dojo.lang.assert(invocation);

      var event = invocation.args[0];
      var refNode = invocation.args[1];
      var position = invocation.args[2];

      dojo.lang.assert(event, "Event must be specified.");
      dojo.lang.assert(refNode, "Reference node must be specified.");
      dojo.lang.assert(position, "Position must be specified.");
      this._assertValidPosition(position);

      var snippetNode = event.dragObject.domNode;
      var snippetId = new ps.aa.ObjectId(snippetNode.id);
      var slotId = this._getParentSlotId(snippetNode);
      var dropTarget = invocation.object;
      var targetSlotId = this._getDropTargetId(dropTarget);
      
      var index = this._getDropIndex(dropTarget, snippetId, refNode, position);

      if (snippetId.getSlotId() !== targetSlotId.getSlotId())
      {
         dojo.lang.assert(!this._m_move);
         this._m_move = new ps.aa.SnippetMove(
             snippetId, slotId, targetSlotId, index, true);
         var result = ps.aa.controller.moveToSlot(this._m_move);
      }
      // source and target slots are the same
      else if (ps.aa.controller.reorderSnippetInSlot(
            snippetId, index))
      {
         dojo.lang.assert(!this._m_move);
         // used later to refresh the slot
         this._m_move = new ps.aa.SnippetMove(
              snippetId, slotId, targetSlotId, index, true);
         this._m_move.setUiUpdateNeeded(true);
         this._m_move.setSuccess(true);
         var result = true;
      }
      else
      {
         var result = false;
      }
      
      // clear drop indicator again, in case it was created by mistake,
      // e.g. during error handling user interactions
      if (dropTarget.dropIndicator)
      {
         dojo.html.removeNode(dropTarget.dropIndicator);
         delete dropTarget.dropIndicator;
      }
      
      return result && invocation.proceed();
   }
   
   /**
    * An around advice for the <code>onDropEnd</code> method of a drop target
    * handler.
    */
   this._onDropEnd = function ()
   {
      if (this._m_move)
      {
         dojo.lang.assertType(this._m_move.isSuccess(), Boolean);
         // page still can be updated, e.g. in template selection
         this._m_move.setDontUpdatePage(false);
         if (this._m_move.isUiUpdateNeeded() && this._m_move.isSuccess())
         {
            ps.aa.controller.maybeRefreshMovedSnippetNode(this._m_move, true);

            // activate the target snippet
            var snippetId = this._m_move.getTargetSnippetId();
            ps.aa.controller.activate(ps.aa.Page.getElement(snippetId));
         }
         this._m_move = null;
      }
   }
   
   /**
    * Index to drop for the dragged snippet component. Counts snippet nodes
    * in the container before the provided node.
    * @param dropTarget the drop target to calculate the position for.
    * Not null.
    * @param {ps.aa.ObjectId} snippetId the snippet id to drop.
    * Not <code>null</code>.
    * @param {String} position a valid position relative by refNode
    * as defined by {@link #_assertValidPosition}.
    * @return a 1-based index where the snippet component is dropped.
    * Not <code>null</code>.
    * @see #_dropTargetInsert
    */
   this._getDropIndex = function (dropTarget, snippetId, refNode, position)
   {
      dojo.lang.assert(dropTarget, "Target must be specified");
      dojo.lang.assertType(snippetId, ps.aa.ObjectId);
      dojo.lang.assert(refNode, "Reference node must be specified");
      this._assertValidPosition(position);

      var childrenLen = dropTarget.childBoxes.length;
      for (var i = 0, refNodeIdx = 1; i < childrenLen; i++)
      {
         var childBox = dropTarget.childBoxes[i];
         if (childBox.node === refNode && position !== this.POS_APPEND)
         {
            if (position != this.POS_BEFORE)
            {
               refNodeIdx++;
            }
            return Math.min(refNodeIdx, childrenLen);
         }

         // skip the snippet being moved
         if (childBox.node.id !== snippetId.serialize())
         {
            refNodeIdx++;
         }
      }

      if (position === this.POS_APPEND)
      {
         return refNodeIdx;
      }

      dojo.debug(refNode);
      dojo.lang.assert(false,
            "Could not find reference node in the list of nodes");
   }
   
   /**
    * Determines whether drop indicator should be vertical.
    * If the first 2 snippets of the slot are stacked side-by-side,
    * it returns true, otherwise it returns false.
    * Note, we handle only the simplest cases, because a slot can have any
    * layout.
    * Even with scary layouts when our check guesses wrong,
    * users still can drag and drop a snippet from another slot,
    * and move it inside a slot to the desired position using Up and Down
    * menu items.
    * @param dropTarget the drop target to check whether it's vertical.
    * Not null.
    * @return true if the slot is considered vertical. False otherwise.
    */
   this._isDropIndicatorVertical = function (dropTarget)
   {
      dojo.lang.assert(dropTarget, "Drop target must be specified");

      if (dropTarget.childBoxes.length < 2)
      {
         return false;
      }

      var box0 = dropTarget.childBoxes[0];
      var box1 = dropTarget.childBoxes[1];

      return Math.abs(box0.left - box1.left) > Math.abs(box0.top - box1.top);
   }

   /**
    * Makes drop indicator more visible.
    * @param invocation call to
    * {@link dojo.dnd.HtmlDropTarget#createDropIndicator}.
    * Not <code>null</code>.
    */
   this._createDropIndicator = function (invocation)
   {
      dojo.lang.assert(invocation);
      invocation.proceed();
      var target = invocation.object;
      dojo.lang.assert(target.dropIndicator);
      var style = target.dropIndicator.style;
      var color = "gray";
      var borderWidth = "3px";
      if (target.vertical)
      {
         style.borderLeftWidth = borderWidth;
         style.borderLeftColor = color;
      }
      else
      {
         style.borderTopWidth = borderWidth;
			style.borderTopColor = color;
      }
   }

   /**
    * Finds a slot node, which is a parent of the provided node.
    * @param domNode the node to search from.
    * Defined.
    * @return the id of the first node from domNode or its parents,
    * corresponding to a slot.
    * Returns <code>null</code> if a slot node can't be found.
    */
   this._getParentSlotId = function(domNode)
   {
      dojo.lang.assert(domNode, "Dom node is not specified");
      var node = domNode;
      while (node)
      {
         if (node.nodeType === dojo.dom.ELEMENT_NODE &&
             node.className === ps.aa.SLOT_CLASS)
         {
            return new ps.aa.ObjectId(node.id);
         }
         else
         {
            node = node.parentNode;
         }
      }
      return null;
   }

   /**
    * Checks that the provided position value is a valid value as defined
    * in {@link dojo.dnd.HtmlDropTarget#insert}.
    */
   this._assertValidPosition = function (position)
   {
      dojo.lang.assert(
            position === this.POS_BEFORE
            || position === this.POS_AFTER
            || position === this.POS_APPEND,
            "Unrecognized position: " + position);
   }

   /**
    * Generates a box object for placing it into
    * dojo.dnd.HtmlDropTarget.boxes list.
    * Borrowed from dojo.dnd.HtmlDropTarget.onDragOver
    * @param child the dom element to generate the box for.
    * @see _resetTargetChildBoxes
    */
   this._getDropTargetChildBox = function (child)
   {
         var pos = dojo.html.getAbsolutePosition(child, true);
         var inner = dojo.html.getBorderBox(child);
         return {top: pos.y, bottom: pos.y + inner.height,
               left: pos.x, right: pos.x + inner.width,
               height: inner.height,  width: inner.width,
               node: child};
   }

   /**
    * Returns an array of slot ids under ther provided id.
    */
   this._getSlotIds = function (id)
   {
      dojo.lang.assertType(id, ps.aa.ObjectId);
      var ids = ps.aa.controller.treeModel.getIdsFromNodeId(id).toArray();
      return dojo.lang.filter(ids, function (id) {return id.isSlotNode()});
   }
   
   /**
    * Returns an array of snippet ids under the provided id.
    */
   this._getSnippetIds = function (id)
   {
      dojo.lang.assertType(id, ps.aa.ObjectId);
      var ids = ps.aa.controller.treeModel.getIdsFromNodeId(id).toArray();
      return dojo.lang.filter(ids, function (id) {return id.isSnippetNode()});
   }
   
   /**
    * Extracts id from the drop target.
    * @param dropTarget the drop target to extract id from. Not null.
    * @return the object id of the target.
    */
   this._getDropTargetId = function (dropTarget)
   {
      dojo.lang.assert(dropTarget, "Expected dropTarget");
      return new ps.aa.ObjectId(dropTarget.domNode.id);
   }

   /**
    * Constant to indicate that a node should be inserted before the specified
    * node in {@link dojo.dnd.HtmlDropTarget#insert}.
    */
   this.POS_BEFORE = "before";

   /**
    * Constant to indicate that a node should be inserted after the specified
    * node in {@link dojo.dnd.HtmlDropTarget#insert}.
    */
   this.POS_AFTER = "after";

   /**
    * Constant to indicate that a node should be appended to the specified
    * node in {@link dojo.dnd.HtmlDropTarget#insert}.
    */
   this.POS_APPEND = "append";

   /**
    * Drag sources of type dojo.dnd.HtmlDragSource.
    * Keys - string representation of ids, values -
    * {@link dojo.dnd.HtmlDragSource} objects.
    * Can be empty if not defined yet or the page does not have any sources.
    */
   this.dragSources = {};

   /**
    * Keys - string representation of ids, values -
    * {@link dojo.dnd.HtmlDropTarget} objects.
    * Can be empty if not defined yet or the page does not have any targets.
    */
   this.dropTargets = {};
}

/******************************************************************************
 *
 * [ ps.io.Response.js ]
 *
 * COPYRIGHT (c) 1999 - 2006 by Percussion Software, Inc., Woburn, MA USA.
 * All rights reserved. This material contains unpublished, copyrighted
 * work including confidential and proprietary information of Percussion.
 *
 *****************************************************************************/
 
dojo.provide("ps.io.Response");

/**
 * A small class to hold server action response information
 */
ps.io.Response = function()
{
	/**

	 * Get the response data string value.
	 * @return may be <code>null</code> or empty.
	 */
	this.getValue = function()
	{
	   return this._m_value;
	}
	
	/**
	 * Indicates that this response was successful.
	 * @return <code>true</code> if successful or <code>false</code> 
	 * if a failure.
	 */
	this.isSuccess = function()
	{
	   return this._m_success;
	}
	
	/**
	 * @return the error code if an error occured.
	 */
	this.getErrorCode = function()
	{
	   return this._m.errorcode;	   
	}
	
	// Private members
	
	/**
	 * Flag indicating a successful response.
	 */
	this._m_success= false;
	
	/**
	 * The response data value or error message if a failure.
	 */
	this._m_value = null;
	
	
	/**
	 * The error code.
	 */
	this._m_errorcode = null;
	
};

/******************************************************************************
 *
 * [ ps.io.Actions.js ]
 *
 * COPYRIGHT (c) 1999 - 2007 by Percussion Software, Inc., Woburn, MA USA.
 * All rights reserved. This material contains unpublished, copyrighted
 * work including confidential and proprietary information of Percussion.
 *
 *****************************************************************************/
 
dojo.provide("ps.io.Actions");










/**
 * This javascript class contains a stub function for each action available on
 * the server side AA servlet.
 */
ps.io.Actions = new function()
{
   
   this.MIMETYPE_PLAIN = "text/plain";
   this.MIMETYPE_JSON = "text/json";
   this.MIMETYPE_HTML = "text/html";
   this.MIMETYPE_XML = "text/xml";   
   this.formSubmitResults = null;
   
   /**
    * The number of locales the server has enabled. Set the first time the
    * GetLocaleCount() method is called, which caches the returned value here.
    */
   this.localeCount = -1;

   /**
    * Moves a slot item within a slot
    * 
    * @param {ps.aa.ObjectId} objectId the objectId object for
    *  this slot item (Required).
    * @param {string} mode one of the following "up", "down", "reorder" 
    * (Required).
    * @param (string) index required if using reorder mode. Can be 
    * <code>null</code> or empty if mode is "up" or "down".
    * Required if mode is "reorder".
    * @return ps.io.Response object.
    */
   this.move = function(objectId, mode, index)
   {
      dojo.lang.assertType(objectId, ps.aa.ObjectId);      
      var action = "Move";
      var params = new dojo.collections.Dictionary();
      params.add("mode", mode);
      if(index != null && index != undefined)
      {
         params.add("index", index);
      }
      return this._makeRequest(
         action, this.MIMETYPE_PLAIN, objectId.serialize(), params);
   }
   
   /**
    * Moves a slot item to another slot.
    *
    * @param {ps.aa.ObjectId} objectId the objectId object for this slot item
    * (Required).
    * @param {ps.aa.ObjectId} targetslotid the target slot id (Required).
    * @param {string} newtempid the template id,
    * may be <code>null</code> if the method should use the template currently
    * associated with the snippet.
    * @param {string} index the sort rank for the item in the target slot.
    * May be <code>null</code> in which case the item will be appended
    * to the end of the slot items.
    * @return ps.io.Response object. If a template is needed then
    * the isSuccess method of the response will be <code>false</code> and the
    * error message will be {@link ps.io.Actions#NEEDS_TEMPLATE_ID}.
    */ 
   this.moveToSlot = function(objectId, targetslotid, newtempid, index)
   {
      dojo.lang.assertType(objectId, ps.aa.ObjectId);      
      var action = "MoveToSlot";
      var params = new dojo.collections.Dictionary();
      params.add("newslotid", targetslotid);
      if (newtempid)
      {
         params.add("newtemplate", newtempid);
      }
      if (index)
      {
         params.add("index", index);
      }
      return this._makeRequest(
         action, this.MIMETYPE_PLAIN, objectId.serialize(), params);
   }
   
   /**
    * Retrieves the url for the specified action name and content item.
    *
    * @param {ps.aa.ObjectId}objectId the objectId object for the 
    * content item (Required).
    * @param {string} actionname the action name that defines the type
    * of url to be returned. One of the following strings:
    * <pre>
    * CE_EDIT
    * CE_VIEW_CONTENT
    * CE_VIEW_PROPERTIES
    * CE_FIELDEDIT
    * CE_VIEW_REVISIONS
    * CE_VIEW_AUDIT_TRAIL
    * PREVIEW_PAGE
    * PREVIEW_MYPAGE
    * RC_SEARCH
    * TOOL_SHOW_AA_RELATIONSHIPS
    * TOOL_LINK_TO_PAGE
    * ACTION_xxx
    * </pre>
    * Names of the form ACTION_xxx are generic. Any PSAction name registered 
    * with the server can be used. The name should be supplied in place of the 
    * xxx. e.g. ACTION_Translate. When received, the server will search for an
    * action whose name is Translate and will load the command and params from
    * that action to build the url, performing substitutions as needed.
    * @return Json object, never <code>null</code> or empty.
    * The returned json object contains the following parameters:
    * <pre>
    * url = the requested url
    * dlg_height = the dialog height (Only exists for the field edit url)
    * dlg_width = the dialog height (Only exists for the field edit url)
    * </pre>
    */
   this.getUrl = function(objectId, actionname)
   {
      dojo.lang.assertType(objectId, ps.aa.ObjectId);      
      var action = "GetUrl";
      var params = new dojo.collections.Dictionary();
      params.add("actionname", actionname);
      try
      {
         if(___sys_aamode != undefined && ___sys_aamode != null)
            params.add("sys_aamode", new String(___sys_aamode));
      }
      catch(ignore){}
      return this._makeRequest(
         action, this.MIMETYPE_JSON, objectId.serialize(), params);
   }

   /**
    * Looks up an action based on a name, then calculates whether the current
    * user should be able to see the action in this context. (This is all done
    * by the server.)
    * 
    * @param actionNames A single string or a set of strings, each of which is 
    * used to lookup a PSAction. If empty, a successful response 
    * with an empty object is returned. The names are case-insensitive.
    * 
    * @param objectId The ps.aa.ObjectId that identifies the context within
    * which to check the visibility. If not provided, a successful response 
    * with an empty object is returned.
    * 
    * @return ps.io.Response whose value (if successful) is a map. The names 
    * (lower-cased) of all the supplied actions are used as keys while the value 
    * is a boolean true for visible, false for not visible. Never null.
    */
   this.getActionVisibility = function(actionNames, objectId)
   {
      var o = this._normalizeNames(actionNames);
      if (o instanceof ps.io.Response)
         return o;
      if (typeof objectId == "undefined" || objectId == null)
      {
         var result = new ps.io.Response();
         result._m_success = true;
         result._m_value = new Object();
         return result;
      }

      var action = "GetActionVisibility";
      var params = new dojo.collections.Dictionary();
      params.add("names", o.names);   
      var result = this._makeRequest(
         action, this.MIMETYPE_JSON, objectId.serialize(), params);
      if (result.isSuccess())
      {
         result._m_value = result._m_value[0];
      }
      return result;
   }
   
   /**
    * Converts the supplied type to an Object whose properties are the action 
    * names, if necessary and assigns it to another Object as the value of its
    * 'names' property.
    * 
    * @param actionNames May be undefined, null, primitive string, String, Array
    * of string or Object.
    * 
    * @return Either a ps.io.Response, whose value is an empty Object, if 
    * actionNames is undefined or null, or an Object with a single property, 
    * names, whose value is an Object with a property for each name supplied 
    * in actionNames and whose value is null.
    */
   this._normalizeNames = function(actionNames)
   {
      if (typeof actionNames == "undefined" || actionNames == null
         || (typeof actionNames == "array" && empty(actionNames)))
      {
         var result = new ps.io.Response();
         result._m_success = true;
         result._m_value = new Object();
         return result;
      }
      
      var p = new Object();
      if (typeof actionNames == "string")
      {
         p.names = {actionNames:null};
      }
      else if (typeof actionNames == "object" )
      {
         if (actionNames instanceof String)
            p.names = {actionNames:null};
         else
            p.names = actionNames;
      }
      return p;
   }
   
   /**
    * Looks up an action based on a name, then retrieves its label.
    * 
    * @param names A single string or a set of strings, each of which is used 
    * to lookup a PSAction. If empty, a successful response 
    * with an empty object is returned.
    * 
    * @return ps.io.Response whose value is a map. The names of all the visible 
    * actions are used as keys while the value is the label of that action. Never 
    * null.
    */
   this.getActionLabels = function(actionNames)
   {
      var o = this._normalizeNames(actionNames);
      if (o instanceof ps.io.Response)
         return o;
      var action = "GetActionLabels";
      var params = new dojo.collections.Dictionary();
      params.add("names", o.names);      
      return this._makeRequest(
         action, this.MIMETYPE_JSON, null, params);
   }
   
   /**
    * Returns the allowed content types for the specified slot.
    * @param {ps.aa.ObjectId} the slot objectid (Required)
    * @return a Json array that will contain a Json object
    * for each content type.
    * <pre>
    * Each object contains the following parameters:
    * 
    * contenttypeid
    * name
    * description
    * </pre>
    */
   this.getAllowedContentTypeForSlot = function(objectId)
   {
      dojo.lang.assertType(objectId, ps.aa.ObjectId);
      var action = "GetAllowedContentTypeForSlot";
      return this._makeRequest(
         action, this.MIMETYPE_JSON, objectId.serialize(), null);
   }

   /**
    * Retrieves the content type id for the content id passed in.
    *
    * @param {string} contentid of the content item in question.
    * 
    * @return Json object, never <code>null</code> or empty.
    * The returned json object contains the following parameters:
    * <pre>
    * sys_contenttypeid = the content type id
    * </pre>
    */
   this.getContentTypeByContentId = function(contentid)
   {
      var action = "GetContentTypeByContentId";
      var params = new dojo.collections.Dictionary();
      params.add("sys_contentid", contentid);      
      return this._makeRequest(
         action, this.MIMETYPE_JSON, null, params);
   }
   
   /**
    * Returns the urls of images of templates.
    * If the objectId consists of slot id then only image urls of allowed 
    * templates are returned.
    * @param {String} the contentTypeId (Required)
    * @param {ps.aa.ObjectId} the objectid (Required)
    * @return ps.io.Response object containing a array that will contain a map
    * for each content type.
    * <pre>
    * Each map contains the following parameters:
    * 
    * templateId
    * templateName
    * thumbUrl
    * fullUrl
    * </pre>
    */
   this.getTemplateImagesForContentType = function(contentTypeId, objectId)
   {
      dojo.lang.assert(contentTypeId);
      dojo.lang.assertType(objectId, ps.aa.ObjectId);
      var action = "GetTemplateImagesForContentType";
      var params = new dojo.collections.Dictionary();
      params.add("sys_contenttypeid", contentTypeId);      
      return this._makeRequest(
         action, this.MIMETYPE_JSON, objectId.serialize(), params);
   }
   
   /**
    * Creates an item of supplied content type. 
    * @param {int} contentTypeId content type id (Required)
    * @param {String} folderPath the path of the folder in which the item needs 
    *   to be created, if an item exists with the same name in the folder,
    *   newly created item is not added to the folder.
    * @param {String} itemPath the source item path, may be null or empty in 
    * which case a new item is created otherwise a new copy is created 
    * corresponding to this item.
    * @param {String} itemTitle title for the newly created item must not be 
    *   <code>null</code> or empty.
    * @return ps.io.Response consisting of a map consisting of the 
    *   following parameters.
    *   validationError -- only incase of validation errors and will have 
    *      the error message.
    *   itemId -- content id of newly created item
    *   folderId -- parent folder id of newly created. 
    *     may be -1 if failed to add the item to the folder. 
    */
   this.createItem = function(contentTypeId,folderPath,itemPath,itemTitle)
   {
      dojo.lang.assert(contentTypeId);
      dojo.lang.assert(folderPath);
      dojo.lang.assert(itemTitle);
      var action = "CreateItem";
      var params = new dojo.collections.Dictionary();
      params.add("sys_contenttypeid", contentTypeId);      
      params.add("folderPath", folderPath);      
      params.add("itemPath", itemPath);      
      params.add("itemTitle", itemTitle);      
      return this._makeRequest(
         action, this.MIMETYPE_JSON, null, params);
   }
    
   /**
    * Returns the item path of the supplied object id. 
    * Gets the parent folder id from the supplied objectId, 
    * if none calculates from item folder relationsships.
    * Builds a path with parent folder path and item name. 
    * Throws exception if the folder id is invalid.
    * If fails to get the parent folder, assumes that the item does not exist 
    * in any folder and returns its name.
    * @return path of the item of supplied objectId.
    */
   this.getItemPath = function(objectId)
   {
      dojo.lang.assertType(objectId, ps.aa.ObjectId);
      var action = "GetItemPath";
      return this._makeRequest(
         action, this.MIMETYPE_PLAIN, objectId.serialize(), null);
   }
   
   /**
    * Returns true if the item qualifies for managing of
    * the navigation.
    */
   this.canManageNav = function(objectId)
   {
      dojo.lang.assertType(objectId, ps.aa.ObjectId);
      var action = "CanManageNav";
      return this._makeRequest(
         action, this.MIMETYPE_PLAIN, objectId.serialize(), null);
   }
   
   /**
    * Returns array of all available workflow actions for the
    * passed in objectId, based on user permissions and current
    * community.
    * <pre>
    * Resulting object structure:
    * [
    *    {
    *       name: '',
    *       actionname: '',
    *       actiontype: '',
    *       comment: '',
    *       adhoc: '',
    *       transitionid: '',
    *       label: ''
    *    }
    * ]
    * 
    * </pre>
    */
   this.getWorkflowActions = function(objectId)
   {
      dojo.lang.assertType(objectId, ps.aa.ObjectId);
      var action = "GetWorkFlowActions";
      return this._makeRequest(
         action, this.MIMETYPE_JSON, objectId.serialize(), null);
   }

   /**
    * Action to get the content id or folder id by path
    * @param {String} path of item or folder
    * @return JSONObject of id(int) and type(String either item or folder) of 
    * the content item or folder represented by the supplied path. 
    * If the supplied path does not correspond to any item or folder then the 
    * server throws PSAAClientException.
    */
   this.getIdByPath = function(path)
   {
      var action = "GetIdByPath";
      var params = new dojo.collections.Dictionary();
      params.add("path", path);
      
      return this._makeRequest(
         action, this.MIMETYPE_JSON, null, params);
   }
   

   /**
    * Returns allowed templates for the specified snippet and a template count. 
    * The snippet is assembled with each template and is decorated
    * with a surrounding div tag that contains an onclick action
    * to allow the template to be selected. This is meant to
    * be used within a dialog that pops up when a template choice
    * is required. A close button is also included after
    * the last template is rendered.
    * @param {ps.aa.ObjectId} the snippet objectid (Required)
    * @return rendered templates as html, decorated with 
    * special div tags.
    * <pre>
    * The JSON object will contain the following parameters:
    * 
    * templateHtml - The assembled template variations
    * count - The template count
    * </pre>
    */
   this.getAllowedSnippetTemplates = function(objectId)
   {
      dojo.lang.assertType(objectId, ps.aa.ObjectId);
      var action = "GetAllowedSnippetTemplates";
      return this._makeRequest(
         action, this.MIMETYPE_JSON, objectId.serialize(), null);
   }
   
   /**
    * Returns the allowed templates for the specified slot.
    * @param {ps.aa.ObjectId} the slot objectid (Required).
    * @return a Json array that will contain a Json object
    * for each template.
    * <pre>
    * Each object contains the following parameters:
    * 
    * variantid
    * name
    * description
    * objectid
    * </pre>
    */
   this.getItemTemplatesForSlot = function(objectId)
   {
      dojo.lang.assertType(objectId, ps.aa.ObjectId);
      var action = "GetItemTemplatesForSlot";
      return this._makeRequest(
         action, this.MIMETYPE_JSON, objectId.serialize(), null);
   }
   
   /**
    * Returns the assembled content for the specified field.
    * @param {ps.aa.ObjectId} the slot objectid (Required)
    * @param {boolean} flag indicating that the content
    * should be decorated for active assembly.
    * @return html content.
    */
   this.getFieldContent = function(objectId, isAAMode)
   {
      dojo.lang.assertType(objectId, ps.aa.ObjectId);
      var action = "GetFieldContent";
      var params = null; 
      if(isAAMode)
      {
         params = new dojo.collections.Dictionary();
         params.add("isaamode", "true");
         if(___sys_aamode != undefined && ___sys_aamode != null)
            params.add("sys_aamode", new String(___sys_aamode));   
      }
      return this._makeRequest(
         action, this.MIMETYPE_HTML, objectId.serialize(), params);
   }
   
   /**
    * Returns the assembled content for the specified slot.
    * This method should be used to get snippet content too,
    * because assembly API is not granular enough to get only a snippet.
    * @param {ps.aa.ObjectId} the slot objectid (Required)
    * @param {boolean} flag indicating that the content
    * @return html content.
    */
   this.getSlotContent = function(objectId, isAAMode)
   {
      dojo.lang.assertType(objectId, ps.aa.ObjectId);
      var action = "GetSlotContent";
      var params = null; 
      if(isAAMode)
      {
         params = new dojo.collections.Dictionary();
         params.add("isaamode", "true");
         if(___sys_aamode != undefined && ___sys_aamode != null)
            params.add("sys_aamode", new String(___sys_aamode));
      }
      return this._makeRequest(
         action, this.MIMETYPE_HTML, objectId.serialize(), params);
   }
   
   /**
    * Returns the assembled content for the specified snippet.
    * @param {ps.aa.ObjectId} the slot objectid (Required)
    * @param {boolean} flag indicating that the content
    * @param {String} selected text (Optional).
    * @return html content.
    */
   this.getSnippetContent = function(objectId, isAAMode, selectedtext)
   {
      dojo.lang.assertType(objectId, ps.aa.ObjectId);
      var action = "GetSnippetContent";
      var params = null;
        if(isAAMode)
      {
         params = new dojo.collections.Dictionary();
         params.add("isaamode", "true");
         if(___sys_aamode != undefined && ___sys_aamode != null)
            params.add("sys_aamode", new String(___sys_aamode));
      }
        if(selectedtext != undefined && 
           selectedtext != null && selectedtext.length > 0)
        {
            if(params == null)
               params = new dojo.collections.Dictionary();
            params.add("rxselectedtext", encodeURIComponent(selectedtext)); 
        }      
      return this._makeRequest(
         action, this.MIMETYPE_HTML, objectId.serialize(), params);
   }
   
    /**
     * Sends data to the server to change unmanaged links to managed links.
     * @param {String} content The html content to process.
     * @param {String} contentId The id of the owning item. If not provided, -1
     * is sent.
     * @param {String} folderId The id of the parent folder of this item. If not
     * provided, -1 is sent.
     * @return The result object contains 2 members:
     *       content - The (possibly) modified content - with new managed links where appropriate.
     *       message - Text suitable to display to the user as to what the processing did with the links.
     */
    this.convertLinksToManaged = function(content, contentId, folderId)
    {
        var action = "ConvertLinksToManaged";
        var params = null;
        contentId = contentId == undefined || contentId == null || contentId.length == 0 ? "-1" : contentId;
        folderId = folderId == undefined || folderId == null || folderId.length == 0 ? "-1" : folderId; 

        params = new dojo.collections.Dictionary();
        if (content != undefined && content != null && content.length > 0)
            params.add("content", encodeURIComponent(content)); 
        params.add("sys_contentid", contentId); 
        params.add("sys_folderid", folderId); 

        return this._makeRequest(action, this.MIMETYPE_HTML, null, params);
    }
    
   /**
    * Return the mime type of the assembled snippet.
    * @param {ps.aa.ObjectId} the slot objectid (Required)
    * @return a Json array that will contain a Json object.
    * <pre>
    * The object contains the following parameter(s):
    * 
    * mimetype
    * </pre> 
    */
    this.getSnippetMimeType = function(objectId)
    {
        dojo.lang.assertType(objectId, ps.aa.ObjectId);
        var action = "GetSnippetMimeType";
         return this._makeRequest(
         action, this.MIMETYPE_JSON, objectId.serialize(), null);
    }

   /**
   * Returns the assembled slot content for snippet picker dialog.
   * @param {ps.aa.ObjectId} the slot objectid (Required)
   * @param {boolean} flag if true gets titles of the snippets otherwise
   * gets the assembled snippets.
   * @return html content.
   */
   this.getRenderedSlotContent = function(objectId, isTitles)
   {
      dojo.lang.assertType(objectId, ps.aa.ObjectId);
      var action = "GetSnippetPickerSlotContent";
      var params = null; 
      if(isTitles)
      {
         params = new dojo.collections.Dictionary();
         params.add("isTitles", "true");
      }      
      return this._makeRequest(
      action, this.MIMETYPE_HTML, objectId.serialize(), params);
   }

  /**
    * Removes a specified snippet (or relationship).
    *
    * @param {int} relationshipIds the comma separated list relationships 
    *    ids to be removed. This is a required parameter.
    */
   this.removeSnippet = function(relationshipIds)
   {
      var action = "RemoveSnippet";
      var params = new dojo.collections.Dictionary();
      params.add("relationshipIds", relationshipIds);      

      return this._makeRequest(
         action, this.MIMETYPE_PLAIN, null, params);
   }
   
   /**
    * Adds a specified (new) snippet.
    *
    * @param {ps.aa.ObjectId} snippetId id of the new snippet.
    * This is a required parameter.
    * @param {ps.aa.ObjectId} slotId the slot id of the new snippet.
    * This is a required parameter.
    * @param {String} folderPath the folder path of the new snippet.
    * This is an optional parameter.
    * @param {String} siteName the site name of the new snippet.
    * This is an optional parameter.
    */
   this.addSnippet = function(snippetId, slotId, folderPath, siteName)
   {
      dojo.lang.assertType(snippetId, ps.aa.ObjectId);
      dojo.lang.assertType(slotId, ps.aa.ObjectId);
      folderPath && dojo.lang.assertType(folderPath, String);
      siteName && dojo.lang.assertType(siteName, String);
      var action = "AddSnippet";
      var params = new dojo.collections.Dictionary();
      
      // add the required parameters
      params.add("dependentId", snippetId.getContentId());
      params.add("templateId", snippetId.getTemplateId());
      params.add("ownerId", slotId.getContentId());
      params.add("slotId", slotId.getSlotId());

      // add the optional parameters
      this.addOptionalParam(params, "folderPath", folderPath);
      this.addOptionalParam(params, "siteName", siteName);
         
      return this._makeRequest(
         action, this.MIMETYPE_JSON, null, params);
   }
   
   /**
    * Checks in the specified item.
    *
    * @param {int} contentId the id of the to be checked in item.
    * @param {String} commentText the (optional) comment for the checkin action.
    */
   this.checkInItem = function(contentId, commentText)
   {
      var action = "Workflow";
      var params = new dojo.collections.Dictionary();
      
      // add the required parameters
      params.add("operation", "checkIn");
      params.add("contentId", contentId);
      this.addOptionalParam(params, "comment", commentText);
         
      return this._makeRequest(
         action, this.MIMETYPE_PLAIN, null, params);
   }

   /**
    * Checks out the specified item.
    *
    * @param {int} contentId the id of the to be checked out item.
    * @param {String} commentText the (optional) comment for the checkin action.
    */
   this.checkOutItem = function(contentId, commentText)
   {
      var action = "Workflow";
      var params = new dojo.collections.Dictionary();
      
      // add the required parameters
      params.add("operation", "checkOut");
      params.add("contentId", contentId);
      this.addOptionalParam(params, "comment", commentText);
         
      return this._makeRequest(
         action, this.MIMETYPE_PLAIN, null, params);
   }

   /**
    * Transition and check out the specified item.
    *
    * @param {int} contentId the id of the to be transitioned item.
    * @param {String} trigger the (required) trigger name of the transition.
    * @param {String} commentText the (optional) comment for the transition operation.
    * @param {String} adhocUsers the (optional) adhoc users. It is ';' delimited user names.
    */
   this.transitionCheckOutItem = function(contentId, trigger, commentText, adhocUsers)
   {
      var action = "Workflow";
      var params = new dojo.collections.Dictionary();
      
      params.add("operation", "transition_checkout");
      params.add("contentId", contentId);
      params.add("triggerName", trigger);
      this.addOptionalParam(params, "comment", commentText);
      this.addOptionalParam(params, "adHocUsers", adhocUsers);
         
      return this._makeRequest(
         action, this.MIMETYPE_PLAIN, null, params);
   }

   /**
    * Transition the specified item.
    *
    * @param {int} contentId the id of the to be transitioned item.
    * @param {String} trigger the (required) trigger name of the transition.
    * @param {String} commentText the (optional) comment for the transition operation.
    * @param {String} adhocUsers the (optional) adhoc users. It is ';' delimited user names.
    */
   this.transitionItem = function(contentId, trigger, commentText, adhocUsers)
   {
      var action = "Workflow";
      var params = new dojo.collections.Dictionary();
      
      params.add("operation", "transition");
      params.add("contentId", contentId);
      params.add("triggerName", trigger);
      this.addOptionalParam(params, "comment", commentText);
      this.addOptionalParam(params, "adHocUsers", adhocUsers);
         
      return this._makeRequest(
         action, this.MIMETYPE_PLAIN, null, params);
   }

   /**
    * Adds the specified key/value to the given parameters if the
    * value is not null or undefined.
    * 
    * @param {dojo.collections.Dictionary} params the parameters
    * @param {String} the name of the optional parameter. It may not be null or
    *    undefined.
    * @param {Object} value the optional parameter. It may be null or undefined. 
    */
   this.addOptionalParam = function(params, key, value)
   {
      if (value != null && (!dojo.lang.isUndefined(value)))
         params.add(key, value);  
   }
   
   /**
    * Retrieves the sort rank for the items relationship.
    * @param {int} relid the relationship id (Required)
    * @return the sort rank
    */
   this.getItemSortRank = function(relid)
   {
      var action = "GetItemSortRank";
      var params = new dojo.collections.Dictionary();
      params.add("sys_relationshipid", relid);
      
      return this._makeRequest(
         action, this.MIMETYPE_PLAIN, null, params);
   }

   /**
    * Get all server properties.
    * @return a JSON object that contains a property for each
    * corresponding server property.
    */
   this.getServerProperties = function()
   {
      var action = "GetServerProperties";
      return this._makeRequest(
         action, this.MIMETYPE_JSON, null, null);
   }
   
   /**
    * Get all registered sites from the system.
    * @return a list of sites as a JSON array.
    */
   this.getSites = function()
   {
      var action = "GetSites";
      return this._makeRequest(
         action, this.MIMETYPE_JSON, null, null);
   }
   
   /**
    * Get all root folders (Children of //Folders in the CX) from the system.
    * @return a list of root folders as a JSON array.
    */
   this.getRootFolders = function()
   {
      var action = "GetRootFolders";
      return this._makeRequest(
         action, this.MIMETYPE_JSON, null, null);
   }

   /**
    * Resolves the id values for the passed in site and site folder.
   * @return a JSON object with two properties sys_folderid and
   * sys_siteid both of which may be <code>null</code> or empty.
   */
   this.resolveSiteFolders = function(siteName, folderPath)
   {
       var action = "ResolveSiteFolders";
      var params = new dojo.collections.Dictionary();
       params.add("folderPath", folderPath);
      params.add("siteName", siteName);
      return this._makeRequest(
         action, this.MIMETYPE_JSON, null, params);
   }
   
   /**
    * Create a folder with supplied name under the parent folder supplied (by
    * path). The security/permissions and other properties of the new folder
    * will be inherited from the parent folder.
    * @param {string} parentFolderPath the parent folder path. Cannot be
    * <code>null</code> or empty. Must meet the following requirements:
    * <ul>
    * <li>Must start with '/'</li>
    * <li>The part between first '/' and the next '/' (or end) must be a site
    *   name registered in the system</li>
    * </ul>
    * @param {string} name the folder name. Cannot be <code>null</code>
    * or empty.
    * @param {boolean} isSiteFolder flag indicating that the newly created
    * folder should or should not be a site folder.
    * @return  a JSON object representing the newly
    * created folder, never <code>null</code> or empty.
    */
   this.createFolder = function(parentFolderPath, name, isSiteFolder)   
   {
      var action = "CreateFolder";
      var params = new dojo.collections.Dictionary();
      params.add("parentFolderPath", parentFolderPath);
      params.add("folderName", name);
      params.add("category", isSiteFolder ? "sites" : "folders");
      return this._makeRequest(
         action, this.MIMETYPE_JSON, null, params);
   }
   
    /**
    * Get the children of the supplied  folder path filtered for
    * the supplied content type and if a site folder then the slotid.
    * 
    * @param {string} parentFolderPath the parent folder path. Cannot be
    * <code>null</code> or empty. Must meet the following requirements:
    * <ul>
    * <li>Must start with '/'</li>
    * <li>For the site folders the part between first '/' and the next '/'
    * (or end) must be a site name registered in the system</li>
    * </ul>
    * @param {int} ctypeid the contenttypeid. "-1" if the content type id
    * is not specified and results should be returned for all content types.
    * Cannot be <code>null</code> or empty.
    * @param {int} slotid the contenttypeid. Cannot be <code>null</code>
    * or empty if isSiteFolder is <code>true</code>.
    * @param {boolean} isSiteFolder flag indicating that the folder in
    * question is a site folder.
    * @return  child folders and items of the supplied folder as JSON array.
    * Never <code>null</code> or empty.
    */
   this.getFolderChildren = function(parentFolderPath, ctypeid, slotid, isSiteFolder)
   {
      var action = "GetChildren";
      var params = new dojo.collections.Dictionary();
      params.add("parentFolderPath", parentFolderPath);
      params.add("sys_contenttypeid", ctypeid);
      if(isSiteFolder)
         params.add("sys_slotid", slotid);
      params.add("category", isSiteFolder ? "sites" : "folders");
      return this._makeRequest(
         action, this.MIMETYPE_JSON, null, params);
   }
   
    /**
    * Get the children of the supplied  folder path filtered for
    * the supplied content type and if a site folder then the slotid.
    * 
    * @param {string} parentFolderPath the parent folder path. Cannot be
    * <code>null</code> or empty. Must meet the following requirements:
    * <ul>
    * <li>Must start with '/'</li>
    * <li>For the site folders the part between first '/' and the next '/'
    * (or end) must be a site name registered in the system</li>
    * </ul>
    * @param {int} ctypeid the contenttypeid. Must be a valid content type id.
    * @param {boolean} isSiteFolder flag indicating that the folder in
    * question is a site folder.
    * @return  URL to open a content editor to create item of specified content 
    * type. Never <code>null</code> or empty.
    */
   this.getCreateItemUrl = function(parentFolderPath, ctypeid, isSiteFolder)
   {
      var action = "GetCreateItemUrl";
      var params = new dojo.collections.Dictionary();
      params.add("parentFolderPath", parentFolderPath);
      params.add("sys_contenttypeid", ctypeid);
      params.add("category", isSiteFolder ? "sites" : "folders");
      return this._makeRequest(
         action, this.MIMETYPE_JSON, null, params);
   }
   
   /**
    * Gets the inline link parent ids for the specified dependent id. 
    * 
    * @param {int} dependentId The dependent id.
    * @param {Array} managedIds The managed ids as array of integers.
    * 
    * @return the response which contains the parent ids described above, 
    *   they must exist in the specified managed ids. 
    */
   this.getInlinelinkParentIds = function(dependentId, managedIds)
   {
      var action = "GetInlinelinkParents";
      var params = new dojo.collections.Dictionary();
      params.add("dependentId", dependentId);
      params.add("managedIds", dojo.json.serialize(managedIds));
      return this._makeRequest(
         action, this.MIMETYPE_JSON, null, params);
   }
   
   /**
    * Gets the value of the field from the content editor.
    * @param {ps.aa.ObjectId} of the field.
    * This is a required parameter.
    */
   this.getContentEditorFieldValue = function(objectId)
   {
      dojo.lang.assertType(objectId, ps.aa.ObjectId);      
      var action = "GetContentEditorFieldValue";
      return this._makeRequest(
      action, this.MIMETYPE_HTML, objectId.serialize(), null);
   }
   
   /**
    * Sets the supplied value to the supplied fieldname that is part of the 
    * supplied objectid
    * @param {ps.aa.ObjectId} of the field.
    * This is a required parameter.
    */
   this.setContentEditorFieldValue = function(objectId, fieldValue)
   {
      dojo.lang.assertType(objectId, ps.aa.ObjectId);
      var action = "SetContentEditorFieldValue";
      var params = new dojo.collections.Dictionary();
      params.add("fieldValue", fieldValue);      
      return this._makeRequest(
         action, this.MIMETYPE_JSON, objectId.serialize(), params);
   }
   
   /**
   * Builds action url for getting the related content search results.
   */
   this.getUpdateItemUrl = function()
   {
      return this._buildRequestUrl("UpdateItem",null);
   }
   
   /**
    * Retrieves the server session max timeout in seconds.
    */
   this.getMaxTimeout = function()
   {
      var action = "GetMaxTimeout";            
      return this._makeRequest(
         action, this.MIMETYPE_PLAIN, null, null);
   }
   
   /**
    * How many locales does the server support. If the request to the server
    * fails for any reason, the value is conservatively set to 1. The value is
    * cached after the 1st request.
    
    * Returns a value >= 1. 
    */
   this.getLocaleCount = function()
   {
      if (this.localeCount > -1)
         return this.localeCount;
         
      var action = "GetLocaleCount";
      var response = this._makeRequest(
         action, this.MIMETYPE_PLAIN, null, null);      
      if(response.isSuccess())
      {
         this.localeCount = parseInt(response.getValue());
      }
      else
      {
         localeCount = 1;
      }
      return this.localeCount;
   }
   
   /**
    * Builds action url for getting the related content search results.
    */
   this.getRcSearchUrl = function()
   {
      return this._buildRequestUrl("GetSearchResults",null);
   }
      
   /**
    * Calls onsubmit on the supplied form object. If the form is not bound to 
    * to the supplied formObject alerts the user and returns null.
    * @param formObj the form object that needs to be submitted.
    * @return ps.io.Response object.
    */
    this.submitForm = function(formObj)
    {
       this.formSubmitResults = null;
       var fn = this.rcFormBind.bindArgs.formNode;
       var fid = (typeof(fn) == "string")?fn:fn.id;
       if(formObj.id != fid)
       {
          alert("Error occured submitting the form. The form is not bound.");
          return this.formSubmitResults;
       }
       formObj.onsubmit();
       return this.formSubmitResults;
    }
    
    /**
     * Initializes the formbind object with the supplied action and form. 
     * This method must be called before calling the submitForm.
     * @param action, name of the action 
     */
    this.initFormBind = function(reqUrl,formId,mimetype)
    {
      var _this = this;
      var result = new ps.io.Response();
      this.rcFormBind = new dojo.io.FormBind({
      url:reqUrl,
      sync: true,
      useCache: false,
      preventCache: true,
      mimetype: mimetype,
      formNode:formId,
      load: function(load, data, e) {
            if(load == "error")
            {
               result._m_success = false;
               var msg = ps.io.Actions._parseError(data.message, e);
               result._m_value = msg.message;
               result._m_errorcode = msg.errorCode;                     
            }
            else
            {
               result._m_success = true;
               if(typeof(data) == "object")
                  result._m_value = ps.io.Actions._flattenArrayProperties(data);
               else
                  result._m_value = data;
            }
            _this.formSubmitResults = result;
         }
      });
    }

   /**
    * Function to test calling the server .
    *
    * @param {string} mode
    * @return
    */
   this.test = function(mode)
   {
      var action = "Test";
      var params = new dojo.collections.Dictionary();
      params.add("mode", mode);      
      return this._makeRequest(
         action, this.MIMETYPE_PLAIN, null, params);
   }
   
   /**
    * Sends a test request to the server to keep the session alive.
    *
    */
   this.keepAlive = function()
   {
      // make a test request to the server to keep alive
      var aresponse = this.getMaxTimeout();
      if(!aresponse.isSuccess())
         return;
      var delay = parseInt(aresponse.getValue()) * 900;
      setTimeout("ps.io.Actions.keepAlive()", delay);
   }
   
   // Private functions
   
   /**
    * Builds the server request url for the action.
    * Requires that __rxroot was set with the correct server root.
    * @param {string} action the action name, assumed not <code>null</code>
    * or empty.
    * @param {objectId} the object id object, may be <code>null</code>.
    */
   this._buildRequestUrl = function(action, objectId)
   {
      var base = __rxroot + "/contentui/aa?action=" + action;
      if(objectId != null && objectId != undefined)
      {
         base += "&objectId=" + escape(objectId);
      }      
      return base;
   }
   
   /**
    * Gets request url and makes the request
    * @param {string} action the action name, assumed not <code>null</code>
    * or empty.
    * @param {string} the mimetype, assumed not <code>null</code> or
    * empty.
    * @param {objectId} the object id object, may be <code>null</code>.
    * @param {dojo.collections.Dictionary} a dictionary map of parameters
    * for the request. May be <code>null</code> or empty.
    */
   this._makeRequest = function(action, mimetype, objectId, params)
   {
      var transError = "XMLHttpTransport Error:";      
      var result = new ps.io.Response();
      var requestUrl = this._buildRequestUrl(action, objectId);
      var paramsObj = new Object();
      if(params != null && params != undefined)
      {                
         var keys = params.getKeyList();
         for(i = 0; i < keys.length; i++)
         {
            var val = params.item(keys[i]);
            if(val == null || val == "" || val == undefined)
               continue;
            paramsObj[keys[i]] = val;   
         }
      }
      dojo.io.bind({
               url: requestUrl,
               useCache: false,
               preventCache: true,
               mimetype: mimetype,
               method : "POST",
               content: paramsObj,
               sync: true,
               handler: function(type, data, e) 
               {
                  if(type == "error")
                  {
                     result._m_success = false;
                     var msg = ps.io.Actions._parseError(data.message, e);
                     result._m_value = msg.message;
                     result._m_errorcode = msg.errorCode;                     
                  }
                  else
                  {
                     result._m_success = true;
                     result._m_value = ps.io.Actions._flattenArrayProperties(data);
                  }
               }
           });
           return result;
   }
    
   /**
    * Helper method that parses a response error string
    */
   this._parseError = function(error, e)
   {
      var results = new Object();
      var transError = "XMLHttpTransport Error: ";
      if(dojo.string.startsWith(error, transError))
      {
         var temp = error.substring(transError.length);
         var eCode = parseInt(temp.substring(0, 3));
         var msg = temp.substring(4);
         results.errorCode = eCode;
         if(eCode === 404 || eCode === 0)
         {
            msg = ps.io.Actions.ERROR_MSG_NO_SERVER;
            eCode = 404;
         }
         else if(eCode === 500 && 
             dojo.string.has(e.responseText, ps.io.Actions.SESS_NOTAUTH_TEXT))
         {
           msg = ps.io.Actions.ERROR_MSG_REQUIRES_AUTH;
         }
         results.message = msg;
      }
      else
      {
         results.errorCode = "unknown";
         results.message = error;
      }
      return results;
      
   }
   
   /**
    * Flattens any single value array properties
    * @param {object} the object to be flattened
    * @return the modified object, never <code>null</code>
    */
   this._flattenArrayProperties = function(obj)
   {
      if (typeof(obj) != "object")
         return obj;
      var newObj = dojo.lang.isArrayLike(obj) ? [] : new Object();
      for (var item in obj)
      {
         var prop = obj[item];
         if(dojo.lang.isArrayLike(prop) && prop.length == 1)
         {
            newObj[item] = prop[0];            
         }
         else
         {
            newObj[item] = prop;
         }
      }
      return newObj;
   }

   /**
    * If the provided action response indicates an error,
    * reports the error to the user.
    * Does nothing if the response indicates success.
    * @param response an instance of {@link ps.io.Response}.
    * Not <code>null</code>.
    */
   this.maybeReportActionError = function (response)
   {
      dojo.lang.assertType(response, ps.io.Response);
      if (!response.isSuccess())
      {
         ps.error(response.getValue());
      }
   }
   
   /**
    * Constant for needs template error
    */
   this.NEEDS_TEMPLATE_ID = "needs_template_id";
   
   /**
    * Text to find to determine if the internal server error
    * is a missing auth error.
    */
   this.SESS_NOTAUTH_TEXT = "Processing Error: Not Authenticated";
   
   /**
    * Error message to be displayed if authentication is needed
    * for current session.
    */
   this.ERROR_MSG_REQUIRES_AUTH = "This request requires authentication, but the " +   
      "current session is not authenticated.\nThe user " +
       "session may have expired or the server may have been "+
      "restarted.\nYou must log back into Rhythmyx to continue.";
   
   /**
    * Error message to be display if a 404 error code comes
    * back from a request.
    */
   this.ERROR_MSG_NO_SERVER = "Unable connect to the Rhythmyx server.\nThe server may be down." +
      "\nPlease contact your Rhythmyx administrator.";
};

/******************************************************************************
 *
 * [ ps.aa.Menu.js ]
 *
 * COPYRIGHT (c) 1999 - 2007 by Percussion Software, Inc., Woburn, MA USA.
 * All rights reserved. This material contains unpublished, copyrighted
 * work including confidential and proprietary information of Percussion.
 *
 *****************************************************************************/
 
dojo.provide("ps.aa.Menu");







/**
 * This is used to manage the menubar and context menu for the current
 * selected object, which could be the page, a snippet or a slot.
 */
ps.aa.Menu = new function()
{
   /**
    * A list of member data used to remember various menu items (HTMLDivElement)
    */
   this.menubarIcon = null;
   this.showTreeElem = null;
   this.hideTreeElem = null;
   this.showBordersElem = null;
   this.hideBordersElem = null;
   this.showPlaceholdersElem = null;
   this.hidePlaceholdersElem = null;

   // member data for menu bar
   this.addSnippetElem = null;

   this.changeTemplateElem = null;
   this.downElem = null;
   this.upElem = null;

   //member data for 'Content' menu
   this.contentElem = null;
   this.contentNewElem = null;
   this.contentNewItemElem = null;

   //member data for 'Account' menu
   this.accountElem = null;
   this.accountLogoutElem = null;
   this.accountUserInfoElem = null;

   // member data for 'Edit' submenu
   this.editElem = null;
   this.editAllElem = null;
   this.editFieldElem = null;
   this.removeElem = null;
   
   // data for the 'View' submenu
   this.viewElem = null;
   
   // member data for 'Tools' submenu
   this.toolElem = null;
   this.workflow = null;
   
   this.compare = null;
   this.showRelationships = null;
   this.translate = null;
   this.createVersion = null
   this.showUrl = null;
   this.pubNow = null;
   
   this.separator = null;
   
   this.viewContent = null;
   this.viewProperties = null;
   this.viewRevisions = null;
   this.viewAuditTrail = null;

   // preview menu
   this.preview = null;

   // member data for context menu
   
   this.slotCtxMenu = null;
   this.itemCtxMenu = null;

   this.ctxChangeTemplate = null;
   this.ctxUp = null;
   this.ctxDown = null;
   this.ctxRemove = null;
   
   this.ctxNewFromSnippet = null;
   this.ctxInsertFromSnippet = null;
   this.ctxReplaceFromSnippet = null;
   this.ctxOpenFromSnippet = null;
	
   this.ctxItemSeparator1 = null;
   this.ctxItemSeparator2 = null;
   this.ctxEditAll = null;
   this.ctxEditField = null;   
   
   this.ctxAddSnippet = null;
   this.ctxRemoveSnippet = null;
   this.ctxNewSnippet = null;

   /**
    * Used to determine if menu entries based on PSActions are visible to the 
    * user given the context of the item as well as to get the label for an
    * action. The class hides all the server calls
    * and cache management required to provide the functionality.
    * <p>
    * The general use case for visbility is:
    * <pre>
    *    this.actionVisibilityChecker.setCurrentId(objectId);
    *    loop:
    *       this.actionVisibilityChecker.isVisible(actionName);
    * </pre>
    */
   this.actionVisibilityChecker = 
   {
      /**
       * Finds a label for a given name, case-insensitive. If the label can't
       * be retrieved for any reason, the supplied name is returned.
       * 
       * @param actionName Assumed to be the name of a PSAction registered
       * with the workbench and that is being used by this class. 
       * 
       * @return The label set on the action identified by the supplied name,
       * or the supplied name if it can't be found or loaded.
       */
      getLabel: function(actionName)
      {
         if (this.m_labels == null)
         {
            var response = ps.io.Actions.getActionLabels(this.getNames());
            if (!response.isSuccess())
            {
               dojo.debug(
                  "Failed to retrieve labels for some menu actions. Reason: " 
                  + response.getValue());
               return actionName;
            }
            this.m_labels = {};
            var resp = response.getValue()[0];
            for (var name in resp)
               this.m_labels[name.toLowerCase()] = resp[name];
         }
         
         var label = this.m_labels[actionName.toLowerCase()]
         if (label == undefined || label == null)
            return actionName;
         return label;
      },
      
      /**
       * Checks whether the item in the context supplied via the setCurrentId
       * method is visible to the current user.
       * 
       * @return true if the action identified by the supplied name, case-
       * insensitive is visible to the current user given the current
       * context, false otherwise.
       */
      isVisible: function(actionName)
      {
         if (this.m_currentId == null || actionName == undefined || actionName == null)
            return false;
         var visibilityMap = this.m_cache[this.m_currentId.toString()];
         
         if (visibilityMap == null)
         {
            var response = ps.io.Actions.getActionVisibility(this.getNames(), 
               this.m_currentId);
            if (!response.isSuccess())
            {
               dojo.debug(
                  "Failed to retrieve visibility states for some menu actions. Reason: " 
                  + response.getValue());
               return false;
            }
            visibilityMap = response.getValue();
            this.m_cache[this.m_currentId.toString()] = visibilityMap;
         }
         
         return visibilityMap[actionName.toLowerCase()];
      },
      
      /**
       * Must be called if any events occur that might change the visibility
       * of PSAction based menu entries. Causes all cached visibility maps
       * to be discarded.
       * 
       * @return none
       */
      flush: function()
      {
         this.m_cache = {};
      },
      
      /**
       * Must be called  before isVisible will work correctly.
       * 
       * @param objectId Assumed to be a valid id.
       * 
       * @return none
       */
      setCurrentId: function(objectId)
      {
         this.m_currentId = objectId;
      },
      
      /**
       * All actions that are PSAction based must be hard-coded in this method.
       * 
       * @return An array of all the names. Never null. The
       * array is owned by this class and should not be modified in any way.
       */
      getNames: function()
      {
         if (this.m_names == null)
         {
            this.m_names = [
               "Edit_PromotableVersion",
               "Publish_Now",
               "Item_ViewDependents",
               "View_Compare",
               "Translate",
            ];
         }
         return this.m_names;
      },
      
      /**
       * Lazily generated list of all known menu entries based on PSActions.
       * Filled the first time by walking the enumerable objects in the outer
       * class. If the widget has the actionName property, it is 
       * considered to be such an action. The type is Array.
       */
      m_names: null,
      
      /**
       * A map whose property name is the action name (lower-cased) and whose 
       * value is the label. There is an entry for each entry in m_names. Must 
       * be accessed via the getLabel() method.
       */
      m_labels: null,
      
      /**
       * Set by the setCurrentId method. This is the context used to 
       * determine the visibility of an action.
       */
      m_currentId: null,
      
      /**
       * Visibility results are cached by objectId for speed improvement.
       * Never null.
       */
      m_cache: {},
      
      /**
       * The outer object.
       */
      m_parent: this
   }
   
   /**
    * Initialize the properties of the menu. This should be called right after 
    * the dojo is done passing the HTML content.
    */
   this.init = function(ids)
   {
      this._initMenuBar();
   }
   
   /**
    * Non-critical initialization, which can be called later.
    */
   this.initAsynch = function (ids)
   {
      this._initContextMenu(ids);
      var menubar = dojo.widget.byId("ps.aa.Menubar");
      this._addMenubarItems2(menubar);
   }
   
   /**
    * Reset the menu for the specified object id
    * 
    * @param {ps.aa.ObjectId} objId The to be activated object id.
    */
   this.activate = function(objId, parentId)
   {
      this._resetMenubar(objId, parentId);
      this._resetContextMenu(objId, parentId);
   }
   
   /**
    * Reset the menubar for the specified object id.
    * 
    * @param {ps.aa.ObjectId} objId
    */
   this._resetMenubar = function(objId, parentId)
   {
      this._resetMenubarParams = {objId: objId, parentId: parentId};

      if (objId.isSlotNode())
      {
         this._resetSlotBar(objId.isCheckoutByMe());
      }
      else if (objId.isPageNode() || objId.isFieldNode())
      {
         this._resetPageFieldBar(objId);
      }
      else // if (objId.isSnippetNode())
      {
         this._resetSnippetBar(objId, parentId);
      }
      
      this._updateIconMenuItem(objId);
   }
   
   /**
    * Same as running {@link #resetMenubar} with the last parameters it was
    * called with.
    */
   this._resetLastMenubar = function()
   {
      var params = this._resetMenubarParams;
      if (params)
      {
         this._resetMenubar(params.objId, params.parentId);
      }
   }

   /**
    * Updates the image and the tooltip for the icon menu item on the menubar
    * 
    * @param objId the actived object id.
    */
   this._updateIconMenuItem = function(objId)
   {
      // updates the icon image
      this.menubarIcon.setImage(objId.getImagePath(
       ps.aa.controller.IMAGE_ROOT_PATH));

      // updates the title or tooltip             
      var title = "";
      if (objId.isFieldNode())
      {
         title = objId.getFieldName();
      }
      else
      {
         div = dojo.byId(objId.serialize());
         title = div.getAttribute("psAaLabel");
      }
      this.menubarIcon.setTitle(title);      
   }
   
   /**
    * Shows the widget element if it is not null and is visible, otherwise,
    * hides it.
    * 
    * @param widget The menu to show. May be null.
    * @param objId The context under which the menu is shown. This is used to
    * calculate the visibility of certain actions. If the action is not visible,
    * it will be hidden instead. If not provided, the menu will be shown.
    */
   this._maybeShow = function (widget, objId)
   {
      var visible = true;
      if (widget)
      {
         if (objId)
         {
            if (widget.rx_actionName !== undefined)
            {
               this.actionVisibilityChecker.setCurrentId(objId);
               visible = 
                  this.actionVisibilityChecker.isVisible(widget.rx_actionName);
            }
         }
         if (visible)
            dojo.html.show(widget.domNode);
         else
            dojo.html.hide(widget.domNode);
      }
   }
   
   /**
    * Hides the widget element if it is not null.
    */
   this._maybeHide = function (widget)
   {
      if (widget)
      {
         dojo.html.hide(widget.domNode);
      }
   }

   /**
   * Reset menubar for a slot
    * 
    * @param {boolean} isCheckoutByMe 'true' if the parent item is checkout by
    *    the user; 'false' otherwise.
    */
   this._resetSlotBar = function(isCheckoutByMe)
   {
      // hide menu items that do not apply to slot
      this._maybeHide(this.changeTemplateElem);
      this._maybeHide(this.upElem);
      
      this._maybeHide(this.downElem);
      
      dojo.html.hide(this.editElem.domNode);
      this._maybeHide(this.editAllElem);
      this._maybeHide(this.editFieldElem);
      this._maybeHide(this.removeElem);

      // hide Tools menu because it contains no items visible for a slot
      dojo.html.hide(this.toolElem.domNode)
      this._maybeHide(this.workflow);

      // show menu items that are specific for a slot
      this._maybeShow(this.addSnippetElem);
      
      if (this.addSnippetElem)
      {
         this.addSnippetElem.setDisabled(!isCheckoutByMe);
      }
   },
   
   /**
    * Reset the menu bar for a page or field object.
    */
   this._resetPageFieldBar = function(objId)
   {
      var response = ps.io.Actions.canManageNav(objId);
      if (response.isSuccess() && response.getValue() == "true")
      {
         this._maybeShow(this.nav);         
      }
      else
      {
         this._maybeHide(this.nav);
      }
      
      // hide menu items that are specific for snippet
      this._maybeHide(this.addSnippetElem);

      this._maybeHide(this.changeTemplateElem);
      this._maybeHide(this.upElem);
      this._maybeHide(this.downElem);
      
      this._maybeHide(this.removeElem);

      // show the menu items that are specific for a page/field node
      dojo.html.show(this.editElem.domNode);
      this._maybeShow(this.editAllElem);

      dojo.html.show(this.toolElem.domNode);
      this._maybeShow(this.viewContent);
      this._maybeShow(this.viewProperties);
      this._maybeShow(this.viewRevisions);
      this._maybeShow(this.viewAuditTrail);
      this._maybeShow(this.translate, objId);
      this._maybeShow(this.createVersion, objId);
      this._maybeShow(this.compare, objId);
      this._maybeShow(this.showRelationships, objId);
      
      this._maybeShow(this.workflow);

      //Show the publish now action to page only.
      if(objId.isPageNode())
      {
         this._maybeShow(this.pubNow, objId);
      }
      else
      {
         this._maybeHide(this.pubNow, objId);
      }

      
      if (objId.isFieldNode())
      {
         this._maybeShow(this.editFieldElem);
      }
      else
      {
         this._maybeHide(this.editFieldElem);
      }

      // enable and disable appropriate menu items
      var disable = !objId.isCheckoutByMe();
      this.editElem.setDisabled(disable);
      if (this.editAllElem)
      {
         this.editAllElem.setDisabled(disable);
      }
      if (objId.isFieldNode() && this.editFieldElem)
      {
         this.editFieldElem.setDisabled(disable);
      }
   },

   this._resetSnippetBar = function(objId, parentId)
   {
      // hide menu items that are not appliable to a snippet
      this._maybeHide(this.addSnippetElem);
      this._maybeHide(this.editFieldElem);
      this._maybeHide(this.nav);

      //Hide publish now action for snippets
      this._maybeHide(this.pubNow, objId);

      // show the menu items that are specific for a snippet
      this._maybeShow(this.changeTemplateElem);
      this._maybeShow(this.upElem);
      this._maybeShow(this.downElem);
      
      dojo.html.show(this.editElem.domNode);
      this._maybeShow(this.editAllElem);
      this._maybeShow(this.removeElem);

      dojo.html.show(this.toolElem.domNode);
      this._maybeShow(this.workflow);

      var disableParent = !parentId.isCheckoutByMe();
      if (this.changeTemplateElem)
      {
         this.changeTemplateElem.setDisabled(disableParent);
      }
      if (this.downElem)
      {
         this.downElem.setDisabled(disableParent);
      }
      if (this.upElem)
      {
         this.upElem.setDisabled(disableParent);
      }
      if (this.removeElem)
      {
         this.removeElem.setDisabled(disableParent);
      }

      if (objId.isCheckoutByMe())
      {
         this.editElem.setDisabled(false);
         if (this.editAllElem)
         {
            this.editAllElem.setDisabled(false);
         }
      }
      else
      {
         if (parentId.isCheckoutByMe())
         {
            this.editElem.setDisabled(false);
            if (this.editAllElem)
            {
               this.editAllElem.setDisabled(true);
            }
         }
         else
         {
            this.editElem.setDisabled(true);
         }
      }
   },

   /**
    * Initialize the member data for menu items of the menubar.
    */
   this._initMenuBar = function()
   {
      // dynamically build the menubar
      var menubar = dojo.widget.byId("ps.aa.Menubar");
      
      this.menubarIcon = dojo.widget.createWidget(ps.aa.Menu.MENUBARICON);
      menubar.addChild(this.menubarIcon);
      this._addContentMenu(menubar);
      this._addEditMenu(menubar);
      this._addViewMenu(menubar);
      this.workflow = dojo.widget.createWidget(ps.aa.Menu.MENUBARITEM, 
           {caption: "Workflow...", 
           onClick: function(){ps.aa.controller.workflowItem();}});
      menubar.addChild(this.workflow);
      
      this._addToolsMenu(menubar);
      this._addPreviewMenu(menubar);
      this._addAccountMenu(menubar);
      this._addNavigationMenu(menubar);
      this._addHelpMenu(menubar);
      this.toggleShowHidePlaceholders(true);
   }

   /**
    * Helper method to create menu bar items.
    * @param menubar the menu bar to add the menubar items to.
    * Not null.
    */
   this._addMenubarItems2 = function(menubar)
   {
      dojo.lang.assert(menubar, "Menu bar must be specified");
      
      this.addSnippetElem = dojo.widget.createWidget(ps.aa.Menu.MENUBARITEM, 
                      {caption: "Insert Snippet...", 
                      onClick: function(){
                         ps.aa.controller.addSnippet(
                         ps.aa.Menu.INSERT_FROM_SLOT);}});
      dojo.html.hide(this.addSnippetElem.domNode);

      menubar.addChild(this.addSnippetElem, null, "before", this.preview.domNode);


      this.changeTemplateElem = dojo.widget.createWidget(ps.aa.Menu.MENUBARITEM, 
                      {caption: "Template...", 
                      onClick: function(){ps.aa.controller.changeTemplate();}});
      dojo.html.hide(this.changeTemplateElem.domNode);

      this.upElem = dojo.widget.createWidget(ps.aa.Menu.MENUBARITEM, 
                      {caption: "Up", 
                      onClick: function(){ps.aa.controller.moveSnippetUp();}});
      dojo.html.hide(this.upElem.domNode);

      this.downElem = dojo.widget.createWidget(ps.aa.Menu.MENUBARITEM, 
                      {caption: "Down", 
                      onClick: function(){ps.aa.controller.moveSnippetDown();}});
      dojo.html.hide(this.downElem.domNode);

      // add them 3 in a row
      menubar.addChild(this.changeTemplateElem, null, "after", 
         this.toolElem.domNode);
      menubar.addChild(this.upElem, null, "after", 
         this.changeTemplateElem.domNode);
      menubar.addChild(this.downElem, null, "after", this.upElem.domNode);
   }
   
   this._addViewMenu = function(menubar)
   {
      var _this = this;

      /* these must be created before the menu is accessed because they are
         called early during init */
      this.showTreeElem = dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
                  {caption: "Show Outline", 
                  onClick: function(){ps.aa.controller.showTree();}});
      this.hideTreeElem = dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
                  {caption: "Hide Outline", 
                  onClick: function(){ps.aa.controller.hideTree();}});
      if(___sys_aamode == 1)
      {
         this.showBordersElem = dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
                  {caption: "Show Icons/Borders", 
                  onClick: function(){ps.aa.controller.showBorders();}});
      }
      else
      {
         this.hideBordersElem = dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
                  {caption: "Hide Icons/Borders", 
                  onClick: function(){ps.aa.controller.hideBorders();}});
      }
      this.showPlaceholdersElem = dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
                  {caption: "Show Place Holders", 
                  onClick: function(){ps.aa.controller.showPlaceholders();}});
      this.hidePlaceholdersElem = dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
                  {caption: "Hide Place Holders", 
                  onClick: function(){ps.aa.controller.hidePlaceholders();}});


      function createSubmenu()
      {
         var popmenu = dojo.widget.createWidget(ps.aa.Menu.POPUPMENU,
               {id: "ps.aa.ViewSubMenu"});

         popmenu.addChild(_this.showTreeElem);

         popmenu.addChild(_this.hideTreeElem);
          if(___sys_aamode == 1)
          {
             popmenu.addChild(_this.showBordersElem);
          }
          else
          {
             popmenu.addChild(_this.hideBordersElem);
          }
         popmenu.addChild(_this.showPlaceholdersElem);

         popmenu.addChild(_this.hidePlaceholdersElem);

         
         _this._resetLastMenubar();
      }

      this.viewElem = dojo.widget.createWidget(ps.aa.Menu.MENUBARITEMDROPDOWN, 
                      {caption: "View", submenuId: "ps.aa.ViewSubMenu"});
      this.viewElem.createSubmenu = createSubmenu;
      menubar.addChild(this.viewElem);      
   }
   
   /**
    * Helper method to create the tools menu
    */
   this._addToolsMenu = function(menubar)
   {
      var _this = this;

      function createSubmenu()
      {
         var popmenu = dojo.widget.createWidget(ps.aa.Menu.POPUPMENU,
               {id: "ps.aa.ToolSubMenu"});

         var actionName = "View_Compare";
         _this.compare = dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
               {caption: _this.actionVisibilityChecker.getLabel(actionName), 
               onClick: function(){ps.aa.controller.compareItemRevisions();}});
         _this.compare.rx_actionName = actionName;
         popmenu.addChild(_this.compare);

         actionName = "Item_ViewDependents";
         _this.showRelationships = dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
               {caption: _this.actionVisibilityChecker.getLabel(actionName), 
               onClick: function(){ps.aa.controller.showItemRelationships();}});
         _this.showRelationships.rx_actionName = actionName;
         popmenu.addChild(_this.showRelationships);

         var separator = dojo.widget.createWidget(ps.aa.Menu.MENUSEPARATOR)
         popmenu.addChild(separator);


         _this.viewContent = dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
               {caption: "View Content Item", 
               onClick: function(){ps.aa.controller.viewContent();}});
         popmenu.addChild(_this.viewContent);

         _this.viewProperties = dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
               {caption: "Properties", 
               onClick: function(){ps.aa.controller.viewProperties();}});
         popmenu.addChild(_this.viewProperties);

         _this.viewRevisions = dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
               {caption: "Revisions", 
               onClick: function(){ps.aa.controller.viewRevisions();}});
         popmenu.addChild(_this.viewRevisions);

         _this.viewAuditTrail = dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
               {caption: "Audit Trail", 
               onClick: function(){ps.aa.controller.viewAuditTrail();}});
         popmenu.addChild(_this.viewAuditTrail);

         _this.separator = dojo.widget.createWidget(ps.aa.Menu.MENUSEPARATOR)
         popmenu.addChild(_this.separator);

         if (ps.io.Actions.getLocaleCount() > 1)
         {
            actionName = "Translate";
	         _this.translate = dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
	               {caption: _this.actionVisibilityChecker.getLabel(actionName), 
	               onClick: function(){ps.aa.controller.createTranslation();}});
	         _this.translate.rx_actionName = actionName;
	         popmenu.addChild(_this.translate);
         }

         actionName = "Edit_PromotableVersion";
         _this.createVersion = dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
               {caption: _this.actionVisibilityChecker.getLabel(actionName), 
               onClick: function(){ps.aa.controller.createVersion();}});
         _this.createVersion.rx_actionName = actionName;
         popmenu.addChild(_this.createVersion);

         _this.showUrl = dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
               {caption: "Link to Page", 
               onClick: function(){ps.aa.controller.showPageUrl();}});
         popmenu.addChild(_this.showUrl);

         actionName = "Publish_Now";
         _this.pubNow = dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
               {caption: _this.actionVisibilityChecker.getLabel(actionName), 
               onClick: function(){ps.aa.controller.publishPage();}});
         _this.pubNow.rx_actionName = actionName;
         popmenu.addChild(_this.pubNow);

         //Hide all the dynamic menus initially and they will be shown as 
         //per the visibility.
         _this._maybeHide(_this.translate);
         _this._maybeHide(_this.pubNow);
         _this._maybeHide(_this.createVersion);
         _this._maybeHide(_this.compare);
         _this._maybeHide(_this.showRelationships);

         _this._resetLastMenubar();
      }

      this.toolElem = dojo.widget.createWidget(ps.aa.Menu.MENUBARITEMDROPDOWN, 
                      {caption: "Tools", submenuId: "ps.aa.ToolSubMenu"});
      this.toolElem.createSubmenu = createSubmenu;
      menubar.addChild(this.toolElem);
   }

   /**
    * Helper method to create the content menu
    */   
   this._addContentMenu = function(menubar)
   {
      var _this = this;

      function createSubmenu()
      {
         var popmenu = dojo.widget.createWidget(ps.aa.Menu.POPUPMENU,
               {id: "ps.aa.ContentSubMenu"});

         _this.contentNewElem = dojo.widget.createWidget(ps.aa.Menu.MENUITEM,
               {caption: "Copy", 
               onClick: function(){ps.aa.controller.createItem(
                   ps.aa.Menu.COPY_FROM_CONTENT);}});
         popmenu.addChild(_this.contentNewElem);

         _this.contentNewItemElem = dojo.widget.createWidget(
               ps.aa.Menu.MENUITEM, 
               {caption: "New", 
               onClick: function(){ps.aa.controller.createItem(
                  ps.aa.Menu.NEW_FROM_CONTENT);}});
         popmenu.addChild(_this.contentNewItemElem);

         _this._resetLastMenubar();
      }

      this.contentElem = dojo.widget.createWidget(ps.aa.Menu.MENUBARITEMDROPDOWN, 
            {caption: "Content", submenuId: "ps.aa.ContentSubMenu"});
      this.contentElem.createSubmenu = createSubmenu;
      menubar.addChild(this.contentElem);
   }

  
   /**
    * Helper method to create account menu.
    */
   this._addAccountMenu = function(menubar)
   {
      var _this = this;

      function createSubmenu()
      {
         var popmenu = dojo.widget.createWidget(ps.aa.Menu.POPUPMENU,
               {id: "ps.aa.AccountSubMenu"});

         _this.accountUserInfoElem = dojo.widget.createWidget(
               ps.aa.Menu.MENUITEM,
               {caption: "User Info", 
               onClick: function(){ps.UserInfo.showInfo();}});
         popmenu.addChild(_this.accountUserInfoElem);

         _this.accountLogoutElem = dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
               {caption: "Logout", 
               onClick: function(){ps.aa.controller.logout();}});
         popmenu.addChild(_this.accountLogoutElem);
      }

      this.accountElem = dojo.widget.createWidget(ps.aa.Menu.MENUBARITEMDROPDOWN, 
            {caption: "Account", submenuId: "ps.aa.AccountSubMenu"});
      this.accountElem.createSubmenu = createSubmenu;
      menubar.addChild(this.accountElem);
   }
   
   /**
    * Helper method to create the edit menu
    */   
   this._addEditMenu = function(menubar)
   {
      var _this = this;

      function createSubmenu()
      {
         var popmenu = dojo.widget.createWidget(ps.aa.Menu.POPUPMENU,
               {id: "ps.aa.EditSubMenu"});

         _this.editAllElem = dojo.widget.createWidget(ps.aa.Menu.MENUITEM,
               {caption: "Content Item", 
               onClick: function(){ps.aa.controller.editAll();}});
         popmenu.addChild(_this.editAllElem);

         _this.editFieldElem = dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
               {caption: "Field", 
               onClick: function(){ps.aa.controller.editField();}});
         dojo.html.hide(_this.editFieldElem.domNode);
         popmenu.addChild(_this.editFieldElem);

         _this.removeElem = dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
               {caption: "Remove", 
               onClick: function(){ps.aa.controller.removeSnippet();}});
         dojo.html.hide(_this.removeElem.domNode);
         popmenu.addChild(_this.removeElem);

         _this._resetLastMenubar();
      }

      this.editElem = dojo.widget.createWidget(ps.aa.Menu.MENUBARITEMDROPDOWN, 
            {caption: "Edit", submenuId: "ps.aa.EditSubMenu"});
      this.editElem.createSubmenu = createSubmenu;
      menubar.addChild(this.editElem);
   }
 
   /**
    * Helper method to create the help menu
    */   
   this._addHelpMenu = function(menubar)
   {
      var _this = this;

      function createSubmenu()
      {
         var popmenu = dojo.widget.createWidget(ps.aa.Menu.POPUPMENU,
               {id: "ps.aa.HelpSubMenu"});
         popmenu.addChild(dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
               {caption: "Active Assembly Help", 
               onClick: function()
               {
                  ps.aa.controller.openHelpWindow(ps.aa.Menu.AAHELP);
               }}));
         popmenu.addChild(
               dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
               {caption: "Active Assembly Tutorial", 
               onClick: function()
               {
                  ps.aa.controller.openHelpWindow(ps.aa.Menu.AATUTORIAL);
               }}));
         popmenu.addChild(dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
               {caption: "About Active Assembly", 
               onClick: function()
               {
                  ps.aa.controller.openHelpWindow(ps.aa.Menu.AAABOUT);
               }}));
         _this._resetLastMenubar();
      }

      var helpMenu = dojo.widget.createWidget(ps.aa.Menu.MENUBARITEMDROPDOWN, 
                      {caption: "Help", submenuId: "ps.aa.HelpSubMenu"});
      helpMenu.createSubmenu = createSubmenu;
      menubar.addChild(helpMenu);
   }
   
   /**
    * Helper method to create the preview menu
    */
   this._addPreviewMenu = function(menubar)
   {
      var _this = this;

      function createSubmenu()
      {
         var popmenu = dojo.widget.createWidget(ps.aa.Menu.POPUPMENU, 
               {id: "ps.aa.PreviewSubMenu"});
         popmenu.addChild(dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
               {caption: "Current Revisions", 
               onClick: function()
               {
                  ps.aa.controller.previewWithCurrentRevisions();
               }}));
         popmenu.addChild(dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
               {caption: "With Edits", 
               onClick: function()
               {
                  ps.aa.controller.previewWithEditRevisions();
               }}));
         _this._resetLastMenubar();
      }

      this.preview = dojo.widget.createWidget(ps.aa.Menu.MENUBARITEMDROPDOWN, 
		      {caption: "Preview", submenuId: "ps.aa.PreviewSubMenu"});
		this.preview.createSubmenu = createSubmenu;
      menubar.addChild(this.preview);
   }
   
   this._addNavigationMenu = function(menubar)
   {
	   var _this = this;
	   
	   function createSubmenu()
       {
           var popmenu = dojo.widget.createWidget(ps.aa.Menu.POPUPMENU, 
                 {id: "ps.aa.NavigationSubMenu"});
           popmenu.addChild(dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
                 {caption: "Manage Navigation", 
                 onClick: function()
                 {
        	         ps.aa.controller.openManageNavigationDlg();
                 }}));
          
	        _this._resetLastMenubar();
	    }

	    this.nav = dojo.widget.createWidget(ps.aa.Menu.MENUBARITEMDROPDOWN, 
		     {caption: "Navigation", submenuId: "ps.aa.NavigationSubMenu"});
		this.nav.createSubmenu = createSubmenu;
	    menubar.addChild(this.nav);
   }
   
   /**
    * Bind the context menus to its related href <a...> element.
    * 
    * @param {dojo.collections.ArrayList} ids The list of {ps.aa.ObjectId} ids.
    */
   this._initContextMenu = function(ids)
   {
      var _this = this;
      
      // create Slot Context Menu
      this.slotCtxMenu = dojo.widget.createWidget(ps.aa.Menu.POPUPMENU, 
		   {id: "ps.aa.SlotCtxMenu"});
		var slotMenu = this.slotCtxMenu;
      document.body.appendChild(slotMenu.domNode);
      slotMenu.createMenuItems = function()
      {
         _this.ctxNewSnippet = dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
            {caption: "New Snippet...", 
            onClick: function(){ps.aa.controller.createItem(
                ps.aa.Menu.NEW_FROM_SLOT);}});
            slotMenu.addChild(_this.ctxNewSnippet);
         _this.ctxAddSnippet = dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
            {caption: "Insert Snippet...", 
            onClick: function(){
               ps.aa.controller.addSnippet(ps.aa.Menu.INSERT_FROM_SLOT);}});
            slotMenu.addChild(_this.ctxAddSnippet);
         _this.ctxRemoveSnippet = dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
            {caption: "Remove Snippets...", 
            onClick: function(){ps.aa.controller.openRemoveSnippetsDlg();}});
            slotMenu.addChild(_this.ctxRemoveSnippet);
      };

      // create Item Context Menu
      this.itemCtxMenu = dojo.widget.createWidget(ps.aa.Menu.POPUPMENU, 
		   {id: "ps.aa.ItemCtxMenu"});
		var itemMenu = this.itemCtxMenu;
      document.body.appendChild(itemMenu.domNode);
      itemMenu.createMenuItems = function()
      {
         _this.ctxChangeTemplate = dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
               {caption: "Template...", 
               onClick: function(){ps.aa.controller.changeTemplate();}});
         itemMenu.addChild(_this.ctxChangeTemplate);

         _this.ctxUp = dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
               {caption: "Up", 
               onClick: function(){ps.aa.controller.moveSnippetUp();}});
         itemMenu.addChild(_this.ctxUp);

         _this.ctxDown = dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
               {caption: "Down", 
               onClick: function(){ps.aa.controller.moveSnippetDown();}});
         itemMenu.addChild(_this.ctxDown);

         _this.ctxRemove = dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
               {caption: "Remove", 
               onClick: function(){ps.aa.controller.removeSnippet();}});
         itemMenu.addChild(_this.ctxRemove);

         _this.ctxItemSeparator1 = dojo.widget.createWidget(
               ps.aa.Menu.MENUSEPARATOR);
         itemMenu.addChild(_this.ctxItemSeparator1);		

         _this.ctxNewFromSnippet = dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
               {caption: "New...", 
               onClick: function(){
                  ps.aa.controller.createItem(ps.aa.Menu.NEW_FROM_SNIPPET);}});
         itemMenu.addChild(_this.ctxNewFromSnippet);

         _this.ctxInsertFromSnippet = dojo.widget.createWidget(
               ps.aa.Menu.MENUITEM, 
               {caption: "Insert...", 
               onClick: function(){
                  ps.aa.controller.addSnippet(ps.aa.Menu.INSERT_FROM_SNIPPET);}});
         itemMenu.addChild(_this.ctxInsertFromSnippet);

         _this.ctxReplaceFromSnippet = dojo.widget.createWidget(
            ps.aa.Menu.MENUITEM, {caption: "Replace...", 
            onClick: function(){
               ps.aa.controller.createItem(ps.aa.Menu.REPLACE_FROM_SNIPPET);}});
         itemMenu.addChild(_this.ctxReplaceFromSnippet);

         _this.ctxItemSeparator2 = dojo.widget.createWidget(
               ps.aa.Menu.MENUSEPARATOR);
         itemMenu.addChild(_this.ctxItemSeparator2);		

         _this.ctxOpenFromSnippet = dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
               {caption: "Open", 
               onClick: function(){
                  ps.aa.controller.openSnippet();}});
         itemMenu.addChild(_this.ctxOpenFromSnippet);

         _this.ctxWorkflow = dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
               {caption: "Workflow...", 
               onClick: function(){ps.aa.controller.workflowItem();}})
         itemMenu.addChild(_this.ctxWorkflow);
          
         _this.ctxEditField = dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
               {caption: "Edit Field", 
               onClick: function(){ps.aa.controller.editField();}});
         itemMenu.addChild(_this.ctxEditField); 
         
         _this.ctxEditAll = dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
               {caption: "Edit Content Item", 
               onClick: function(){ps.aa.controller.editAll();}});
         itemMenu.addChild(_this.ctxEditAll);

         itemMenu.addChild(dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
               {caption: "View Content Item", 
               onClick: function(){ps.aa.controller.viewContent();}}));

         itemMenu.addChild(dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
               {caption: "Properties", 
               onClick: function(){ps.aa.controller.viewProperties();}}));

         itemMenu.addChild(dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
               {caption: "Revisions", 
               onClick: function(){ps.aa.controller.viewRevisions();}}));

         itemMenu.addChild(dojo.widget.createWidget(ps.aa.Menu.MENUITEM, 
               {caption: "Audit Trail", 
               onClick: function(){ps.aa.controller.viewAuditTrail();}}));
         _this._resetLastContextMenu();
      }

        if(___sys_aamode != 1)
           this.bindContextMenu(ids);
   },

   /**
    * Binds the specified image elements to ids related context menu.
    * 
    * @param {dojo.collections.ArrayList} ids The list of {ps.aa.ObjectId} ids
    *    of the specified image elements.
    */
   this.bindContextMenu = function(ids, special)
   {
      var slotNodes = new Array();
      var itemNodes = new Array();
      
      var slotCount = 0;
      var itemCount = 0;
      var objId = null;
      var prefix = ___sys_aamode == 1 && !special ? "" : "img.";
      for(var i=0;i<ids.count;i++)
      {
         var objId = ids.item(i);
         if (objId.isSlotNode())
            slotNodes[slotCount++] = prefix + objId.serialize();
         else
            itemNodes[itemCount++] = prefix + objId.serialize();
      }
      this.slotCtxMenu.bindTargetNodes(slotNodes);
      this.itemCtxMenu.bindTargetNodes(itemNodes);      
   }

   /**
    * Unbinds the specified image elements from ids related context menu.
    * 
    * @param {dojo.collections.ArrayList} ids The list of {ps.aa.ObjectId} ids
    *    of the specified image elements.
    */
   this.unBindContextMenu = function(ids, special)
   {
      var slotNodes = new Array();
      var itemNodes = new Array();
      
      var slotCount = 0;
      var itemCount = 0;
      var objId = null;
      var prefix = ___sys_aamode == 1 && !special ? "" : "img.";
      for(var i=0;i<ids.count;i++)
      {
         var objId = ids.item(i);
         if (objId.isSlotNode())
            slotNodes[slotCount++] = prefix + objId.serialize();
         else
            itemNodes[itemCount++] = prefix + objId.serialize();
      }
      this.slotCtxMenu.unBindTargetNodes(slotNodes);
      this.itemCtxMenu.unBindTargetNodes(itemNodes);      
   }
   
   
   /**
    * Bind the context menus for its related div element.
    */
   this._resetContextMenu = function(objId, parentId)
   {
      this._resetContextMenuParams = {objId: objId, parentId: parentId};

      if (objId.isSlotNode())
      {
         this._resetCtxSlotMenu(objId);
      }
      else if (objId.isSnippetNode())
      {
         this._resetCtxSnippetMenu(objId, parentId);         
      }
      else
      {
         this._resetCtxPageFieldMenu(objId);
      }
   }

   /**
    * Same as running {@link #resetContextMenu} with the last parameters it was
    * called with.
    */
   this._resetLastContextMenu = function()
   {
      var params = this._resetContextMenuParams;
      if (params)
      {
         this._resetContextMenu(params.objId, params.parentId);
      }
   }

   /**
    * Reset the context menu for a page slot object.
    */
   this._resetCtxSlotMenu = function(objId)
   {
      if (this.ctxAddSnippet)
      {
         this.ctxAddSnippet.setDisabled(!objId.isCheckoutByMe());
      }
      if (this.ctxNewSnippet)
      {
         this.ctxNewSnippet.setDisabled(!objId.isCheckoutByMe());
      }
      if (this.ctxRemoveSnippet)
      {
         this.ctxRemoveSnippet.setDisabled(!objId.isCheckoutByMe());
      }
   }

   /**
    * Reset the context menu for a snippet object.
    */
   this._resetCtxSnippetMenu = function(objId, parentId)
   {
      if (!this.ctxChangeTemplate)
      {
         // menu items are not created yet
         return;
      }
      // hide and show snippet specific menu items
      dojo.html.hide(this.ctxEditField.domNode);
      
      dojo.html.show(this.ctxChangeTemplate.domNode);
      dojo.html.show(this.ctxUp.domNode);
      dojo.html.show(this.ctxDown.domNode);
      dojo.html.show(this.ctxRemove.domNode);
      
      dojo.html.show(this.ctxItemSeparator1.domNode);
      dojo.html.show(this.ctxNewFromSnippet.domNode);
      dojo.html.show(this.ctxInsertFromSnippet.domNode);
      dojo.html.show(this.ctxReplaceFromSnippet.domNode);
      dojo.html.show(this.ctxOpenFromSnippet.domNode);
      dojo.html.show(this.ctxItemSeparator2.domNode);
      
      dojo.html.show(this.ctxWorkflow.domNode);
      dojo.html.show(this.ctxEditAll.domNode);

      // enable and disable menu items according to 'objId' and 'parentId'
      var disable = !parentId.isCheckoutByMe();
      this.ctxChangeTemplate.setDisabled(disable);
      this.ctxUp.setDisabled(disable);
      this.ctxDown.setDisabled(disable);
      this.ctxRemove.setDisabled(disable);
      this.ctxNewFromSnippet.setDisabled(disable);
      this.ctxInsertFromSnippet.setDisabled(disable);
      this.ctxReplaceFromSnippet.setDisabled(disable);
      this.ctxOpenFromSnippet.setDisabled(disable);
      
      this.ctxEditAll.setDisabled(!objId.isCheckoutByMe());
   }

   /**
    * Reset the context menu for a snippet object.
    */
   this._resetCtxPageFieldMenu = function(objId)
   {
      if (!this.ctxChangeTemplate)
      {
         // menu items are not created yet
         return;
      }
      // hide menu items which are not appliable to snippet
      dojo.html.hide(this.ctxChangeTemplate.domNode);
      dojo.html.hide(this.ctxUp.domNode);
      dojo.html.hide(this.ctxDown.domNode);
      dojo.html.hide(this.ctxRemove.domNode);
      dojo.html.hide(this.ctxItemSeparator1.domNode);
      dojo.html.hide(this.ctxNewFromSnippet.domNode);
      dojo.html.hide(this.ctxInsertFromSnippet.domNode);
      dojo.html.hide(this.ctxReplaceFromSnippet.domNode);
      dojo.html.hide(this.ctxOpenFromSnippet.domNode);
      dojo.html.hide(this.ctxItemSeparator2.domNode);
      
      // show snippet specific menu items
      dojo.html.show(this.ctxEditAll.domNode);
      if (objId.isPageNode())
      {
        dojo.html.hide(this.ctxEditField.domNode);
      }
      else
      {
        dojo.html.show(this.ctxEditField.domNode);
      }
      dojo.html.show(this.ctxWorkflow.domNode);

      // enable and disable menu items according to 'objId' and 'parentId'
      var disable = !objId.isCheckoutByMe();
      this.ctxEditAll.setDisabled(disable);
      this.ctxEditField.setDisabled(disable);
   }

   this.toggleShowHideTree = function(isShowTree)
   {
      if (isShowTree)
      {
         dojo.html.show(this.hideTreeElem.domNode);
         dojo.html.hide(this.showTreeElem.domNode);
      }
      else
      {
         dojo.html.hide(this.hideTreeElem.domNode);
         dojo.html.show(this.showTreeElem.domNode);
      }
   }

   this.toggleShowHidePlaceholders = function(isShow)
   {
      if (isShow)
      {
         dojo.html.show(this.hidePlaceholdersElem.domNode);
         dojo.html.hide(this.showPlaceholdersElem.domNode);
      }
      else
      {
         dojo.html.hide(this.hidePlaceholdersElem.domNode);
         dojo.html.show(this.showPlaceholdersElem.domNode);
      }
   }
   
   /**
    * Returns an array of menu items managed by this controller.
    */
   this.getMenuItems = function ()
   {
      var items = [];
      for (name in this)
      {
         var item = this[name];
         if (item instanceof dojo.widget.MenuItem2)
         {
            items.push(item);
         }
      }
      dojo.lang.assert(items.length > 0);
      return items;
   }
};

/**
 * Constants for the paths of all icon images
 */
ps.aa.Menu.PAGE_IMG_PATH = "../sys_resources/images/page.gif";
ps.aa.Menu.SNIPPET_IMG_PATH = "../sys_resources/images/item.gif";
ps.aa.Menu.SLOT_IMG_PATH = "../sys_resources/images/relatedcontent/slot.gif";
ps.aa.Menu.FIELD_IMG_PATH = "../sys_resources/images/pen.gif";

/**
 * Constants for menu components
 */
ps.aa.Menu.MENUBAR = "ps:MenuBar2";
ps.aa.Menu.MENUBARICON = "ps:MenuBarIcon";
ps.aa.Menu.MENUBARITEM = "MenuBarItem2";
ps.aa.Menu.MENUBARITEMDROPDOWN = "ps:MenuBarItemDropDown";
ps.aa.Menu.MENUITEM = "MenuItem2";
ps.aa.Menu.MENUSEPARATOR = "MenuSeparator2";
ps.aa.Menu.POPUPMENU = "ps:PopupMenu";

/**
 * Constant for Active Assembly Help action types
 */
ps.aa.Menu.AAHELP = "AAHelp";
ps.aa.Menu.AATUTORIAL = "AATutorial";
ps.aa.Menu.AAABOUT = "AAAbout";
 
/**
 * Constants for create item menus
 */
ps.aa.Menu.NEW_FROM_SLOT = 0;
ps.aa.Menu.NEW_FROM_SNIPPET = 1;
ps.aa.Menu.REPLACE_FROM_SNIPPET = 2;
ps.aa.Menu.COPY_FROM_CONTENT = 3;
ps.aa.Menu.NEW_FROM_CONTENT = 4;

/**
 * Constants for insert snippets
 */
ps.aa.Menu.INSERT_FROM_SLOT = 0;
ps.aa.Menu.INSERT_FROM_SNIPPET = 1;


/******************************************************************************
 *
 * [ ps.UserInfo.js ]
 *
 * COPYRIGHT (c) 1999 - 2008 by Percussion Software, Inc., Woburn, MA USA.
 * All rights reserved. This material contains unpublished, copyrighted
 * work including confidential and proprietary information of Percussion.
 *
 *****************************************************************************/
 
dojo.provide("ps.UserInfo");







/**
 * This is used to manage the controls that allow the user to logout and change
 * her community/locale.
 */
ps.UserInfo = new function()
{
	/**
	 * The dialog that displays the users name, roles, etc. Initialized on 
	 * first call to _getUserInfoDialog(), then never null.
	 */
	this._userInfoDlg = null;
	
	/**
	 * The full path (no protocol,server or query) to the page that renders the
	 * user info such as name and role membership.
	 */
	this.USER_INFO_PAGE_URL = "/Rhythmyx/ui/activeassembly/UserStatus.jsp";
	
   this.showInfo = function()
   {
   	var dlg = this._getUserInfoDialog();
   	dlg.show();
   }
   
   this._getUserInfoDialog = function()
   {
  		this._userInfoDlg = ps.createDialog(
      {
         id: "ps.UserInfoDlg",
         title: "User Info"
      }, "420px", "150px");
      var aaUrl = ps.aa.controller.getLinkToCurrentPage();
      aaUrl = aaUrl.replace("/Rhythmyx", "..");
      var url = ps.util.addParamToUrl(this.USER_INFO_PAGE_URL, "sys_redirecturl", 
      	escape(aaUrl));
      this._userInfoDlg.setUrl(url);
  		return this._userInfoDlg;
   }
}

/******************************************************************************
 *
 * [ ps.aa.Page.js ]
 *
 * COPYRIGHT (c) 1999 - 2006 by Percussion Software, Inc., Woburn, MA USA.
 * All rights reserved. This material contains unpublished, copyrighted
 * work including confidential and proprietary information of Percussion.
 *
 *****************************************************************************/
 
dojo.provide("ps.aa.Page");








/**
 * The page (view) controller. It manages the viewable element of the Active 
 * Assembly page.
 */
ps.aa.Page = new function()
{
   /**
    * The actived div element.
    */
   this.activeDiv = null;

   /**
    * Initialize the properties of the page. This should be called right after 
    * the dojo is done passing the HTML content.
    */
   this.init = function()
   {
   },
   
   /**
    * Activate the specified div element and deactivate the previous activated
    * div element.
    *
    * @param {HTMLDivElement} div The to be activated div element.
    * Not <code>null</code>.
    * @return <code>true</code> if the selected element was changed,
    * otherwise returns <code>false</code>.
    */
   this.activate = function(div)
   {
      dojo.lang.assert(div);
      if (div === this.activeDiv)
         return false;

      // reset it back the previous activated div element if any
      if (this.activeDiv!=null)
      {
         this.activeDiv.style.border = "1px dotted";
         if(___sys_aamode == 1)
         {
            this.activeDiv.style.borderColor = "transparent";
         }
         else
         {
            this.activeDiv.style.borderColor = "gray";
         }
         
      }
      
      // activate the specified div element
      var pxSize = dojo.render.html.ie ? "3" : "2";
      div.style.border = pxSize + "px dotted";
      div.style.borderColor = "gray";
      
      this.activeDiv = div;
      return true;
      
      // FIXME: the following code does not work with IE7
      // if(activeDiv!=null)
      //   dojo.html.scrollIntoView(activeDiv);
   },
   
   /**
    * Gets the parent id (on the immidiate parent/slot node) for the specified 
    * snippet node. 
    * 
    * @param {HTMLDivElement} snippetNode The snippet node.
    * @param {ps.aa.ObjectId} objId The object id of the snippet node.
    */
   this.getParentId = function(snippetNode, objId)
   {
      var parentNode = null;
      var childNode = snippetNode;
      while (parentNode == null)
      {
         var node = childNode.parentNode;
         if (node == null || dojo.lang.isUndefined(node))
            break;

         if (dojo.html.getClass(node) === ps.aa.SLOT_CLASS
               && dojo.html.isTag(node, 'div'))
            parentNode = node;
            
         childNode = node;            
      }
      
      var parentId = null;
      if (parentNode != null)
         parentId = this.getObjectId(parentNode);
         
      if (parentId == null)
      {
         alert("Cannot find parent node for snippet: " + objId.serialize());
         return null;
      }
      else
      {
         return parentId;
      }
   },

   /**
    * Gets the object id from the given HTML element.
    * 
    * @param {HTMLElement} htmlElem the HTML element that may contains the
    *    object id as an attribute.
    * 
    * @return the ps.aa.ObjectId if it contains one; null otherwise.
    */
   this.getObjectId = function (htmlElem)
   {
      if (dojo.lang.isUndefined(htmlElem) || htmlElem == null)
         return null;
         
      var idString = null;
      
      // the object id is specified in the <a ...> tag at 'id' attribute with "img." prefix
      // it is also specified in <div ...> tag at 'id' attribute
      idString = dojo.html.getAttribute(htmlElem, "id");

      if (idString != null && (dojo.lang.isString(idString)))
      {
         var objId = new ps.aa.ObjectId(idString);
         if (objId != null && (!dojo.lang.isUndefined(objId)))
            return objId;
      }
      return null;
   },
   
   /**
    * Gets the element corresponding to the given object Id.
    * Throws an exception if the element with this id does not exist.
    * 
    * @param {ps.aa.ObjectId} objectId
    * @return {HTMLElement}
    */
   this.getElement = function (objectId)
   {
      dojo.lang.assertType(objectId, ps.aa.ObjectId);
      var element = document.getElementById(objectId.toString());
      dojo.lang.assert(element, "No element found for id " + objectId.toString());
      return element;
   }
   
};


/******************************************************************************
 *
 * [ ps.aa.Tree.js ]
 *
 * COPYRIGHT (c) 1999 - 2007 by Percussion Software, Inc., Woburn, MA USA.
 * All rights reserved. This material contains unpublished, copyrighted
 * work including confidential and proprietary information of Percussion.
 *
 *****************************************************************************/

dojo.provide("ps.aa.Tree");









/**
 * <p>The tree model contains the id of all managed DOM nodes in the page panel. 
 * This tree model contains by a root node and multiple child nodes. 
 * Each node is a {ps.aa.TreeNode) object.
 * </p>
 * <p>If the page panel is rendered with a page template, then the root 
 * represents the local template if the page uses a global template otherwise it 
 * is the page node as a whole. The 1st level of child nodes are "Field" nodes, 
 * which are followed by "Slot" nodes. The "Field" node is the leaf node, but 
 * the "Slot" node may contains a list of "Snippet" nodes. The "Snippet" node 
 * contains a list of "Field" nodes and possibly a list of "Slot" nodes and so 
 * on.
 * </p>
 * @constructor
 */
ps.aa.Tree = function()
{
   //ps.aa.TreeNode
   this.root = null;
   
   /**
    * Populate the data model from the DOM element with the id of 'MainBody'. 
    * This must be  called before calling any other methods of this class.
    */
   this.init = function()
   {
      var startElement = dojo.byId("ps.aa.ContentPane");
      dojo.lang.assert(startElement != null, 
         "Cannot find DOM element id='ps.aa.ContentPane'");
      this._createNodes(startElement, null);
      this._sort(this.root);
   }
   
   /**
    * Sort the tree based on the rules below:
    * 1. Field nodes appear first under the parent alpha ordered.
    * 2. Then appean slot nodes and alpha ordered.
    * 3. Snippets are not affected by this means they preserve the system sort 
    *    order.
    */
   this._sort = function(treeNode)
   {
      if(treeNode != null && !treeNode.isLeafNode())
      {
         treeNode.childNodes.sort(function(o1, o2){

            if((o1.objId.isFieldNode() && o2.objId.isSlotNode()))
            {
                return -1;  
            }           
            if((o1.objId.isSlotNode() && o2.objId.isFieldNode()))
            {
                return 1;  
            }           
            if((o1.objId.isFieldNode() && o2.objId.isFieldNode()) ||            
               (o1.objId.isSlotNode() && o2.objId.isSlotNode()))
            {
               var s1 = o1.getLabel().toLowerCase();
               var s2 = o2.getLabel().toLowerCase();
               if (s1 > s2)
               {
                  return 1;
               }
               else if (s1 < s2)
               {
                  return -1;
               }
            }
            if(o1.objId.isSnippetNode() && o2.objId.isSnippetNode())
            {
               var s1 = parseInt(o1.objId.getSortRank());
               var s2 = parseInt(o2.objId.getSortRank());
               if (s1 > s2)
               {
                  return 1;
               }
               else if (s1 < s2)
               {
                  return -1;
               }
            }
            return 0;
            
         });
         dojo.lang.forEach(treeNode.childNodes.toArray(), this._sort, this);
      }
   }
   /**
    * Creates tree nodes from the specified DOM element.
    * 
    * @param {HTMLDivElement} startElement The parent DOM element which 
    *    contains all child nodes. Assumed not null.
    * @param {ps.aa.TreeNode} pnode the last parent node, which may be null.
    */
   this._createNodes = function(startElement, pnode)
   {
      // the getElementsByTagName function returns the elements in the result 
      // of a "Preorder Traversal" (or first depth-first traversal) operation.
      var divs = startElement.getElementsByTagName("div");
      var div = null;
      var lastParent = pnode;
      for(var i=0; i<divs.length; i++)
      {
         div = divs[i];
         if (div.className == ps.aa.PAGE_CLASS)
         {
            lastParent = this._addPageNode(div);
         }
         else if (div.className == ps.aa.FIELD_CLASS)
         {
            lastParent = this._addFieldNode(div, lastParent);
         }
         else if (div.className == ps.aa.SNIPPET_CLASS)
         {
            lastParent = this._addSnippetNode(div, lastParent);
         }
         else if (div.className == ps.aa.SLOT_CLASS)
         {
            lastParent = this._addSlotNode(div, lastParent, null);
         }
      }      
   }
   
   /**
    * Resets the child nodes of the node, associated with the specified 
    * DOM element. Fails, if the tree node cannot be found.
    * 
    * @param {HTMLDivElement} element The DOM element, that contains the id of
    *    an existing tree node. Not <code>null</code>.
    */
   this._resetChildNodes = function (element)
   {
      dojo.lang.assert(element);
      var id = ps.aa.Page.getObjectId(element);
      dojo.lang.assert(id, "Cannot find object id");
         
      var node = this.getNodeById(id);
      dojo.lang.assert(node, "Cannot find node");
         
      node.removeChildNodes();
      this._createNodes(element, node);
      this._sort(node);
   }

   /**
    * Should be called before any dom node is removed, or its structure is
    * changed.
    * Calls {@link #onBeforeDomChange} event.
    * @param {ps.aa.ObjectId} id the id of the node which will change.
    * Not <code>null</code>.
    * @see #onBeforeDomChange
    * @see #fireDomChanged
    */   
   this.fireBeforeDomChange = function (id)
   {
      dojo.lang.assertType(id, ps.aa.ObjectId);

      this.onBeforeDomChange(id);
   }
   
   /**
    * The event which is fired from {@link #fireBeforeDomChange}.
    * Put a listener on this event to process the dom nodes which are going
    * to be disposed.
    * @see #fireBeforeDomChange
    * @see #onDomChanged
    */
   this.onBeforeDomChange = function (id)
   {
      dojo.lang.assertType(id, ps.aa.ObjectId);
   }

   /**
    * Should be called after a page dom node is changed or removed,
    * or the dom tree structure is changed.
    * Calls {@link #onAfterDomChanged}.
    * @param {ps.aa.ObjectId} notChangedId the id node which is not changed.
    * Can be this node, or parent node if this node is changed.
    * Is used as a starting point for the tree model refresh.
    * Can be <code>null</code> if the full page is changed.
    * @param {ps.aa.ObjectId} id the id of the node which will change.
    * Can be <code>null</code>, if the root is changed.
    * @see #onDomChanged
    * @see #fireBeforeDomChange
    */
   this.fireDomChanged = function (notChangedId, id)
   {
      id && dojo.lang.assertType(id, ps.aa.ObjectId);
      notChangedId && dojo.lang.assert(notChangedId, ps.aa.ObjectId);

      if (id && id.equals(this.root.objId))
      {
         // root node can be reset
         id = null;
      }

      if (notChangedId)
      {
         var element = ps.aa.Page.getElement(notChangedId);
         this._resetChildNodes(element);
      }
      else
      {
         // reset whole model
         this.root.clear();
         this.root = null;
         this.init();
      }

      if (!id)
      {
         id = this.root.objId;
      }
      this.onDomChanged(id);
   }

   /**
    * The event which is fired from {@link #fireDomChanged}.
    * Put a listener on this event to process the newly appended dom nodes.
    * @see #fireDomChanged
    * @see #onBeforeDomChange
    */
   this.onDomChanged = function (id)
   {
      dojo.lang.assertType(id, ps.aa.ObjectId);
   }

   /**
    * Adds the specified PAGE div element to the tree as the root. It is an 
    * error attempting to add more than once.
    * 
    * @param {HTMLDivElement} div The element contains the added object id.
    * 
    * @return the added page node if successful; otherwise return null.
    */
   this._addPageNode = function (div)
   {
      if (this.root != null)
      {
         ps.util.error("Unknown page node, already got a root: " 
            + this.root.objId.toString());
         return null;
      }
      
      return this.root = this._getNodeRqd(div);
   }
   
   /**
    * Adds the specified SLOT div element to the tree.
    * 
    * @param {HTMLDivElement} div The element contains the added object id.
    * @param {ps.aa.TreeNode} lastParent The last (possible) parent node,
    *    which can be a page, a slot or a snippet node. It may be null.
    * @param {ps.aa.TreeNode} slotNode The slot node, which is used to collect
    *    all its child nodes if specified. It may be null.
    * 
    * @return the added slot node if successful; otherwise return null.
    */
   this._addSlotNode = function(div, lastParent, slotNode)
   {
      var node = slotNode;
      if (node == null)
         node = this._getNodeRqd(div);

      var parentNode = this._getParentPageSnippet(node, lastParent);
      dojo.lang.assert(parentNode != null, 
         "Cannot find parent node for slot node: " + node.toString());

      parentNode.addChildNode(node);
      return node;
   }
   
   /**
    * Gets the parent page or snippet node for the specified child node.
    * 
    * @param {ps.aa.TreeNode} childNode The specified child node.
    * @param {ps.aa.TreeNode} lastParent The last (possible) parent node,
    *    which may be null. If this is not the parent node, then it is used to 
    *    traverse the tree in reverse (or bottom up) order.
    * 
    * @return The parent page/snippet node, its content id is the same as the 
    *    childNode node. It is null if cannot find the parent page/snippet node.
    */
   this._getParentPageSnippet = function(childNode, lastParent)
   {
      var parentNode = lastParent;
      
      while (parentNode)
      {
         if ((parentNode.isPageNode() || parentNode.isSnippetNode()) && 
             parentNode.objId.getContentId() == childNode.objId.getContentId())
         {
            return parentNode;
         }
         else
         {
            parentNode = parentNode.parentNode;
         }
      }
      
      return null;
   }

   /**
    * Adds the specified SNIPPET div element to the tree.
    * 
    * @param {HTMLDivElement} div The element contains the added object id.
    * @param {ps.aa.TreeNode} lastParent The last (possible) parent node,
    *    which can be a page, a slot or a snippet node. It may be null.
    * 
    * @return the added snippet node if successful; otherwise return null.
    */
   this._addSnippetNode = function(div, lastParent)
   {
      var node = this._getNodeRqd(div);
      if (this.root == null)
      {
         this.root = node;
         return this.root;
      }
      else
      {
         var parentNode = this._getParentSlot(node, lastParent);
         if (parentNode != null)
         {
            parentNode.addChildNode(node);
            return node;
         }
      }
      
      ps.util.error("Cannot find parent node for snippet node: " + node.toString());
      return null;
   }   
   
   /**
    * Gets the parent slot for the specified snippet node.
    * 
    * @param {ps.aa.TreeNode} snippetNode The specified snippet node.
    * @param {ps.aa.TreeNode} lastParent The last (possible) parent node,
    *    which can be a page, a slot or a snippet node. It may be null.
    *    This is used to traverse the tree in reverse (or bottom up) order.
    * 
    * @return The parent slot node, its slot id is the same as the snippet node
    *    and the content id of the slot is the parent id of the snippet.
    *    It is null if cannot find the parent slot node.
    */
   this._getParentSlot = function(snippetNode, lastParent)
   {
      var parentNode = lastParent;
      
      // find the slot whose content id is the parent id of the snippet and
      // the slot id of both node are the same.
      while (parentNode)
      {
         if (parentNode.isSlotNode() && 
             parentNode.objId.getSlotId() == snippetNode.objId.getSlotId() &&
             parentNode.objId.getContentId() == snippetNode.objId.getParentId())
         {
            return parentNode;
         }
         else
         {
            parentNode = parentNode.parentNode;
         }
      }
      
      return null;
   }

   /**
    * Adds the specified FIELD div element to the tree.
    * 
    * @param {HTMLDivElement} div The element contains the added object id.
    * @param {ps.aa.TreeNode} lastParent The last (possible) parent node,
    *    which can be a page, a slot or a snippet node. It may be null.
    */
   this._addFieldNode = function(div, lastParent)
   {
      var node = this._getNodeRqd(div);
      var parentNode = this._getParentPageSnippet(node, lastParent);
      dojo.lang.assert(parentNode != null, 
         "Cannot find parent node for field node: " + node.toString());

      parentNode.addChildNode(node);
      return parentNode;
   }   

   /**
    * Gets the object id from the specified HTML div element. It prompt
    * error message if fail to get the object id.
    * 
    * @param {HTMLDivElement} div The div element.
    * 
    * @return {ps.aa.ObjectId} the object id of the element.
    */
   this._getNodeRqd = function(div)
   {
      var objId = ps.aa.Page.getObjectId(div);
      dojo.lang.assert(objId != null, 
         "Malformed objectId for a node of class=" + div.className);

      return new ps.aa.TreeNode(objId);
   }
   
   /**
    * Gets the root of the tree.
    *
    * @return {ps.aa.TreeNode} object, never null.
    */
   this.getRootNode = function()
   {
      return this.root;
   }

   /**
    * Gets a specified node.
    *
    * @param {ps.aa.ObjectId} id The id of the specified node.
    *
    * @return {ps.aa.TreeNode} object. It may be null if cannot find the node.
    */
   this.getNodeById = function(id)
   {
      dojo.lang.assertType(id, ps.aa.ObjectId);
      return this._getNodeById(id, this.root);
   }

   /**
    * Search for the specified node from the given parent node.
    *
    * @param {ps.aa.ObjectId} id The id of the specified node.
    * @param {ps.aa.TreeNode} pnode The parent node to search from.
    *
    * @return {ps.aa.TreeNode} object. It may be null if cannot find the node.
    */
   this._getNodeById = function(id, pnode)
   {
      dojo.lang.assertType(id, ps.aa.ObjectId);
      pnode && dojo.lang.assertType(pnode, ps.aa.TreeNode);

      if (pnode.equals(id))
      {
         return pnode;
      }

      if (!pnode.isLeafNode())
      {
         var node = null;
         for (var i=0; i<pnode.childNodes.count; i++)
         {
            node = this._getNodeById(id, pnode.childNodes.item(i));
            if (node != null)
               return node;
         }
      }
      
      return null;
   }
   
   /**
    * Gets all object ids of the nodes that satisfy the following:
    * 
    * If the field name is specified, then gets the object ids from the field
    * nodes, where the content id and field name of the node equal to the
    * specified parameters.
    * 
    * If the field name is not specified, then gets the nodes described below:
    * (1) The immidiate (child) field nodes of the root, where the content id 
    *     of the node equals the specified content id.
    * (2) The snippet nodes whose content id equals to the specified content id.
    *
    * @param {int} contentId The content id of the searched nodes. This is a 
    *    required parameter.
    * @param {String} fieldName The field name of the searched nodes. This is
    *    an optional parameter. 
    *
    * @return a list {dojo.collections.ArrayList} of {ps.aa.ObjectId} objects. 
    *    Never null, but may be empty.
    */
   this.getIdsFromContentId = function(contentId, fieldName)
   {
      if (this.root.isLeafNode())
         return result;

      var result = null;
      if (dojo.lang.isString(fieldName))
      {
         result = new dojo.collections.ArrayList();
         this._getFieldIdsByContentIdName(contentId, fieldName, 
            this.root, result);
      }
      else
      {
         result = this._getIdsOfTopLevelFieldNode(contentId);
         this._getSnippetIdsFromContentId(contentId, this.root, result);
      }
      
      return result;
   }

   /**
    * Gets all object ids whose content id equals the specified content id.
    * 
    * @param contentId The content id of the returned object id. It may be
    *    null if wants to get all object ids regardless the content id property.
    * 
    * @return {dojo.collections.ArrayList} a list of {ps.aa.ObjectId} ids 
    *    described above. Never null, but may be empty.
    */
   this.getAllIdsByContentId = function(contentId)
   { 
      var result = new dojo.collections.ArrayList();
      if (this.root == null)
         return result;

      this._getAllIdsByContentId(contentId, this.root, result);
      
      return result;
   }

   /**
    * Gets the object ids from the given node and its descendants.
    * 
    * @param {ps.aa.ObjectId} objId The object id of the specified node.
    * 
    * @return {dojo.collections.ArrayList} a list of ids described above. 
    *    Never null, but may be empty.
    */
   this.getIdsFromNodeId = function (objId)
   {
      dojo.lang.assertType(objId, ps.aa.ObjectId);
      var ids = new dojo.collections.ArrayList();
      var node = this.getNodeById(objId);
      if (node != null)
         this._getIdsFromNode(node, ids);
         
      return ids;
   }

   /**
    * Gets the object ids from the given node and its descendants.
    * 
    * @param {ps.aa.TreeNode} objId The object id of the specified node.
    * @param {dojo.collections.ArrayList} ids The list of ids described above,
    *    which is used to collects all ids.
    */
   this._getIdsFromNode = function(node, ids)
   {
      if (node == null)
         return;
         
      ids.add(node.objId);
      if (!node.isLeafNode())
      {
         for (var i=0; i<node.childNodes.count; i++)
           this._getIdsFromNode(node.childNodes.item(i), ids);
      }
   }

   /**
    * Gets all object ids of the nodes, whose content id equals the specified 
    * content id.
    *
    * @param {int} contentId The content id of the searched nodes. This is a 
    *    required parameter. It may be null if wants to get all object ids 
    *    regardless the content id property.
    * @param {ps.aa.TreeNode} node The node which is searched from. 
    *    This is a  required parameter.
    * @param {dojo.collections.ArrayList} result The variable that collects
    *    all qualified snippet nodes. This is a required parameter.
    */
   this._getAllIdsByContentId = function(contentId, node, result)
   {
      if (contentId == null)
        result.add(node.objId);
      if (node.objId.getContentId() == contentId)
        result.add(node.objId);
      
      if (node.isLeafNode())
         return;
      
      for (var i=0; i<node.childNodes.count; i++)
      {
         this._getAllIdsByContentId(contentId, node.childNodes.item(i), result);
      }
   }         
   
   /**
    * Gets all object ids of the field nodes, whose content id and field name
    * equals the specified parameters.
    *
    * @param {int} contentId The content id of the searched nodes. This is a 
    *    required parameter.
    * @param {String} fieldName The field name of the searched nodes. This is
    *    a required parameter. 
    * @param {ps.aa.TreeNode} pnoade The parent node that the search from. 
    *    This is a  required parameter.
    * @param {dojo.collections.ArrayList} result The variable that collects
    *    all qualified snippet nodes. This is a required parameter.
    */
   this._getFieldIdsByContentIdName = function(contentId, fieldName, pnode, 
      result)
   {
      if (pnode.isLeafNode())
        return;
        
      for (var i=0; i<pnode.childNodes.count; i++)
      {
         var node = pnode.childNodes.item(i);
         if (node.isFieldNode() 
             && node.objId.getContentId() == contentId
             && node.objId.getFieldName() == fieldName)
         {
            result.add(node.objId);
         }
         else if (!node.isLeafNode())
         {
            this._getFieldIdsByContentIdName(contentId, fieldName, node, 
               result);
         }
      }
   }   
      

   /**
    * Gets the object ids from the immidiate (child) field nodes of the root, 
    * where the content id of the node equals the specified content id.
    * 
    * @param {int} contentId The content id of the searched nodes. This is a 
    *    required parameter.
    *
    * @return a list {dojo.collections.ArrayList} of {ps.aa.ObjectId} objects. 
    *    Never null, but may be empty.
    */
   this._getIdsOfTopLevelFieldNode = function(contentId)
   {
      var result = new dojo.collections.ArrayList();
      for (var i=0; i<this.root.childNodes.count; i++)
      {
         var node = this.root.childNodes.item(i);
         if (node.isFieldNode() && node.objId.getContentId() == contentId)
         {
            result.add(node.objId);
         }
      }
      return result;      
   }   

   /**
    * Gets all object ids of the nodes that satisfy the following:
    * (1) The content id of the object id equals the specified content id,
    * (2) The snippet field nodes. 
    *
    * @param {int} contentId The content id of the searched nodes. This is a 
    *    required parameter.
    * @param {ps.aa.TreeNode} pnoade The parent node that the search from. 
    *    This is a  required parameter.
    * @param {dojo.collections.ArrayList} result The variable that collects
    *    all qualified snippet nodes. This is a required parameter.
    */
   this._getSnippetIdsFromContentId = function(contentId, pnode, result)
   {
      for (var i=0; i<pnode.childNodes.count; i++)
      {
         var node = pnode.childNodes.item(i);
         if (node.isSnippetNode() && node.objId.getContentId() == contentId)
         {
            result.add(node.objId);
         }
         else if (!node.isLeafNode())
         {
            this._getSnippetIdsFromContentId(contentId, node, result);
         }
      }
   }   
      
   /**
    * Removes the specified node and all its child nodes. Do nothing if cannot
    * find the node with the specified id.
    *
    * @param {ps.aa.ObjectId} id The id of the to be removed node.
    *
    * @return true if successfully removed the specified node; false otherwise.
    */
   this.removeNode = function(id)
   {
      var node = this.getNodeById(id);
      if (node == null)
         return false;
         
      var pnode = node.parentNode;
      if (pnode != null)
         pnode.childNodes.remove(node);
         
      node.clear();
      return true;
   }
   
   /**
    * Gets the next sibling node if there is one. If there is no next sibling
    * node, then gets the previous sibling node; otherwise, gets the parent node.
    * 
    * @return the id of the node described above. It may be null none of the 
    *    above exists.
    */
   this.getNextSiblingId = function(id)
   {
      var node = this.getNodeById(id);
      dojo.lang.assert(node, "Cannot find node id=" + id.serialize());

      var pnode = node.parentNode;
      if (pnode == null)
         return null;
         
      var len = pnode.childNodes.count;
      var index = pnode.childNodes.indexOf(node);
      var node = null;
      if (index < (len-1))
      {
         node = pnode.childNodes.item(index+1); // next sibling
      }
      else if (index > 0)
      {
         node = pnode.childNodes.item(index-1); // previous sibling
      }
      else
      {
         node = pnode; // there is no sibling, return the parent node.
      }
      return node.objId;
   }
   
   /**
    * Converts a node (if specified) or the whole tree to text.
    * 
    * @param {ps.aa.TreeNode} node The to be converted node if specified; 
    *    otherwise, converts the whole tree into text.
    * 
    * @return serialized string of the node or the whole tree.
    */   
   this.toString = function(node)
   {
      if (dojo.lang.isUndefined(node))
      {
         return this.toString(this.root);
      }
      else
      {
         var text = node.toString() + "\n";
         if (node.isLeafNode())
            return text;
            
         for (var i=0; i<node.childNodes.count; i++)
         {
            var cnode = node.childNodes.item(i);
            text += "   child[" + i + "]: " + this.toString(cnode) + "\n";
         }
         return text;
      }
   }   
};


/**
 * This is a node that contains in the {ps.aa.Tree} object.
 *
 * @param (ps.aa.ObjectId} objectId  The id of this node, never null.
 * @param (ps.aa.TreeNode} parentNode  The id of the parent node, it may be null 
 *    for a root node; otherwise it may not be null.
 * @param {dojo.collections.ArrayList} childNodes  The child nodes, never null, 
 *    may be empty.
 * @constructor
 */
ps.aa.TreeNode = function (objectId, pNode, childNodes)
{
   dojo.lang.assertType(objectId, ps.aa.ObjectId);
   pNode && dojo.lang.assertType(pNode, ps.aa.TreeNode);
   
   /**
    * The object id of this node (ps.aa.ObjectId}.
    */
   this.objId = objectId;

   /**
    * The object id of this node (ps.aa.TreeNode}.
    */
   if (dojo.lang.isUndefined(pNode))
      this.parentNode = null;
   else
      this.parentNode = pNode;

   /**
    * The immidiate child nodes. {dojo.collections.ArrayList}.
    */
   if (dojo.lang.isUndefined(childNodes))
      this.childNodes = null;
   else
      this.childNodes = childNodes;
   
   /**
    * The label of the node.
    */
   this.nodeLabel = null;
   
   /**
    * @return true if this node does not have any child nodes; otherwise false.
    */
   this.isLeafNode = function()
   {
      return this.childNodes == null || this.childNodes.count == 0;
   }

   /**
    * @return the label of the node.
    */
   this.getLabel = function()
   {
      if (this.nodeLabel == null)
      {
         if (this.isFieldNode())
         {
            // Get field label but remove any trailing colon (:)
            this.nodeLabel = this.objId.getFieldLabel().replace(/\:$/g, "");
         }
         else
         {
            var id = this.objId.serialize();
            var divElem = dojo.byId(id);
            dojo.lang.assert(divElem, "Cannot find DIV element with id=" + id);
            this.nodeLabel = dojo.html.getAttribute(divElem, "psAaLabel");
         }
      }
      return this.nodeLabel;
   }
   
   /**
    * Determines if the specified object id equals the object id of the node.
    * 
    * @param {ps.aa.ObjectId} id The object id in question.
    * Not <code>null</code>
    * 
    * @return true if the object ids are equal; false otherwise.
    */
   this.equals = function(id)
   {
      dojo.lang.assertType(id, ps.aa.ObjectId);
      return this.objId.serialize() == id.serialize();
   }
   
   /**
    * Clears all properties of the node and removes its child nodes if there is
    * any. This is used before remove/destroy the node from the tree.
    */
   this.clear = function()
   {
      this.removeChildNodes();
      
      this.objId = null;
      this.parentNode = null;  
      this.nodeLabel = null;
   }
   
   /**
    * Clears the label property.
    */
   this.clearLabel = function()
   {
      this.nodeLabel = null;
   }
   
   /**
    * Removes all child nodes if exists.
    */
   this.removeChildNodes = function()
   {
      if (this.childNodes == null)
         return;
         
      for (var i=0; i<this.childNodes.count; i++)
      {
         var node = this.childNodes.item(i);
         node.clear();
      }
      this.childNodes.clear(); 
   }
   
   /**
    * @return this.objId.isSnippetNode();
    */
   this.isSnippetNode = function()
   {
      return this.objId.isSnippetNode();
   }
   
   /**
    * Returns the id of the data object associated with this node.
    * @return ps.aa.ObjectId
    */
   this.getObjectId = function()
   {
      return this.objId;
   }
   
   /**
    * @return this.objId.isPageNode();
    */
   this.isPageNode = function()
   {
      return this.objId.isPageNode();
   }
   
   /**
    * @return this.objId.isFieldNode();
    */
   this.isFieldNode = function()
   {
      return this.objId.isFieldNode();
   }
   
   /**
    * @return this.objId.isSlotNode();
    */
   this.isSlotNode = function()
   {
      return this.objId.isSlotNode();
   }
   
   /**
    * Adds the specified child node.
    * 
    * @param {ps.aa.TreeNode} node The new child node.
    */
   this.addChildNode = function(node)
   {
      if (this.childNodes == null)
         this.childNodes = new dojo.collections.ArrayList();
      
      node.parentNode = this;
      this.childNodes.add(node);   
   }
   
   /**
    * Returns the node index in the parent node or throws an exception
    * if this is a root node, which does not have a parent,
    * or if it can't find the node.
    */
   this.getIndex = function ()
   {
      dojo.lang.assert(this.parentNode);
      var siblings = this.parentNode.childNodes.toArray();
      for (var i in siblings)
      {
         var node = siblings[i];
         if (node === this)
         {
            return parseInt(i);
         }
     }
     dojo.lang.assert(false,
         "Inconsistent tree structure, could not find this node in the parent");
   }
   
   /**
    * @return serialized string of this object.
    */   
   this.toString = function()
   {
      if (this.parentNode == null && this.childNodes == null)
      {
         return "id = " + this.objId.serialize();
      }
      else if (this.parentNode == null)
      {
         return "id = " + this.objId.serialize() + "\n" +
                "childNodes.count = " + this.childNodes.count;
      }
      else if (this.childNodes == null)
      {
         return "id = " + this.objId.serialize() + "\n" +
                "parent = " + this.parentNode.objId.serialize();
      }
      else
      {
         return "id = " + this.objId.serialize() + "\n" +
                "parent = " + this.parentNode.objId.serialize() + "\n" +
                "childNodes.count = " + this.childNodes.count;         
      }
         
   }
};

/******************************************************************************
 *
 * [ ps.aa.SnippetMove.js ]
 *
 * COPYRIGHT (c) 1999 - 2007 by Percussion Software, Inc., Woburn, MA USA.
 * All rights reserved. This material contains unpublished, copyrighted
 * work including confidential and proprietary information of Percussion.
 *
 *****************************************************************************/

dojo.provide("ps.aa.SnippetMove");




/**
 * Data for moving a snippet between slots.
 * Read-only after creation.
 *
 * @param {ps.aa.ObjectId} snippetId the snippet id. Not null.
 * @param {ps.aa.ObjectId} targetSlotId the id of the slot to move
 * the snippet to. Not null.
 * @param {Number} targetIndex the position, starting with 1,
 * in the target slot to move the snippet to.
 * Not <code>null</code>.
 * @param {Boolean} dontUpdatePage if specified and <code>true</code>
 * the move operation should not update the page. Optional.
 * Can be used, for example, with DnD, to allow the drop operation
 * to update the page itself.
 * @constructor
 */
ps.aa.SnippetMove = function (snippetId, slotId, targetSlotId, targetIndex,
       dontUpdatePage)
{
   dojo.lang.assertType(snippetId, ps.aa.ObjectId);
   dojo.lang.assertType(targetSlotId, ps.aa.ObjectId);
   dojo.lang.assert(dojo.lang.isNumeric(targetIndex),
         "Should be interpreted as number");
   dontUpdatePage && dojo.lang.isBoolean(dontUpdatePage);

   this._m_snippetId = snippetId;
   this._m_slotId = slotId;
   this._m_targetSlotId = targetSlotId;
   this._m_targetIndex = targetIndex;
   this._m_dontUpdatePage = dontUpdatePage || false;

   this._m_targetSnippetId = snippetId.clone();
   this._m_targetSnippetId.setSlotId(targetSlotId.getSlotId());
   this._m_targetSnippetId.setSortRank(targetIndex);
   this._m_uiUpdateNeeded = false;
   this._m_success = undefined;

   /**
    * Returns the original snippet id, originally passed to the constructor.
    * @return the snippet id.
    * Not <code>null</code>.
    */
   this.getSnippetId = function ()
   {
      return this._m_snippetId;
   }
   
   /**
    * Returns snippet id after it is moved to the new slot.
    * @return the snippet id.
    * Not <code>null</code>.
    */
   this.getTargetSnippetId = function ()
   {
      return this._m_targetSnippetId;
   }
   
   /**
    * Specifies new target snippet id.
    * @param targetSnippetId the new target snippet id.
    * Not <code>null</code>.
    */
   this.setTargetSnippetId = function (targetSnippetId)
   {
      dojo.lang.assertType(targetSnippetId, ps.aa.ObjectId);
      this._m_targetSnippetId = targetSnippetId;
   }

   /**
    * Returns the source slot id, originally passed to the constructor.
    * @return the slot id.
    * Not <code>null</code>.
    */
   this.getSlotId = function ()
   {
      return this._m_slotId;
   }

   /**
    * Returns the destination slot id, originally passed to the constructor.
    * @return the destination slot id.
    * Not <code>null</code>.
    */
   this.getTargetSlotId = function ()
   {
      return this._m_targetSlotId;
   }
   
   /**
    * Returns the 1-based target position of the snippet in the slot,
    * returned by {@link #getTargetSlot}.
    * May be <code>null</code>, in which case the item will be appended
    * to the end of the slot items.
    */
   this.getTargetIndex = function ()
   {
      return this._m_targetIndex;
   }
   
   /**
    * Whether the move operation should also update the page.
    */
   this.getDontUpdatePage = function ()
   {
      return this._m_dontUpdatePage;
   }
   
   /**
    * Sets new value to the property returned by {@link #getDontUpdatePage}.
    */
   this.setDontUpdatePage = function (dontUpdatePage)
   {
      this._m_dontUpdatePage = dontUpdatePage;
   }
   
   /**
    * Equals to <code>true</code>, only if the move was performed, backend
    * data were updated, but the update is not reflected in UI yet,
    * because {@link #getDontUpdatePage} is <code>true</code>.
    */
   this.isUiUpdateNeeded = function ()
   {
      return this._m_uiUpdateNeeded;
   }
   
   /**
    * Sets new value returned by {@link #isUiUpdateNeeded}.
    * @param {Boolean} uiUpdateNeeded the new value. Can be <code>true</code>
    * only if {@link getDontUpdatePage} is <code>true</code>.
    * Not <code>null</code>.
    */
   this.setUiUpdateNeeded = function (uiUpdateNeeded)
   {
      dojo.lang.assert(dojo.lang.isBoolean(uiUpdateNeeded));
      if (uiUpdateNeeded)
      {
         dojo.lang.assert(this.getDontUpdatePage(),
               "uiUpdateNeedeed can be true only if getDontUpdatePage is true");
      }
      this._m_uiUpdateNeeded = uiUpdateNeeded;
   }
   
   /**
    * Indicates whether the move is successful.
    * @return <code>true</code> if the move operationwas successful,
    * <code>false</code> if it failed, <code>undefined</code> otherwise.
    */
   this.isSuccess = function ()
   {
      return this._m_success;
   }
   
   /**
    * Sets the value returned by {@link #isSuccess}.
    * @param {Boolean} success the new value.
    */
   this.setSuccess = function (success)
   {
      dojo.lang.assertType(success, Boolean);
      this._m_success = success;
   }
}

/******************************************************************************
 *
 * [ ps.content.History.js ]
 *
 * COPYRIGHT (c) 1999 - 2007 by Percussion Software, Inc., Woburn, MA USA.
 * All rights reserved. This material contains unpublished, copyrighted
 * work including confidential and proprietary information of Percussion.
 *
 *****************************************************************************/
dojo.provide("ps.content.History");




/**
 * A history data object. Acts as a stack of string entries.
 * Insures that it has at least one path, which is never removed or changed.
 * Top of the stack serves as the current entry.
 * @param {String} initialEntry the initial history entry, which is never removed.
 * @constructor
 */
ps.content.History = function (initialEntry)
{
   dojo.lang.assertType(initialEntry, String);

   /**
    * Stack of string paths visited by the user. The current path is on the top
    * of the stack. Never <code>null</code> or empty.
    */
   this._m_stack = new dojo.collections.Stack([initialEntry]);
   
   /**
    * Adds new entry to the history.
    * @param {String} newEntry new history entry.
    * Does nothing if the entry is the same as the entry returned by
    * {@link #getCurrent}.
    * Not <code>null</code>.
    */
   this.add = function (newEntry)
   {
      dojo.lang.assertType(newEntry, String);
      if (newEntry !== this.getCurrent())
      {
         this._m_stack.push(newEntry);
      }
   }

   /**
    * Removes the top stack entry,
    * if {@link #canGoBack} returns <code>true</code>.
    * Otherwise throws an assertion exception.
    * @return the next history entry. Not <code>null</code>.
    */
   this.back = function ()
   {
      dojo.lang.assert(this.canGoBack());
      return this._m_stack.pop();
   }

   /**
    * Indicates whether there are more entries in the history to go back to.
    */
   this.canGoBack = function ()
   {
      return this._m_stack.count > 1;
   }
   
   /**
    * The topmost history entry.
    */
   this.getCurrent = function ()
   {
      return this._m_stack.peek();
   }
}

/******************************************************************************
 *
 * [ ps.content.ContentPaneProgress.js ]
 *
 * COPYRIGHT (c) 1999 - 2007 by Percussion Software, Inc., Woburn, MA USA.
 * All rights reserved. This material contains unpublished, copyrighted
 * work including confidential and proprietary information of Percussion.
 *
 *****************************************************************************/
dojo.provide("ps.widget.ContentPaneProgress");
 
/**
 * Shows "wait" cursor while {@link dojo.widget.ContentPane} loads.
 *
 * @author Andriy Palamarchuk
 * @param contentPane the content pane widget to show content loading for.
 * Not null.
 * @constructor
 */
ps.widget.ContentPaneProgress = function (contentPane)
{
   dojo.lang.assert(contentPane
         && contentPane.onDownloadStart
         && contentPane.onDownloadEnd, "Content pane must be defined");

   // the content pane element
   var element = contentPane.domNode;

   // the cursor 
   var originalCursor = element.style.cursor;
   var WAIT_CURSOR = "wait";

   // whether indication of progress is already shown
   function isIndicating()
   {
      return element.style.cursor === WAIT_CURSOR;
   }

   // show progress indicator
   function start()
   {
      if (isIndicating())
      {
         return;
      }
      element.style.cursor = WAIT_CURSOR;
   }
   
   // in case loading is already in progress ...
   if (!contentPane.isLoaded)
   {
      start();
   }
   dojo.event.connect(contentPane, "onDownloadStart", function() {start()});
   dojo.event.connect(contentPane, "onDownloadEnd", function()
   {
      element.style.cursor =
            originalCursor === WAIT_CURSOR ? "" : originalCursor;
   });
}

/******************************************************************************
 *
 * [ ps.content.SelectTemplates.js ]
 *
 * COPYRIGHT (c) 1999 - 2007 by Percussion Software, Inc., Woburn, MA USA.
 * All rights reserved. This material contains unpublished, copyrighted
 * work including confidential and proprietary information of Percussion.
 *
 *****************************************************************************/
 dojo.provide("ps.content.SelectTemplates");
 
 
 
 
 /**
  * The javascript code needed to make the select templates
  * dialog work.
  */
 ps.content.SelectTemplates = function()
 {
 	this.isAsDialog = true;
 	this.preferredHeight = 450;
    this.preferredWidth = 750;
    this.parentMode = "";
 
   /**
    * Initializes this dialog. Should only call once.
    * @param (string} url the url of the content that this
    * dialog will display.
    */
   this.init = function(url)
   {
      this.url = url;
   }
   
   /**
    * Creates the template selection dialog if it is not created yet.
    * Stores the dialog in the {@link #wgtDlg} field.
    */
   this.maybeCreateSelectTemplateDialog = function ()
   {
      if (this.wgtDlg)
      {
         return;
      }
      this.wgtDlg = ps.createDialog(
            {
               id: "ps.content.SelectTemplatesDlg",
               title: psxGetLocalMessage("javascript.ps.content.selecttemplates@Templates"),
               href: this.url
            }, "750px", "450px");
      new ps.widget.ContentPaneProgress(this.wgtDlg);

      var _this = this;
      //override the dialog close function
      // to not destroy the dialog
      this.wgtDlg.closeWindow = function()
      {
         _this.cancelCallback();
         this.hide();
      }     
 
      dojo.event.connect(this.wgtDlg, "onLoad", function()
      {
         _this.parseControls();
         var temps = _this.wgtTemplates;
         if(temps.options.length > 0)
         {
            // figure out which template is currently selected by
            // passed in snippet
            var idx = 0;
            var currentTemp = _this.snippetId.getTemplateId();
            for(i = 0; i < temps.options.length; i++)
            {
               var val = temps.options[i].value;
               var objId = new ps.aa.ObjectId(val);
               if(objId.getTemplateId() == currentTemp)
               {
                  idx = i;
                  break;
               }
            }            
            
            temps.selectedIndex = idx;
            _this.onTemplateChoice();
         }
         else
         {
            _this.wgtPreviewPane.setContent("No templates associated to the slot.");            
         }         
      });
   }

   /**
    * Use when the select templates dialog contents is used in a panel.
    * The contents must be loaded before calling this for it to work.
    */
   this.initAsPanel = function(parentMode)
   {
      if(parentMode != undefined && parentMode != null)
		  this.parentMode = parentMode;
	  this.isAsDialog = false;
      this.parseControls();
      var temps = this.wgtTemplates;
      if(temps.options.length == 0)
      {
         this.wgtPreviewPane.setContent("No templates associated to the slot.");            
      }
      else
      {
         this.wgtTemplates.selectedIndex = 0;
         this.onTemplateChoice();
      } 
   }
   
   /**
    * Retrieves the controls from the main content and connects
    * the necessary events and functions.
    */
   this.parseControls = function()
   {
      var _this = this;
      this.wgtTemplates = document.getElementById("ps.select.templates.wgtTemplates");
      this.wgtPreviewPane = dojo.widget.byId("ps.select.templates.wgtPreviewPane");
      this.wgtTemplates.onchange = function()
      {
         _this.onTemplateChoice();
      }
      if(this.isAsDialog)
      {
         this.wgtButtonSelect = dojo.widget.byId("ps.select.templates.wgtButtonSelect");
         this.wgtButtonCancel = dojo.widget.byId("ps.select.templates.wgtButtonCancel");
         this.wgtButtonCancel.onClick = function()
         {
            _this.cancelCallback();
            _this.wgtDlg.hide();
         };
         
         this.wgtButtonSelect.onClick = function()
         {
            var id = _this.getSelectedId();
            if(id)
            {
               _this.okCallback(id, _this.snippetId);
               _this.wgtDlg.hide();
            }
         }
      }      
          
      
   }   
  
   /**
    * Resets the content url and displays the dialog.
    * @param {function} okCallback the callback function that will be
    * called if the select button is clicked and a selection exists.
    * @param {function} cancelCallback  the callback function that will be
    * called if the cancel button is clicked.
    * @param {ps.aa.ObjectId} the objectid of the snippet in question
    * with its slot modified to be the target slotid.
    */
   this.open = function(okCallback, cancelCallback, snippetId)
   {
      if(!this.isAsDialog)
         return;
      dojo.lang.assertType(snippetId, ps.aa.ObjectId);
      this.snippetId = snippetId;
      this.okCallback = okCallback;
      this.cancelCallback = cancelCallback;
      var newUrl = this.url + "?objectId=" + escape(snippetId.serialize());
      
      this.maybeCreateSelectTemplateDialog();
      this.wgtDlg.setUrl(newUrl);
      ps.util.setDialogSize(this.wgtDlg, this.preferredWidth, this.preferredHeight);
      this.wgtDlg.show();
      
   }
   
   /**
    * Callback used when a template is highlighted in the
    * selection list. Causes the template snippet combination to
    * be assembled and previewed.
    */  
   this.onTemplateChoice = function()
   {
      var id = this.getSelectedId();
      if(id)
         this.loadPreviewPane(id);
   }
   
   /**
    * Returns the selected template id.
    */
   this.getSelectedId = function()
   {
      var index = this.wgtTemplates.selectedIndex;
      if(index == -1)
         return null;
      var option =  this.wgtTemplates.options[index];
      return new ps.aa.ObjectId(option.value); 
  }
   
   /**
    * Assembles and loads the snippet template combination
    * in the preview pane.
    */
   this.loadPreviewPane = function(snippetId)
   {
     
     dojo.lang.assertType(snippetId, ps.aa.ObjectId);
     var tempId = snippetId.getTemplateId();
     var isBinary = false;
     var content = "";
	  var response = null;
     // load template list
      var response = ps.io.Actions.getItemTemplatesForSlot(snippetId);
		if(response.isSuccess())
		{
         var res = response.getValue();
         for(i = 0; i < res.length; i++)
         {
            if(res[i].variantid == tempId)
            {
               if(res[i].outputformat == "Binary")
                  isBinary = true;
               break;
            }
         }
		}
     
	  if(this.parentMode == ps.util.BROWSE_MODE_RTE_INLINE_IMAGE)
	  {
        response = ps.io.Actions.getUrl(snippetId, "CE_LINK");
		  if(response.isSuccess())
		  {
              content = "<img src=\"" + response.getValue().url + "\">";
		  }
	  }
     else if(this.parentMode == ps.util.BROWSE_MODE_RTE_INLINE_LINK && isBinary)
     {
        var isImage = false;
		  response = ps.io.Actions.getSnippetMimeType(snippetId);
		  if(response.isSuccess())
		  {
		     mType = response.getValue().mimetype;
			  isImage = mType.toLowerCase().indexOf("image/") != -1;	
		  }
		  
		  response = ps.io.Actions.getUrl(snippetId, "CE_LINK");
		  if(response.isSuccess())
		  {
           if (isImage)
			  {
			     content = "<img src=\"" + response.getValue().url + "\">";
			  }
			  else 
			  {
			  	   content = "<table width=\"100%\" height=\"100%\"><tr><td valign=\"middle\" align=\"center\">";
			  	   content += "<a target=\"_new\" href=\"" + response.getValue().url + "\">" +
			  	   "<u>Click To View Binary</u>" +
			  	   "</a>";
			  	   content += "</td></tr></table>";
			  }
		  }
     }
	  else
	  {
       if(!isBinary)
       {
          var selectedContent = null;
          try
          {
            selectedContent = ___selectedContent;
          }
          catch (ignore){}
          
          response = ps.io.Actions.getSnippetContent(snippetId, false,  selectedContent);
		    if(response.isSuccess())
		    {
		       content = response.getValue();
		    }
       }

	  }
	  if(content == "")
	     content = "No preview available.";
     this.wgtPreviewPane.setContent(content);
      
   }
 
 }

/******************************************************************************
 *
 * [ ps.util.js ]
 *
 * COPYRIGHT (c) 1999 - 2007 by Percussion Software, Inc., Woburn, MA USA.
 * All rights reserved. This material contains unpublished, copyrighted
 * work including confidential and proprietary information of Percussion.
 *
 *****************************************************************************/

/*
 * Various utilities.
 * This is a generic module.
 * While changing this file consider moving functions to separate modules.
 */

dojo.provide("ps.util");

ps.util = new function(){}


/**
 * Utility method to add a parameter to the URL.
 * If ? exists in url then adds the param appending an & otherwise
 * adds the param by appending ? to the url.
 */
ps.util.addParamToUrl = function(url,name,value)
{
   url.indexOf("?")==-1?url+="?":url+="&";
 	url+=name+"="+value;
   return url;
}


/**
 * Reports an error to the user, and logs it.
 * @param error the error to report. Optional.
 * <ul>
 * 
 * <il>If the value is skipped or can be converted to boolean <code>false</code>
 * value, the method just notifies the user that an error occured.</il>
 * 
 * <il>Otherwise, if the error is a string, it is shown as is.</il>
 * 
 * <il>Otherwise, if the error is an object of {@link ps.io.Response} type,
 * it shows an error stored in it.
 * The method fails if the object indicates a successful operation.</il>
 *
 * <il>Otherwise, if the error object has property "message",
 * the method shows content of this field.</il>
 * 
 * <il>Otherwise, the method reports that an unrecognized error has occured, and
 * logs the error object. The logged object can be later inspected with debugger
 * like Firebug</il>
 * </ul>
 *
 * @return nothing.
 */
ps.util.error = function (error)
{
   function hasProperty(o, propertyName)
   {
      for (var property in o)
      {
         if (property === propertyName)
         {
            return true;
         }
      }
      return false;
   }
   error_val = error;

   var debugObj;
   if (!error)
   {
      var message = "An Error Occured!";
   }
   else if (dojo.lang.isString(error))
   {
      var message = error;
   }
   else if (error instanceof ps.io.Response)
   {
      dojo.lang.assert(!error.isSuccess(),
            "error() was called with ps.io.Response indicating success. "
            + "It should be called on an error only.");
      ps.util.error(error.getValue());
      return;
   }
   else if (hasProperty(error, "message"))
   {
      ps.util.error(error.message);
      return;
   }
   else
   {
      debugObj = true;
      var message = "An Unrecognized Error Occured!";
   }
   dojo.debug(message);
   if (debugObj)
   {
      dojo.debug(error);
   }
   alert(message);
}

/**
 * Finds a DOM node with the specified id in the array of nodes or their
 * child nodes.
 * @param {Array} nodes the nodes to search for. Not <code>null</code>.
 * @param {String} id the node id to search for. Not <code>null</code>.
 * @return the found node or <code>null</code> if the node with the specified
 * id was not found.
 */
ps.util.findNodeById = function (nodes, id)
{
   dojo.lang.assert(dojo.lang.isArrayLike(nodes));
   dojo.lang.assertType(id, String);

   // check nodes of this level
   for (var i in nodes)
   {
      var node = nodes[i];
      if (node.id === id && node.nodeType === dojo.html.ELEMENT_NODE)
      {
         return node;
      }
   }

   // recursively check each of the children
   for (var i in nodes)
   {
      var node = nodes[i];
      if (node.nodeType === dojo.html.ELEMENT_NODE)
      {
         var foundNode = ps.util.findNodeById(node.childNodes, id);
         if (foundNode)
         {
            return foundNode;
         }
      }
   }
   return null;
}

/**
 * Swaps two nodes in place. Each node should have a parent.
 * @param node1 the first node.
 * Not <code>null</code>.
 * @param node2 the second node.
 * Not <code>null</code>.
 */
ps.util.swapNodes = function (node1, node2)
{
   dojo.lang.assert(node1);
   dojo.lang.assert(node2);

   var parent1 = node1.parentNode;
   var parent2 = node2.parentNode;
   dojo.lang.assert(parent1);
   dojo.lang.assert(parent2);

   var marker = document.createElement("div");
   parent1.insertBefore(marker, node1);
   parent2.insertBefore(node1, node2);
   parent1.insertBefore(node2, marker);

   dojo.html.destroyNode(marker);
}

/**
 * Returns the width and height of the main window.
 * @param win A top level window object or null to use 'window'.
 * @param useInner flag indicating innerWidth/innerHeight should be used to calculate
 * size for non IE browsers, else if <code>false</code> then
 * use outerWidth/outerHeight.
 * @return an object with a width and height property.
 */
ps.util.getScreenSize = function(win, useInner) 
{
   if (win == null)
      win = window;
   var doc = win.document;
   var dims = new Object();
   if( typeof( win.innerWidth ) == 'number' )
   {
      //Non-IE
      if(useInner)
      {
         dims.width = win.innerWidth;
         dims.height = win.innerHeight;
      }
      else
      {
         dims.width = win.outerWidth;
         dims.height = win.outerHeight;
      }
   }
   else if( doc.documentElement && (
      doc.documentElement.clientWidth ||
      doc.documentElement.clientHeight ) )
   {
      //IE 6+ in 'standards compliant mode'
      dims.width = doc.documentElement.clientWidth;
      dims.height = doc.documentElement.clientHeight;
   } 
   else if( doc.body && ( 
      doc.body.clientWidth ||
      doc.body.clientHeight ) )
   {
      //IE 4 compatible
      dims.width = doc.body.clientWidth;
      dims.height = doc.body.clientHeight;
   }
   return dims;
}

/**
 * Sets the size of the passed in dialog to the passed in 
 * preferred sizes. If the preferred sizes don't fit
 * in the screen then they are adjusted to fit within the
 * screen.
 * @param {dojo.widget.FloatingPane} dialog the dialog to be
 * sized.
 * @param {int} width the preferred width for the dialog.
 * @param {int} height the preferred height for the dialog.
 */
ps.util.setDialogSize = function(dialog, width, height)
{
   dojo.lang.assertType(dialog, dojo.widget.FloatingPane);
   var scrSize = ps.util.getScreenSize();
   var pHeight = height * .96;
   var pWidth = width * .96;
   if(pHeight >= scrSize.height)
      height = scrSize.height * .96;
   if(pWidth >= scrSize.width)
      width = scrSize.width * .96;
   dialog.resizeTo(width, height);      
}

/**
 * Returns the size of the passed in dialog as an object with
 * a width and height property.
 * @param {dojo.widget.FloatingPane} dialog the dialog to return
 * its size.
 */
ps.util.getDialogSize = function(dialog)
{
   dojo.lang.assertType(dialog, dojo.widget.FloatingPane);
   return dojo.html.getMarginBox(dialog.domNode);   
}

/**
 * Forces the passed in dialog to resize. This is used to 
 * get around a layout issues with browsers.
 * @param {dojo.widget.FloatingPane} dialog the dialog
 * @param {number} preferredWidth the preferred width,
 *  used if get dialog size returns zero. 
 * @param {number} preferredHeight the preferred height,
 *  used if get dialog size returns zero.
 */
ps.util.forceDialogResize = function(dialog, preferredWidth, preferredHeight)
{
   dojo.lang.assertType(dialog, dojo.widget.FloatingPane);
   var size = ps.util.getDialogSize(dialog);
   var width = size.width > 0 ? size.width : preferredWidth;
   var height = size.height > 0 ? size.height : preferredHeight;
   ps.util.setDialogSize(dialog, width - 1, height - 1);
   ps.util.setDialogSize(dialog, width, height);
}

/**
 * A helper method to get around the issue in IE 6 where
 * the CSS hover style does not work. If Firefox, Safari or
 * IE 7 then we donothing and return as the CSS hover
 * works in these browsers.
 * @param {htmlNode} div the div tag in question.
 * @param {boolean} isHovering flag indicating that the
 * mouse is currently hovering over this div tag.
 */
ps.util.handleIE6FieldDivHover = function(div, isHovering)
{
   if(!dojo.render.html.ie || dojo.render.html.ie70)
      return;
   var color = isHovering ? "#ffc" : "";   
   div.style.backgroundColor = color;   
}

/**
 * Returns an object with attributes 'top', 'left', 'bottom', 'right',
 * indicating distances of the element in pixels from left and top page side.
 * @param element the dom node of the element to find visible sides for.
 * Not <code>null</code>
 */
ps.util.getVisibleSides = function (element)
{
   dojo.lang.assert(element, "Element must be specified");

   var box = dojo.html.getBorderBox(element);
   var visible = ps.util.getVisiblePosition(element);

   var top = visible.y;
   var left = visible.x;
   var bottom = top + box.height;
   var right = left + box.width;

   return {top: top, left: left, bottom: bottom, right: right};
}

/**
 * Returns visible position of the node on the page as an object with x, y
 * attributes.
 * @param node the node to find visible position for. Not <code>null</code>.
 */
ps.util.getVisiblePosition = function (node)
{
   function visibleSize (node, styleAttr)
   {
      var result = 0;
      var n = node;
      while (n)
      {
         var dpixels = dojo.html.getPixelValue(n, styleAttr);
         if (dpixels)
         {
            result += dpixels;
         }
         n = n.parentNode;
      }
      return result;
   }

   return {x: visibleSize(node, "left"), y: visibleSize(node, "top")};
}

/**
 * Creates a dialog with the provided parameters and default parameters.
 * @param params the parameters to create the dialog.
 * Not null.
 * @param {String} width the dialog width as specified in HTML.
 * Can be null if not specified.
 * @param {String} height the dialog height.
 * Can be null if not specified.
 * @param (boolean) resizable option, if specified and false then creates the
 * dialog as not resizable otherwise resizable.
 */
ps.util.createDialog = function (params, width, height, isResizable)
{
   dojo.lang.assert(params, "Parameters should be specifed");
   var isRes = true;
   if(isResizable == false)
   {
      isRes = false;
   }
   // programmatic creation of a modal floating pane only works
   // when its element is created first.
   var div = document.createElement('div');
   if (width)
   {
      div.style.width = width;
   }
   if (height)
   {
      div.style.height = height;
   }
   div.style.position = "absolute";
   document.body.appendChild(div);

   var p = {
      bgColor: ps.util.DIALOG_BACKGROUND,
      bgOpacity: ps.util.DIALOG_BACKGROUND_OPACITY,
      toggle: "explode",
      toggleDuration: 10,
      constrainToContainer: true,
      hasShadow: true,
      resizable: isRes,
      executeScripts: true,
      cacheContent: false
   };
   dojo.lang.mixin(p, params);

   return dojo.widget.createWidget("ModalFloatingPane", p, div);
}

/**
 * Gets the target from the supplied event and executes the select() method on
 * it. This is meant for text controls such as INPUT type="text".
 */
ps.util.selectAll = function(e)
{
   var targ;
   if (!e)
   {
      var e=window.event;
   }
   if (e.target)
   {
      targ=e.target;
   }
   else if (e.srcElement)
   {
      targ=e.srcElement;
   }
   if (targ.nodeType==3) // defeat Safari bug
   {
      targ = targ.parentNode;
   }
   targ.select();
}


/**
 * Creates a small dialog with a 1 line text control to show the provided text.
 * The control is readonly and the content is selected when focus is gained.
 * The control is given focus initially.
 * Selection still has quirks on FF.
 */
ps.util.ShowPageLinkDialog = function(text)
{
   var div = document.createElement('div');
   div.style.position = "absolute";
   div.style.border = "0px";
   document.body.appendChild(div);

   var dlg = dojo.widget.createWidget("ModalFloatingPane",
   {
       id: "ps.pageLinkDiv",
       title: 'Paste link into email or IM ',
       titleBarDisplay: true,
       displayCloseAction: true,
       bgColor: ps.DIALOG_BACKGROUND,
       bgOpacity: ps.DIALOG_BACKGROUND_OPACITY,
       executeScripts: true,
       resizable: false
   }, div);

   //couldn't use Dojo's dojo.event.connect, it wouldn't work for onfocus (??)
   dlg.setContent(
      '<input onfocus="ps.util.selectAll(event)" id="ps.util.wgtShowPageLink" type="text" size="60" readonly="true" value="' + text + '" />'
   );
   ps.util.setDialogSize(dlg, 440, 70);
   dlg.show();

   var foo = dojo.byId("ps.util.wgtShowPageLink");
   foo.focus();
}

/**
 * Creates a prompt dialog, consisting of a test box with two buttons.
 * Expects options as an array of parameters to use while creating the dialog.
 * The button clicks will call the callback functions.
 * options
 * dlgTitle : (String)Dialog title, Default: Prompt Dialog
 * promptTitle : (String)Text box title, Default: Text
 * promptText: (String)Text box value, Default: ""
 * textRequired: (boolean) alerts user for non empty text on OK click., Default:false
 * okBtnText: (String)Text to show on OK button, Default : OK
 * cancelBtnText: (String)Text to show on Cancel button, Default: Cancel
 * okBtnCallBack: (function)Callback function for Ok button pressed, 
 *    Default:does nothing
 * cancelBtnCallBack: (function)Callback function for Cancel button pressed, 
 * if not 
 * It is callers responsibility to close the dialog by calling hide method. 
 * @param options array of options, if provided must be an object of array.

 * @return dojo dialog object.
 */
ps.util.CreatePromptDialog = function(options)
{
   var _this = this;

   this.dlgTitle = "Prompt Dialog";
   this.promptTitle = "Text";
   this.promptText = "";
   this.textRequired = false;
   this.okBtnText = "OK";
   this.cancelBtnText = "Cancel";
   this.okBtnCallBack = null;
   this.cancelBtnCallBack = null;
   if(options != null)
   {
      this.dlgTitle = options.dlgTitle;      
      this.promptTitle = options.promptTitle;      
      this.promptText = options.promptText;      
      this.textRequired = options.textRequired;      
      this.okBtnText = options.okBtnText;      
      this.cancelBtnText = options.cancelBtnText;      
      this.okBtnCallBack = options.okBtnCallBack;      
      this.cancelBtnCallBack = options.cancelBtnCallBack;      
   }

   var div = document.createElement('div');
   div.style.position = "absolute";
   div.style.border = "0px";
   document.body.appendChild(div);

   this.wgtDlg = dojo.widget.createWidget("ModalFloatingPane",
   {
       id: "ps.promptDiv",
       title: this.dlgTitle,
       titleBarDisplay: true,
       displayCloseAction: true,
       bgColor: ps.DIALOG_BACKGROUND,
       bgOpacity: ps.DIALOG_BACKGROUND_OPACITY,
       executeScripts: true,
       resizable: false
   }, div);

   dojo.event.connect(this.wgtDlg, "onLoad", function()
   {
      _this.wgtButtonOk = dojo.widget.byId("ps.util.promptButtonSelect");
      _this.wgtButtonCancel = dojo.widget.byId("ps.util.promptButtonCancel");
      _this.wgtPromptText = dojo.byId("ps.util.promptInput");
      _this.wgtButtonCancel.onClick = function()
      {
         if(_this.cancelBtnCallBack)
         {
             _this.cancelBtnCallBack(_this.wgtPromptText.value);
         }
         else
         {
            _this.wgtDlg.hide();
         }
      };
      _this.wgtButtonOk.onClick = function()
      {
         if(_this.textRequired && ps.util.trim(_this.wgtPromptText.value).length<1)
         {
            alert(_this.promptTitle + " is required.");
            _this.wgtDlg.focusTitle();
            return;
         }
         if(_this.okBtnCallBack)
         {
            _this.okBtnCallBack(_this.wgtPromptText.value);
         }
      };
      
   });
   
   /**
    * Sets the focus on the prompt text box.
    */
   this.wgtDlg.focusTitle = function()
   {
      _this.wgtPromptText.focus();
   }
   var dlgContent = "<div>" + this.promptTitle + "</div>" +
          "<div>" +
          "<input id='ps.util.promptInput' type='text' size='60' value='" + this.promptText + "' /></div>" +
          "<br />" +
          "<div class='PsAaButtonBox'>" +
          "<button dojoType='ps:PSButton' id='ps.util.promptButtonCancel'>" + this.cancelBtnText + "</button>" +
          "<button dojoType='ps:PSButton' id='ps.util.promptButtonSelect'>" + this.okBtnText + "</button>"+
			"</div>";
   
   this.wgtDlg.setContent(dlgContent);
   
   ps.util.setDialogSize(this.wgtDlg, 440, 120);
   return this.wgtDlg;
}

/**
 * Compares 2 strings ignoring case. Is used for sorting filtering table.
 */
ps.util.compareIgnoreCase = function (s1, s2)
{
   s1 = s1.toLowerCase();
   s2 = s2.toLowerCase()
   if (s1 > s2)
   {
      return 1;
   }
   else if (s1 < s2)
   {
      return -1;
   }
   else
   {
      return 0;
   }
}

/**
 * Helper class to trim the supplied string.
 * @param str, if <code>null</code> returns empty string otherwise returns 
 * trimmed string. Asserts if str is not of type String.
 */
ps.util.trim = function(str)
{
   if(!str)
     return "";
   dojo.lang.assertType(str,String);
   return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
}

/**
 * Helper method to get the the css text of the supplied element from the
 * Style Sheets (including the builtin style sheet of 0).
 * @param elemName, Name of the element whose styles needs to be returned, 
 *    if defined must be a String.
 * @param clearStyle, flag to indicate whether to clear the style after 
 *    extracting.
 * @return, element style or empty string. Never <code>null</code>
 */
ps.util.getElementStyleSheetCss = function(elemName, clearStyle)
{
   if(!elemName || ps.util.trim(elemName).length < 1)
      return "";
   dojo.lang.assertType(elemName,String);
   var clrStyle = clearStyle && clearStyle == true;
   var elemStyles = "";
   elemName = ps.util.trim(elemName).toLowerCase();
   var sheets = document.styleSheets;
   for(var i = 0; i < sheets.length; i++)
   {
      var rules = sheets[i].cssRules?sheets[i].cssRules:sheets[i].rules;
      if(rules.length > 0)
      {
         for(var j = 0; j < rules.length; j++)
         {
            var s = rules[j].style;
            if(rules[j].selectorText && 
               ps.util.trim(rules[j].selectorText).toLowerCase()==elemName)
            {
               elemStyles = elemStyles==""?s.cssText:elemStyles+";"
                              +s.cssText;
               if(clrStyle)
                  s.cssText = "";
            }
         }
      }
   }
   return elemStyles;
}

/**
 * Enables or disables style sheets. Disables or enables all the stylesheets 
 * whose href ends case insensitively with the given fileName.
 * @param fileName name of the style sheet file, if blank does nothing.<b>
 * @param enabled flag to indicate whether to enable or disable. 
 */
ps.util.enableStyleSheet = function(fileName, enabled)
{
   if(!fileName || ps.util.trim(fileName).length < 1)
      return;
   dojo.lang.assertType(fileName,String);
   var sheets = document.styleSheets;
   fileName = fileName.toLowerCase();
   for(var i = 0; i < sheets.length; i++)
   {
      var sheet = sheets[i];
      var href = ps.util.trim(sheet.href).toLowerCase();
      if(dojo.string.endsWith(href,fileName))
      {
         sheet.disabled = !enabled;
      }
   }
}

/**
 * Helper class to find all empty Active Assembly containers and
 * add a place holder.
 */
ps.util.addPlaceholders = function(doc)
{
   var allDivs = doc.getElementsByTagName("div");
   for(i = 0; i < allDivs.length; i++)
   {
      var className = allDivs[i].className;
      var isEmpty = allDivs[i].childNodes.length == 0;
      var prefix = null;
      if(className == "PsAaPage")
      {
         prefix = "Page";
      }
      if(className == "PsAaSlot")
      {
         prefix = "Slot";
      }
      else if(className == "PsAaSnippet")
      {
         prefix = "Snippet";
      }
      else if(className == "PsAaField")
      {
         prefix = "Field";
      }

      if(prefix != null && isEmpty)
      {
         var placeholder = document.createElement('div');
         placeholder.className = "PsAaPlaceholder";
         var pText = document.createTextNode("Empty " + prefix);
         placeholder.appendChild(pText);
         allDivs[i].appendChild(placeholder);
      }
   }
   
}

/**
 * Returns the value of the server property for the given property name. If 
 * not found returns the default value if supplied or null.
 * @param propertyName, name of the property must not be null and must be a 
 * string object.
 * @param defaultValue, the value that needs to be returned if the property 
 * does not exist. If this is not defined then returns null.
 * @return the property value or default value. May be empty.
 */
ps.util.getServerProperty = function(propertyName,defaultValue)
{
   dojo.lang.assertType(propertyName,String);
   if(!defaultValue)
      defaultValue = "";
   if(ps.util._serverProperties == null)
   {
      var response = ps.io.Actions.getServerProperties();
      if(!response.isSuccess())
      {
         ps.io.Actions.maybeReportActionError(response);
         return "";
      }
      ps.util._serverProperties = response.getValue();
   }
   if(ps.util._serverProperties[propertyName])
      return ps.util._serverProperties[propertyName];
   else
      return defaultValue;
}
   

/**
 * Helper class to show or hide all place holders.
 */
ps.util.showHidePlaceholders = function(doc, isShow)
{
   var allDivs = doc.getElementsByTagName("div");
   for(i = 0; i < allDivs.length; i++)
   {
      var className = allDivs[i].className;
      if(className == "PsAaPlaceholder")
      {
         if(isShow)
         {
            allDivs[i].style.display = "block";
         }
         else
         {
            allDivs[i].style.display = "none";
         }
      }
   }
}

/**
 * Array object that holds the server properties. 
 * Initialized in {@link #getServerProperty(String)} method.
 */
ps.util._serverProperties = null;
   

/**
 * The color rest of the page is painted with when a modal dialog is displayed.
 */
ps.util.DIALOG_BACKGROUND = "white";

/**
 * The opacity rest of the page is painted with when a modal dialog is displayed.
 */
ps.util.DIALOG_BACKGROUND_OPACITY = 0.1;

/**
 * Controls' id prefix for the sites panel.
 */
ps.util.BROWSETAB_SITES_PANEL_PREF = "ps.content.sitespanel";

/**
 * Controls' id prefix for the folders panel.
 */
ps.util.BROWSETAB_FOLDERS_PANEL_PREF = "ps.content.folderspanel";

/**
 * Controls' id prefix for the search panel.
 */
ps.util.BROWSETAB_SEARCH_PANEL_PREF = "ps.content.searchpanel";

/**
 * Constant: ContentBrowser Dialog page URL
 */
ps.util.CONTENT_BROWSE_URL = "../../ui/content/ContentBrowserDialog.jsp";

/**
 * Constant for active assembly browse mode.
 */
ps.util.BROWSE_MODE_ACTIVE_ASSEMBLY = "activeAssembly";

/**
 * Constant for active assembly browse mode.
 */
ps.util.BROWSE_MODE_ACTIVE_ASSEMBLY_TABLE_EDITOR = "activeAssemblyTable";

/**
 * Constant for rich text editor inline browse mode for templates.
 */
ps.util.BROWSE_MODE_RTE_INLINE = "rteInline";

/**
 * Constant for rich text editor inline browse mode for inline links.
 */
ps.util.BROWSE_MODE_RTE_INLINE_LINK = "rteInlineLink";

/**
 * Constant for rich text editor inline image browse mode.
 */
ps.util.BROWSE_MODE_RTE_INLINE_IMAGE = "rteInlineImage";



dojo.lang.mixin(ps, ps.util);

dojo.provide("ps.content.BrowseTabPanel");











/**
 * <p>An individual tab in the browser dialog</p>.
 * <p>Stores current path as a concatenation of site, folder names, separated
 * by '/' character. For an item this class stores path to its folder with
 * appended '|' character, and numeric item id.
 * </p>
 */
dojo.declare("ps.content.BrowseTabPanel", null,
	function(_parent){
	   dojo.lang.assert(_parent, "Parent must be specified");

      this.parent = _parent;
      this.isSearchForm = true;
      this.isSelectTemplateMode = false;
      this.lastButtonState = new dojo.collections.Dictionary();
      this.templatesPanelObj = null;     
	},
{
   /**
    * Initializes the tab.
    */
   init: function ()
   {
      dojo.event.topic.subscribe(
            this.tab.parent.domNode.id + "-selectChild", this, "_onTabSelected");
      this.tab.setUrl(this.url);

      if (this._isTabLoaded())
      {
         this._initOnLoad();
      }
      else
      {
         var _this = this;
         dojo.event.connect(this.tab, "onLoad", function()
         {
            try
            {
               _this._initOnLoad();
            }
            catch (e)
            {
               dojo.debug(e);
            }
         });
      }
   },   
   /**
    * Forces tab to relayout itself to work around broken layout when user
    * switches to a different tab not waiting when the tab is loaded completely.
    * Andriy: I saw this problem on a slow IE6.
    */
   _redoLayout: function()
   {
      var _this = this;
      dojo.lang.setTimeout(function ()
      {
         var p = _this.tab.parent;
         var w = p.width;
         w = w % 2 ? w + 1 : w - 1;
         var styleWidth = p.domNode.style.width;
         var styleHeight = p.domNode.style.height;
         p.resizeTo(w, p.height);

         // restore style, so the size won't be forced
         // and layout during resizing would work
         p.domNode.style.width = styleWidth;
         p.domNode.style.height = styleHeight;
      }, 1000);
   },
   
   /**
    * Returns <code>true</code> if the tab is already loaded.
    */
   _isTabLoaded: function()
   {
      return !!this._getWidgetById("okButton");
   },

   /**
    * Is called during initialization after the UI is loaded.
    */
   _initOnLoad: function ()
   {
      this.rootContentActions = this._defineRootContentActions();
      dojo.lang.assert(this._isTabLoaded(),
            "Tab " + this.prefix + " should be loaded already");

      this.parseControls();

      //this.setSearchMode(true);
      
      if (this.selectOnLoad)
      {
         // tab is already selected
         this.selectOnLoad = false;
         this._onTabSelected(this.tab);
      }
      this._redoLayout();
   },

   /**
    * Is called when a tab in the tab container is selected.
    */
   _onTabSelected: function (tab)
   {
     
      if (tab !== this.tab)
      {
         return;
      }
      this.parent.currentTab = this;

      if (!this.slotId
            || this.slotId.serialize() !== this.parent.slotId.serialize())
      {
         if (!this._isTabLoaded())
         {
            // tab is selected, but not loaded yet
            // repeat the call to this method on load
            this.selectOnLoad = true;
            return;
         }

         this.slotId = this.parent.slotId;
         if (!this.pathHistory)
         {
            this.pathHistory = this._createInitialHistory();
         }

         this._refresh();
      }
      //Force resize the dialog to avoid painting issues on some browsers (cheaper and easier!)
      ps.util.forceDialogResize(this.parent.wgtDlg, 
         this.parent.preferredWidth, 
         this.parent.preferredHeight);
      //			
   },

   /**
    * Returns <code>true</code> if the tab is already loaded.
    */
   _isTabLoaded: function()
   {
      return !!this._getWidgetById("okButton");
   },



   /**
    *  Parses all the expected controls for this tab.
    */
   parseControls: function()
   {
      //Abstract function implemented by subclass
   },
   
   /**
    * Parse the controls common to all tabs
    */ 
   _parseCommonControls: function()
   {
      this.okButton = this._getWidgetById("okButton");
      this.cancelButton = this._getWidgetById("cancelButton");
      this.mainSplitPane = this._getWidgetById("mainsplitpane");
      this.contentSplitPane = this._getWidgetById("contentsplitpane");
      this.commandPanel = this._getWidgetById("commandpanel");

      dojo.event.connect(this.okButton, "onClick", this, "_onOk");
      dojo.event.connect(this.cancelButton, "onClick", this, "_onCancel");
   },   

   /**
    * Callback function called when the OK button is clicked.
    * This will also call the parents okCallback function.
    */
   _onOk: function()
   {
      if(this.isSelectTemplateMode)
      {
         this._handleTemplateOk();
         return true;
      }
      var row = this.contentTable.getSelectedData();
      var a = this._getRowA(row);
      a.onclick();
   },

   
   /**
    * Adds a column to the content table.
    * @param {String} field the column field name.
    * Not <code>null</code>.
    * @param {String} label the column label.
    * Not <code>null</code>.
    */
   _addContentTableColumn: function (field, label)
   {
      dojo.lang.assertType(field, String);
      dojo.lang.assertType(label, String);
      
      var col = this._cloneColumn(this.contentTableColumns[0]);
      col.field = field;
      col.label = label;
      this.contentTable.columns.push(col);
   },
   
   /**
    * Returns site name selected in UI, if available and requested by the user.
    * Otherwise returns <code>null</code>.
    */
   _getUISiteName: function ()
   {
      return null;
   },
   
   /**
    * Returns folder path selected in UI, if available and requested by the user.
    * Otherwise returns <code>null</code>.
    */
   _getUIFolderPath: function ()
   {
      return null;
   },
   
   /**
    * Same as <code>dojo.byId</code>, but throws an assertion if the node
    * does not exist.
    */
   _mustById: function (id)
   {
      var node = dojo.byId(id);
      dojo.lang.assert(node, "Could not find node " + id);
      return node;
   },
   
   _handleTemplateOk: function()
   {
      var snippetId = this.templatesPanelObj.getSelectedId();
      var response = ps.io.Actions.resolveSiteFolders(
	      this._getUISiteName(), this._getUIFolderPath());
	   if(response.isSuccess())
	   {
	       var temp = response.getValue();
		    if(temp.sys_folderid != undefined)
		    {
             snippetId.setFolderId(temp.sys_folderid);
		    }
		    if(temp.sys_siteid != undefined)
		    {
             snippetId.setSiteId(temp.sys_siteid);
		    }		 
	  }
	  else
	  {
         ps.io.Actions.maybeReportActionError(response);
	  }

      var slotId = this.parent.slotId;
      if(this.parent.mode == ps.util.BROWSE_MODE_ACTIVE_ASSEMBLY ||
		     this.parent.mode == ps.util.BROWSE_MODE_ACTIVE_ASSEMBLY_TABLE_EDITOR)
	   { 
         var response = ps.io.Actions.addSnippet(
               snippetId, slotId, this._getUIFolderPath(), this._getUISiteName());
         if(response.isSuccess())
         {
            this.parent.okCallback(slotId) ;
            if(this.parent.mode == ps.util.BROWSE_MODE_ACTIVE_ASSEMBLY_TABLE_EDITOR)
            {
               //no-op
            }
            else
            {
               var newRelId = response.getValue();
               var refRelId = this.parent.refRelId;
               var position = this.parent.position;
               ps.aa.controller.repositionSnippet(slotId,refRelId,newRelId,position);
               //Reset the reference to new rel id and position to "after"
               this.parent.refRelId = newRelId;
               this.parent.position = "after";
            }
            
            window.open('','_self').close();
         }
         else
         {
            ps.io.Actions.maybeReportActionError(response);
         }
      }
      else
      {
         this.parent.okCallback(snippetId);
      }
      this._maybeRestoreButtonState("okButton");
      this.cancelButton.setCaption(this.CLOSE_LABEL);
      this.setSelectTemplateMode(false);
   },
   
   _handleTemplateCancel: function()
   {
      if(!this.isSelectTemplateMode)
         return true;
      this._maybeRestoreButtonState("okButton");
      this.cancelButton.setCaption(this.CLOSE_LABEL);
      this.setSelectTemplateMode(false);
      return false;
   },
   
   /**
    * Callback function called when the Cancel button is clicked.
    * This will also call the parents cancelCallback function and
    * close the dialog.
    */
   _onCancel: function()
   {      
      var shouldClose = this._handleTemplateCancel();
      if(shouldClose)
    	  window.open('','_self').close();
   },
   
   /**
    * Sets the button state and records current state values.
    * @param {string} name the name key for this button as will be stored
    * in the last button state variable.
    * @param {dojo.widgt.Button} button the button to be modified.
    * @param {string} caption the button caption to be set.
    * @param {boolean} disabled the flag indicating if the button
    *  should be disabled.
    */
   _setButtonRememberState: function(name, button, caption, disabled)
   {
      var obj = new Object();
      obj.disabled = button.disabled;
      obj.ref = button;
      obj.caption = button.caption;
      this._maybeSetButton(button, caption, disabled);
      this.lastButtonState.add(name, obj);      
   },
   
   /**
    * Sets the button's caption or disabled state only if different
    * from what it is currently set to.
    * @param {dojo.widget.Button} button the button to be modified.
    * @param {string} caption the button caption to be set.
    * @param {boolean} disabled the flag indicating if the button
    *  should be disabled.
    */
   _maybeSetButton: function(button, caption, disabled)
   {
      if(disabled != null && button.disabled != disabled)
      {
         button.setDisabled(disabled);

         // a workaround for a problem when a button is disabled multiple times,
         // it should be enabled multiple times,
         // to completely switch to the "enabled" appearance
         if (!disabled)
         {
            button.setDisabled(disabled);
         }
      }
      if(caption != null && button.caption != caption)
         button.setCaption(caption);   
   },
   
   /**
    * Restores the button state if needed.
    */
   _maybeRestoreButtonState: function(name)
   {
      if(this.lastButtonState.containsKey(name))
      {
         var obj = this.lastButtonState.item(name);
         this._maybeSetButton(obj.ref, obj.caption, obj.disabled);
         this.lastButtonState.remove(name);
      }   
   
   },

   /**
    * Callback function called when the filter text changes.
    */
   _onFilterTyped: function ()
   {
      var _this = this;
      
      // to eliminate too frequent refresh
      if (this.lastFilterValue === this.filterText.value)
      {
         return;
      }
      this.lastFilterValue = this.filterText.value;
      
      // delay the execution until this.filterText.value is updated
      dojo.lang.setTimeout(function ()
      {
         _this._filterContentTable();
      }, 10);
   },
   
   /**
    * Filters contentTable rows using the value of the filterText field
    * as a filter.
    */
   _filterContentTable: function ()
   {
      var _this = this;
      this.contentTable.setFilter(psxGetLocalMessage("javascript.ps.content.browse@Name"), function (value)
      {
         var str = value.toLowerCase();
         var filter = _this.filterText.value.toLowerCase();
         return dojo.string.isBlank(filter)
               || _this._getCellText(str).indexOf(filter) !== -1;
      });
   },
   
   /**
    * Callback function called when the content table selection changes.
    */
   _onContentTableSelect: function (obj)
   {
      this._maybeRestoreButtonState("okButton");
      this._maybeSetButton(this.okButton, this.okButton.caption, 
         !this.contentTable.getSelectedData());
   },

   /**
    * Callback function called when a selection changes on the content type list.
    */
   _onCTypeChanged: function ()
   {
      this._refresh();
   },
   
   /**
    * Callback function called when the content type dropdown gets focus.
    */
   _onCTypeFocused: function ()
   {
      var list = this.getContentTypeList();
      if (!list.slotId
            || list.slotId.serialize() != this.slotId.serialize())
      {
         list.slotId = this.slotId;

         var response = ps.io.Actions.getAllowedContentTypeForSlot(this.slotId);
         ps.io.Actions.maybeReportActionError(response);
         var typesNum = 0;
         if (response.isSuccess())
         {
            var marker = list.options[0].nextSibling;
            var types = response.getValue();
            typesNum = types.length;

            // add the 
            for (i = 0; i < typesNum; i++)
            {
               var option = document.createElement('option');
               option.appendChild(document.createTextNode(types[i].name));
               option.value = types[i].contenttypeid;
               list.insertBefore(option, marker);
            }

            // delete the previous options, leave the first "All" entry.
            // adding/removing is done in this complex way to prevent the dropdown
            // from resizing all the time
            list.options.length = 1 + typesNum;
         }
      }
   },

   /**
    * Is called when the path of the tab is changed.
    * Updates state of UI conrols based on the current data.
    */
   _onPathChanged: function ()
   {
      this._setLastStoredPath(this.getFolder());
      this.pathText.value = this.getFolder();

      this._setButtonDisabledSpecial(this.backButton, !this.pathHistory.canGoBack());
      this._setButtonDisabledSpecial(this.upButton, this.getPath() === this.ROOT);

      this._maybeRestoreButtonState("okButton");
      this._maybeSetButton(this.okButton, 
         psxGetLocalMessage("javascript.ps.content.browse@Open"), true);
      
      this._scrollPathText();
      this.filterText.value = "";
   },
   
   /**
    * Special function to switch the disabled image for the address
    * bar buttons.
    * @param {dojo.widget.Button} button the button to be disabled.
    * @param {boolean} disabled <code>true</code> if disabled.
    */
   _setButtonDisabledSpecial: function(button, disabled)
   {
      if (button.disabled == disabled)
         return;
      button.setDisabled(disabled);

      // replace button image
      var node = button.containerNode ? button.containerNode : button.domNode;
      var img = node.getElementsByTagName('img')[0];
      dojo.lang.assert(img, "Expected to find an image in a button content.");
      if (disabled)
      {
         var from = /16\.gif/;
         var to = "_disabled16.gif";
      }
      else
      {
         var from = /\_disabled16\.gif/;
         var to = "16.gif";
      }
      img.src = img.src.replace(from, to);
   },
   
   /**
    * Scrolls path field text, so it shows the last portion of the text.
    * There is no cross-browser way to do that.
    * Had to resort to browser-specific hacks
    * Looks like DOM 3 will provide common key event handling API.
    */
   _scrollPathText: function ()
   {
      // move cursor to the end of the field
      try
      {
         this._setCaretToEnd(this.pathText);
      }
      catch (ignore)
      {
         // for some reason switching back to a tab on Firefox 2.0
         // causes an exception here
      }
      
      if (this.pathText.dispatchEvent)
      {
         try
         {
            // add a dummy space character to make the field scroll
            var e = document.createEvent("KeyboardEvent");
            e.initKeyEvent("keypress", true, true, window,
                  false, false, false, false, 32, 32);
            this.pathText.dispatchEvent(e);

            // remove it with backspace
            var e = document.createEvent("KeyboardEvent");
            e.initKeyEvent("keypress", true, true, window,
                  false, false, false, false, 8, 0);
           this.pathText.dispatchEvent(e);
         }
         catch(ignore){}
      }
      else
      {
         // For some browsers (e.g.) IE just setting caret scrolls the field.
         // Just ignore for other browsers, such as Safari, Konqueror,
         // because we can't do anything for them.
      }
   },
   
  /**
    * Switches the tab to the new path.
    * Refreshes the tab content for the new path.
    * @param {String} path the path to switch to.
    * Not <code>null</code>. 
    */
   _goTo: function (path, row)
   {
      dojo.lang.assertType(path, String);
      var _this = this;

      function maybeSetContent(response)
      {
         if (response.isSuccess())
         {
            _this.pathHistory.add(path);
            _this.setContent(response.getValue());
         }
      }

      // strip last "/"
      var last = path.length - 1;
      if (last !== 0 && path.charAt(last) === "/")
      {
         path = path.substring(0, path.length - 1);
      }

      if (path === this.ROOT)
      {
         var action = this.rootContentActions[this.prefix];
         dojo.lang.assert(action,
              "Root content action for " + this.prefix + " should be specified");
         var response = action();
         maybeSetContent(response);
      }
      else if (this.isItemPath(path))
      {
         // generate a snippet id from the slot id
         var snippetId = this.parent.slotId.clone();
         var cid = this.parseContentIdFromPath(path);
         snippetId.setContentId(cid);
         snippetId.setSnippetNode();

         this.templatesPanelObj = this._loadTemplatesPanel(snippetId);
         if (row)
         {
            this.templatesPanelObj.siteName = row.Site;
            this.templatesPanelObj.folderPath = row.Folder;
         }
         this.setSelectTemplateMode(true);
         this._setButtonRememberState("okButton", this.okButton, 
            psxGetLocalMessage("javascript.ps.content.browse@Select"), false);
         this.cancelButton.setCaption(psxGetLocalMessage("javascript.ps.content.browse@Back"));
        			
			// See _handleTemplateOk as this is the callback that
         // will handle the work after template selection.
         return;
      }
      else // a folder path
      {
         var response = this._getFolderChildren(path);
         maybeSetContent(response);
      }
      
      dojo.lang.assert(response, "Response should be defined");
      ps.io.Actions.maybeReportActionError(response);
      response.isSuccess() && this._onPathChanged();
   },
   
   /**
    * Creates a copy of a FilteringTable.columns data.
    * @param {Array} columns the array to copy.
    */
   _cloneColumns: function (columns)
   {
      dojo.lang.assertType(columns, Array);
      var newColumns = [];
      dojo.lang.forEach(columns, function(column)
      {
         newColumns.push(this._cloneColumn(column));
      }, this)
      return newColumns;
   },
   
   /**
    * Creates a copy of one FilteringTable.columns data element.
    * @param {Array} columns the array to copy.
    */
   _cloneColumn: function (column)
   {
      return dojo.lang.shallowCopy(column, false)
   },

   /**
    * Helper method to parse the content id from the
    * path string.
    * @param {string} the path string.
    */
   parseContentIdFromPath: function(path)
   {
      var temp = path.split("|");
      if(temp.length < 2)
         return "";
      return dojo.string.trim(temp[1]);   
   },

   /**
    * Refreshes the tab.
    */
   refreshBrowser: function()
   {
      this._refresh();
   },
   
   /**
    * Reloads data from the server for the current path.
    */
   _refresh: function ()
   {
      this._goTo(this.getPath());
   },

   /**
    * Makes sure the provided object is valid not-null content table row data.
    * @param row the data to check.
    */
   _assertValidRow: function (row)
   {
      // Do not validate the ID column since it can be a number (simple id for 
      // a site/folder child) or a string (complex id in case of search results)
      dojo.lang.assertType(row.Name, String);
      dojo.lang.assertType(row.Description, String);
      dojo.lang.assertType(row.Type, Number);
   },
   
   /**
    * Actions to get root content.
    */
   _defineRootContentActions: function ()
   {
      var actions = {};
      actions[ps.util.BROWSETAB_SITES_PANEL_PREF] =
            function () {return ps.io.Actions.getSites();};
      actions[ps.util.BROWSETAB_FOLDERS_PANEL_PREF] =
            function () {return ps.io.Actions.getRootFolders();};
      return actions;
   },

   /**
    * Creates history with initial record. Creates empty history if it is search
    *  tab.
    */
   _createInitialHistory: function()
   {
      if(this.isSearchTab())
      {
         return new ps.content.History("");
      }
      if (this._getLastStoredPath())
      {
         var path = this._getLastStoredPath();
      }
      else if (this.isSiteTab())
      {
         var path = this._getCurrentSitePath();
      }
      else
      {
         var path = this.ROOT;
      }

      dojo.lang.assert(path);

      // make sure the path is valid
      if (!this._isValidPath(path))
      {
         path = this.ROOT;
      }
      return new ps.content.History(path);
   },
   
   /**
    * Returns last path successfully accessed by the user, which is stored in a
    * cookie.
    */
   _getLastStoredPath: function ()
   {
      return dojo.io.cookie.getCookie(this.LAST_PATH_COOKIE);
   },

   /**
    * Stores the last visited path as a cookie.
    * @param {String} path the last successfully visited path to store.
    * Not <code>null</code>.
    */
   _setLastStoredPath: function (path)
   {
      dojo.lang.assertType(path, String);
      var daysStoreCookie = 100;
      dojo.io.cookie.setCookie(this.LAST_PATH_COOKIE, path, daysStoreCookie);
   },
   
   /**
    * Returns <code>true</code> if the provided path is valid.
    */
   _isValidPath: function (path)
   {
      return path === this.ROOT || this._getFolderChildren(path).isSuccess();
   },

   /**
    * Returns path for the current site if in Active Assembly mode or the
    * root in any other mode.
    * If has problems to determine the result reports the problems to the user
    * and returns the root directory. 
    */
   _getCurrentSitePath: function ()
   {
      if(this.mode != ps.util.BROWSE_MODE_ACTIVE_ASSEMBLY)
   	  return this.ROOT;

      var siteId = ps.aa.controller.pageId.getSiteId();
      dojo.lang.assert(dojo.lang.isNumeric(siteId), "Can't get site id");

      var response = ps.io.Actions.getSites();
      ps.io.Actions.maybeReportActionError(response);
      if (response.isSuccess())
      {
         var sites = response.getValue();
         var siteName;
         dojo.lang.forEach(sites, function (row)
         {
            if (row.Id == siteId)
            {
               siteName = row.Name;
            }
         }, this);
         dojo.lang.assert(siteName, "Site name was not found");
         var path = this.ROOT + this._getCellText(siteName);
      }
      else
      {
         var path = this.ROOT;
      }
      dojo.lang.assert(path, "path must be defined at this point");
      return path;
   },

   /**
    * Returns root children.
    * @param {String} path the folder to get children for.
    * Not <code>null</code>.
    * @return a response from {@link ps.io.Actions#getFolderChildren}.
    */
   _getFolderChildren: function (path)
   {
      dojo.lang.assertType(path, String);
      return ps.io.Actions.getFolderChildren(
            path, this._getContentType(),
            this.parent.slotId.getSlotId(),
            this.isSiteTab());
   },
   
   /**
    * Sets the caret to different positions and to set the selection should.
    * Uses browser-specific code.
    * Borrowed from http://www.faqts.com/knowledge_base/view.phtml/aid/13562.
    */
   _setSelectionRange: function (input, selectionStart, selectionEnd)
   {
      if (input.setSelectionRange)        // Mozilla
      {
         input.setSelectionRange(selectionStart, selectionEnd);
      }
      else if (input.createTextRange)     // IE
      {
         var range = input.createTextRange();
         range.collapse(true);
         range.moveEnd('character', selectionEnd);
         range.moveStart('character', selectionStart);
         range.select();
      }
   },

   /**
    * Sets the caret to beginning of the input.
    * Borrowed from http://www.faqts.com/knowledge_base/view.phtml/aid/13562.
    */
   _setCaretToEnd: function (input)
   {
      this._setSelectionRange(input, input.value.length, input.value.length);
   },
   
   /**
    * Replaces content of the content area.
    * @param {Array} rows an array of JSON objects to initializes the content
    * table with.
    * Not <code>null</code>, can be empty.
    */
   setContent: function (rows)
   {
      dojo.lang.assertType(rows, Array);
      rows.length > 0 && this._assertValidRow(rows[0]);
      
      this._setNameImages(rows);
      this.contentTable.store.setData(rows);
      this._addContentClickHandlers(rows);
   },

   /**
    * Adds image to the name HTML to indicate kind of table content entry.
    * @param {Array} rows an array of JSON objects the content table
    * will be initialized with.
    * Not <code>null</code>, can be empty.
    */
   _setNameImages: function (rows)
   {
      dojo.lang.assertType(rows, Array);
      rows.length > 0 && this._assertValidRow(rows[0]);

      var imgPref = '<img style="vertical-align: middle" src="';
      var folderImg = imgPref + this.parent.rxroot + '/sys_resources/images/folder.gif"/>&nbsp;';
      var itemImg = imgPref + this.parent.rxroot + '/sys_resources/images/item.gif"/>&nbsp;';
      var _this = this;
      dojo.lang.forEach(rows, function (row)
      {
         var img = row.Type === _this.ITEM_TYPE
               ? itemImg : folderImg;
         if(row.IconPath && row.IconPath.length>0)
         {
           var iPath = row.IconPath;
           if(iPath.substring(0, 3) == "../")
              iPath = "/Rhythmyx" + iPath.substring(2);
           img = imgPref + iPath + '"/>&nbsp;';
         }
         row.Name = img + row.Name;
      });
   },

   /**
    * Adds onclick handles on the names hyperlinks,
    * which open the content table entry.
    * @param {Array} rows an array of JSON objects the content table is
    * initialized table with.
    * Not <code>null</code>, can be empty.
    */
   _addContentClickHandlers: function (rows)
   {
      dojo.lang.assertType(rows, Array);
      rows.length > 0 && this._assertValidRow(rows[0]);

      var path = this.getPath();
      if (path !== this.ROOT)
      {
         path += "/";
      }
      
      // remember "checked" state now, because in IE the checkboxes checked
      // state is lost and it always reports them as unchecked later
      this.includeSitesChecked =
            this.includeSitesCheckbox && this.includeSitesCheckbox.checked;
      this.includeFoldersChecked =
            this.includeFoldersCheckbox && this.includeFoldersCheckbox.checked;

      dojo.lang.forEach(rows, function (row)
      {
         var a = this._getRowA(row);
         if (row.Type === this.ITEM_TYPE)
         {
            var idComponents = (row.Id + "").split(":")
            var newPath = path + this.ITEM_SEPARATOR + idComponents[0];
         }
         else
         {
            var newPath = path + dojo.html.renderedTextContent(a);
         }
         dojo.lang.assert(newPath);
         var _this = this;
         var wrapper = {
            myClickFunc: function(){_this._goTo(newPath, row);} 
         };
         dojo.event.connect(a, "onclick", wrapper, "myClickFunc");
      }, this);
   },

   /**
    * Returns an <a /> dom node from the table for the provided data row
    * Throws an assertion error if such node does not exist.
    */
   _getRowA: function (row)
   {
      this._assertValidRow(row);

      var tr = this.contentTable.getRow(row);
      dojo.lang.assert(tr, "Table row should exist for this data");
      var nameTd = tr.getElementsByTagName("td")[0];
      dojo.lang.assert(nameTd, "Name cell should exist");
      var a = nameTd.getElementsByTagName("a")[0];
      dojo.lang.assert(a, "Name should be a hyperlink to open it");
      return a;
   },
   
   /**
    * Handles setting the appropriate panels visible for
    * select template mode.
    * @param {boolean} isTemplateMode whether the panel should be shown in a
    * template mode.
    */
   setSelectTemplateMode: function(isTemplateMode)
   {
      dojo.lang.assertType(isTemplateMode, Boolean);

      this.isSelectTemplateMode = isTemplateMode;
      if (isTemplateMode)
      {
         this._maybeCreateTemplatesPanel();
         this._setSplitPaneChildVisible(
            this.mainSplitPane, this.templatesPanel, true);
         if (!this.isFolderTab())
         {
            this._maybeCreateTemplatesSiteFolderParam();
            this._setSplitPaneChildVisible(
                  this.mainSplitPane, this.templatesSiteFolderParam, true);
         }
         // We first remove the command panel then add it
         // so it appears in the correct order.   
         this._setSplitPaneChildVisible(
            this.mainSplitPane, this.commandPanel, false);
         this._setSplitPaneChildVisible(
            this.mainSplitPane, this.commandPanel, true); 
         if(this.isSearchTab())
         {
            this._setSplitPaneChildVisible(
               this.mainSplitPane, this.contentSplitPane, false);
            this.searchBackButton.hide();   
         }
         else
         {
            this._setSplitPaneChildVisible(
               this.mainSplitPane, this.addressbarPanel, false);
            this._setSplitPaneChildVisible(
               this.mainSplitPane, this.clientPanel, false);
         }
      }
      else // !isTemplateMode
      {
         if(this.isSearchTab())
         {
            this._setSplitPaneChildVisible(
               this.mainSplitPane, this.contentSplitPane, true);
            if(!this.isSearchForm)
               this.searchBackButton.show();
         }
         else
         {
            this._setSplitPaneChildVisible(
               this.mainSplitPane, this.addressbarPanel, true);
            this._setSplitPaneChildVisible(
               this.mainSplitPane, this.clientPanel, true);
         }         
         // We first remove the command panel then add it
         // so it appears in the correct order.   
         this._setSplitPaneChildVisible(
            this.mainSplitPane, this.commandPanel, false);
         this._setSplitPaneChildVisible(
            this.mainSplitPane, this.commandPanel, true);    
         if (this.templatesPanel)
         {
            this._setSplitPaneChildVisible(
               this.mainSplitPane, this.templatesPanel, false);
         }
         if (this.templatesSiteFolderParam)
         {
            this._setSplitPaneChildVisible(
                  this.mainSplitPane, this.templatesSiteFolderParam, false);
         }
      }
      ps.util.forceDialogResize(this.parent.wgtDlg,
       this.parent.preferredWidth, this.parent.preferredHeight);      
   },
	
	 /**
    * Creates templatesPanel if it is not created yet.
    */
   _maybeCreateTemplatesPanel: function ()
   {
      if (this.templatesPanel)
      {
         // already created
         return;
      }
      var div = document.createElement('div');
      div.style.position = "absolute";
      div.style.padding = "10px";
      document.body.appendChild(div);

      var params = {
            id: this.prefix + ".templatespanel",
            sizeMin: 200,
            sizeShare: 95,
            executeScripts: true,
            cacheContent: false
      };

      this.templatesPanel =
            dojo.widget.createWidget("ContentPane", params, div);
      new ps.widget.ContentPaneProgress(this.templatesPanel);

   },

   /**
    * Creates templatesSiteFolderParam panel if it is not created yet.
    */
   _maybeCreateTemplatesSiteFolderParam: function ()
   {
      if (this.templatesSiteFolderParam)
      {
         // already created
         return;
      }
      var div = document.createElement('div');
      div.style.position = "absolute";
      div.style.padding = "10px";
      document.body.appendChild(div);

      var params = {
            id: this.prefix + ".templatessitefolderparam",
            sizeMin: 30,
            sizeShare: 10,
            executeScripts: true,
            cacheContent: false
      };

      this.templatesSiteFolderParam =
            dojo.widget.createWidget("ContentPane", params, div);
      new ps.widget.ContentPaneProgress(this.templatesSiteFolderParam);
   },
	
	/**
    * Loads the template select panel based on the passed in
    * slot object id.
    * @param {ps.aa.ObjectId} snippetId the snippet id to select a template for.
    * @return the template panel, never <code>null</code>.
    */
   _loadTemplatesPanel: function (snippetId)
   {
      dojo.lang.assertType(snippetId, ps.aa.ObjectId);

      if (!this.isFolderTab())
      {
         this._maybeCreateTemplatesSiteFolderParam();
         var newUrl = __rxroot + "/ui/content/sitefolderparam.jsp"
               + "?idPrefix=" + escape("ps.select.templates.")
               + "&includeSitesLabel=" + escape(
                  psxGetLocalMessage("javascript.ps.content.browse@Include_Site"))
               + "&includeFoldersLabel=" + escape(
                  psxGetLocalMessage("javascript.ps.content.browse@Include_Folder"));
         this.templatesSiteFolderParam.setUrl(newUrl);
         dojo.event.connect(this.templatesSiteFolderParam, "onLoad", function()
         {
            _this._onTemplatesSiteFolderParamLoaded();
         });
      }

      this._maybeCreateTemplatesPanel();
      var newUrl = __rxroot + "/ui/content/selecttemplate.jsp" + 
         "?noButtons=false&objectId=" + escape(snippetId.serialize());
      this.templatesPanel.setUrl(newUrl);
      var panel = new ps.content.SelectTemplates();
      var _this = this;

      dojo.event.connect(this.templatesPanel, "onLoad", function()
      {
         panel.initAsPanel(_this.parent.mode);
      });
      return panel;
   },

   /**
    * Sets the child of a split pane visible or invisible.
    * @param {dojo.widget} the split pane whose child will be
    * set.
    * @param {dojo.widget} the child to be made visible or not.
    * @param {boolean} isVisible flag indicating that the
    * filter panel should or should not be visible.
    */    
   _setSplitPaneChildVisible: function (splitpane, child, isVisible)
   {
      if(!child)
         return;

      if(isVisible)
      {
         var alreadyHasChild = false;
         
         for(var x = 0; x < splitpane.children.length; x++)
         {
            if(splitpane.children[x] === child)
            {
               alreadyHasChild = true;
               break;
            }
         }
         if(!alreadyHasChild)
            splitpane.addChild(child);
      }
      else
      {
         splitpane.removeChild(child);
      }
   },
      
   /**
    * Is called when templates selection panel is loaded.
    */
   _onTemplatesSiteFolderParamLoaded: function ()
   {
         //Set the default values for include site id and folder id check boxes
         var inclSitesFlag = ps.util.getServerProperty("slotContentIncludeSiteDefaultValue","");
         var inclFoldersFlag = ps.util.getServerProperty("slotContentIncludeFolderDefaultValue","");
         var includeSites = this._mustById(
               "ps.select.templates.includeSitesCheckbox");
         includeSites.checked = inclSitesFlag=="true"?true:false;
         includeSites.disabled = false;

         var includeFolders = this._mustById(
               "ps.select.templates.includeFoldersCheckbox");
         includeFolders.checked = inclFoldersFlag=="true"?true:false;
         includeFolders.disabled = false;

   },

   /**
    * Finds DOM element by id.
    * Returns <code>null</null> if the element can't be found.
    * @param {String} id the part of id, unqualified by the tab prefix,
    * to search for. The method fully qualifies it.
    * Not <code>null</code>.
    */
   _getElemById: function (id)
   {
      dojo.lang.assertType(id, String);
      return dojo.byId(this._getQId(id));
   },

   /**
    * Finds DOJO widget by id.
    * Returns <code>null</null> if the widget can't be found.
    * @param {String} id the part of id, unqualified by the tab prefix,
    * to search for. The method fully qualifies it.
    * Not <code>null</code>.
    */
   _getWidgetById: function (id)
   {
      dojo.lang.assertType(id, String);
      return dojo.widget.byId(this._getQId(id));
   },

   /**
    * Helper method to return the fully qualified id for
    * this tab.
    * @param {string} name for the control.
    */
   _getQId: function (s)
   {
      return this.prefix + "." + s;
   },
   
   /**
    * Returns currently selected content type.
    * If no content type is selected by user, returns "-1".
    */
   _getContentType: function ()
   {
      var ctype = this.getContentTypeList().value;
      if (ctype)
      {
         return dojo.string.trim(ctype);
      }
      else
      {
         return "-1";
      }
   },
   
   /**
    * The content type list. Should be used instead of direct access to the
    * content list field, because the getter provides additional assertions.
    */
   getContentTypeList: function ()
   {
      dojo.lang.assert(!this.isSearchTab());
      return this._ctypeList;
   },
   
   /**
    * Returns <code>true</code> if this is a site tab.
    */
   isSiteTab: function ()
   {
      return this.prefix === ps.util.BROWSETAB_SITES_PANEL_PREF;
   },

   /**
    * Returns <code>true</code> if this is a search tab.
    */
   isSearchTab: function ()
   {
      return this.prefix === ps.util.BROWSETAB_SEARCH_PANEL_PREF;
   },
   
   /**
    * Returns <code>true</code> if this is a search tab.
    */
   isFolderTab: function ()
   {
      return this.prefix === ps.util.BROWSETAB_FOLDERS_PANEL_PREF;
   },
   /**
    * Provides complete current path.
    */
   getPath: function ()
   {
      return this.pathHistory.getCurrent();
   },
   
   /**
    * Returns </code>true</code> if the current path points to an item.
    * @param {String} path the path to check.
    * If </code>null</code>, checks the current path.
    */
   isItemPath:  function (path)
   {
      path && dojo.lang.assertType(path, String);
      if (!path)
      {
         path = this.getPath();
      }
      return /\|\d+$/.test(path);
   },
   
   /**
    * Returns a parent folder.
    * @param {String} path the path to get current folder for.
    * If </code>null</code>, returns a folder for processes the current path.
    */
   getParentFolder: function (path)
   {
      path && dojo.lang.assertType(path, String);
      if (!path)
      {
         path = this.getPath();
      }
      dojo.lang.assert(path !== this.ROOT,
            "Tried to get parent folder for a root directory");
      var separator = this.isItemPath(path) ? this.ITEM_SEPARATOR : "/";
      var lastIdx = path.lastIndexOf(separator);
      var path = path.substring(0, lastIdx);
      if (path === "")
      {
         path = this.ROOT;
      }
      return path;
   },
   
   /**
    * Provides folder part of the current path.
    * @param {String} path the path to get folder for.
    * If </code>null</code>, returns a folder for processes the current path.
    */
   getFolder: function (path)
   {
      path && dojo.lang.assertType(path, String);
      if (!path)
      {
         path = this.getPath();
      }
      return this.isItemPath(path) ? this.getParentFolder(path) : path;
   },

   /**
    * Returns a text of a content table cell.
    * @param {String} html the cell html.
    */
   _getCellText: function (html)
   {
      var beforeStr = '<a href="#">';
      var from = html.lastIndexOf(beforeStr) + beforeStr.length;
      var to = html.lastIndexOf("</a>")
      dojo.lang.assert(from > 0 && to > 0 && from <= to,
            "Unexpected html of the string: " + html);
      return html.substring(from, to);
   },

   ROOT: "/",

   /**
    * The item id separator in a path.
    */
   ITEM_SEPARATOR: "|",

   /**
    * Cookie name to store last path successfully accessed by the user.
    */
   LAST_PATH_COOKIE: this.parent.mode + "." + this.prefix + ".lastPath",  

   /**
    * A type used for row data indicating an item.
    */
   ITEM_TYPE: 1,

   /**
    * A type used for row data indicating a folder.
    */
   FOLDER_TYPE: 2,

   /**
    * A type used for row data indicating a site.
    */
   SITE_TYPE: 9,

   /**
    * Constant for the Cancel button.
    */
   CANCEL_LABEL: psxGetLocalMessage("javascript.ps.content.browse@Cancel"),

   /**
    * Constant for the Close button.
    */
   CLOSE_LABEL: psxGetLocalMessage("javascript.ps.content.browse@Close"),

   /**
    * Constant for the Ok button.
    */
   OK_LABEL: psxGetLocalMessage("javascript.ps.content.browse@Ok")
});


dojo.provide("ps.content.FolderSitesBaseTabPanel");











dojo.declare("ps.content.FolderSitesBaseTabPanel", ps.content.BrowseTabPanel,
	function(_parent){
	   dojo.lang.assert(_parent, "Parent must be specified");

      this.parent = _parent;      
	},
{
   /**
    * Parses the address bar panel controls and add appropriate events.
    */
   _parseAddressbarPanelControls: function()
   {
      this.pathText = this._getElemById("pathText");
      this.refreshButton = this._getWidgetById("refreshButton");
      this.backButton = this._getWidgetById("backButton");
      this.upButton = this._getWidgetById("upButton");
      this.clientPanel = this._getWidgetById("clientpanel");
      this.addressbarPanel = this._getWidgetById("addressbarpanel");

      dojo.event.connect(this.pathText, "onchange", this, "_onPathTextChanged");
      dojo.event.connect(this.refreshButton, "onClick", this, "_onRefresh");
      dojo.event.connect(this.backButton, "onClick", this, "_onBack");
      dojo.event.connect(this.upButton, "onClick", this, "_onUp");      
   },
	
	/**
    *  Parses all the expected controls for this tab.
    */
   parseControls: function()
   {
      this._parseCommonControls();
      this._parseFilterPanelControls();
      this.contentTable = this._getWidgetById("FilteringTable");
      // initial conent table columns
      this.contentTableColumns = this._cloneColumns(this.contentTable.columns);
      this._parseAddressbarPanelControls();
      dojo.event.connect(
            this.contentTable, "onSelect", this, "_onContentTableSelect");      
   },
	
	/**
    * Parses the filter panel controls and add appropriate events.
    */
   _parseFilterPanelControls: function()
   {
      this.filterPanel = this._getWidgetById("filterpanel");
      this.filteringTablePanel = this._getWidgetById("tablepanel");
      this.filteringTable = this._getWidgetById("FilteringTable");
      this.filterText = this._getElemById("filterText");

      dojo.event.connect(this.filterText, "onkeyup", this, "_onFilterTyped");

      this._ctypeList = this._getElemById("ctypeList");
      dojo.event.connect(
         this.getContentTypeList(), "onchange", this, "_onCTypeChanged");
      dojo.event.connectBefore(
         this.getContentTypeList(), "onfocus", this, "_onCTypeFocused");
      
   },
	
   /**
    * Callback function called when the path text changes.
    */
   _onPathTextChanged: function()
   {
      this._goTo(this.pathText.value);
   },
   
   /**
    * Callback function called when the "Refresh" button is clicked.
    */
   _onRefresh: function()
   {
      this._refresh();
   },
   
   /**
    * Callback function called when the "Back" button is clicked.
    */
   _onBack: function()
   {
      this.pathHistory.back();
      this._refresh();
   },
   
   /**
    * Callback function called when the "Up" button is clicked.
    */
   _onUp: function()
   {
      this._goTo(this.getParentFolder());
   }
});

dojo.provide("ps.content.SitesTabPanel");












dojo.declare("ps.content.SitesTabPanel", ps.content.FolderSitesBaseTabPanel,
	function(_parent){
	   dojo.lang.assert(_parent, "Parent must be specified");

      this.prefix = ps.util.BROWSETAB_SITES_PANEL_PREF;
      this.parent = _parent;      
	},
{
   init: function()
   {
      this.tabId = this.prefix + ".tab";
      this.tab = dojo.widget.byId(this.tabId);
      dojo.lang.assert(this.tab, "Tab for " + this.prefix + " should exist");
      this.url = this.parent.rxroot + "/ui/content/sitesfolderpanel.jsp?mode=sites";
      ps.content.SitesTabPanel.superclass.init.apply(this);
   },
	
	/**
    * Returns site name selected in UI, if available and requested by the user.
    * Otherwise returns <code>null</code>.
    */
   _getUISiteName: function ()
   {      
      var id = "ps.select.templates.includeSitesCheckbox";
      if (this._mustById(id).checked)
      {
         var parts = dojo.string.splitEscaped(this.getFolder(), "/");
         parts = dojo.lang.filter(parts, function (part)
         {
            return part.length > 0;
         }, this);
         return parts[0];
      }
      else
      {
         return null;
      }      
   },
   
   /**
    * Returns folder path selected in UI, if available and requested by the user.
    * Otherwise returns <code>null</code>.
    */
   _getUIFolderPath: function ()
   {
      var id = "ps.select.templates.includeFoldersCheckbox";
      return this._mustById(id).checked ? this.getFolder() : null;      
   }

});

dojo.provide("ps.content.FoldersTabPanel");











dojo.declare("ps.content.FoldersTabPanel", ps.content.FolderSitesBaseTabPanel,
	function(_parent){
	   dojo.lang.assert(_parent, "Parent must be specified");

      this.prefix = ps.util.BROWSETAB_FOLDERS_PANEL_PREF;
      this.parent = _parent;      
	},
{
   init: function()
   {
      this.tabId = this.prefix + ".tab";
      this.tab = dojo.widget.byId(this.tabId);
      dojo.lang.assert(this.tab, "Tab for " + this.prefix + " should exist");
      this.url = this.parent.rxroot + "/ui/content/sitesfolderpanel.jsp?mode=folders";
      ps.content.FoldersTabPanel.superclass.init.apply(this);
   },
	
	/**
    * Is called when templates selection panel is loaded.
    */
   _onTemplatesSiteFolderParamLoaded: function ()
   {
      dojo.lang.assert(false,
            "Templates site folder params pane should not be loaded "
            + "on the folders tab");
   }

});

dojo.provide("ps.content.SearchTabPanel");











dojo.declare("ps.content.SearchTabPanel", ps.content.BrowseTabPanel,
	function(_parent){
	   dojo.lang.assert(_parent, "Parent must be specified");

      this.prefix = ps.util.BROWSETAB_SEARCH_PANEL_PREF;
      this.parent = _parent; 		
      this.searchScriptElem = null;		
      this.isSearchSimple = false;        
	},
{
   init: function()
   {
      this.tabId = this.prefix + ".tab";
      this.tab = dojo.widget.byId(this.tabId);
      dojo.lang.assert(this.tab, "Tab for " + this.prefix + " should exist");
      this.url = this.parent.rxroot + "/ui/content/searchpanel.jsp";
      ps.content.SearchTabPanel.superclass.init.apply(this);
   },

   /**
    * Handles the various things needed for each search mode view
    */
   setSearchMode: function(isForm)
   {
      // Return if not the search tab
      if (!this.isSearchTab())
         return;
      this.isSearchForm = isForm;

     if (this.isSearchForm)
      {
         this._setSplitPaneChildVisible(this.contentSplitPane, this.searchformPanel, true);
         // We first remove the filter panel then add it
         // so it appears in the correct order. 
         this._setSplitPaneChildVisible(this.contentSplitPane, this.filterPanel, false);
         this._setSplitPaneChildVisible(this.contentSplitPane, this.filterPanel, true);
         this._setSplitPaneChildVisible(this.contentSplitPane, this.filteringTablePanel, false);

         dojo.html.hide(this._getQId("nameAndCtypeFilterDiv"));
         dojo.html.show(this._getQId("siteAndFolderFilterDiv"));
         this.searchBackButton.hide();
         this._maybeSetButton(this.okButton, 
            psxGetLocalMessage("javascript.ps.content.browse@Search"), false);
      }
      else
      {
         this._setSplitPaneChildVisible(this.contentSplitPane, this.filteringTablePanel, true);
         // We first remove the filter panel then add it
         // so it appears in the correct order. 
         this._setSplitPaneChildVisible(this.contentSplitPane, this.filterPanel, false);
         this._setSplitPaneChildVisible(this.contentSplitPane, this.filterPanel, true);
         this._setSplitPaneChildVisible(this.contentSplitPane, this.searchformPanel, false);
         dojo.html.show(this._getQId("nameAndCtypeFilterDiv"));
         dojo.html.hide(this._getQId("siteAndFolderFilterDiv"));
         this.searchBackButton.show();
         this._maybeSetButton(this.okButton, 
            psxGetLocalMessage("javascript.ps.content.browse@Open"), false);
      }
   },  

   /**
    * Shows or hides the advanced search fields based on the search mode.
    */
   _showSearchFields: function()
   {
      if(this.isSearchSimple)
      {
         dojo.html.show(dojo.byId("advancedfields"));
         this.advancedButton.hide();
         this.simpleButton.show();
      }
      else
      {
         dojo.html.hide(dojo.byId("advancedfields"));
         this.advancedButton.show();
         this.simpleButton.hide();
      }
      this.isSearchSimple = !this.isSearchSimple;
      this._enableDisableSearch();
   },

   _onOk: function()
   {
      if (!this.isSearchForm || this.isSelectTemplateMode)
      {
         return ps.content.SearchTabPanel.superclass._onOk.apply(this);
      }
      else 
      var inclsites = this.includeSitesCheckbox.checked ? "yes" : "no";
      var inclfolders = this.includeFoldersCheckbox.checked ? "yes" : "no";
      var sf = document.searchQuery;
      sf.includeSites.value = inclsites;
      sf.includeFolders.value = inclfolders;
      sf.sys_searchMode.value = "simple";
      if(!this.isSearchSimple)
         sf.sys_searchMode.value = "advanced";

      if (!this._validateQueryForSynonymExp())
         return;
      if (!this._validateQuery())
         return;

      var response = ps.io.Actions.submitForm(document.searchQuery);
      if(response == null)
         return;
      ps.io.Actions.maybeReportActionError(response);
      if(!response.isSuccess())
      {
         return false;
      }

      // reset table columns
      this.contentTable.reset();
      var head = this.contentTable.domNode.getElementsByTagName("thead")[0];
      dojo.dom.removeChildren(head);
      this.contentTable.columns = this._cloneColumns(this.contentTableColumns);

      if (this.includeSitesCheckbox.checked)
      {
         this._addContentTableColumn("Site", "Site");
      }
      if (this.includeFoldersCheckbox.checked)
      {
         this._addContentTableColumn("Folder", "Folder");
      }
      this.setContent(response.getValue());
      this.setSearchMode(false);
      dojo.event.connect(
         this.contentTable, "onSelect", this, "_onContentTableSelect");
      this._setButtonRememberState("okButton", this.okButton, null, true);
      return true;
   },

   /**
    * Utility function to handle the search cleanup code on close.
    */
   _onCancel: function()
   {
      if(this.isSelectTemplateMode)
         return this._handleTemplateCancel();
      var _this = this;
      dojo.lang.setTimeout(function ()
      {
         _this.setSearchMode(true);
      }, 500);

      if(typeof psSearch != "undefined")
         psSearch = null;
      ps.content.SearchTabPanel.superclass._onCancel.apply(this);
   },

   /**
    * Validates that the full text search query
    * does not begin with '*' or '?' as this is
    * not allowed by the lucene search engine.
    */
   _validateQuery: function()
   {
      if (!document.searchQuery.sys_fulltextquery)
         return true;

      var searchForValue = document.searchQuery.sys_fulltextquery.value;
      var firstChar = searchForValue.charAt(0);
      if (firstChar == '*' || firstChar == '?')
      {
         var msg = psxGetLocalMessage("javascript.ps.content.browse@Invalid_First_Char");
         alert(msg);
         return false;
      }
      else
         return true;
   },

   /**
    * Validates that the full text search query
    * does not include any characters defined as
    * "special" by lucene.
    */
   _validateQueryForSynonymExp: function()
   {
      if (!document.searchQuery.sys_synonymexpansion)
         return true;

      var synonymExp = document.searchQuery.sys_synonymexpansion.checked;
      if (synonymExp)
      {                   
         var searchForValue = document.searchQuery.sys_fulltextquery.value;
         var spChars = "";
         var specialChars = new Array("+", "-", "&&", "||", "!", "(", ")", "{", "}", "[", "]", "^", "\"", "~", "*", "?", ":", "\\");
         for (var i = 0; i < specialChars.length; i++)
         {
            var spChar = specialChars[i];
            if (searchForValue.indexOf(spChar) != -1)
            {
               if (spChars.length == 0)
                  spChars = spChar;
               else
                  spChars += ", " + spChar;
            }
         }
               
         if (spChars.length > 0)
         {
            var msg = psxGetLocalMessage("javascript.ps.content.browse@Invalid_Chars_Synonym_Exp");
            alert(msg + " " + spChars);
            return false;
         }
      }
    
      return true;
   },

   /**
    * Load the search form from the server.
    * todo: deal with the inline javascript.
    */
   loadSearchForm: function()
   {
      if (!this.isSearchTab())
      {
         // not the search tab
         return;
      }

      if (!this._isTabLoaded())
      {
         // tab is not loaded yet
         // repeat the call to _onTabSelected on load
         this.selectOnLoad = true;
         return;
      }

      var slotId = this.parent.slotId;
      if (this.searchformPanel.slotId
            && this.searchformPanel.slotId.serialize() === slotId.serialize())
      {
         // already loaded search form for this slot id
         return;
      }
      this.searchformPanel.slotId = slotId;

      // clean up script
      if (this.searchScriptElem)
      {
         this.searchformPanel.setContent("");
         dojo.dom.removeNode(this.searchScriptElem, true);
         this.searchScriptElem = null;
      }

      this.isSearchSimple = false;

      //Get the rc search url
      var response = ps.io.Actions.getUrl(this.parent.slotId, "RC_SEARCH");
      // handle failure
      if (!response.isSuccess())
      {
         ps.io.Actions.maybeReportActionError(response);
         return;
      }
      this.searchFormUrl = response.getValue().url;
      this.searchformPanel.setUrl(this.searchFormUrl + "&genMode=aaHTML");
   },
   
   /**
    * Is called when the search form panel is loaded.
    */
   _onSearchFormPanelLoad: function ()
   {
      if (!dojo.byId("advancedfields"))
      {
         // this method was called on form cleanup
         return;
      }

      this.advancedButton = dojo.widget.byId("ps.search.advanced");
      this.simpleButton = dojo.widget.byId("ps.search.simple");
      this.ftquery = dojo.byId("searchfor");     
     
      this._loadSearchScript();
      
      ps.io.Actions.initFormBind(ps.io.Actions.getRcSearchUrl(), "searchQuery",
            ps.io.Actions.MIMETYPE_JSON);
      if (this.advancedButton)
      {
         dojo.event.connect(
               this.advancedButton, "onClick", this, "_showSearchFields");
      }
      if (this.simpleButton)
      {
         dojo.event.connect(
               this.simpleButton, "onClick", this, "_showSearchFields");
      }
      if (this.advancedButton)
      {
         this._showSearchFields();
      }

      if (this.ftquery)
      {
         dojo.event.connect(
               this.ftquery, "onkeyup", this, "_enableDisableSearch");
      }
      this._enableDisableSearch();
   },

   /**
    * Load the search javascript into the document head
	*/
   _loadSearchScript: function()
	{
      // The search script must be loaded each time as the reference
	  // to javascript variables get lost.
	  var head = document.getElementsByTagName("head")[0];
	  var scr = document.getElementById("ps.content.search.searchScript");
	  if(scr)
	  {
		  head.removeChild(scr);
	  }
      this.searchScriptElem = document.createElement('script');
      this.searchScriptElem.id = 'ps.content.search.searchScript';
      this.searchScriptElem.type = 'text/javascript';
      this.searchScriptElem.src = this.searchFormUrl + "&genMode=aaJS";
      head.appendChild(this.searchScriptElem);
	},

   /**
    * Disable search button if the search is in simple mode and the query field id not empty.
    */
   _enableDisableSearch: function()
   {
      var q = this.ftquery;
      this._maybeSetButton (this.okButton, null,
            this.isSearchSimple && q && dojo.string.isBlank(q.value));
   },

   /**
    * Is called when a tab in the tab container is selected.
    */
   _onTabSelected: function (tab)
   {
      this.loadSearchForm();
      ps.content.SearchTabPanel.superclass._onTabSelected.apply(this, [tab]);
   },
   /**
    * Is called during initialization after the UI is loaded.
    */
   _initOnLoad: function ()
   {
      ps.content.SearchTabPanel.superclass._initOnLoad.apply(this);
      this.setSearchMode(true);
   },
   /**
    * Set the searchmode to true
    */
   _onSearchAgain: function()
   {
      this.setSearchMode(true);
   },
	
   /**
    *  Parses all the expected controls for this tab.
    */
   parseControls: function()
   {
      this._parseCommonControls();
      this._parseFilterPanelControls();
      this.contentTable = this._getWidgetById("FilteringTable");
      // initial conent table columns
      this.contentTableColumns = this._cloneColumns(this.contentTable.columns);
      this._parseSearchPanelOnlyControls();      
   },
	
	/**
    * Parses the filter panel controls and add appropriate events.
    */
   _parseFilterPanelControls: function()
   {
      this.includeSitesCheckbox = this._getElemById("includeSitesCheckbox");
      this.includeFoldersCheckbox = this._getElemById("includeFoldersCheckbox");
      this.filterPanel = this._getWidgetById("filterpanel");
      this.filteringTablePanel = this._getWidgetById("tablepanel");
      this.filteringTable = this._getWidgetById("FilteringTable");
      this.filterText = this._getElemById("filterText");

      dojo.event.connect(this.filterText, "onkeyup", this, "_onFilterTyped");
      //Set the default values for include site id and folder id check boxes
      var inclSitesFlag = ps.util.getServerProperty("slotContentIncludeSiteDefaultValue","");
      var inclFoldersFlag = ps.util.getServerProperty("slotContentIncludeFolderDefaultValue","");
      if(inclSitesFlag == "true")
      {
         this.includeSitesCheckbox.checked = true;
      }
      if(inclFoldersFlag == "true")
      {
         this.includeFoldersCheckbox.checked = true;
      }

      this._ctypeList = this._getElemById("ctypeList");
      dojo.html.hide(this._ctypeList.parentNode);      
   },
	
	/**
    * Parses controls that only exist in the search panel.
    */
   _parseSearchPanelOnlyControls: function()
   {
      this.searchformPanel = this._getWidgetById("searchformpanel");
      new ps.widget.ContentPaneProgress(this.searchformPanel);
      dojo.event.connect(
            this.searchformPanel, "onLoad", this, "_onSearchFormPanelLoad");
      

      this.searchBackButton = this._getWidgetById("searchBackButton");
      dojo.event.connect(this.searchBackButton, "onClick", this, "_onSearchAgain");
   },
	
   /**
    * Is called when templates selection panel is loaded.
    */
   _onTemplatesSiteFolderParamLoaded: function ()
   {
      
         var includeSites = this._mustById(
               "ps.select.templates.includeSitesCheckbox");
         includeSites.checked = this.includeSitesChecked;
         includeSites.disabled = true;

         var includeFolders = this._mustById(
               "ps.select.templates.includeFoldersCheckbox");
         includeFolders.checked = this.includeFoldersChecked;
         includeFolders.disabled = true;
      
   },
	
	/**
    * Returns site name selected in UI, if available and requested by the user.
    * Otherwise returns <code>null</code>.
    */
   _getUISiteName: function ()
   {      
      if (this.templatesPanelObj.siteName)
      {
         return this.templatesPanelObj.siteName;
      }
      else
      {
         return null;
      }      
   },
   
   /**
    * Returns folder path selected in UI, if available and requested by the user.
    * Otherwise returns <code>null</code>.
    */
   _getUIFolderPath: function ()
   {
      if (this.templatesPanelObj.folderPath)
      {
         return this.templatesPanelObj.folderPath;
      }
      else
      {
         return null;
      }      
   },
	
	/**
    * Reloads data from the server for the current path.
    * Overriden to do nothing in the search tab
    */
   _refresh: function()
	{
      // no-op	
	}	      
});



/******************************************************************************
 *
 * [ ps.content.Browse.js ]
 *
 * COPYRIGHT (c) 1999 - 2007 by Percussion Software, Inc., Woburn, MA USA.
 * All rights reserved. This material contains unpublished, copyrighted
 * work including confidential and proprietary information of Percussion.
 *
 *****************************************************************************/
dojo.provide("ps.content.Browse");















/**
 * Ctor for the Content Browser Dialog. Content Browser Dialog is a generic 
 * content browsing interface whose behavior can vary depending on the mode. The
 * dialog widget is created in the fly and added as a child of the body element
 * of the document. The contents of the dialog is loaded from the server while
 * creating the widget itself.
 * 
 * Note: Creating on the fly is not setting the dialog size. We assume the 
 * dialog  widget tag is already available in the html doc and acquire from the
 * document for now.
 */
ps.content.Browse = function(mode)
{
   //todo validate the mode to check if the mode is supported
   this.mode = mode;

   this.preferredHeight = 500;
   this.preferredWidth = 750;

   /**
    * Indicates that this dialog will be in standalone mode which means it
	* will be rendered within a browser window and will "stand alone".
	* In this mode it will always resize to the parents window size and
	* will not display a title bar or shadow.
	*/
   this.isStandAlone = this.mode != ps.util.BROWSE_MODE_ACTIVE_ASSEMBLY;

   /**
    * This must be called after construction of the dialog. This actually parses 
    * all controls/widgets within the dialog and connects appropriate events.
    */
   this.init = function(rxroot)
   {
      this.rxroot = rxroot;
      this.currentTab = null;
   }
   
   /**
    * Creates the Browse/Search dialog if it is not created yet.
    * Stores the dialog in the {@link #wgtDlg} field.
    */
   this.maybeCreateBrowseDialog = function ()
   {
      if (this.wgtDlg)
      {
         this.searchtab._loadSearchScript();
         return;
      }

      var scrSize = ps.util.getScreenSize();
	  var theWidth = this.isStandAlone ? scrSize.width : this.preferredWidth;
	  var theHeight = this.isStandAlone ? scrSize.height : this.preferredHeight;
	  this.wgtDlg = ps.createDialog(
            {
               id: "ps.content.BrowseDlg",
               title:psxGetLocalMessage("javascript.ps.content.browse@Active_Assembly_Browse_Content"),
               titleBarDisplay: !this.isStandAlone,
			   hasShadow: !this.isStandAlone,
			   resizable: !this.isStandAlone
            }, theWidth + "px", theHeight + "px");

      function tab(prefix, tabLabel)
      {
         // <tag ...></tag> form is used because for some reason 
         // the <tag.../> form fails
         return '<div dojoType="ContentPane" id="' + prefix + '.tab" '
               + 'label="' + tabLabel + '" preload="true"></div>\n';
      }

      var content =
            '<div id="ps.content.mainTabContainer" dojoType="TabContainer" '
            +       'style="width: 100%; height: 100%">\n'
            +    tab(ps.util.BROWSETAB_SITES_PANEL_PREF, psxGetLocalMessage("javascript.ps.content.browse@Sites"))
            +    tab(ps.util.BROWSETAB_FOLDERS_PANEL_PREF, psxGetLocalMessage("javascript.ps.content.browse@Folders"))
            +    tab(ps.util.BROWSETAB_SEARCH_PANEL_PREF, psxGetLocalMessage("javascript.ps.content.browse@Search"))
            + '</div>';
      this.wgtDlg.setContent(content);
      var _this = this;

      //override the dialog close function
      // to not destroy the dialog
      this.wgtDlg.closeWindow = function()
      {
         ps.aa.controller.enableConflictStyleSheets(true);
         _this.currentTab._onCancel();
         _this.close()
      }
      this.parseTabControls();		
   }

   /**
    * Method called to parse the tab controls and connect events.
    */
   this.parseTabControls = function()
   {
      var sitestab = new ps.content.SitesTabPanel(this);
      var folderstab = new ps.content.FoldersTabPanel(this);
      var searchtab =  new ps.content.SearchTabPanel(this);
      this.searchtab = searchtab;
		
      // these take long time, so interlieve them with the main flow
      // to make the browser more responsive
      var rxroot = this.rxroot;
      // load the first tab ASAP
      sitestab.init();
      dojo.lang.delayThese([
            function() {folderstab.init();},
            function() {searchtab.init();}],
            500);
		var tabContainer = dojo.widget.byId("ps.content.mainTabContainer");
			
   }

   /**
    * This function does all required steps for closing the dialog
    * window.
    */
   this.close = function()
   {
      ps.aa.controller.enableConflictStyleSheets(true);
      if(this.isStandAlone)
	  {
             self.close();
	  }
	  else
	  {
	     this.wgtDlg.hide();
	  }
   }

   /**
    * Open the dialog box connecting the callers Ok and Cancel methods to the 
    * buttons in the dialog.
    * After adding the snippet it is repositioned as per the value of position, 
    * with respect to the snippet represented by the supplied relationship id.
    */
   this.open = function(okCallback, slotId, refRelId, position)
   {
      dojo.lang.assert(slotId, "slotId parameter must be specified");
      dojo.lang.assert(slotId.isSlotNode(), "Must pass a slot id");
      ps.aa.controller.enableConflictStyleSheets(false);
      if(position == null)
          position = "before";
      this.slotId = slotId;
      this.okCallback = okCallback;
      this.refRelId = refRelId;
      this.position = position;
      
      this.maybeCreateBrowseDialog();
	  if(!this.isStandAlone)
	  {
         ps.util.setDialogSize(this.wgtDlg, this.preferredWidth, this.preferredHeight);
	  }
	  else
	  {
	     var _this = this;
		 dojo.lang.setTimeout(function ()
		  {
			 _this.fillInParentWindow()
		  }, 500);
	  }

      // simulate selection
      var tabContainer = dojo.widget.byId("ps.content.mainTabContainer");
      var tab0 = tabContainer.children[0];
      tabContainer.selectChild(tab0, tabContainer);	

      this.wgtDlg.show();
      if (dojo.render.html.ie55 || dojo.render.html.ie60)
      {
         // otherwise it does not displayed when the dialog is shown second time
         dojo.html.hide(tabContainer.domNode);
         dojo.html.show(tabContainer.domNode);
      }
      
      if (dojo.render.html.safari)
      {
         // Force this tab to be selected to get around bug
         // with Safari not displaying or laying out the tab
         // correctly on intial tab load.
         dojo.lang.setTimeout(function ()
         {
            tabContainer.selectChild(tab0, tabContainer);
         }, 500);
      }

      if (dojo.render.html.ie55 || dojo.render.html.ie60)
      {
         dojo.lang.setTimeout(function ()
         {
            // workaroundof of an IE6 bug, when the dialog container
            // does not show up when the dialog is open second time
            dojo.html.hide(tabContainer.domNode);
            dojo.html.show(tabContainer.domNode);
         }, 1000 * 5);
      }
   }
   /**
    * Causes the dialog to fill in the entire parent window and moves it
	* to Top: 0 Left: 0
	*/
   this.fillInParentWindow = function()
	{
      var scrSize = ps.util.getScreenSize(null, true);
		this.wgtDlg.domNode.style.top = 0;
		this.wgtDlg.domNode.style.left = 0;
		this.wgtDlg.resizeTo(scrSize.width, scrSize.height);		
	}
}


/******************************************************************************
 *
 * [ ps.widget.ScrollableNodes.js ]
 *
 * COPYRIGHT (c) 1999 - 2007 by Percussion Software, Inc., Woburn, MA USA.
 * All rights reserved. This material contains unpublished, copyrighted
 * work including confidential and proprietary information of Percussion.
 *
 *****************************************************************************/

dojo.provide("ps.widget.ScrollableNodes");

/**
 * Manages list of scrollable elements to support autoscroll.
 * 
 * @author Andriy Palamarchuk
 */
ps.widget.ScrollableNodes = function ()
{
   /**
    * Stores dom nodes which should be scrolled during dragging operation.
    */
   this.init = function (nodes)
   {
      this.nodes = nodes;

      dojo.lang.forEach(this.nodes, function(node)
      {
         dojo.lang.assert(node, "Expected all scrollable nodes to be defined.");
      });
   }

   /**
    * Finds the scrollable node, over which the provided mouse event occurs.
    * @param e the mouse event. Not <code>null</code>.
    */
   this.getOverNode = function (e)
   {
      dojo.lang.assert(e, "Event must be specified");

      for (var i = 0; i < this.nodes.length; i++)
      {
         var n = this.nodes[i];
         if (this._overElement(n, e))
         {
            return n;
         }
      }
      return null;
   }

   /**
    * Returns <code>true</code> if the mouse event happened over visible part
    * of the provided element.
    * @param element the dom node of the element to process.
    * Not <code>null</code>.
    * @param e the mouse event.
    * Not <code>null</code>.
    */
   this._overElement = function (element, e)
   {
      dojo.lang.assert(element, "Element must be specified");
      dojo.lang.assert(e, "Event must be specified");

      var sides = ps.util.getVisibleSides(element);
      return e.clientX >= sides.left
            && e.clientX <= sides.right
            && e.clientY >= sides.top
            && e.clientY <= sides.bottom;
   }
}

/******************************************************************************
 *
 * [ ps.widget.Autoscroller.js ]
 *
 * COPYRIGHT (c) 1999 - 2007 by Percussion Software, Inc., Woburn, MA USA.
 * All rights reserved. This material contains unpublished, copyrighted
 * work including confidential and proprietary information of Percussion.
 *
 *****************************************************************************/

dojo.provide("ps.widget.Autoscroller");



/**
 * Scrolls an element in the provided direction while it's
 * <code>scroll()</code> method is being called.
 *
 * @author Andriy Palamarchuk
 */
ps.widget.Autoscroller = function ()
{
   /**
    * Initializes the autoscroller.
    * @param nodes array of nodes to autoscroll.
    * Not <code>null</code>
    */
   this.init = function(nodes)
   {
      var _this = this;
      this.scrollableNodes.init(nodes)

      // listen on dojo.dnd.dragManager methods instead of concreate targets
      // and objects to provide autoscroll for all DnD
      dojo.event.connect(dojo.dnd.dragManager, "onMouseUp",
            function () {_this._stopScroll();});
      dojo.event.connectAround(dojo.dnd.dragManager, "onMouseMove",
            this, "_onMouseMove");
   }
   
   /**
    * Around advice for {@link dojo.dnd.dragManager#onMouseMove}.
    * Autoscrolls if necessary.
    */
   this._onMouseMove = function (invocation)
   {
      dojo.lang.assert(invocation, "Invocation must be defined");
      invocation.proceed();
      if (dojo.dnd.dragManager.dragObjects.length)
      {
         var e = invocation.args[0];
         var contentNode = this.scrollableNodes.getOverNode(e);
         this._maybeAutoscroll(contentNode, e);
      }
   }

   /**
    * Autoscrolls the provided element if the mouse event is in the autoscroll
    * area. If the autoscroll is not needed, the existing autoscroll,
    * managed by this object, is cancelled.
    * @param element the dom node of the element to scroll.
    * If <code>null</code>, autoscroll is cancelled.
    * @param event the mouse event. Not <code>null</code>.
    */
   this._maybeAutoscroll = function (element, event)
   {
      dojo.lang.assert(event, "Event for maybeAutoscroll should not be null.")
      this._resetTimeout();
      
      var stopScroll = true;
      if (element)
      {
         var direction = this._detectAutoscrollArea(element, event);
         if (direction)
         {
            this._scroll(element, direction);
            stopScroll = false;
         }
      }

      if (stopScroll)
      {
         this._stopScroll();
      }
   }

   /**
    * Stops currently running autoscroll.
    */
   this._stopScroll = function ()
   {
      this.element = null;
   }

   /**
    * Function to start and maintain autoscrolling. Autoscrolling happens as
    * long as the method is called for this element.
    * The method can be called as frequently as necessary.
    */
   this._scroll = function (element, direction)
   {
      this.direction = direction;
      if (this._isScrollingStopped(element))
      {
         // launch autoscrolling
         this.element = element;
         this._doScroll();
      }
   }
   
   /**
    * Actual scrolling.
    */
   this._doScroll = function ()
   {
      var scrollLeft = this.element.scrollLeft;
      var scrollTop = this.element.scrollTop;

      this.element.scrollLeft += this.direction.x * this.SCROLL_DISTANCE;
      this.element.scrollTop += this.direction.y * this.SCROLL_DISTANCE;

      dojo.lang.setTimeout(this, "_continueScroll", this.SCROLL_TIME,
           this.element);

      var moved = scrollLeft !== this.element.scrollLeft
            || scrollTop !== this.element.scrollTop;

      if (moved)
      {
         dojo.dnd.dragManager.onScroll();
      }
      return moved;
   }
   
   /**
    * Continues autoscrolling if necessary.
    * @param element the scrolled element. Not <code>null</code>.
    */
   this._continueScroll = function (element)
   {
      if (this._isScrollingStopped(element))
      {
         return;
      }
      this._doScroll();
   }
   
   /**
    * Returns <code>true</code> if a scroll should be performed right now.
    * This happens when the autoscrolling process is finished or when element
    * to scroll was changed.
    */
   this._isScrollingStopped = function (element)
   {
      return (!this.element && element !== this.element) || this._isTimeout();
   }
   
   /**
    * Resets autoscrolling timeout.
    * @see #SCROLL_TIMEOUT
    */
    this._resetTimeout = function ()
    {
       this.autoscrollTimeout = new Date().getTime() + this.SCROLL_TIMEOUT;
    }
    
    /**
     * Returns true if autoscroll was left running for more than
     * {@link @SCROLL_TIMEOUT}.
     */
    this._isTimeout = function ()
    {
       return new Date().getTime() > this.autoscrollTimeout;
    }

   /**
    * Detects whether the event happened in autoscroll area of the provided
    * element.
    * @param element the analysed element. Not <code>null</code>.
    * @param e the mouse event to check. Not <code>null</code>.
    * @return <code>null</code> if the event did not occur in the autoscroll
    * area. Otherwise returns an object with attributes 'x', 'y', containing
    * direction of the closest edge as 1, 0, or -1, where 0 means there is no
    * component edge nearby.
    */   
   this._detectAutoscrollArea = function (element, e)
   {
      dojo.lang.assert(element, "Element must be specified");
      dojo.lang.assert(e, "Event must be specified");

      var sides = ps.util.getVisibleSides(element);

      var _this = this;
      function near(i1, i2)
      {
         var d = i2 - i1;
         return d >= 0 && d <= _this.AUTOSCROLL_EDGE_DISTANCE;
      }
      
      // the checks for both directions on the same axis are independent,
      // to allow them cancel each other if the area 
      var x = 0;
      if (near(sides.left, e.clientX))
      {
         x -= 1;
      }
      if (near(e.clientX, sides.right))
      {
         x += 1;
      }
      
      var y = 0;
      if (near(sides.top, e.clientY))
      {
         y -= 1;
      }
      if (near(e.clientY, sides.bottom))
      {
         y += 1;
      }
      
      return x || y ? {x: x, y: y} : null;
   }

   /**
    * Element to be scrolled.
    */
   this.element = null;
   
   /**
    * Direction to scroll. It's an object with attributes x and y,
    * specifying direction to scroll as values -1, 0, 1.
    */
   this.direction = {x:0, y:0};
   
   /**
    * Abandoned autoscroll timeout.
    * @see #SCROLL_TIMEOUT
    */
   this.autoscrollTimeout = 0;

   /**
    * The scrollable nodes manager utility.
    */
   this.scrollableNodes = new ps.widget.ScrollableNodes();

   /**
    * Time between subsequent scrolls.
    */
   this.SCROLL_TIME = 100;
   
   /**
    * Distance a page is scrolled at once.
    */
   this.SCROLL_DISTANCE = 10;
   
   /**
    * Time after which autoscrolling ends.
    * Used as a safety precaution when autoscrolling was not stopped in time.
    */
   this.SCROLL_TIMEOUT = 5 * 1000;

   /**
    * Distance from the side of an element during drag when autoscroll is
    * triggered.
    */
   this.AUTOSCROLL_EDGE_DISTANCE = 50;
}

dojo.provide("dojo.widget.Button");






/*
 * usage
 *	<button dojoType="button" onClick="...">Hello world</button>
 *
 *  var button1 = dojo.widget.createWidget("Button", {caption: "hello world", onClick: foo});
 *	document.body.appendChild(button1.domNode);
 */
dojo.widget.defineWidget(
	"dojo.widget.Button",
	dojo.widget.HtmlWidget,
	{
		// summary
		//	Basically the same thing as a normal HTML button, but with special styling.

		isContainer: true,

		// caption: String
		//	text to display in button
		caption: "",
		
		templatePath: dojo.uri.moduleUri("dojo.widget", "templates/ButtonTemplate.html"),
		templateCssPath: dojo.uri.moduleUri("dojo.widget", "templates/ButtonTemplate.css"),
		
		// inactiveImg: Url
		//	prefix of filename holding images (left, center, right) for button in normal state
		inactiveImg: "templates/images/soriaButton-",
		
		// activeImg: Url
		//	prefix of filename holding images (left, center, right) for button when it's being hovered over
		activeImg: "templates/images/soriaActive-",

		// pressedImg: Url
		//	prefix of filename holding images (left, center, right) for button between mouse-down and mouse-up
		pressedImg: "templates/images/soriaPressed-",

		// disabledImg: Url
		//	prefix of filename holding images (left, center, right) for button when it's disabled (aka, grayed-out)
		disabledImg: "templates/images/soriaDisabled-",
		
		// widget2height: Number
		//	shape of the button's end pieces;
		//	the height of the end pieces is a function of the button's height (which in turn is a function of the button's content),
		//	and then the width of the end pieces is relative to their height.
		width2height: 1.0/3.0,

		fillInTemplate: function(){
			if(this.caption){
				this.containerNode.appendChild(document.createTextNode(this.caption));
			}
			dojo.html.disableSelection(this.containerNode);
		},

		postCreate: function(){
			this._sizeMyself();
		},
	
		_sizeMyself: function(){
			// we cannot size correctly if any of our ancestors are hidden (display:none),
			// so temporarily attach to document.body
			if(this.domNode.parentNode){
				var placeHolder = document.createElement("span");
				dojo.html.insertBefore(placeHolder, this.domNode);
			}
			dojo.body().appendChild(this.domNode);
			
			this._sizeMyselfHelper();
			
			// Put this.domNode back where it was originally
			if(placeHolder){
				dojo.html.insertBefore(this.domNode, placeHolder);
				dojo.html.removeNode(placeHolder);
			}
		},

		_sizeMyselfHelper: function(){
			var mb = dojo.html.getMarginBox(this.containerNode);
			this.height = mb.height;
			this.containerWidth = mb.width;
			var endWidth= this.height * this.width2height;
	
			this.containerNode.style.left=endWidth+"px";
	
			this.leftImage.height = this.rightImage.height = this.centerImage.height = this.height;
			this.leftImage.width = this.rightImage.width = endWidth+1;
			this.centerImage.width = this.containerWidth;
			this.centerImage.style.left=endWidth+"px";
			this._setImage(this.disabled ? this.disabledImg : this.inactiveImg);

			if ( this.disabled ) {
				dojo.html.prependClass(this.domNode, "dojoButtonDisabled");
				this.domNode.removeAttribute("tabIndex");
				dojo.widget.wai.setAttr(this.domNode, "waiState", "disabled", true);
			} else {
				dojo.html.removeClass(this.domNode, "dojoButtonDisabled");
				this.domNode.setAttribute("tabIndex", "0");
				dojo.widget.wai.setAttr(this.domNode, "waiState", "disabled", false);
			}
				
			this.domNode.style.height=this.height + "px";
			this.domNode.style.width= (this.containerWidth+2*endWidth) + "px";
		},
	
		onMouseOver: function(/*Event*/ e){
			// summary: callback when user mouses-over the button
			if( this.disabled ){ return; }
			if (!dojo.html.hasClass(this.buttonNode, "dojoButtonHover")){
				dojo.html.prependClass(this.buttonNode, "dojoButtonHover");
			}
			this._setImage(this.activeImg);
		},
	
		onMouseDown: function(/*Event*/ e){
			// summary: callback when user starts to click the button
			if( this.disabled ){ return; }
			dojo.html.prependClass(this.buttonNode, "dojoButtonDepressed");
			dojo.html.removeClass(this.buttonNode, "dojoButtonHover");
			this._setImage(this.pressedImg);
		},

		onMouseUp: function(/*Event*/ e){
			// summary: callback when the user finishes clicking
			if( this.disabled ){ return; }
			dojo.html.prependClass(this.buttonNode, "dojoButtonHover");
			dojo.html.removeClass(this.buttonNode, "dojoButtonDepressed");
			this._setImage(this.activeImg);
		},
	
		onMouseOut: function(/*Event*/ e){
			// summary: callback when the user moves the mouse off the button
			if( this.disabled ){ return; }
			if( e.toElement && dojo.html.isDescendantOf(e.toElement, this.buttonNode) ){
				return; // Ignore IE mouseOut events that dont actually leave button - Prevents hover image flicker in IE
			}
			dojo.html.removeClass(this.buttonNode, "dojoButtonHover");
			dojo.html.removeClass(this.buttonNode, "dojoButtonDepressed");
			this._setImage(this.inactiveImg);
		},

		onKey: function(/*Event*/ e){
			// summary: callback when the user presses a key (on key-down)
			if (!e.key) { return; }
			var menu = dojo.widget.getWidgetById(this.menuId);
			if (e.key == e.KEY_ENTER || e.key == " "){
				this.onMouseDown(e);
				this.buttonClick(e);
				dojo.lang.setTimeout(this, "onMouseUp", 75, e);
				dojo.event.browser.stopEvent(e);
			}
			if(menu && menu.isShowingNow && e.key == e.KEY_DOWN_ARROW){
				// disconnect onBlur when focus moves into menu
				dojo.event.disconnect(this.domNode, "onblur", this, "onBlur");
				// allow event to propagate to menu
			}
		},

		onFocus: function(/*Event*/ e){
			// summary: callback on focus to the button
			var menu = dojo.widget.getWidgetById(this.menuId);
			if (menu){
				dojo.event.connectOnce(this.domNode, "onblur", this, "onBlur");
			}
		},

		onBlur: function(/*Event*/ e){
			// summary: callback when button loses focus
			var menu = dojo.widget.getWidgetById(this.menuId);
			if ( !menu ) { return; }
	
			if ( menu.close && menu.isShowingNow ){
				menu.close();
			}
		},

		buttonClick: function(/*Event*/ e){
			// summary: internal function for handling button clicks
			if(!this.disabled){ 
				// focus may fail when tabIndex is not supported on div's
				// by the browser, or when the node is disabled
				try { this.domNode.focus(); } catch(e2) {};
				this.onClick(e); 
			}
		},

		onClick: function(/*Event*/ e) {
			// summary: callback for when button is clicked; user can override this function
		},

		_setImage: function(/*String*/ prefix){
			this.leftImage.src=dojo.uri.moduleUri("dojo.widget", prefix + "l.gif");
			this.centerImage.src=dojo.uri.moduleUri("dojo.widget", prefix + "c.gif");
			this.rightImage.src=dojo.uri.moduleUri("dojo.widget", prefix + "r.gif");
		},
		
		_toggleMenu: function(/*String*/ menuId){
			var menu = dojo.widget.getWidgetById(menuId); 
			if ( !menu ) { return; }
			if ( menu.open && !menu.isShowingNow) {
				var pos = dojo.html.getAbsolutePosition(this.domNode, false);
				menu.open(pos.x, pos.y+this.height, this);
				// disconnect onBlur when focus moves into menu
				dojo.event.disconnect(this.domNode, "onblur", this, "onBlur");
			} else if ( menu.close && menu.isShowingNow ){
				menu.close();
			} else {
				menu.toggle();
			}
		},
		
		setCaption: function(/*String*/ content){
			// summary: reset the caption (text) of the button; takes an HTML string
			this.caption=content;
			this.containerNode.innerHTML=content;
			this._sizeMyself();
		},
		
		setDisabled: function(/*Boolean*/ disabled){
			// summary: set disabled state of button
			this.disabled=disabled;
			this._sizeMyself();
		}
	});

/*
 * usage
 *	<button dojoType="DropDownButton" menuId="mymenu">Hello world</button>
 *
 *  var button1 = dojo.widget.createWidget("DropDownButton", {caption: "hello world", menuId: foo});
 *	document.body.appendChild(button1.domNode);
 */
dojo.widget.defineWidget(
	"dojo.widget.DropDownButton",
	dojo.widget.Button,
	{
		// summary
		//		push the button and a menu shows up
		// menuId: String
		//	widget id of the menu that this button should activate
		menuId: "",

		// downArrow: Url
		//	path of arrow image to display to the right of the button text
		downArrow: "templates/images/whiteDownArrow.gif",

		// disabledDownArray: Url
		//	path of arrow image to display to the right of the button text, when the button is disabled
		disabledDownArrow: "templates/images/whiteDownArrow.gif",
	
		fillInTemplate: function(){
			dojo.widget.DropDownButton.superclass.fillInTemplate.apply(this, arguments);
	
			this.arrow = document.createElement("img");
			dojo.html.setClass(this.arrow, "downArrow");

			dojo.widget.wai.setAttr(this.domNode, "waiState", "haspopup", this.menuId);
		},

		_sizeMyselfHelper: function(){
			// draw the arrow (todo: why is the arror in containerNode rather than outside it?)
			this.arrow.src = dojo.uri.moduleUri("dojo.widget", this.disabled ? this.disabledDownArrow : this.downArrow);
			this.containerNode.appendChild(this.arrow);

			dojo.widget.DropDownButton.superclass._sizeMyselfHelper.call(this);
		},

		onClick: function(/*Event*/ e){
			// summary: callback when button is clicked; user shouldn't override this function or else the menu won't toggle
			this._toggleMenu(this.menuId);
		}
	});

/*
 * usage
 *	<button dojoType="ComboButton" onClick="..." menuId="mymenu">Hello world</button>
 *
 *  var button1 = dojo.widget.createWidget("DropDownButton", {caption: "hello world", onClick: foo, menuId: "myMenu"});
 *	document.body.appendChild(button1.domNode);
 */
dojo.widget.defineWidget(
	"dojo.widget.ComboButton",
	dojo.widget.Button,
	{
		// summary
		//		left side is normal button, right side displays menu
		// menuId: String
		//	widget id of the menu that this button should activate
		menuId: "",
	
		templatePath: dojo.uri.moduleUri("dojo.widget", "templates/ComboButtonTemplate.html"),
	
		// splitWidth: Integer
		//	# of pixels between left & right part of button
		splitWidth: 2,
		
		// arrowWidth: Integer
		//	width of segment holding down arrow
		arrowWidth: 5,
	
		_sizeMyselfHelper: function(/*Event*/ e){
			var mb = dojo.html.getMarginBox(this.containerNode);
			this.height = mb.height;
			this.containerWidth = mb.width;

			var endWidth= this.height/3;

			if(this.disabled){
				dojo.widget.wai.setAttr(this.domNode, "waiState", "disabled", true);
				this.domNode.removeAttribute("tabIndex");
			}
			else {
				dojo.widget.wai.setAttr(this.domNode, "waiState", "disabled", false);
				this.domNode.setAttribute("tabIndex", "0");
			}
	
			// left part
			this.leftImage.height = this.rightImage.height = this.centerImage.height = 
				this.arrowBackgroundImage.height = this.height;
			this.leftImage.width = endWidth+1;
			this.centerImage.width = this.containerWidth;
			this.buttonNode.style.height = this.height + "px";
			this.buttonNode.style.width = endWidth + this.containerWidth + "px";
			this._setImage(this.disabled ? this.disabledImg : this.inactiveImg);

			// right part
			this.arrowBackgroundImage.width=this.arrowWidth;
			this.rightImage.width = endWidth+1;
			this.rightPart.style.height = this.height + "px";
			this.rightPart.style.width = this.arrowWidth + endWidth + "px";
			this._setImageR(this.disabled ? this.disabledImg : this.inactiveImg);
	
			// outer container
			this.domNode.style.height=this.height + "px";
			var totalWidth = this.containerWidth+this.splitWidth+this.arrowWidth+2*endWidth;
			this.domNode.style.width= totalWidth + "px";
		},
	
		_setImage: function(prefix){
			this.leftImage.src=dojo.uri.moduleUri("dojo.widget", prefix + "l.gif");
			this.centerImage.src=dojo.uri.moduleUri("dojo.widget", prefix + "c.gif");
		},
	
		/*** functions on right part of button ***/
		rightOver: function(/*Event*/ e){
			// summary:
			//	callback when mouse-over right part of button;
			//	onMouseOver() is the callback for the left side of the button.
			if( this.disabled ){ return; }
			dojo.html.prependClass(this.rightPart, "dojoButtonHover");
			this._setImageR(this.activeImg);
		},
	
		rightDown: function(/*Event*/ e){
			// summary:
			//	callback when mouse-down right part of button;
			//	onMouseDown() is the callback for the left side of the button.
			if( this.disabled ){ return; }
			dojo.html.prependClass(this.rightPart, "dojoButtonDepressed");
			dojo.html.removeClass(this.rightPart, "dojoButtonHover");
			this._setImageR(this.pressedImg);
		},

		rightUp: function(/*Event*/ e){
			// summary:
			//	callback when mouse-up right part of button;
			//	onMouseUp() is the callback for the left side of the button.
			if( this.disabled ){ return; }
			dojo.html.prependClass(this.rightPart, "dojoButtonHover");
			dojo.html.removeClass(this.rightPart, "dojoButtonDepressed");
			this._setImageR(this.activeImg);
		},
	
		rightOut: function(/*Event*/ e){
			// summary:
			//	callback when moving the mouse off of the right part of button;
			//	onMouseOut() is the callback for the left side of the button.
			if( this.disabled ){ return; }
			dojo.html.removeClass(this.rightPart, "dojoButtonHover");
			dojo.html.removeClass(this.rightPart, "dojoButtonDepressed");
			this._setImageR(this.inactiveImg);
		},

		rightClick: function(/*Event*/ e){
			// summary:
			//	callback when clicking the right part of button;
			//	onClick() is the callback for the left side of the button.
			if( this.disabled ){ return; }
			// focus may fail when tabIndex is not supported on div's
			// by the browser, or when the node is disabled
			try { this.domNode.focus(); } catch(e2) {};
			this._toggleMenu(this.menuId);
		},
	
		_setImageR: function(prefix){
			this.arrowBackgroundImage.src=dojo.uri.moduleUri("dojo.widget", prefix + "c.gif");
			this.rightImage.src=dojo.uri.moduleUri("dojo.widget", prefix + "r.gif");
		},

		/*** keyboard functions ***/
		
		onKey: function(/*Event*/ e){
			if (!e.key) { return; }
			var menu = dojo.widget.getWidgetById(this.menuId);
			if(e.key== e.KEY_ENTER || e.key == " "){
				this.onMouseDown(e);
				this.buttonClick(e);
				dojo.lang.setTimeout(this, "onMouseUp", 75, e);
				dojo.event.browser.stopEvent(e);
			} else if (e.key == e.KEY_DOWN_ARROW && e.altKey){
				this.rightDown(e);
				this.rightClick(e);
				dojo.lang.setTimeout(this, "rightUp", 75, e);
				dojo.event.browser.stopEvent(e);
			} else if(menu && menu.isShowingNow && e.key == e.KEY_DOWN_ARROW){
				// disconnect onBlur when focus moves into menu
				dojo.event.disconnect(this.domNode, "onblur", this, "onBlur");
				// allow event to propagate to menu
			}
		}
	});


/******************************************************************************
 *
 * [ ps.widget.PSButton.js ]
 *
 * COPYRIGHT (c) 1999 - 2007 by Percussion Software, Inc., Woburn, MA USA.
 * All rights reserved. This material contains unpublished, copyrighted
 * work including confidential and proprietary information of Percussion.
 *
 *****************************************************************************/

dojo.provide("ps.widget.PSButton");



/**
 * The Button class overriden to customize style sheet
 */
dojo.widget.defineWidget("ps.widget.PSButton", dojo.widget.Button,
{    
    templateCssPath: dojo.uri.moduleUri("ps", "widget/PSButton.css")    
});



/******************************************************************************
 *
 * [ ps.aa.controller.js ]
 *
 * COPYRIGHT (c) 1999 - 2007 by Percussion Software, Inc., Woburn, MA USA.
 * All rights reserved. This material contains unpublished, copyrighted
 * work including confidential and proprietary information of Percussion.
 *
 *****************************************************************************/
 
dojo.provide("ps.aa.controller");




















/**
 * The Active Assembly controler is responsible to manage all activities, which 
 * include, but not limited the following:
 * (a) communicates to the server for all server operations. 
 * (b) informs the page controller (ps.aa.Page) upon successful server 
 *     operation(s), so that the page controller will be able to update its 
 *     (and its dependent) views accordingly. 
 * (c) update menu system (menubar and context menu) for the activated object.
 * (d) keep references to reusable objects such as a content browse dialog etc.
 */
ps.aa.controller = new function()
{
   /**
    * Whether the tree pane is showing.
    */
   this.isShowTree = null;
   
   /**
    * The id of the current page.
    */
   this.pageId = null;
   /**
    * The id of the activated object.
    */
   this.activeId = null;
   /**
    * Reference to the content browser dialog box. Created and initialized in 
    * {@link #init} method. See ps.content.Browse class for actual usage.
    */
   this.contentBrowser = null;
   
   /**
    * Reference to the snippet picker dialog box. Created and initialized in 
    * {@link #init} method. See ps.content.SnippetPicker class for actual usage.
    */
   this.snippetPickerDlg = null;

   /**
    * Reference to the Create New Item dialog box. Created and initialized in 
    * {@link #init} method. See ps.content.CreateItem class for actual usage.
    */
   this.createItemDlg = null;

   /**
    * The object id that represents the item being edited in full content editor
    */
   this.editObjectId = null;

   /**
    * The window object of content editor.
    */
   this.psCeWindow = null;
     
   /**
    * This tree model contains all managed nodes in the page panel.
    */
   this.treeModel = null;
   
   /**
    * The AA tree widget
    */
    this.treeWidget = null;
   
   /**
    * The workflow actions object
    */
    this.wfActions = null;
    
    /**
     * The Field editor object
     */
    this.fieldEdit = null;
    
    /**
     * The width of the tree pane just before being
     * hidden. 
     */
    this.lastShowingTreePaneWidth = 0;
    
    /**
     * Minimal tree width.
     */
    this.MIN_TREE_WIDTH = 20;
    
   /**
    * Menubar style initialized in _handleMenuBarBackGround method.
    */
    this.menuBarStyle = null;

    /**
     * Flag indicating that placeholders are showing
     */
     this.isShowPlaceholders = true;
   
   /**
    * Initialize the controller and other AA objects.
    * Should be called right after the dojo is done passing the HTML content.
    */
   this.init = function()
   {
      // Be careful when adding any new code to initialization, especially
      // dojo widget creation.
      // New code can visibly affect performance old systems (especially IE6).
      var _this = this;

      // init individual objects
      ps.aa.Page.init();

      // init the tree model
      this.treeModel = new ps.aa.Tree();
      this.treeModel.init();
      this.pageId = this.treeModel.getRootNode().objId;
      dojo.event.connect(this.treeModel, "onBeforeDomChange",
            this, "_onBeforeDomChange");
      dojo.event.connect(this.treeModel, "onDomChanged",
            this, "_onDomChanged");
      
      var ids = new dojo.collections.ArrayList();
      ids.add(this.pageId);
      if(___sys_aamode != 1)
         ids = this.treeModel.getIdsFromNodeId(this.pageId);
      
      this._resetObjectIcons(ids);
      
      this.isShowTree = this._loadTreePaneShowing();
      ps.aa.Menu.init(ids);
      this._maybeShowTree();

      this.bottomPane = dojo.widget.byId("ps.aa.BottomPane");
      dojo.event.connect(this.bottomPane, "endSizing", this, "_endTreeSizing");
      this.treeWidget = dojo.widget.manager.getWidgetById("pageTree");
      this.treeWidget.loadFromModel(this.treeModel);
      this.activate(ps.aa.Page.getElement(this.pageId));
      this.updateBodyStyles();
      // do these actions asynchroniously, so they won't delay page loading
      var timeout = dojo.render.html.ie55 || dojo.render.html.ie60 ? 500 : 600;
      dojo.lang.setTimeout(function() {_this.asynchInit(ids);}, timeout);
   },

   /**
    * Helper method to move and clear the body styles to the page content div 
    * element. Moves the inline styles, builtin styles and css class name and 
    * id attribute.
    */
   this.updateBodyStyles = function()
   {
      var bodyElem = document.getElementsByTagName("body")[0];
      var pageDivElem = dojo.byId("ps.aa.PageContent");
      //Get and clear the body element inline styles
      var ilStyles = ps.util.trim(bodyElem.style.cssText);
      bodyElem.style.cssText = "";
      //Get and clear the body element styles from stylesheets
      var elemStyles = ps.util.getElementStyleSheetCss("body",true);
      //Build the new style
      var newStyle = "";
      if(ilStyles.length > 0 && elemStyles.length > 0)
         newStyle = ilStyles + ";" + elemStyles;
      else if(ilStyles.length > 0)
         newStyle = ilStyles;
      else if(elemStyles.length > 0)
         newStyle = elemStyles;
      
      //Move the new style to div element
      if(newStyle.length > 0)
         pageDivElem.style.cssText = newStyle;
      
      //Move the class name
      pageDivElem.className = bodyElem.className;
      //Move the id attribute
      var idAttrib = dojo.html.getAttribute(bodyElem, "id");
      bodyElem.setAttribute("id",idAttrib);
      //Set the body class to the predefined class.
      bodyElem.className = "PsAabody";
   }
   
   /**
    * Run this method with a delay for initialization, which can be done much
    * later, so it won't delay page loading.
    * Note to implementors - try to put activity in here in order of importance.
    * Logic, which is more critical to be executed first to the beginning of the
    * method.
    */
   this.asynchInit = function(ids)
   {
      var _this = this;

      ps.aa.Menu.initAsynch(ids);
      this.treeWidget.loadFromModelAsynch(this.treeModel);

      this.wfActions = new ps.workflow.WorkflowActions();
      this.wfActions.init();
      this.fieldEdit = new ps.aa.Field();
      this.fieldEdit.init();

      ps.aa.dnd.init();
      this.treeWidget.dndInit();

      this.contentBrowser = new ps.content.Browse(ps.util.BROWSE_MODE_ACTIVE_ASSEMBLY);
      this.contentBrowser.init(__rxroot);
      
      this.snippetPickerDlg = new ps.content.SnippetPicker();
      this.snippetPickerDlg.init(__rxroot + "/ui/content/snippetpicker.jsp", 1);

      this.createItemDlg = new ps.content.CreateItem();
      this.createItemDlg.init(__rxroot + "/ui/content/CreateItem.jsp");

      this.templatesDlg = new ps.content.SelectTemplates();      
      this.templatesDlg.init(__rxroot + "/ui/content/selecttemplate.jsp");

      //Handle the menubar back ground style changes.
      this._handleMenuBarBackGround();

      this.adjustLayout();
      window.onresize = this.adjustLayout;

      // init autoscroller
      var nodes = [];
      nodes.push(dojo.byId("ps.aa.ContentPane"));
      nodes.push(dojo.widget.byId("pageTree").domNode);
      this.autoscroller.init(nodes);
      
      // these take long time, so interleave them with main flow
      // to make IE6 more responsive
      dojo.lang.delayThese([
            function() {_this.wfActions.maybeCreateWorkflowDialog();},
            function() {_this.contentBrowser.maybeCreateBrowseDialog();}], 100);
   }

   /**
    * Adjust the current window size, so that there is no scroll bar on the 
    * most out size of the window. This will keep the menubar at the top of
    * the main window.
    */
   this.adjustLayout = function()
   {
      var mainPane = dojo.widget.byId("ps.aa.mainSplitPane");
      var viewport = dojo.html.getViewport();
      mainPane.resizeTo(viewport.width, viewport.height);
   }

   /**
    * Activates the specified object.
    * @param {HTMLElement} or {ps.aa.ObjectId} htmlElem the dom node to activate
    *    or an objectId of the node to activate.
    * Not <code>null</code>.
    */
   this.activate = function (htmlElem)
   {
      dojo.lang.assert(htmlElem);
      var id = null;
      var divElem = null;
      if (dojo.lang.isOfType(htmlElem, ps.aa.ObjectId))
      {
         id = htmlElem;
         divElem = ps.aa.Page.getElement(id);
      }
      else //if (htmlElem.nodeType == Node.ELEMENT_NODE) 
      {
         id = ps.aa.Page.getObjectId(htmlElem);
         //If the id was created from a widget get the page div element.
         if (id.widget != null || dojo.html.isTag(htmlElem, 'a')) {
            divElem = ps.aa.Page.getElement(id);
         }
         else {
            divElem = htmlElem;
         }
      }
      var parentId = null;
      if (id.isSnippetNode() && !this.treeModel.root.equals(id))
      {
         parentId = ps.aa.Page.getParentId(divElem, id);
         dojo.lang.assert(parentId);
      }
      
      this.activeId = id;
      if (ps.aa.Page.activate(divElem))
      {
         ps.aa.Menu.activate(id, parentId);

      }
      if (this.treeWidget)
         this.treeWidget.activate(id);
         
      //dojo.debug("activate id: " + id.toString());
   }
   
   /**
    * Updates the Tree widget.
    * Parameters can be passed but they will be ignored.
    */
   this.updateTreeWidget = function() 
   {
      this.treeWidget.onModelChanged();
   }

   /**
    * Is called when the user resized the tree.
    */   
   this._endTreeSizing = function()
   {
      var wg = dojo.widget.byId("pageTree");
      if (wg.sizeShare > this.MIN_TREE_WIDTH && !this.isShowTree)
      {
         // became visible because of resizing
         this.showTree();
      }
      else if (wg.sizeShare <= this.MIN_TREE_WIDTH && this.isShowTree)
      {
         // was closed by resizing
         this.hideTree();
      }
   },

   this.showTree = function()
   {
      this.isShowTree = true;
      this._maybeShowTree();
   }
   
   this.hideTree = function()
   {
      this.isShowTree = false;
      this._maybeShowTree();
   }
   
   this.showBorders = function()
   {
      this._switchBorderMode(true);
   }

   this.hideBorders = function()
   {
      this._switchBorderMode(false);
   }

   this._switchBorderMode = function(isShow)
   {
      var hash = PSHref2Hash(null);
      hash["sys_aamode"] = isShow ? "0" : "1";
      window.location.href = PSHash2Href(hash, null);
   }

   this.showPlaceholders = function()
   {
      ps.aa.Menu.toggleShowHidePlaceholders(true);
      ps.util.showHidePlaceholders(document, true);
      this.isShowPlaceholders = true;
   }

   this.hidePlaceholders = function()
   {
      ps.aa.Menu.toggleShowHidePlaceholders(false);
      ps.util.showHidePlaceholders(document, false);
      this.isShowPlaceholders = false;
   }
   
   /**
    * Shows/hides a tree based on value of {@link #isShowTree}
    */
   this._maybeShowTree = function()
   {
      ps.aa.Menu.toggleShowHideTree(this.isShowTree);
      this.toggleTreePane(this.isShowTree);
   }

   /**
    * Toggles the tree pane according to the specified flag
    * 
    * @param treePaneShowing <code>true</code> if wanting to show the tree panel.
    * Not <code>null</code>.
    */
   this.toggleTreePane = function (treePaneShowing)
   {
      dojo.lang.assert(dojo.lang.isBoolean(treePaneShowing));

      var wg = dojo.widget.byId("pageTree");

      if (!treePaneShowing)
      {
         this.lastShowingTreePaneWidth = wg.sizeShare;
//         dojo.debug(wg.sizeShare);
         wg.sizeShare = 0;
      }
      else if (wg.sizeShare < 1)
      {
         wg.sizeShare = this.lastShowingTreePaneWidth > this.MIN_TREE_WIDTH
               ? this.lastShowingTreePaneWidth : 290;
      }

      this._saveTreePaneShowing(treePaneShowing);
      var mainPane = dojo.widget.byId("ps.aa.mainSplitPane");
      mainPane._layoutPanels();
   }
   
   /**
    * Persists information whether the tree pane is shown to a cookie.
    * @param {Boolean} showing whether the tree pane is showing.
    * Not <code>null</code>.
    */
   this._saveTreePaneShowing = function (showing)
   {
      dojo.lang.assert(dojo.lang.isBoolean(showing));
      dojo.io.cookie.setCookie(this._TREE_PANE_SHOWING_COOKIE, showing);
   }
   
   /**
    * Loads information whether the tree pane is shown from a cookie.
    * Returns <code>true</code> if a tree pane should be shown.
    */
   this._loadTreePaneShowing = function ()
   {
      var wg = dojo.widget.byId("pageTree");
      var ck = dojo.io.cookie.getCookie(this._TREE_PANE_SHOWING_COOKIE);
      return ck ? eval(ck) : wg.sizeShare > 0;
   }

  /**
    * Refreshes the slot with the specified id.
    * @param {ps.aa.ObjectId} id the id of the slot to refresh.
    * The slot node must exist on the page.
    * Not <code>null</code>.
    * 
    * @return the given 'id'. This is because this only affects the content of
    *    the slot, but not the id (or the slot) itself.
    */
   this.refreshSlot = function (id)
   {
      return this._refreshX(id, undefined, false, ps.io.Actions, "getSlotContent");
   }

  /**
    * Refreshes the snippet with the specified id.
    * @param {ps.aa.ObjectId} id the id of the snippet to refresh.
    * The snippet node must exist on the page.
    * Not <code>null</code>.
    * @param {ps.aa.ObjectId} newId the id of the snippet to replace this snippet
    * with. Optional. If not specified uses <code>id</code> for this.
    * The snippet node must <b>not</b> exist on the page.
    * 
    * @return the id of the unchanged node, which is the id itself if both 'id' 
    *    and 'newId' are the same; or the id of the parent node if given 'id' 
    *    is not equals to 'newId'; otherwise return null, the whole tree has 
    *    been affected.
    */
   this.refreshSnippet = function (id, newId)
   {
      return this._refreshX(id, newId, true, ps.io.Actions, "getSnippetContent");
   }

   /**
    * Refreshes the field with the specified id.
    * @param {ps.aa.ObjectId} id the id of the field to refresh.
    * The field node must exist on the page.
    * Not <code>null</code>.
    * 
    * @return the given 'id'. This is because this only affects the content of
    *    the field, but not the id (or the field) itself.
    */
   this.refreshField = function (id)
   {
      return this._refreshX(id, undefined, true, ps.io.Actions, "getFieldContent");
   }

   /**
    * A utility function for common logic of {@link #refreshSlot},
    * {@link #refreshField}.
    * @param {ps.aa.ObjectId} id the id of the existing object to refresh.
    * The object node must exist on the page.
    * Not <code>null</code>.
    * @param {ps.aa.ObjectId} newId the id used to retrieve object node
    * from the server. Optional. If not specified, then id is used for this.
    * @param {Boolean} onlyContent if <code>true</content> replaces
    * the node content with result of the action,
    * if <code>false</code>, replaces the whole node.
    * Not <code>null</code>.
    * @param actionObject the object to call <code>action</code> method on.
    * An id of the object to load will be passed to it.
    * @param {String} action the name of the method from
    * <code>actionObject</code>
    * 
    * @return the id of the unchanged node, which is the id itself if both 'id' 
    *    and 'newId' are the same; or the id of the parent node if given 'id' 
    *    is not equals to 'newId'; otherwise return null, the whole tree has 
    *    been affected.
    */
   this._refreshX = function(id, newId, onlyContent, actionObject, action)
   {
      var notChangedId = null;
      
      dojo.lang.assertType(id, ps.aa.ObjectId);
      newId && dojo.lang.assertType(newId, ps.aa.ObjectId);
      dojo.lang.assertType(onlyContent, Boolean);
      dojo.lang.assert(actionObject);
      dojo.lang.assertType(action, String);
      
      if (!newId)
      {
         var newId = id;
      }
      
      var node = ps.aa.Page.getElement(id);
      var response = dojo.lang.hitch(actionObject, action)(newId, true);
      ps.io.Actions.maybeReportActionError(response);
      if (response.isSuccess())
      {
         var treeModel = this.treeModel;
         var treeNode = treeModel.getNodeById(id);

         treeModel.fireBeforeDomChange(id);
         
         // refresh or replace the new content (from the response)
         if (onlyContent)
         {
            if (!id.equals(newId))
               this._replaceDomId(id, newId);
            
            this._refreshNodeContent(node, newId,
                  response.getValue(), newId.isSnippetNode());
         }
         else
         {
            this._refreshNode(node, newId, response.getValue());
         }
         
         // Determine the unchanged node, so that we will 
         // rebuild all the child nodes of it in the treeModel
         if (id.equals(newId))
         {
            notChangedId = id;
         }
         else if (treeNode.parentNode)
         {
            notChangedId = treeNode.parentNode.objId;
         }
         else
         {
            // whole page is being changed
            notChangedId = null;
         }
         dojo.lang.assert(!dojo.lang.isUndefined(notChangedId));
         
         treeModel.fireDomChanged(notChangedId, newId);
      }
      ps.util.addPlaceholders(document);
      if(this.isShowPlaceholders)
      {
         this.showPlaceholders();
      }
      else
      {
         this.hidePlaceholders();
      }
      if(___sys_aamode == 1)
         ps.DivActionHelper.reset();
      return notChangedId;
   }

   /**
    * Replaces DOM node with the node created from the provided html text.
    * New and old nodes can have different ids, or can be even different tags.
    * 
    * @param node the node to replace. Not <code>null</code>.
    * @param {ps.aa.ObjectId} objId the id of the node to replace this node
    *    with. Not <code>null</code>.
    * @param {String} htmlContent the html to replace the node.
    *    Not <code>null</code>.
    */
   this._refreshNode = function (node, objId, htmlContent)
   {
      dojo.lang.assert(node);
      dojo.lang.assert(node.nodeType === dojo.dom.ELEMENT_NODE);
      dojo.lang.assertType(objId, ps.aa.ObjectId);
      dojo.lang.assertType(htmlContent, String);
      
      var newNodes = dojo.html.createNodesFromText(htmlContent, true);
      var newNode = ps.util.findNodeById(newNodes, objId.serialize());
      dojo.lang.assert(newNode,
            "Expected html to contain a node with id "
            + objId.serialize() + ".\nThe html: " + htmlContent);

      var unUsedNode = dojo.dom.replaceNode(node, newNode);
      dojo.dom.destroyNode(unUsedNode);
   }

   /**
    * Fresh or replace the node content or child nodes with the specified HTML content.
    * 
    * @param {HTMLElement} elem the DOM element of the specified snippet.
    * @parm {ps.aa.ObjectId} id the id of the object corresponding to the node.
    * Not <code>null</code>.
    * @param {String} htmlContent the html to replace the node.
    *    Not <code>null</code>.
    * @param skipAnchor true if wants to skip the first anchor <a> child element
    *    which is the case of a snippet node; false if simply replace all the
    *    child nodes with the specified HTML content.
    */   
   this._refreshNodeContent = function(pnode, id, htmlContent, skipAnchor)
   {
      dojo.lang.assert(id, ps.aa.ObjectId)
      if (___sys_aamode == 0 && skipAnchor)
      {
         var anchorElem = dojo.byId(id.getAnchorId());
         dojo.lang.assert(anchorElem,
               "Could not find anchor with id " + id.getAnchorId());
         var container = anchorElem.parentNode;
      }
      else
      {
         var anchorElem = null;
         var container = pnode;
      }

      // remove all child nodes from the parent node         
      var childNodes = new Array();
      while(container.hasChildNodes())
      { 
         childNodes.push(container.firstChild);
         dojo.dom.removeNode(container.firstChild); 
      }

      // remove all child nodes, except the anchor node if there is one
      for (var i=0; i<childNodes.length; i++)
      {
         if (childNodes[i] != anchorElem)
            dojo.dom.destroyNode(childNodes[i]);
      }

      // add the anchor node if there was one
      if (anchorElem != null)
         container.appendChild(anchorElem);
         
      // append the new nodes to the parent node
      var newNodes = dojo.html.createNodesFromText(htmlContent, true);
      for (var i=0; i<newNodes.length; i++)
      {
         container.appendChild(newNodes[i]);
      }
   }

   this.addSnippet = function(source)
   {
      var _this = this;
      switch(source)
      {
         case ps.aa.Menu.INSERT_FROM_SLOT:
            var snippets = dojo.html.getElementsByClass("PsAaSnippet",
               document.getElementById(this.activeId.toString()),"div",
               dojo.html.classMatchType.IsOnly,false);
            if(snippets.length<1)
            {
               this._openBrowseDlg(this.activeId,null,"before");
            }
            else
            {
               this.snippetPickerDlg.open(
                     function (slotId,refRelId,position) {
                        _this._openBrowseDlg(slotId,refRelId,position)},
                     function () {}, this.activeId,1);
            }
         break;
         case ps.aa.Menu.INSERT_FROM_SNIPPET:
            var snNode = this.treeModel.getNodeById(this.activeId);
            var snSlotId = snNode.parentNode.objId;
            this.snippetPickerDlg.open(
                  function (slotId,relId,position) {_this._openBrowseDlg(
                  slotId,relId,position)},
                  function () {}, snSlotId,1,"before",this.activeId.getRelationshipId());
         break;
      }
   }

   /**
    * Opens the browse dialog for selecting snippets to insert into slot at a
    * specified position with respect to a snippet represented by its 
    * relationship id.
    * @param slotId (ps.aa.ObjectId) assumed not <code>null</code>.
    * @param refRelId (String) may be <code>null</code>. positioning is not done.
    * @param position (String) assumed to be one of "before", 
    *    "after" and "replace" strings.
    */
   this._openBrowseDlg = function(slotId,refRelId,position)
   {
      var _this = this;
      this.contentBrowser.open(
            function (refreshedSlotId) 
            {_this.addSnippetToSlot(refreshedSlotId)},
            slotId, refRelId, position);
      
   }

   /**
    * Opens the snippet picker dialog for multiple snippet removal if the slot 
    * is not empty.
    */
   this.openRemoveSnippetsDlg = function()
   {
      var snippets = dojo.html.getElementsByClass("PsAaSnippet",
        document.getElementById(this.activeId.toString()),"div",
        dojo.html.classMatchType.IsOnly,false);
      if(snippets.length<1)
      {
         alert("The slot is empty.");
         return;
      }
      var _this = this;
      this.snippetPickerDlg.open(
            function (slotId,relIds) {_this._handleRemoveSnippets(slotId,relIds)},
            function () {}, this.activeId,0);
   }

   /**
    * This method is a common method expected to be called from following menu items.
    * Slot --  New (0)
    * Snippet -- New (1), Replace (2)
    * Page -- New (3), New Item (4)
    * The source param indicates which menu item this method has been called from.
    * For slot New menu, it opens the snippet picker dialog and then create new item dialog.
    * if the slot is empty then directly opens the create new item dialog.
    * For Snippet New and Replace menu actions opens the create new item dialog.
    * For New calls handleCreateItem function to create a new copy of the page.
    * For New Item menu action opens the create new item dialog.
    * 
    */
   this.createItem = function(source)
   {
      var oeWin = null;
      if (parent.newItemWindow && !parent.newItemWindow.closed)
      {
         oeWin = parent.newItemWindow;
      }
      else if(this.fieldEdit.psCeFieldWindow && !this.fieldEdit.psCeFieldWindow.closed)
      {
         oeWin = this.fieldEdit.psCeFieldWindow;
      }
      else if(this.psCeWindow && !this.psCeWindow.closed)
      {
         oeWin = this.psCeWindow;
      }
      if(oeWin != null)
      {
         var oeMsg = "You have an open editor, "
               + "close that window before creating another item.";
         alert(oeMsg);
         oeWin.focus();
         return false; 
      }
      
      var _this = this;
      switch(source)
      {
         case ps.aa.Menu.NEW_FROM_SLOT: //From Slot
            var snippets = dojo.html.getElementsByClass("PsAaSnippet",
               document.getElementById(this.activeId.toString()),"div",
               dojo.html.classMatchType.IsOnly,false);
            if(snippets.length<1)
            {
               this._openNewItemDlg(this.activeId,null,"before");
            }
            else
            {
               this.snippetPickerDlg.open(
                     function (slotId,relId,position) {_this._openNewItemDlg(
                     slotId,_this._getSnippetIdFromRelId(slotId,relId),position)},
                     function () {}, this.activeId,1);
            }
         break;
         case ps.aa.Menu.NEW_FROM_SNIPPET: //New From snippet
            var itemId = this.activeId;
            var node = this.treeModel.getNodeById(this.activeId);
            var slotId = node.parentNode.objId;
            this.snippetPickerDlg.open(
                  function (slotId,relId,position) {_this._openNewItemDlg(
                  slotId,_this._getSnippetIdFromRelId(slotId,relId),position)},
                  function () {}, slotId,1,"before",this.activeId.getRelationshipId());
         break;
         case ps.aa.Menu.REPLACE_FROM_SNIPPET: //Replace from snippet
            var itemId = this.activeId;
            var node = this.treeModel.getNodeById(this.activeId);
            var slotId = node.parentNode.objId;
            this.snippetPickerDlg.open(
                  function (slotId,relId,position) {_this._openBrowseDlg(
                  slotId,relId,position)},
                  function () {}, slotId,1,"replace",this.activeId.getRelationshipId());
         break;
         case ps.aa.Menu.COPY_FROM_CONTENT: //Copy from Page
            var itemId = this.treeModel.getRootNode().getObjectId();
            var response = ps.io.Actions.getItemPath(itemId);
            // handle failure
            if (!response.isSuccess())
            {
               ps.io.Actions.maybeReportActionError(response);
               return;
            }
            var ipath = response.getValue();
            var fpath = ipath.substring(0,ipath.lastIndexOf("/"));
            var newData = {"sys_contenttypeid":itemId.getContentTypeId(),
             "sys_templateid":itemId.getTemplateId(),"folderPath":fpath,
             "itemPath":ipath,"itemTitle":""};
            _this._handleCopyItem(itemId,newData);
         break;
         case ps.aa.Menu.NEW_FROM_CONTENT: //New from Page
            var itemId = this.treeModel.getRootNode().getObjectId();
            _this._openNewItemDlg(null,itemId,null);
         break;
         default:
            alert("invalid source");
      }
   }
   
   /**
    * Prompts the user for item title and validates it. Alerts and prompts again
    * if it is invalid.
    */
   this._handleCopyItem = function(itemId,newData)
   {
      var _this = this;
      var okCallBack = function(resultText)
      {
         newData.itemTitle = resultText;
         var response = ps.io.Actions.getIdByPath(newData.folderPath+"/"+resultText);
         if (response.isSuccess())
         {
            alert("Title should be unique under the specified folder.\n" + newData.folderPath );
            _this.dlg.hide();
            _this._handleCopyItem(itemId,newData);
         }
         else
         {
            _this.handleCreateItem(null,itemId,null,newData);
         }  
      }
      var cancelCallBack = function(){
         _this.dlg.hide();
      };
      
      var options={  "dlgTitle":"Create Copy",
                     "promptTitle":"Title",
                     "promptText":newData.itemTitle,
                     "textRequired":true,
                     "okBtnText":"Create",
                     "cancelBtnText":"Cancel",
                     "okBtnCallBack":okCallBack,
                     "cancelBtnCallBack":cancelCallBack
                  };
      this.dlg = ps.util.CreatePromptDialog(options);
      this.dlg.show();
      this.dlg.focusTitle();
   }

   /**
    * Convenient method to get the snippet id associated with the relationship id
    * in a slot.
    * @param slotId objectid of slot assumed not <code>null</code>
    * @param relId int relationship id, if <code>null</code> null.
    */
   this._getSnippetIdFromRelId = function(slotId,relId)
   {
      if(!relId)
         return null;
      var snippetId = null;
      if(relId != null)
      {
         var snippets = dojo.html.getElementsByClass("PsAaSnippet",
         document.getElementById(slotId.toString()),
         "div",dojo.html.classMatchType.IsOnly,false);
         for(var i=0;i<snippets.length;i++)
         {
            var id = ps.aa.Page.getObjectId(snippets[i]);
            if(id.getRelationshipId()==relId)
            {
               snippetId = id;
               break;
            }
         }
      }
      return snippetId;      
   }
   
   /**
    * Opens the create new item dialog and .
    * If this method is called from slot or snippet the slotId corresponds to 
    * the slot or slot id of snippet. If it is called from Page then the slot id 
    * will be null.
    * The itemId will be null if this method is called from an empty slot.
    * The position will be null if it is called from page.
    * @param slotId If not null assumed to be a valid ObjectId 
    *    corresponding to a slot.
    * @param itemId may be null, if not null assumed to be a valid ObjectId 
    *    corresponding to a snippet or page.
    * @param position may be null, if not assumed to be one of "before", 
    *    "after" and "replace" strings.
    */
   this._openNewItemDlg = function(slotId,itemId,position)
   {
      var _this = this;
      this.createItemDlg.open(
            function (slotId,itemId,position,newData) {
               _this.handleCreateItem(slotId,itemId,position,newData)},
            function () {}, slotId,itemId,position);
   }
   
   
   /**
    * Handles the item creation part.
    * Calls {@see ps.io.Actions#createItem} to create a new item.
    * If item creation fails opens full editor window. 
    * Otherwise calls {@see #postCreateItem}
    * for further processing.
    * If adding the item to folder fails alerts user about it and continues 
    * with other tasks.
    * @param slotId If not null assumed to be a valid ObjectId 
    *    corresponding to a slot.
    * @param itemId may be null, if not null assumed to be a valid ObjectId 
    *    corresponding to a snippet or page.
    * @param position may be null, if not assumed to be one of "before", 
    *    "after" and "replace" strings.
    * @param newData assumed not null and consists of the following parameters
    * {sys_contenttypeid,sys_templateid,folderPath,itemPath}
    * 
    */
   this.handleCreateItem = function(slotId,itemId,position,newData)
   {
      var response = ps.io.Actions.createItem(newData.sys_contenttypeid,
         newData.folderPath,newData.itemPath,newData.itemTitle);
      if(!response.isSuccess())
      {
         ps.io.Actions.maybeReportActionError(response);
         return;
      }
      var obj = response.getValue();
      if(dojo.lang.has(obj, "validationError"))
      {
            if(!confirm("The following errors occured while creating the new item\n"+
                obj.validationError + 
               "\nClick OK to open the full editor."))
               return;
            var iuresp = ps.io.Actions.getCreateItemUrl(
                  newData.folderPath, newData.sys_contenttypeid, false);
            ps.io.Actions.maybeReportActionError(iuresp);
            if (iuresp.isSuccess())
            {
               var url = iuresp.getValue().url;
               var idresp = ps.io.Actions.getIdByPath(newData.folderPath);
               if(!idresp.isSuccess)
               {
                 alert("Failed to get the folderid for the supplied folder path." +
                       "\nSkipping adding item to folder action.");               
               }
               else
               {            
                    url+="&sys_folderid=" + idresp.getValue().id;
               }
               this.newItemData = null;
               var temp = {"slotId":slotId,"itemId":itemId,
                "position":position,"newData":newData};
               this.newItemData = temp;
               parent.newItemWindow = window.open(url, "PsAaCreateItem",
                  this.PREVIEW_WINDOW_STYLE);
               parent.newItemWindow.focus();
            }         
            return;
      }
      var cid = obj.itemId;
      var fid = obj.folderId;
      if(fid == -1)
      {
         alert("Created the new item but failed to add it to the " +
               "folder. \n See console.log for more details.");
      }
      this.postCreateItem(slotId,itemId,position,newData,cid);
   }
   
   /**
    * Handles tasks after creating the items.
    * If slotId parameter is empty then it is assumed to be called from 
    * page level and reloads the page with the newly created item.
    * Otherwise adds the new item to slot and repositions and if position
    * is replace then removes the original item from slot.
    * 
    * @param slotId If not null assumed to be a valid ObjectId 
    *    corresponding to a slot.
    * @param itemId may be null, if not null assumed to be a valid ObjectId 
    *    corresponding to a snippet or page.
    * @param position may be null, if not assumed to be one of "before", 
    *    "after" and "replace" strings.
    * @param newData assumed not null and consists of the following parameters
    * {sys_contenttypeid,sys_templateid,folderPath,itemPath}
    * @param cid content id of newly created item assumed not null.
    * Note: This method gets called from content editor (activeEdit.xsl) 
    * make sure not break it while modifying.
    */
   this.postCreateItem = function(slotId,itemId,position,newData,cid)
   {
      if(slotId == null)
      {
         var newItemId = itemId.clone();
         newItemId.setContentId(cid);
         newItemId.setTemplateId(newData.sys_templateid);
         var response = ps.io.Actions.getUrl(newItemId,"PREVIEW_MYPAGE");
         ps.io.Actions.maybeReportActionError(response);
         if (!response.isSuccess())
         {
            return;
         }
         var value = response.getValue();
         dojo.lang.assert(dojo.lang.has(value, "url"));
         var newUrl = value.url + "&sys_command=editrc";
         window.location.href = newUrl;
      }
      else
      {
         //Add the new snippet 
         var snippetId = slotId.clone();
         snippetId.setContentId(cid);
         snippetId.setSnippetNode();
         snippetId.setTemplateId(newData.sys_templateid);
         
         var response = ps.io.Actions.addSnippet(
               snippetId, slotId, null, null);
         ps.io.Actions.maybeReportActionError(response);
         if (!response.isSuccess()) 
         {
            return;
         }
         var newRelId = response.getValue();
         var oldRelId = itemId==null?null:itemId.getRelationshipId();
         this.repositionSnippet(slotId,oldRelId,newRelId,position);
      }
   }

   /**
    * Repositions the snippet respect to the reference snippet as per the 
    * supplied position string within the given slot.
    * The new and old snippets are represented by their relationship ids.
    * Position could be either before or after or replace.
    * @param slotId (ps.aa.ObjectId) must not be <code>null</code> and must be 
    *    a valid slot id.
    * @param refRelId (String) The relationship id of the reference snippet.
    *    If <code>null</code> there is nothing to reposition, does nothing.
    * @param newRelId (String) The relationship id of the new snippet. 
    *    Must not be <code>null</code>.
    * @param position (String) If not <code>null</code> must be one of "before"
    *    or "after" or "replace". Otherwise defaults to "before".
    */
   this.repositionSnippet = function(slotId, refRelId, newRelId, position)
   {
      this.refreshSlot(slotId);
      var node = this.treeModel.getNodeById(slotId);
      this.updateTreeWidget(node);
      if(refRelId == null)
      {
         return;
      }
      if(position == null)
         position = "before";
      if(!(position == "before" || position == "after" || position=="replace"))
         dojo.lang.assert(false,"position must be either before or after or relace");
      dojo.lang.assert(slotId, "Slot id must be provided for reposition of snippet");
      dojo.lang.assert(slotId.isSlotNode(), "slotId must represent a slot object id");
      dojo.lang.assert(newRelId);

      var newSnippetId = this._getSnippetIdFromRelId(slotId,newRelId);
      dojo.lang.assert(newRelId, "Invalid relationship id of new snippet");
      var oldSnippetId = this._getSnippetIdFromRelId(slotId,refRelId);
      dojo.lang.assert(refRelId, "Invalid relationship id of reference snippet");
      
      var oldItemIndex = oldSnippetId.getSortRank();
      var newItemIndex = newSnippetId.getSortRank();

      //Check whether reposition is required or not
      var newindex = -1;
      if(position == "before" && newItemIndex != oldItemIndex-1)
      {
         newindex = parseInt(oldItemIndex,10)+0;
      }
      else if(position == "after" && newItemIndex != oldItemIndex+1)
      {
         newindex = parseInt(oldItemIndex,10)+1;
      }
      else if(position == "replace" && 
         (newItemIndex != oldItemIndex-1 || newItemIndex != oldItemIndex+1))
      {
         newindex = parseInt(oldItemIndex,10)+0;
      }
      if(newindex != -1)
      {
         var response = ps.io.Actions.move(newSnippetId, "reorder", newindex + "");
         ps.io.Actions.maybeReportActionError(response);
      }
      //Remove the item id from slot if position is replace
      if(position == "replace")
      {
         var response = ps.io.Actions.removeSnippet(oldSnippetId.getRelationshipId());
         ps.io.Actions.maybeReportActionError(response);
      }
      this.refreshSlot(slotId);
      var node = this.treeModel.getNodeById(slotId);
      this.updateTreeWidget(node);
      this.activate(slotId);
   }

   /**
    * Opens the active snippet in aa mode in new window.
    */
   this.openSnippet = function()
   {
      if(this.snippetOpenWindow &&  !this.snippetOpenWindow.closed)
      {
         if(!confirm(this.SNIPPETOPEN_MSG))
         {
             this.snippetOpenWindow.focus();
             return false;
         }
         else
         {
            this.snippetOpenWindow.close();
         }
      }
      this.snippetOpenWindow = this.openWindow(
         "TOOL_LINK_TO_PAGE", 
         this.PREVIEW_WINDOW_STYLE,
         this.activeId,
         "PSAaSnippetWindow");
      
   }
   
   /**
    * Refreshes the browsers current tab, if the browser dialog is still open.
    */
   this.refreshBrowseWindow = function()
   {
      if(!this.contentBrowser.wgtDlg.isShowing())
      {
         dojo.debug("No need to refresh, the content browser is closed.");
         return;
      }
      this.contentBrowser.currentTab.refreshBrowser();
   }
   
   /**
    * Implementation of Preview Current Revisions action. Parses the window url 
    * for all the required parameters to generate a preview url. Creates the 
    * Object id from these parameters and requests the preview url for this  
    * action and then opens in a named window.
    */
   this.previewWithCurrentRevisions = function()
   {
      var paramMap = this._parseUrlParams();
      this.openWindow(
         "PREVIEW_PAGE", 
         this.PREVIEW_WINDOW_STYLE,
         this._previewObjIdFromParamMap(paramMap),
         this.PREVIEW_WINDOW_NAME);
   }

   /**
    * Implementation of Preview With Edits action. Parses the window url for 
    * all the required parameters to generate a preview url. Creates the Object 
    * id from these parameters and requests the preview url for this  action and 
    * then opens in a named window.
    */
   this.previewWithEditRevisions = function()
   {
    var paramMap = this._parseUrlParams();
    var additionalParams = new Array;
    var param = new Object;
    param.name = "useEditRevisions";
    param.value = "yes";
    additionalParams[0] = param;
    this.openWindow(
      "PREVIEW_MYPAGE", 
      this.PREVIEW_WINDOW_STYLE, 
      this._previewObjIdFromParamMap(paramMap), 
      this.PREVIEW_WINDOW_NAME, 
      additionalParams);
   }

   /**
    * Generate objectid applicable to generate preview URL from the supplied 
    * parameter map.
    * @param paramMap javascript object that has all the required parameters 
    * (name-value pairs) to generate a preview URL. Assumed not null.
    */   
   this._previewObjIdFromParamMap = function(paramMap)
   {
      var objId = new Array();
      objId[ps.aa.ObjectId.NODE_TYPE] = "";
      objId[ps.aa.ObjectId.CONTENT_ID] = paramMap.sys_contentid;
      objId[ps.aa.ObjectId.TEMPLATE_ID] = paramMap.sys_variantid;
      objId[ps.aa.ObjectId.SITE_ID] = paramMap.sys_siteid;
      objId[ps.aa.ObjectId.FOLDER_ID] = paramMap.sys_folderid;
      objId[ps.aa.ObjectId.CONTEXT] = paramMap.sys_context;
      objId[ps.aa.ObjectId.AUTHTYPE] = paramMap.sys_authtype;
      objId[ps.aa.ObjectId.CONTENTTYPE_ID] = "";
      objId[ps.aa.ObjectId.CHECKOUT_STATUS] = "";
      objId[ps.aa.ObjectId.SLOT_ID] = "";
      objId[ps.aa.ObjectId.RELATIONSHIP_ID] = "";
      objId[ps.aa.ObjectId.FIELD_NAME] = "";
      objId[ps.aa.ObjectId.PARENT_ID] = "";
      objId[ps.aa.ObjectId.FIELD_LABEL] = "";
      objId[ps.aa.ObjectId.SORT_RANK] = "";
      return new ps.aa.ObjectId(dojo.json.serialize(objId));
   }
   
   /**
    * Parse the supplied URL string for the parameters and return as a map 
    * (JavaScript object).
    * @param url url string to parse for parameters, may be null in which case 
    * the URL is read from the window. If empty, an empty object is returned. 
    * The anchor part (everything starting with # till end) is ignored.
    */
   this._parseUrlParams = function(url)
   {
      // supplied url is null so get it from the window location
      if(url==null)
         url = window.location.toString();
      //Remove everything starting with "#" before parsing
      loc = url.indexOf("#");
      if(loc !=-1)
         url = url.substring(0, loc);
      //get the parameters
      url.match(/\?(.+)$/);
      var params = RegExp.$1;
      // split up the query string and store in an
      // associative array
      var params = params.split("&");
      var paramMap = {};
      for(var i=0;i<params.length;i++)
      {
          var tmp = params[i].split("=");
          paramMap[tmp[0]] = unescape(tmp[1]);
      }
      return paramMap;
    }
   
   /**
    * Opens the manage navigation dialog for the active page.
    */
   this.openManageNavigationDlg = function()
   {
      this.activeId
      var paramMap = this._parseUrlParams();
      this.openWindow(
         "MANAGE_NAVIGATION", 
         this._getSizedStyle(null, 800, 750),
         this.activeId,
         "MANAGE_NAVIGATION");
   }


   /**
    * Opens a window with the impact analysis applet, showing only AA type rels.
    */ 
   this.showItemRelationships = function()
   {
      this.openWindow("TOOL_SHOW_AA_RELATIONSHIPS", 
         this._getSizedStyle(null, null, 500));
   }

   /**
    * Opens a window that allows the user to pick a language to create a 
    * translation.
    */ 
   this.createTranslation = function()
   {
      this.openWindow("ACTION_Translate", this._getSizedStyle(null, 300, 225));
   }

   /**
    * Creates a promotable version of the current item and then opens it in
    * the same browser using the template of the current item. If the current
    * item's id does not have a folder id, then the folder id of the parent is
    * used.
    */ 
   this.createVersion = function()
   {
      this.openWindow("ACTION_Edit_PromotableVersion", 
         this._getSizedStyle(null, 800, 700));
   }

   /**
    * Generates a URL that would launch the user into AA for the active item and 
    * shows it in a small popup so it can be copied by the user.
    */ 
   this.showPageUrl = function()
   {
      var tmpId = this.activeId;
      var url = this._getUrl("TOOL_LINK_TO_PAGE", tmpId);
      if (url == null)
      {
         dojo.debug("Failed to get link for item id = " + this.activeId.getContentId());
         return;
      }
      var loc = window.location;
      var fullUrl = loc.protocol + "//" + loc.host + url;
     
      ps.util.ShowPageLinkDialog(fullUrl);
   }

   /**
    * Makes a server call to create a url that can be used to access the 
    * current page and returns it. Could be null if any problems occur.
    * This is always the top level page, regardless of the currently active
    * object.
    */
   this.getLinkToCurrentPage = function()
   {
      var tmpId = this.treeModel.getRootNode().getObjectId();
      var url = this._getUrl("TOOL_LINK_TO_PAGE", tmpId);
      return url;
   }

   /**
    * Sends a logout request to the server and updates the current window
    * location.
    */
   this.logout = function()
   {
      var aaUrl = ps.aa.controller.getLinkToCurrentPage();
      var loc = window.location;
      var urlPath = loc.protocol + "//" + loc.host + "/Rhythmyx/logout";
      var url = ps.util.addParamToUrl(urlPath, "sys_redirecturl", 
       	 escape(aaUrl));
      window.location = url;
   }

   /**
    * Launches an edition that will publish the current item now and show the
    * results in a new browser window.
    */ 
   this.publishPage = function()
   {
      this.openWindow("TOOL_PUBLISH_NOW", this._getSizedStyle(null, 700, 450));
      //in case the item was checked in /transitioned
      this.wfActions.handleObjectIdModifications("0");
      var ids = new Array();
      ids[0] = this.activeId;
      this._resetObjectIcons(ids);
      this.refreshImageForObject(this.activeId);
   }

   /**
    * Opens a window with the compare tool using the currently viewed (CR) and 
    * (CR-1) revisions and the same template as the current item. 
    */ 
   this.compareItemRevisions = function()
   {
      this.openWindow("ACTION_View_Compare", 
         this._getSizedStyle(null, 900, 700));
   }

   /**
    * Opens a window with contents of the active item.
    */ 
   this.viewContent = function()
   {
        this.openWindow("CE_VIEW_CONTENT", this._getSizedStyle(null, -1, 700));
   }

   /**
    * Opens a window with properties of the active item.
    */ 
   this.viewProperties = function()
   {
        this.openWindow("CE_VIEW_PROPERTIES");
   }

   /**
    * Opens a window with revisions of the active item.
    */ 
   this.viewRevisions = function()
   {
        this.openWindow("CE_VIEW_REVISIONS");
   }

   /**
    * Opens a window with audit trail of the active item.
    */ 
   this.viewAuditTrail = function()
   {
        this.openWindow("CE_VIEW_AUDIT_TRAIL");
   }
   
   /**
    * This is a helper method for opening the view menu action window. Default 
    * settings correspond to a content editor window.
    * @param windowType See same param of _getUrl().
    * @param wStyle Window style, may be null in which case, this._getSizedStyle
    * is called.
    * @param objectId See same param of _getUrl().
    * @param wName Name of the window, may be null in which case 
    * this.CE_WINDOW_NAME is assumed.
    * @param additionalParams additional parameters to append to the url, if 
    * any, must be an array of objects and each object must have obj.name and 
    * obj.value fields.
    * @return returns the object of newly opened window.
    */
   this.openWindow = function (windowType, wStyle, objectId, wName, additionalParams) 
   {
      var url = this._getUrl(windowType, objectId);
      if (url == null)
         return;
      if (additionalParams != null && additionalParams != undefined) {
          dojo.lang.forEach(additionalParams, function (param) 
          {
             url = url + "&" + param.name + "=" + param.value;
          });
      }
      var ws = wStyle;
      if(ws==null)
         ws = this._getSizedStyle();
      var wn = wName;
      if(wn==null)
         wn = this.CE_WINDOW_NAME;
      var vwin = window.open(url, wn, ws);
      var actualSize = ps.util.getScreenSize(vwin, false);
      var desiredSize = this._getSizeFromStyle(ws);
      if (actualSize.width != desiredSize.width 
         || actualSize.height != desiredSize.height)
      {  
         vwin.resizeTo(desiredSize.width, desiredSize.height);
      }
      vwin.focus();
      return vwin;
   }
   
   /**
    * Changes the template that a snippet currently uses.
    */
   this.changeTemplate = function()
   {
      this.templatesDlg.controller = this;
      var _this = this;
      this.templatesDlg.open(
         function (newSnippetId, snippetId)
         {
            _this._handleTemplateChange(newSnippetId, snippetId);
         },
         function () {}, this.activeId);
   }
   
   /**
    * Parses the supplied style string looking for a width and height property.
    * If found, that value is returned, otherwise default values of 800 for 
    * width and 400 for height are returned.
    *
    * @param style A window style string, e.g. 'location=0,width=200,height=300'
    * If null, the default values are returned.
    * @return An object with 2 properties that contain the width and height
    * as found in the supplied style (in pixels.)
    */
   this._getSizeFromStyle = function(style)
   {
      var size = new Object();
      size.width = 800;
      size.height = 400;
      if (style == null)
      {
         return size;
      }
      var winProps = style.split(",");
      var foundWidth = false;
      var foundHeight = false;
      for (var i  = 0; i < winProps.length && !(foundWidth && foundHeight); i++)
      {
         var prop = winProps[i].split("=");
         if (prop[0] == "width")
         {
            size.width = prop[1];
            foundWidth = true;
         }
         else if (prop[0] == "height")
         {
            size.height = prop[1];
            foundHeight = true;
         }
      }
      return size;
   }
   
   /**
    * Builds a window style string from the supplied params. Each param has a
    * default as noted in its description. 
    * 
    * @param style The base style, without the width and height. If undefined or 
    * null, defaults to this.BASE_WINDOW_STYLE.
    * @param width The desired window width, in pixels. If undefined or 
    * negative, defaults to 800.
    * @param height The desired window height, in pixels. If undefined or 
    * negative, defaults to 400.
    *
    * @return A String that contains the style props as noted above. 
    */
   this._getSizedStyle = function(style, width, height)
   {
      if (style == null)
         style = this.BASIC_WINDOW_STYLE;
      if (width == null || width < 0)
         width = 800;
      if (height == null || height < 0)
         height = 400;
      if (style.length > 0)
         style = style + ",";
      return style + "width=" + width + ",height=" + height;
   }
   
   /**
    * Handler for change template select action
    * @param {ps.aa.ObjectId} the objectId of the new snippet.
    * @param {ps.aa.ObjectId} the objectId of the old snippet.
    */
   this._handleTemplateChange = function(newSnippetId, snippetId)
   {
      var response = ps.io.Actions.getItemSortRank(newSnippetId.getRelationshipId());
      if(response.isSuccess())
      {
         var rank = parseInt(response.getValue());
         if(rank == 0)
            rank = 1;
         var resp = ps.io.Actions.moveToSlot(
            newSnippetId, newSnippetId.getSlotId(), newSnippetId.getTemplateId(), rank);
         if(!resp.isSuccess())
         {
            ps.io.Actions.maybeReportActionError(resp);
         }
         else
         {
            var parentId = this.refreshSnippet(snippetId, newSnippetId);
            this.updateTreeWidget(parentId);
            this.activate(newSnippetId);
         }   
      }
   }

   this._handleRemoveSnippets = function(slotId,relIds)
   {
      var response = ps.io.Actions.removeSnippet(relIds);
      ps.io.Actions.maybeReportActionError(response);
      if (response.isSuccess())
      {
         this.refreshSlot(slotId);
         var node = this.treeModel.getNodeById(slotId);
         this.updateTreeWidget(node);
         this.activate(slotId);
      }
   }

   /**
    * Removes the active snippet.
    */
   this.removeSnippet = function()
   {
      var node = this.treeModel.getNodeById(this.activeId);
      var nextActiveId = this.treeModel.getNextSiblingId(node.objId);
      
      var response = ps.io.Actions.removeSnippet(node.objId.getRelationshipId());
      ps.io.Actions.maybeReportActionError(response);
      if (response.isSuccess())
      {
         var pid = node.parentNode.objId;
         this.refreshSlot(pid);
         this.updateTreeWidget(node.parentNode);
         var div = ps.aa.Page.getElement(nextActiveId);
         this.activate(div);
      }
   }

   /**
    * Opens the content editor window for editing the item.
    * Checks whether the item is checked out or not. If not shows an alert message to
    * user to check out the item before editing.
    * If the full editor or single field editor window is open then alerts the
    * user whether he wants to continue with other field editing or open this
    * item for editing.
    * Gets the content editor url from the server and opens editor window.   
    */
   this.editAll = function(cachedUrl)
   {
        //Check whether the item is checked out or not
        if(this.activeId.isCheckoutByMe() == 0)
        {
            alert(this.CHECKOUT_MSG);
            return false;
        }
         //If a field editor window is open for editing a field, propmt user
         //whether he wants to open this item and cancel editing of the field?
        if(this.fieldEdit.psCeFieldWindow && !this.fieldEdit.psCeFieldWindow.closed)
        {
            if(!confirm(ps.aa.controller.EDITOROPEN_MSG))
            {
                this.fieldEdit.psCeFieldWindow.focus();
                return false;
            }
            else
            {
               this.fieldEdit.psCeFieldWindow.close();
            }
        }
         //If a full editor window is open for editing an item, propmt user
         //whether he wants to open this item and cancel editing of the other item?
        else if(this.psCeWindow && !this.psCeWindow.closed)
        {
            if(this.activeId.getContentId() == this.editObjectId.getContentId() || !confirm(ps.aa.controller.EDITOROPEN_MSG))
            {
                ps.aa.controller.psCeWindow.focus();
                return false;
            }
            else
            {
               ps.aa.controller.psCeWindow.close();
            }
        }
        else if(this.fieldEdit.inplaceEditing)
        {
           if(!confirm(this.INPLACE_EDITOROPEN_MSG))
              return false;
           this.fieldEdit.onInplaceCancel();
        }
        
        this.editObjectId = this.activeId;
        var ceurl = "";
        if(cachedUrl && cachedUrl.length > 0)
        {
            ceurl = cachedUrl;
        }
        else
        {
           var response = ps.io.Actions.getUrl(this.activeId,"CE_EDIT");
           ps.io.Actions.maybeReportActionError(response);
            if (!response.isSuccess())
            {
               return false;
            }
            var value = response.getValue();
            dojo.lang.assert(dojo.lang.has(value, "url"));
            ceurl = value.url;
        }
        this.psCeWindow = window.open(ceurl,this.CE_EDIT_ITEM_WINDOW,this.PREVIEW_WINDOW_STYLE);
        this.psCeWindow.focus();
   }
   
   /**
    * Updates all the fields corresponding to the active objectid.
    * 
    */
   this.updateAllFields = function(sysTitle)
   {
      this.refreshFieldsOnPage(this.editObjectId.getContentId(),null,this.psCeWindow);
      //Reset the tree label
      this._resetTreeLabel(sysTitle);
   }
   
   /**
    * Queries the server for a Url that matches the requested windowType, using
    * the supplied Id. If the Id is null, the currently active Id is used.
    *
    * @param windowType The type of the window to be opened. Makes a request
    * to the server action with the supplied type and gets the url, if the
    * response is not success, then shows error message to user. The name must
    * match one of the TYPE_xxx values in PSGetUrlAction.java.
    * @param objectId Object Id, may be null in which case it is assumed as 
    * this.activeId.
    *
    * @return Either null (meaning the request to the server failed and a 
    * message was shown to the user,) or a valid URL as a String.
    */
   this._getUrl = function(windowType, objectId)
   {
      var oid = objectId;
      if(oid==null)
         oid = this.activeId;
      var response = ps.io.Actions.getUrl(oid, windowType);
      ps.io.Actions.maybeReportActionError(response);
      if (!response.isSuccess()) 
      {
         return null;
      }
      var value = response.getValue();
      dojo.lang.assert(dojo.lang.has(value, "url"));
      return value.url;
   }   
   
   /**
    * Convenient method to reset the tree labels, meant to be called from 
    * updateAllFields method, which gets invoked when the full content editor is
    * used to edit the content.
    * @param newtitle, the new title that needs to be set, does nothing if 
    * newtitle is null or empty.
    */
   this._resetTreeLabel = function(newtitle)
   {
      if(newtitle == null || newtitle == "")
         return;
      if(this.editObjectId == null)
         return;
      /*It is assumed that the full editor is called from either page node or
      snippet node or field node. For field nodes the parent node is assumed to
      be the page node or snippet node.
      */
      var parentNd = this.treeModel.getNodeById(this.editObjectId);
      if(this.editObjectId.isFieldNode())
         parentNd = parentNd.parentNode;
      parentNd.clearLabel();
      var id = parentNd.objId.serialize();
      var divElem = dojo.byId(id);
      dojo.lang.assert(divElem, "Cannot find DIV element with id=" + id);
      var oldtitle = dojo.html.getAttribute(divElem, "psAaLabel");
      if(newtitle != oldtitle)
      {
         divElem.setAttribute("psAaLabel",newtitle);
         this.updateTreeWidget();
      }
   }
   
   /**
    * Gets the affected object ids after the specified item has been modified.
    * 
    * @param {int} contentId The content id of the item that has been modified.
    * @param {String} fieldName The modified field name. It may be null if all
    *    field may have been modified.
    * 
    * @return {dojo.collections.ArrayList} a list of affected object ids in
    *    {ps.aa.ObjectId}.
    */
   this._getAffectedObjectIds = function(contentId, fieldName)
   {
      // gets the nodes that are directly affected by modifying this item
      var results = this.treeModel.getIdsFromContentId(contentId, fieldName);
         
      // gets the nodes that are indirectly affected by modifying this item,
      
      // gets the content id of all managed nodes
      var allObjIds = this.treeModel.getAllIdsByContentId(null);
      var allContentIds = new dojo.collections.ArrayList();
      var cid;
      for (var i=0; i<allObjIds.count; i++)
      {
         cid = allObjIds.item(i).getContentId();
         if (!allContentIds.contains(cid))
            allContentIds.add(cid);
      }
      
      // gets the affected parent/owner nodes
      var response = ps.io.Actions.getInlinelinkParentIds(contentId, 
          allContentIds.toArray());
      ps.io.Actions.maybeReportActionError(response);
      if (response.isSuccess())
      {
          var parentIds = response.getValue();
          for (var i=0; i<parentIds.length; i++)
          {
             if (parentIds[i] != contentId)
             {
                var objIds = this.treeModel.getIdsFromContentId(parentIds[i], null);
                results.addRange(objIds);
             }
          }
      }
      
      return results;
   }
   
   /**
    * Refreshes the fields on page by getting the rendered content for the fields
    * 
    * @param {int} contentId The content id of the item that has been modified.
    * @param {String} fieldName The modified field name. It may be null if all
    *    field may have been modified.
    * @param windowObj The window to need to gain focus afterwards if specified.
    */
   this.refreshFieldsOnPage = function(contentId,fieldName,windowObj)
   {
      var results = this._getAffectedObjectIds(contentId, fieldName);

      // refresh the related nodes        
      for(var i=0; i<results.count; i++)
      {
         var result = results.item(i);
         dojo.lang.assertType(result, ps.aa.ObjectId);
         if(result.isFieldNode())
         {
            this.refreshField(result, null);
         }
         else if(result.isSnippetNode())
         {
            this.refreshSnippet(result,null);
         }
      }
      //If the window is not closed then focus the window
      if(windowObj && !windowObj.closed)
      {
         windowObj.focus();
      }
      this.refreshOpener(contentId);
   }
   
   /**
    * Edit the field, calls fields edit function.
    */
   this.editField = function()
   {
      if(___sys_aamode == 1)
         ps.DivActionHelper.reset();
      this.fieldEdit.editField(ps.aa.Page.activeDiv,null);
   }

   this.cutSnippet = function()
   {
      alert("FIXME: cutSnippet()");
   }

   this.pasteSnippet = function()
   {
      alert("FIXME: pasteSnippet()");
   }

   /**
    * Moves active snippet down.
    * Facade method to be called from event handlers.
    */
   this.moveSnippetDown = function()
   {
      var snippet = this._getSnippetNode(ps.aa.Page.activeDiv);
      if (snippet)
      {
         var snippetId = ps.aa.Page.getObjectId(snippet)
         dojo.lang.assert(snippetId);

         var treeNode = this.treeModel.getNodeById(snippetId);
         var nodeIndex = treeNode.getIndex();
         var siblings = treeNode.parentNode.childNodes.toArray();

         if (nodeIndex < siblings.length - 1)
         {
            var response = ps.io.Actions.move(snippetId, "down");
            ps.io.Actions.maybeReportActionError(response);
            if (response.isSuccess())
            {
               var node2Index = nodeIndex + 1;
               var node2 = siblings[node2Index];
               // swap tree model nodes
               treeNode.parentNode.childNodes.setByIndex(nodeIndex, node2);
               treeNode.parentNode.childNodes.setByIndex(node2Index, treeNode);
               var snippet2 = ps.aa.Page.getElement(node2.objId);
               ps.util.swapNodes(snippet, snippet2);
               this.updateTreeWidget(treeNode.parentNode);
               this.activate(snippet);
            }
         }
      }
   }

   /**
    * Moves active snippet up.
    * Facade method to be called from event handlers.
    */
   this.moveSnippetUp = function()
   {
      var snippet = this._getSnippetNode(ps.aa.Page.activeDiv);
      if (snippet)
      {
         var snippetId = ps.aa.Page.getObjectId(snippet)
         dojo.lang.assert(snippetId);

         var treeNode = this.treeModel.getNodeById(snippetId);
         var nodeIndex = treeNode.getIndex();
         var siblings = treeNode.parentNode.childNodes.toArray();

         if (nodeIndex > 0)
         {
            var response = ps.io.Actions.move(snippetId, "up");
            ps.io.Actions.maybeReportActionError(response);
            if (response.isSuccess())
            {
               var node2Index = nodeIndex - 1;
               var node2 = siblings[node2Index];
               // swap tree model nodes
               treeNode.parentNode.childNodes.setByIndex(nodeIndex, node2);
               treeNode.parentNode.childNodes.setByIndex(node2Index, treeNode);

               var snippet2 = ps.aa.Page.getElement(node2.objId);
               ps.util.swapNodes(snippet, snippet2);
               this.updateTreeWidget(treeNode.parentNode);
               this.activate(snippet);
            }
         }
      }
   }

   this.workflowItem = function()
   {
      this.wfActions.open();
   }

   /**
    * Moves snippet to the specified slot.
    * If necessary requests user to specify a new template.
    * @param {ps.aa.SnippetMove} move the snippet move parameters.
    * Can be changed by the method, e.g. when the method needs to change the
    * template.
    * Not <code>null</code>.
    * @return <code>true</code> if the move is successful so far.
    * Otherwise returns <code>false</code>.
    * The oparation can still fail after
    * this method returns, e.g. if user cancels template selection dialog.
    */
   this.moveToSlot = function (move)
   {
      dojo.lang.assertType(move, ps.aa.SnippetMove);

      var response = ps.io.Actions.moveToSlot(
            move.getSnippetId(),
            move.getTargetSlotId().getSlotId(),
            move.getTargetSnippetId().getTemplateId(),
            move.getTargetIndex());

      var success = this._handleMoveToSlotResponse(response, move);
      move.setSuccess(success);
      return success;

   }
   
   /**
    * Is used to process response from {@link ps.io.Actions#moveToSlot}.
    * @param {ps.io.Response} response return value of
    * {@link ps.io.Actions#moveToSlot}.
    * Not <code>null</code>.
    * @param {ps.aa.SnippetMove} move the snippet move parameters.
    * Not <code>null</code>.
    * @return <code>true</code> if the snippet move is successful so far.
    * @see #moveToSlot
    */
   this._handleMoveToSlotResponse = function (response, move)
   {
      dojo.lang.assertType(response, ps.io.Response);
      dojo.lang.assertType(move, ps.aa.SnippetMove);

      if (response.isSuccess())
      {
         this.maybeRefreshMovedSnippetNode(move, true);
         return true;
      }
      else if (response.getValue() === ps.io.Actions.NEEDS_TEMPLATE_ID)
      {
         if (move.getSnippetId().getTemplateId() !==
             move.getTargetSnippetId().getTemplateId())
         {
            ps.error("Template was already changed!");
            return false;
         }
         var response = ps.io.Actions.getAllowedSnippetTemplates(
               move.getTargetSnippetId());

         // handle failure         
         ps.io.Actions.maybeReportActionError(response);
         if (!response.isSuccess())
         {
            return false;
         }

         var value = response.getValue();
         dojo.lang.assert(dojo.lang.has(value, "count"));
         dojo.lang.assert(dojo.lang.has(value, "templateHtml"));

         if (value.count == 0)
         {
            ps.error("There are no templates, configured for the target slot!");
            return false;
         }
         else if (value.count == 1)
         {
            var nodes = dojo.html.createNodesFromText(value.templateHtml, true);
            // 1 extra node is for the "Cancel" button
            dojo.lang.assert((nodes.length - 1) === 1,
                  "Got more than 1 node from " + value.templateHtml);
            var snippetDiv = nodes[0];
            move.setTargetSnippetId(ps.aa.Page.getObjectId(snippetDiv));
            dojo.dom.destroyNode(snippetDiv);
            delete snippetDiv;

            var result = this.moveToSlot(move);
            this.maybeRefreshMovedSnippetNode(move, result);
            return result;
         }
         else
         {
            
            this.templatesDlg.snippetMove = move;
            this.templatesDlg.controller = this;
            this.templatesDlg.open(this._onMoveToSlotTemplateSelected,
               this._onSnippetTemplateSelectionDialogCancelled, move.getTargetSnippetId());            
            
            // *do not* refresh snippet from backend, because the snippet
            // has not been changed on backend, as the actual move operation
            // will be performed much later, when user selected the template
            return true;
         }
      }
      else // unexpected failure
      {
         ps.io.Actions.maybeReportActionError(response);
         return false;
      }
      dojo.lang.assert(false, "Should not reach here");
   }
   
   /**
    * Refreshes the target snippet node if it is moved and the update is allowed
    * by the <code>move</code> parameter.
    * Used to update the snippet HTML after the drop is complete.
    * {ps.aa.SnippetMove} move the snippet move parameters.
    * Not <code>null</code>.
    * {Boolean} moved whether the page was moved.
    * Not <code>null</code>.
    */
   this.maybeRefreshMovedSnippetNode = function (move, moved)
   {
      dojo.lang.assertType(move, ps.aa.SnippetMove);
      
      if (moved)
      {
         if (move.getDontUpdatePage())
         {
            move.setUiUpdateNeeded(true);
         }
         else
         {
            this.refreshSlot(move.getSlotId());
            var changedNodes = [move.getSlotId()];
            if (move.getSlotId().getSlotId() !==
                 move.getTargetSlotId().getSlotId())
            {
               this.refreshSlot(move.getTargetSlotId());
               changedNodes.push(move.getTargetSlotId());
            }
            
            this.updateTreeWidget(changedNodes);
         }
      }
   }
   
   /**
    * This method is called when a user selects a snippet
    * in the template selection dialog.
    * When called this will have the scope of SelectTemplates.
    * @param {ps.aa.ObjectId} the objectId of the new snippet.
    * @param {ps.aa.ObjectId} the objectId of the old snippet.
    */
   this._onMoveToSlotTemplateSelected = function (newSnippetId, snippetId)
   {
      dojo.lang.assert(newSnippetId, ps.aa.ObjectId);
      dojo.lang.assert(snippetId, ps.aa.ObjectId);
      
      var move = this.snippetMove;
      dojo.lang.assert(move);
      move.setTargetSnippetId(newSnippetId);
      var result = this.controller.moveToSlot(move);
      if (!result)
      {
         this.cancelCallback();
      }
      else
      {
         this.controller.maybeRefreshMovedSnippetNode(move, true);

         var snippetId = move.getTargetSnippetId();
         this.controller.activate(ps.aa.Page.getElement(snippetId));
      }
   }   

   /**
    * Is called when the snippet template selection dialog is cancelled.
    * When called this will have the scope of SelectTemplates.
    */
   this._onSnippetTemplateSelectionDialogCancelled = function ()
   {
      // notes, 'this' is in the context of 'ps.content.SelectTemplates', but
      // not in the context of 'ps.aa.controller'
      var move = this.snippetMove;
      dojo.lang.assert(move);
      
      this.controller.refreshSlot(move.getSlotId());
      this.controller.refreshSlot(move.getTargetSlotId());
      this.controller.updateTreeWidget(move.getSlotId(), move.getTargetSlotId());
   }
   
   /**
    * This method is called to dismiss the template selection dialog.
    */
   this._cancelSnippetTemplateSelectionDialog = function ()
   {
      var dialog = dojo.widget.byId(this._SELECT_TEMPLATE_DLG_ID);
      if (!dialog)
      {
         return;
      }
      this._onSnippetTemplateSelectionDialogCancelled();
      dialog.closeWindow();
   }
   
   /**
    * @param {ps.aa.ObjectId} snippetId the id of the snippet to move.
    * Not null.
    * @param {Number} targetIndex the position, starting with 1,
    * in the target slot to move the snippet to.
    * @return <code>true</code> if the operation was successful.
    * Otherwise returns <code>false</code>.
    */
   this.reorderSnippetInSlot = function (snippetId, targetIndex)
   {
      dojo.lang.assertType(snippetId, ps.aa.ObjectId);
      dojo.lang.assert(dojo.lang.isNumeric(targetIndex),
            "Can't be interpreted as number: \"" + targetIndex + "\"");
      var response = ps.io.Actions.move(snippetId, "reorder", targetIndex);
      ps.io.Actions.maybeReportActionError(response);
      return response.isSuccess();
   }
   
   /**
    * Replaces the specified old id to the new one.
    * 
    * @param {ps.aa.ObjectId} oldId The to be replaced id.
    * @param {ps.aa.ObjectId} newId The new id.
    */
   this.replaceId = function(oldId, newId)
   {
      dojo.lang.assert(dojo.lang.isOfType(oldId, ps.aa.ObjectId));
      dojo.lang.assert(dojo.lang.isOfType(newId, ps.aa.ObjectId));

      var oldIds = new Array();
      oldIds[0] = oldId;
      var newIds = new Array();
      newIds[0] = newId;
      
      this.replaceIds(oldIds, newIds);
   }

   /**
    * Replaces the specified old ids to the new ones
    * 
    * @param {Array of ps.aa.ObjectId} oldIds The to be replaced ids.
    * @param {Array of ps.aa.ObjectId} newIds The new ids.
    */
   this.replaceIds = function(oldIds, newIds)
   {
      dojo.lang.assert(dojo.lang.isArray(oldIds));
      dojo.lang.assert(dojo.lang.isArray(newIds));
      dojo.lang.assert(oldIds.length === newIds.length);

      // use function instead of a var, because it can change      
      var _this = this;
      function getRootId()
      {
         return _this.treeModel.getRootNode().objId;
      }
      
      this.treeModel.fireBeforeDomChange(getRootId());

      var activeId = this.activeId;
      var activeIdChanged = false;
      for (var i=0; i<oldIds.length; i++)
      {
         var oldId = oldIds[i];
         var newId = newIds[i];
         if (oldId.equals(activeId))
         {
            activeId = newId;
            activeIdChanged = true;
         }
         this._replaceDomId(oldId, newId);
         this.refreshImageForObject(newId);
      }
      this.treeModel.fireDomChanged(null, null);
      this.updateTreeWidget(getRootId());

      if (activeIdChanged)
      {
         // reset selection
         var otherId = getRootId();
         if (otherId.equals(activeId)
           && this.treeModel.getRootNode().childNodes.count > 0)
         {
            otherId = this.treeModel.getRootNode().childNodes.item(0).objId;
         }
         this.activate(otherId);
         this.activate(activeId);
      }
   }
   
   /**
    * Replaces the id of an DOM element.
    * 
    * @param {ps.aa.ObjectId} oldId The to be replaced id.
    * @param {ps.aa.ObjectId} newId The new id.
    */
   this._replaceDomId = function(oldId, newId)
   {
      function changeElementId(id1, id2)
      {
         var elem = dojo.byId(id1);
         dojo.lang.assert(elem != null);
         elem.id = id2;
      }
      
      changeElementId(oldId.serialize(), newId.serialize());
      if(___sys_aamode == 0)
         changeElementId(oldId.getAnchorId(), newId.getAnchorId());
      
//    The following code is needed if wants to change ids directly from 
//    tree Model, which is to avoid rebuild treeModel 
//         this._replaceDomId(oldId.getTreeNodeWidgetId(), newId.getTreeNodeWidgetId());
//         var node = this.treeModel.getNodeById(oldId);
//         dojo.lang.assert(node != null);
//         node.objId = newId;;
   }
   
   /**
    * Add snippet to slot call back that will be called by the content 
    * browse/search dialog.
    * @param snippetToAdd is the snippet to add to slot, always defined.
    * todo: implement this
    */
   this.addSnippetToSlot = function(refreshedSlotId)
   {
      this.refreshSlot(refreshedSlotId);
      this.updateTreeWidget(refreshedSlotId);
   }
   
   /**
    * Refresh the icons of the given object ids.
    * 
    * @param {dojo.collections.ArrayList} ids the list of object ids {ps.aa.ObjectId}.
    */
   this._resetObjectIcons = function(ids)
   {
      for (var i=0; i<ids.count; i++)
      {
         var id = ids.item(i);
         this.refreshImageForObject(id);
      }
   }
      
   /**
    * Given the object id, refresh the image for the object rendered to reflect 
    * the checkout status.
    * @param objId objectid of the managed object, must not be null.
    */
   this.refreshImageForObject = function(objId)
   {
      dojo.lang.assertType(objId, ps.aa.ObjectId);
      if(___sys_aamode == 1)
         return;
      var anchor = dojo.byId(objId.getAnchorId());
      var imgElem = dojo.dom.getFirstChildElement(anchor);
      if(imgElem == null)
      {
         dojo.debug("Image element for the objectid = " + objId.serialize() 
           + "is not found");
         return;
      }
      else
      {
         imgElem.src = objId.getImagePath(this.IMAGE_ROOT_PATH);
      }
   }
   
   /**
    * Returns the snippet node containing the provided node.
    * The node is returned if it is a snippet node.
    * @param node the node to search snippet node for.
    * If <code>null</code> the method returns <code>null</code>.
    * @return the snippet node containing the provided node,
    * or <code>null</code>, if such node can't be found.
    */
   this._getSnippetNode = function (node)
   {
      if (!node)
      {
         return null;
      }
      while (node)
      {
         if (node.className === ps.aa.SNIPPET_CLASS)
         {
            return node;
         }
         node = node.parentNode;
      }
      return null;
   }   
   
   /**
    * A listener on {@link ps.aa.Tree#onBeforeDomChange}.
    */
   this._onBeforeDomChange = function (id)
   {
      var ids = this.treeModel.getIdsFromNodeId(id);

      // unbind the context menu from the to be replaced DOM elements
      if(___sys_aamode != 1)
         ps.aa.Menu.unBindContextMenu(ids);
   }

   /**
    * A listener on {@link ps.aa.Tree#onDomChanged}.
    */
   this._onDomChanged = function (id)
   {
      var ids = this.treeModel.getIdsFromNodeId(id);
      
      // refresh all image icons to keep them insync with their checkout status
      for (var i=0; i<ids.count; i++)
         this.refreshImageForObject(ids.item(i));

      // bind the context menu from the to be replaced DOM elements
      if(___sys_aamode != 1)
         ps.aa.Menu.bindContextMenu(ids);
   }
   
   /**
    * Refreshes the opener window of Active Assembly window.
    * Does noting If the opener is none or closed or crossdomain opener.
    * Checks the opener url, if it has sys_cx then calls
    * refreshCxApplet method of browser.js file to refresh the selected nodes.
    * Otherwise reloads that opener window if the url has contentid equal to
    * the supplied contentId.
    * @param contentId, the content id of teh item which needs to be refreshed
    * in the window opener.   
    */
   this.refreshOpener = function(contentId)
   {
      try
	  {
		  var wopener = window.opener;
		  if(wopener == null || wopener.closed)
			 return;
		  var wurl = wopener.location.href;
		  if(wurl.indexOf("sys_cx")!=-1)
		  {
			 refreshCxApplet(wopener, "Selected", contentId, null);
		  }
		  else
		  {
			 var h = PSHref2Hash(wurl);
			 if(h["sys_contentid"] == contentId)
				wopener.location.href = wopener.location.href;
		  }
	  }
	  catch(e)
	  {
		//Ignore if we can't refresh the opener, this may happen if you are using a linkback functionality.
		//The domain of the opener and AA page are different.
	  }
   }

   /**
    * Convenient method to handle the menu bar background change functions, while
    * opening the modal dialogs.
    * Initializes menu bar style. 
    * Changes the text color of the dialog boxes to black.
    * Overides the show and hide methods of ModalFloatingPane.
    */
   this._handleMenuBarBackGround = function()
   {
      var menubar = dojo.widget.byId("ps.aa.Menubar");
      this.menuBarStyle = menubar.domNode.style;
      var _this = this;
      //Overrides the show function of ModalFloatingPane, copies the original 
      //function and overrides it by calling disable menubar function
      //first and then calling the original show function. 
      dojo.widget.ModalFloatingPane.prototype.origShow =
            dojo.widget.ModalFloatingPane.prototype.show;
      dojo.widget.ModalFloatingPane.prototype.show = function() 
      {
         _this._toggleMenuBarBackGround(false);
         this.origShow();
      }      
      //Overrides the hide function of ModalFloatingPane, copies the original 
      //function and overrides it by calling enable menubar function
      //first and then calling the original hide function. 
      dojo.widget.ModalFloatingPane.prototype.origHide =
            dojo.widget.ModalFloatingPane.prototype.hide;
      dojo.widget.ModalFloatingPane.prototype.hide = function() 
      {
         _this._toggleMenuBarBackGround(true);
         this.origHide();
      }      
   }

   /**
    * Toggles the menu bar background from dull to bright and vice versa based 
    * on the supplied parameter.
    * @param brighten if true menubar back ground is set to bright color other
    * wise dull color.
    */
    this._toggleMenuBarBackGround = function(brighten)
    {
       if(this.menuBarStyle)
       {
          if(brighten)
             this.menuBarStyle.background = "#85aeec url(../sys_resources/images/aa/soriaBarBg.gif) repeat-x top left";
          else
             this.menuBarStyle.background = "#85aeec url(../sys_resources/images/aa/soriaBarBgDisabled.gif) repeat-x top left";
          
       }
    }

   /**
    * Opens the help window based on the supplied windowName.
    * Accepted values for windowName parameter are AAHelp, AATutorial and AAAbout.
    * For window name
    * AAHelp -- opens Active Assembly help window, if the window already exists
    * then sets the focus to that window. 
    * AATutorial -- opens Active Assembly tutorial window, if the window already exists
    * then sets the focus to that window.
    * AAAbout -- opens the Active Assembly About Dialog. 
    */
    this.openHelpWindow = function(windowName)
    {
       dojo.lang.assert((windowName === ps.aa.Menu.AAHELP
             || windowName === ps.aa.Menu.AATUTORIAL
             || windowName === ps.aa.Menu.AAABOUT),
             "Unexpected windowName " + windowName);
       if(windowName == ps.aa.Menu.AAHELP)
       {
          var hwin = window.open(this.helpUrl,windowName);
          hwin.focus();
       }
       else if(windowName == ps.aa.Menu.AATUTORIAL)
       {
          var hwin = window.open(this.helpTutorialUrl,windowName);
          hwin.focus();
       }
       else if(windowName == ps.aa.Menu.AAABOUT)
       {
          var dlg = ps.createDialog(
                {
                   id: "ps.Help.AboutDlg",
                   title: "About Rhythmyx Active Assembly",
                   href: this.helpAboutUrl
                }, "510px", "400px");
          dlg.show();
       }
       else
       {
          dojo.lang.assert(false, "Unhandled window " + windowName);
       }
    }
    
   /**
    * Enables or disables the conflict css stylesheets based on the supplied 
    * parameter. Gets the server property named AaConflictStyleSheets and
    * if exists the value is assumed to bea comma separated list of stylesheets.
    * Disables or enables all of them. 
    */
   this.enableConflictStyleSheets = function(enabled)
   {
      if(this._aaConflictStyleSheets == null)
      {
         var ss = ps.util.getServerProperty("AaConflictStyleSheets","");
         this._aaConflictStyleSheets = ss==""?[]:dojo.string.splitEscaped(ss,",");
      }
      for(var i=0;i<this._aaConflictStyleSheets.length;i++)
      {
         ps.util.enableStyleSheet(this._aaConflictStyleSheets[i],enabled);
      }
   }
   
   /**
    * The autoscrolling manager.
    */
   this.autoscroller = new ps.widget.Autoscroller();

   /**
    * Constant for alert message shown to the user when the item is not checked 
    * out by him.
    */
    this.CHECKOUT_MSG = "The item is not checked out to you, please check out the item to edit the field.";
    
    /**
    * Constant for alert message shown to the user when a field is already open 
    * for edit and user clicks on another field};
    */
    this.EDITOROPEN_MSG = "A window is already open for editing another field. Do you want to abort the changes to the open field and activate the field you have selected?";
    
    /**
    * Constant for alert message shown to the user when a snippet is already open 
    * for edit and user clicks on open menu on another snippet;
    */
    this.SNIPPETOPEN_MSG = "A window is already open for editing another " +
          "snippet. Do you want to replace it with current snippet?";
    
    /**
     * Window object for open snippet action window. Initialized in openSnippet
     * method. May be <code>null</code>
     */
    this.snippetOpenWindow = null;
     
    /**
    * Constant for alert message shown to the user when a field is already open 
    * for edit and user clicks on another field};
    */
    this.INPLACE_EDITOROPEN_MSG = "A field is already open for editing. Do you want to abort the changes to the open field and activate the field you have selected?";

    /**
     * An id for the select template dialog.
     */
    this._SELECT_TEMPLATE_DLG_ID = "selectTemplateDialog";
    
    /**
     * Constant for the target window name of the view actions
     */
    this.CE_WINDOW_NAME = "Ce_Window";
    
    /**
     * For editing and tool windows. Does not include width or height.
     */
    this.BASIC_WINDOW_STYLE = "toolbar=0,location=0,directories=0,status=0,menubar=0,scrollbars=1,resizable=1";

    /**
     * Constant for the target window name of the preview actions
     */
    this.PREVIEW_WINDOW_NAME = "Preview_Window";
    
    /**
     * Target style for preview windows
     */
    this.PREVIEW_WINDOW_STYLE = "toolbar=0,location=0,directories=0,status=1,menubar=0,scrollbars=1,resizable=1,width=800,height=700";
    
    /**
     * Image root diectory.
     */
    this.IMAGE_ROOT_PATH = "../sys_resources/images/aa";
    
    /**
     * Constant for content editor window 
     */
    this.CE_EDIT_ITEM_WINDOW = "PsAaEditItem";
    
    /**
     * Name of the cookie, indicating whether the tree pane is showing.
     */
    this._TREE_PANE_SHOWING_COOKIE = "treePaneShowing";    

   /**
    * Array variable to hold the style sheets that conflict with the AA.
    */
    this._aaConflictStyleSheets = null;
    
   /**
    * Urls for help actions
    */
    this.helpUrl = "../Docs/Rhythmyx/Active_Assembly_Interface/index.htm";
    this.helpTutorialUrl = "../Docs/Rhythmyx/Active_Assembly_Tutorial/index.htm";
    this.helpAboutUrl = "/Rhythmyx/ui/activeassembly/help/aboutaahelp.jsp";
};    


/******************************************************************************
 *
 * [ ps.workflow.Workflow.js ]
 *
 * COPYRIGHT (c) 1999 - 2007 by Percussion Software, Inc., Woburn, MA USA.
 * All rights reserved. This material contains unpublished, copyrighted
 * work including confidential and proprietary information of Percussion.
 *
 *****************************************************************************/
 
dojo.provide("ps.workflow.WorkflowActions");














/**
 * The workflow object. Manages the workflow actions of an item.
 */
ps.workflow.WorkflowActions = function()
{
   /**
    * The workflow action id of the currently selected action. Initialized in
    * @see #onWfActionChanged method which gets called on the onload.
    */
   this.actionId = null;

   /**
    * The dialog object of workflow dialog.
    */
   this.wfDlg = null;

   /**
    * The content id of the item for which the workflow dialog is opened.
    * Initialized in dialog open method.
    */
    this.contentId = null;
    
   /**
    * Base URL for workflow action dialog.
    */ 
    this.workflowActionsUrl = "/Rhythmyx/ui/activeassembly/workflow/workflowactions.jsp";
    
   /**
    * Base URL for adhoc user search pane.
    */ 
    this.adhocSearchUrl = "/Rhythmyx/ui/activeassembly/workflow/adhocsearch.jsp";

   /**
    * Base URL for adhoc user results pane.
    */ 
    this.adhocResultsUrl = "/Rhythmyx/ui/activeassembly/workflow/adhocresults.jsp";

   /**
    * This must be called after construction of the dialog. This actually parses 
    * all controls/widgets within the dialog and connects appropriate events.
    */
   this.init = function()
   {
   }

   /**
    * Creates the workflow dialog if it is not created yet.
    * Stores the dialog in the {@link #wfDlg} field.
    */
   this.maybeCreateWorkflowDialog = function ()
   {
      if (this.wfDlg)
      {
         return;
      }
      
      this.wfDlg = ps.createDialog(
            {
               id: "ps.workflow.WorkflowActionsDlg",
               title: "Workflow Actions"
            }, "420px", "250px");
      

      var _this = this;
      //override the dialog close function
      // to not destroy the dialog
      this.wfDlg.closeWindow = function()
      {
         _this.wfDlg.hide();
      }
      dojo.event.connect(this.wfDlg, "onLoad", function()
      {
         _this.parseControls();
         if(_this._isUserAuthorized())
         {
            _this.onWfActionChanged();
         }
      });
   }

   /**
    * Helper method called by init() to parse all the controls and connect 
    * events.
    */
   this.parseControls = function()
   {
      var _this = this;
      //Workflow Action Pane Stuff
      //Form elements
      this.wfActionPane = dojo.byId("ps.workflow.actionPane");
      if (this._isUserAuthorized())
      {         
         this.wfActionSelector = dojo.byId("ps.workflow.workflowActionSelect");
         this.wfCommentText = dojo.byId("ps.workflow.commentText");
         this.wfAdhocUsers = dojo.byId("ps.workflow.adhocUsers");

         //Buttons
         this.wgtAdhocSearch = dojo.widget.byId("ps.workflow.wgtButtonAdhocSearch");
         var submit = dojo.widget.byId("ps.workflow.wgtButtonSubmit");
         var cancel = dojo.widget.byId("ps.workflow.wgtButtonCancel");

         //Resize the dialog
         if (this.wfCommentText && this.wgtAdhocSearch)
         {
            ps.util.setDialogSize(this.wfDlg, 420, 370);
         }
         else if (this.wfCommentText || this.wgtAdhocSearch)
         {
            ps.util.setDialogSize(this.wfDlg, 420, 250);
         }
         else
         {
            ps.util.setDialogSize(this.wfDlg, 420, 125);
         }

         //Event Connectors
         dojo.event.connect(this.wfActionSelector, "onchange",
              this, "onWfActionChanged");
         if (this.wgtAdhocSearch)
         {
            dojo.event.connect(this.wgtAdhocSearch, "onClick",
                  this, "openAdhocSearchDialog");
         }
         dojo.event.connect(submit, "onClick", this, "executeWorkflowAction");
         dojo.event.connect(cancel, "onClick", this, "onWfActionCancelled");
      }
      else
      {
         this.wgtButtonClose = dojo.widget.byId("ps.workflow.wgtButtonClose");
         dojo.event.connect(this.wgtButtonClose, "onClick", this, "onWfActionCancelled");
         ps.util.setDialogSize(this.wfDlg, 420, 125);
      }
   }

   /**
    * Opens the dialog box.
    */
   this.open = function()
   {
      this.maybeCreateWorkflowDialog();
      this.contentId = ps.aa.controller.activeId.getContentId();
      var wfurl = ps.util.addParamToUrl(this.workflowActionsUrl,"sys_contentid",this.contentId);
      this.wfDlg.setUrl(wfurl);      
      this.wfDlg.show();
   }

   /**
    * Function to update the dialog content when the workflow action is changed.
    */
   this.onWfActionChanged = function()
   {
       var index = this.wfActionSelector.selectedIndex;
       if(index < 0) index=0;
       var idStr = this.wfActionSelector.options[index].value;
       this.actionId = new ps.workflow.ActionId(idStr);
       
       // update comment UI
       if (this.wfCommentText)
       {
          if (!this.wfCommentRequiredStar)
          {
             this.wfCommentRequiredStar = dojo.byId("ps.workflow.commentStar");
          }
          
          if(this.actionId.isCommentBoxNeeded())
          {
             this.wfCommentText.disabled = false;
             this.wfCommentText.style.bgcolor = "white";

             if(this.actionId.isCommentRequired())
             {
                 this.wfCommentRequiredStar.style.visibility = "visible";
             }
             else
             {
                 this.wfCommentRequiredStar.style.visibility = "hidden";
             }
          }
          else
          {
             this.wfCommentText.disabled = true;
             this.wfCommentText.style.bgcolor = "grey";
             this.wfCommentRequiredStar.style.visibility = "hidden";
          }
       }
       
       // update the adhoc UI
       if (this.wgtAdhocSearch)
       {
          if(this.actionId.isAdhocBoxNeeded())
          {
             this.wfAdhocUsers.disabled = false;
             this.wfAdhocUsers.style.bgcolor = "white";
             this.wgtAdhocSearch.setDisabled(false);
          }
          else
          {
             this.wfAdhocUsers.disabled = true;
             this.wfAdhocUsers.style.bgcolor = "gray";
             this.wgtAdhocSearch.setDisabled(true);
          }
       }
   }
    
    /**
     * Opens the adhoc search dialog. 
     */
    this.openAdhocSearchDialog = function()
    {
       this._maybeCreateAdhocSearchDialog();

       dojo.html.hide(this.wfActionPane);
       this.adhocResultsPane.hide();
       var wfurl = ps.util.addParamToUrl(this.adhocSearchUrl,"sys_contentid",this.contentId);
       wfurl = ps.util.addParamToUrl(wfurl,"sys_transitionid",this.actionId.getTransitionId());
       this.adhocSearchPane.cacheContent = false;
       var _this = this;
       dojo.event.connect(this.adhocSearchPane, "onLoad", function()
       {
         _this.adhocRoleSelect = dojo.byId("ps.workflow.adhocRole");
         _this.nameFilterText = dojo.byId("ps.workflow.nameFilter");
         _this.wgtButtonSearch = dojo.widget.byId("ps.workflow.wgtButtonSearch");
         _this.wgtButtonAdd = dojo.widget.byId("ps.workflow.wgtButtonAdd");
         _this.wgtButtonClose = dojo.widget.byId("ps.workflow.wgtButtonClose");
         //If the button exists already setting the disabled multiple times 
         //causing multiple dojoButtonDisabled classes to be added to the element
         //and enable code is not working properly.
         if(!dojo.html.hasClass(_this.wgtButtonAdd.domNode,"dojoButtonDisabled"))
            _this.wgtButtonAdd.setDisabled(true);
         
         dojo.event.connect(_this.wgtButtonSearch, "onClick", _this, "onSearchClicked");
         dojo.event.connect(_this.wgtButtonAdd, "onClick", _this, "onAddClicked");
         dojo.event.connect(_this.wgtButtonClose, "onClick", _this, "onSearchClosed");
       });
       this.adhocSearchPane.setUrl(wfurl);
       this.wfAdhocPane.show();
    }
    
   /**
    * Creates the adhoc search pane if it is not created yet.
    * Stores the pane in {@link #wfAdhocPane} field.
    */
   this._maybeCreateAdhocSearchDialog = function ()
   {
      if (this.wfAdhocPane)
      {
         return;
      }
      var div = document.createElement('div');
      var style = div.style;
      style.overflow = "auto";
      style.border = "0px solid black";
      this.wfActionPane.parentNode.appendChild(div);
      
      this.wfAdhocPane = dojo.widget.createWidget("ContentPane",
            {
               titleBarDisplay: false,
               executeScripts: true
            }, div);

      this.wfAdhocPane.setContent(
         '<table width="100%">\n'
         + '<tr><td width="100%">\n'
         + '<div dojoType="ContentPane" id="ps.workflow.adhocSearchPane" executeScripts="true" style="border: 1px solid #e3edfa;"/>\n'
         + '</td></tr>\n'
         + '<tr><td><table width="100%">\n'
         + '<tr><td bgcolor="#e3edfa" width="100%">Search Results</td></tr>\n'
         + '<tr><td width="100%">\n'
         + '<div dojoType="ContentPane" id="ps.workflow.adhocResultsPane" executeScripts="true" style="border: 1px solid #e3edfa;">\n'
         + '</div></td></tr>\n'
         + '</table></td></tr><tr>\n'

         + '<td align="center" width="100%">\n'
         + '<table width="100%" align="left" cellpadding="1"><tr>\n'
         + '<td align="right">\n'
         + '<button style="border: 1px solid black;" dojoType="ps:PSButton" id="ps.workflow.wgtButtonAdd">Add</button>\n'
         + '</td>\n'
         + '<td align="left">\n'
         + '<button style="border: 1px solid black;" dojoType="ps:PSButton" id="ps.workflow.wgtButtonClose">Close</button>\n'
         + '</td>\n'
         + '</tr></table></td>\n'

         + '</tr>\n'
         + '<tr><td width="100%" height="100%"/></tr>\n'
         + '</table>');

      this.adhocSearchPane = dojo.widget.byId("ps.workflow.adhocSearchPane");
      dojo.lang.assert(this.adhocSearchPane, "Expected adhocSearchPane")
      this.adhocResultsPane = dojo.widget.byId("ps.workflow.adhocResultsPane");
      dojo.lang.assert(this.adhocResultsPane, "Expected adhocResultsPane")
   }
    
    /**
     * Calls appropriate workflow server action based on the selected action. 
     * If successful calls the @see #handleObjectIdModifications() to update the 
     * checkout status of the objectids on the page.  
     */
    this.executeWorkflowAction = function()
    {
        var atype = this.actionId.getActionType();
        var response = null;
        var checkOutStatusChanged = false;
        var newStatus = null;
        if(this.actionId.isCommentRequired() && this._getComment() === "")
        {
           alert("Comment must be entered for workflow transition <" + this.actionId.getActionLabel() +">.");
           return false;
        }
        if(atype == ps.workflow.ActionId.ACTION_TYPE_CHECKIN || atype == ps.workflow.ActionId.ACTION_TYPE_FORCE_CHECKIN)
        {
           response = ps.io.Actions.checkInItem(this.contentId, this._getComment());
           checkOutStatusChanged = true;
           newStatus = "0";
        }
        else if(atype == ps.workflow.ActionId.ACTION_TYPE_CHECKOUT)
        {
           response = ps.io.Actions.checkOutItem(this.contentId, this._getComment());
           checkOutStatusChanged = true;
           newStatus = "1";
        }
        else if(atype == ps.workflow.ActionId.ACTION_TYPE_TRANSITION_CHECKOUT)
        {
           response = ps.io.Actions.transitionCheckOutItem(this.contentId,
                 this.actionId.getWfAction(), this._getComment(),
                 this._getAdhocUsers());
           checkOutStatusChanged = true;
           newStatus = "1";
        } 
        else
        {
           response = ps.io.Actions.transitionItem(this.contentId,
                 this.actionId.getWfAction(), this._getComment(),
                 this._getAdhocUsers());
           if(ps.aa.controller.activeId.isCheckout() || ps.aa.controller.activeId.isCheckoutByMe())
           {
              checkOutStatusChanged = true;
              newStatus = "0";
           }
        }

        if (!response.isSuccess())
        {
           ps.io.Actions.maybeReportActionError(response);
           return false;
        }
        if(checkOutStatusChanged)
        {
           this.handleObjectIdModifications(newStatus);
         }
        ps.aa.controller.refreshOpener(this.contentId);        
        this.wfDlg.hide();
        if(this.wfAdhocPane)
           location.reload();
        
    }

   /**
    * Updates the objectids on the page.
    * Gets all the ids from tree model. Creates new array of ids by cloning
    * the items in the original array and changes the checkout status on the new
    * ids. Replaces the old ids with the new ids. 
    */
   this.handleObjectIdModifications = function(checkOutStatus)
   {
      dojo.lang.assert((checkOutStatus === "0" || checkOutStatus === "1" || checkOutStatus === "2"), "checkOutStatus must be 0, 1, or 2");
      
      //get all ids from tree model by passing the active contentid
     var results = ps.aa.controller.treeModel.getAllIdsByContentId(this.contentId);
     dojo.lang.assertType(results, dojo.collections.ArrayList);
     var oldIds = new Array();
     var newIds = new Array();
     var slotIds = new Array();
     for(var i=0; i<results.count; i++)
     {
        var result = results.item(i);
        dojo.lang.assertType(result, ps.aa.ObjectId);
        oldIds[i] = result;
        var newId = result.clone();
        newId.setCheckoutStatus(checkOutStatus);
        newIds[i] = newId;
        if(result.isSlotNode())
           slotIds.push(newId);
     }
     ps.aa.controller.replaceIds(oldIds,newIds);
     if(checkOutStatus == 1)
     {
        for(var j=0; j<slotIds.length; j++)
        {
           ps.aa.controller.refreshSlot(slotIds[j]);
        }
        if(slotIds.length > 0)
           ps.aa.controller.updateTreeWidget();
     }
   }
    
    /**
     * Closes the workflow dialog.
     */
    this.onWfActionCancelled = function()
    {
        this.wfDlg.hide();
        if(this.wfAdhocPane)
           location.reload();
    }
    
    /**
     * Sets the adhoc results pane with the adhoc results url. 
     * The base adhoc results url is appended with sys_contentid, rolename and 
     * sys_transitionid parameters before setting onto thepane.
     */
    this.onSearchClicked = function()
    {
       this.adhocResultsPane.show();
       var wfurl = ps.util.addParamToUrl(this.adhocResultsUrl,"sys_contentid",this.contentId);
       wfurl = ps.util.addParamToUrl(wfurl,"sys_transitionid",this.actionId.getTransitionId());
       wfurl = ps.util.addParamToUrl(wfurl,"rolename",this.adhocRoleSelect.value);
       wfurl = ps.util.addParamToUrl(wfurl,"namefilter","%"+this.nameFilterText.value+"%");
       var mm = this;
       dojo.event.connect(this.adhocResultsPane, "onLoad", function()
       {
         var count = dojo.byId("ps.workflow.adhocusercount").value;
         mm.adhocUsersChk = new Array();
         for(var i=0; i<count; i++)
         {
            mm.adhocUsersChk[i] = dojo.byId("ps.workflow.adhocusercheckbox_"+i);
         }
       });
       this.adhocResultsPane.cacheContent = false;
       this.adhocResultsPane.setUrl(wfurl);
    }
    
    /**
     * Enables or disables the Add button based on the user selection
     */
    this.onUserChecked = function()
    {
       var _self = this;
       setTimeout(function(){    
         var disableAdd = true;
         for (var i=0; i<_self.adhocUsersChk.length; i++)
         {
            if (_self.adhocUsersChk[i].checked) 
            {
               disableAdd = false;
               break;
            }
         }
         _self.wgtButtonAdd.setDisabled(disableAdd);
       }, 250);
    }

    /**
     * Adds the users to the list of adhoc users.
     * Gets the current list and adds the new users by seperating them with ;.
     * Avoids the duplicate user names.
     */
    this.onAddClicked = function()
    {
      var newUsers = new Array();
      var count = 0;
      for (var i=0; i<this.adhocUsersChk.length; i++)
      {
         if (this.adhocUsersChk[i].checked) 
         {
            newUsers[count++] = this.adhocUsersChk[i].value;
         }
      }
       if(newUsers.length < 1)
       {
          alert("Please select at least one user to add.");
          return false;
       }
   	// First copy the original values
   	var newval = "";
      var oldUsers = this.wfAdhocUsers.value;
      var originalArray = oldUsers.split(";");
   	for(var i = 0; i < originalArray.length; i++)
   	{
   		var val = originalArray[i];
   		if (val != "")
   		{
   			newval = this._appendWithDel(newval,";",val);
   		}
   	}
   	// Now copy new values that don't exist in the existing values
   	for(i = 0; i < newUsers.length; i++)
   	{
   		var val = newUsers[i];
   		if (val.length > 0 && !this._contains(originalArray, val))
   		{
   			newval = this._appendWithDel(newval,";",val);
   		}
   	}

	    // Reset to new value
   	 this.wfAdhocUsers.value = newval;
   	 dojo.html.show(this.wfActionPane);
   	 this.wfAdhocPane.hide();
    }
    
    /**
     * Show the workflow actions pane and hide the adhoc pane.
     */
    this.onSearchClosed = function()
    {
       dojo.html.show(this.wfActionPane);
   	 this.wfAdhocPane.hide();
    }

   /**
    * Returns true if the given value is in the passed vector
    * @param vector a set of values
    * @param value a value to search the vector for
    */
   this._contains = function(vector, value)
   {
      var len = vector.length;
      var i = 0;
      while(i < len)
      {
      if (vector[i] == value) return true;
      i++;
      }
      return false;
   }
   // Append the new element using the delimiter. Omit the delimeter
   // if the string is empty
   this._appendWithDel = function(string, del, newelement)
   {
   	if (string.length == 0)
   	{
   		return newelement;
   	}
   	else
   	{
   		return string + del + newelement;
   	}
   }
   
   /**
    * Returns a trimmed comment string, entered by the user,
    * or "" if the comment field does not exist.
    */
   this._getComment = function ()
   {
      return this.wfCommentText
            ? dojo.string.trim(this.wfCommentText.value)
            : "";
   }
   
   /**
    * Returns a trimmed adhoc users string,
    * or "" if the adhoc users field does not exist.
    */
   this._getAdhocUsers = function ()
   {
      return this.wfAdhocUsers
            ? dojo.string.trim(this.wfAdhocUsers.value)
            : "";
   }
   
   /**
    * Indicates whether the user is authorized to perform workflow actions.
    */
   this._isUserAuthorized = function ()
   {
      return this.wfActionPane;
   }
};

/**
 * Constructs an object of workflow action from a JSON string.
 * @param {String} idString The JSON string for workflow actions. 
 *    It is an array of pre-defined values of
 * ACTION_NAME - name of the action
 * WORKFLOW_COMMENT - has three values 0 - hide the comment box, 
 * 1 - comment optional, 2 - comment required.
 * SHOW_ADHOC - has two values 0 - no adhoc and 1 - show adhoc.
 * ACTION_TYPE - the type of the action 0 - checkin 1 - forcecheckin 2 - checkout
 * 3 - transition_checkout 4 - transition.
 * WF_ACTION - the trigger name
 * WF_TRANSITIONID - the transition id.
 * 
 */
ps.workflow.ActionId = function(idString)
{
   /**
    * Stores the id in serialized format as in 'string'
    */
   this.idString = idString;
   
   /**
    * Stores the list of values into array.
    */
   this.idobj = dojo.json.evalJson(idString);
   
   /**
    * Determines if the specified object equals this object.
    * 
    * @param {ps.aa.ObjectId} other The object in question.
    * 
    * @return 'true' if both objects have the same value; 'false' otherwise.
    */
   this.equals = function(other)
   {
      if ((typeof other == 'undefined') || other == null)
         return false;
      else
         return this.idString == other.idString;
   }
   
   /**
    * Convert this object to a JSON string. It is the reverse operation of the
    * constructor.
    */
   this.serialize = function()
   {
      return this.idString;
   }
   
   /**
    * @return true if the comment box is needed otherwise false.
    */
   this.isCommentBoxNeeded = function()
   {
       return this.idobj[ps.workflow.ActionId.WORKFLOW_COMMENT] > 0;
   } 

   /**
    * @return true if the comment is required otherwise false.
    */
   this.isCommentRequired = function()
   {
       return this.idobj[ps.workflow.ActionId.WORKFLOW_COMMENT] == 2;
   }
   
   /**
    * @return true if the Adhoc box is needed otherwise false.
    */
   this.isAdhocBoxNeeded = function()
   {
       return this.idobj[ps.workflow.ActionId.SHOW_ADHOC] == 1;
   }
   
   /**
    * Returns the type of action.
    */
   this.getActionType = function()
   {
       return this.idobj[ps.workflow.ActionId.ACTION_TYPE];
   }
   
   /**
    * Returns the transition trigger name.
    */
   this.getWfAction = function()
   {
      return this.idobj[ps.workflow.ActionId.WF_ACTION];
   }
   
   /**
    * Returns the transition id.
    */
   this.getTransitionId = function()
   {
      return this.idobj[ps.workflow.ActionId.WF_TRANSITIONID];
   }

   /**
    * Returns the label of action.
    */
   this.getActionLabel = function()
   {
       return this.idobj[ps.workflow.ActionId.WF_ACTION_LABEL];
   }
};

ps.workflow.ActionId.ACTION_NAME=0;
ps.workflow.ActionId.WORKFLOW_COMMENT=1;
ps.workflow.ActionId.SHOW_ADHOC=2;
ps.workflow.ActionId.ACTION_TYPE=3;
ps.workflow.ActionId.WF_ACTION=4;
ps.workflow.ActionId.WF_TRANSITIONID=5;
ps.workflow.ActionId.WF_ACTION_LABEL=6;

ps.workflow.ActionId.ACTION_TYPE_CHECKIN=0;
ps.workflow.ActionId.ACTION_TYPE_FORCE_CHECKIN=1;
ps.workflow.ActionId.ACTION_TYPE_CHECKOUT=2;
ps.workflow.ActionId.ACTION_TYPE_TRANSITION_CHECKOUT=3;
ps.workflow.ActionId.ACTION_TYPE_TRANSITION=4;





/******************************************************************************
 *
 * [ ps.aa.field.js ]
 *
 * COPYRIGHT (c) 1999 - 2007 by Percussion Software, Inc., Woburn, MA USA.
 * All rights reserved. This material contains unpublished, copyrighted
 * work including confidential and proprietary information of Percussion.
 *
 *****************************************************************************/
 
dojo.provide("ps.aa.Field");






/**
 * The field object. Manages the field editing.
 */
ps.aa.Field = function()
{
    this.objectId = null;
    this.refreshField = false;
    this.psCeFieldWindow = null;
    this.fieldModalDlg = null;
    this.renderer = null;
    this.ceUrl = null;
    this.divElem = null;
    this.inplaceEditing = null;
    
   /**
    * Initializion of Field object.
    */
   this.init = function()
   {
   }
   
   /**
    * Creates the field modal dialog if it is not created yet.
    * Stores the dialog in the {@link #fieldModalDlg} field.
    */
   this.maybeCreateFieldModalDlg = function ()
   {
      if (this.fieldModalDlg)
      {
         return;
      }

      this.fieldModalDlg = ps.createDialog(
            {
               id: "ps.Field.FieldEditingDlg",
               title: "Edit Field"
            }, "200px", "100px");
      
      var _this = this;

      //override the dialog close function
      // to not destroy the dialog
      this.fieldModalDlg.closeWindow = function()
      {
         _this.fieldModalDlg.hide();
      }
      dojo.event.connect(this.fieldModalDlg, "onLoad", function()
      {
         _this.parseControls();
      });
   }

   /**
    * Creates the inplace editing dialog if it is not created yet.
    * Stores the dialog in the {@link #inplaceDlg} field.
    */
   this.maybeCreateInplaceDlg = function ()
   {
      if (this.inplaceDlg)
      {
         // already created
         return;
      }

      var div = document.createElement('div');
      div.style.position = "absolute";
      div.style.border = "0px";
      document.body.appendChild(div);

      this.inplaceDlg = dojo.widget.createWidget("ModalFloatingPane",
            {
               id: "ps.field.inplaceTextBoxDiv",
               titleBarDisplay: false,
               bgColor: ps.DIALOG_BACKGROUND,
               bgOpacity: ps.DIALOG_BACKGROUND_OPACITY,
               executeScripts: true,
               resizable: false
             }, div);
      this.inplaceDlg.setContent(
            '<input type="text" style="border:0px; padding:0px; margin-top:1px"'
               + 'size="50" id="ps.field.inplaceTextBox" '
               + 'name="ps.field.inplaceTextBox"/>\n'
            + '<div class="PsAaFieldButtonsbox">\n'
            + '<table align="center" width="100%" border="0">\n'
            + '<tr>\n'
            + '<td align="right">\n'
            + '<button dojoType="Button" id="ps.field.inplaceUpdateButton">'
               + 'Update</button>\n'
            + '</td>\n'
            + '<td align="left">\n'
            + '<button dojoType="Button" id="ps.field.inplaceCancelButton">'
               + 'Cancel</button>\n'
            + '</td>\n'
            + '</tr>\n'
            + '</table>\n'
            + '</div>');

      this.inplaceTextBox = dojo.byId("ps.field.inplaceTextBox");
      dojo.event.connect(
            this.inplaceTextBox, "onkeyup", this, "_onInplaceTextTyped");
      var updateButton = dojo.widget.byId("ps.field.inplaceUpdateButton");
      dojo.lang.assert(updateButton, "Update button could not be found");
      var cancelButon = dojo.widget.byId("ps.field.inplaceCancelButton");
      dojo.lang.assert(cancelButon, "Cancel button could not be found");

      dojo.event.connect(updateButton, "onClick", this, "updateField");
      dojo.event.connect(cancelButon, "onClick", this, "onInplaceCancel");
   }
   
   /**
    * Helper method called by init() to parse all the controls and connect 
    * events.
    */
   this.parseControls = function()
   {
      this.wgtButtonFullEditor = dojo.widget.byId("ps.Field.wgtButtonFullEditor");
      this.wgtButtonUpdate = dojo.widget.byId("ps.Field.wgtButtonUpdate");
      this.wgtButtonClose = dojo.widget.byId("ps.Field.wgtButtonClose");
      //Handle the buttons
      this.divRegularButtons = dojo.byId("psRegularButtons");
      this.divDojoButtons = dojo.byId("psDojoButtons");
      this.divRegularButtons.style.visibility = "hidden";
      this.divDojoButtons.style.visibility = "visible";

      dojo.event.connect(this.wgtButtonFullEditor, "onClick", this, "openFullEditor");
      dojo.event.connect(this.wgtButtonUpdate, "onClick", this, "updateField");
      dojo.event.connect(this.wgtButtonClose, "onClick", this, "_onDialogClose");
      var edfrm = dojo.byId("EditForm");
      edfrm.setAttribute("onsubmit","");
      var ceurl = this.ceUrl.split("?")[0];
      var suburl = ps.io.Actions.getUpdateItemUrl() + "&ceUrl=" + encodeURI(ceurl);
      ps.io.Actions.initFormBind(suburl,"EditForm",ps.io.Actions.MIMETYPE_JSON);
      this.initialCheckSum = ps_getAllFieldChecksums(document.EditForm,true);
   }

   /**
    * Dialog close.
    */
   this._onDialogClose = function()
   {
      var finalCheckSum =  ps_getAllFieldChecksums(document.EditForm,false);
      if(finalCheckSum != this.initialCheckSum)
      {
         if(confirm(this.FORM_CHANGE_WARNING_FOR_CLOSING))
         {
            this.updateField();
         }
      }
      this.fieldModalDlg.hide();
   }

   /**
    * Function to open the full editor.
    */
   this.openFullEditor = function()
   {
      var finalCheckSum =  ps_getAllFieldChecksums(document.EditForm,false);
      if(finalCheckSum != this.initialCheckSum)
      {
         if(confirm(this.FORM_CHANGE_WARNING_FOR_FULLEDITOR))
         {
            this.updateField();
         }
      }
      ps.aa.controller.editAll();
      this.fieldModalDlg.hide();
   }
       
   /**
    * Function to edit the filed
    * Checks whether alt key is pressed or not if it is, then simply returns true.
    * Calls controller to activate the element.
    * Calls content editor url server action to get the content editor url
    * Opens the editor dialog with the URL.
    */
   this.editField = function(divElem, e)
   {
      if(this.checkClickEvent(e))
         return true;
      ps.aa.controller.activate(divElem);
      //From the div element get the new objectid
      var newObjId = ps.aa.Page.getObjectId(divElem);
      //Check whether the item is checked out or not
      if(newObjId.isCheckoutByMe() == 0)
      {
         alert(ps.aa.controller.CHECKOUT_MSG);
         return false;
      }
      
      //If a full editor window is open for editing an item, propmt user
      //whether he wants to open this field and cancel editing of the item?
      if(ps.aa.controller.psCeWindow && !ps.aa.controller.psCeWindow.closed)
      {
         if(!confirm(ps.aa.controller.EDITOROPEN_MSG))
         {
            ps.aa.controller.psCeWindow.focus();
            return false;
         }
         ps.aa.controller.psCeWindow.close();
      }
      //If a field editor window is open for editing a field, propmt user
      //whether he wants to open this field and cancel editing of the field?
      else if(this.psCeFieldWindow && !this.psCeFieldWindow.closed)
      {
         if(newObjId.equals(this.objectId) || !confirm(ps.aa.controller.EDITOROPEN_MSG))
         {
            this.psCeFieldWindow.focus();
            return false;
         }
         this.psCeFieldWindow.close();
      }
      //If a field is opened for inplace editing prompt user
      //whether he wants to open this field and cancel editing of the inplace field?
      else if(this.inplaceEditing)
      {
         if(!confirm(ps.aa.controller.INPLACE_EDITOROPEN_MSG))
            return false;
         this.onInplaceCancel();
      }
      
      this.objectId = ps.aa.controller.activeId;
      this.divElem = divElem;
      ps.aa.controller.editObjectId = this.objectId;
      //Get the content editor url and open a dialog with it.
      var response = ps.io.Actions.getUrl(this.objectId,"CE_FIELDEDIT");
      // handle failure         
      if (!response.isSuccess())
      {
         ps.io.Actions.maybeReportActionError(response);
         return false;
      }
      var value = response.getValue();
      dojo.lang.assert(dojo.lang.has(value, "url"));
      this.ceUrl = value.url;
      
      var dlgw = value.dlg_width?value.dlg_width:this.DEFAULT_CONTROL_WIDTH;
      var dlgh = value.dlg_height?value.dlg_height:this.DEFAULT_CONTROL_HEIGHT;
      this.renderer = value.aarenderer?value.aarenderer:this.DEFAULT_FIELD_RENDERER;

      if(this.renderer == this.FIELD_RENDERER_NONE)
      {
         if(confirm(this.FIELD_RENDERER_NONE_MESSAGE))
         {
            ps.aa.controller.editAll();
         }
         return;
      }
      else if(this.renderer == this.FIELD_RENDERER_MODAL)
      {
         this.maybeCreateFieldModalDlg();
         this.fieldModalDlg.setUrl(this.ceUrl);
         this.fieldModalDlg.show();
         this.fieldModalDlg.resizeTo(dlgw,dlgh);
      }
      else if(this.renderer == this.FIELD_RENDERER_INPLACE_TEXT)
      {
         var response = ps.io.Actions.getContentEditorFieldValue(this.objectId);
         if(!response.isSuccess())
         {
            ps.io.Actions.maybeReportActionError(response);
            return false;
         }
         this.onInplaceEdit(response.getValue());
      }
      else
      {
         var wstyle = "toolbar=0,location=0,directories=0,status=0,menubar=0,scrollbars=1,resizable=1,width=" + dlgw + ",height=" + dlgh ;
         this.psCeFieldWindow = window.open(this.ceUrl,ps.aa.controller.CE_EDIT_ITEM_WINDOW,wstyle);
         this.psCeFieldWindow.focus();
         return false;
      }
   },

   /**
    * Utility method to check the click event and returns true if any of the
    * control or shift or alt keys are pressed. It also stops the propagation 
    * of the Event.
    */
   this.checkClickEvent = function(e)
   {
      if(e)
      {
         //For ctrl and shift keys simply return
         if(e.ctrlKey || e.shiftKey)
            return true;
         //Stop the propagation of event
         dojo.event.browser.stopEvent(e);
         //Handle the alt key clicks
         if(e.altKey)
         {
            var tgt = e.target;
            if(typeof(tgt) == "undefined")
               tgt = e.srcElement;
            if (dojo.html.isTag(tgt, 'a'))
            {
               window.location.href = tgt.href;
               return true;
            }
            else if(dojo.html.isTag(tgt, 'div'))
            {
               var fieldLink = dojo.html.getAttribute(tgt, "fieldLink");
               if(typeof(fieldLink) != "undefined" && fieldLink.length > 0)
               {
                  window.location.href = fieldLink;
                  return true;
               }
            }
            return true;
         }
      }
      return false;
   }
   
   /**
    * Is called when on onkeyup event for the inline editing text box.
    * Handles Enter and Esc keys in this control.
    */
   this._onInplaceTextTyped = function(e)
   {
      e_v = e;
      if (e.ctrlKey || e.shiftKey || e.altKey || e.metaKey)
      {
         return;
      }
      if (e.keyCode === e.KEY_ENTER)
      {
         this.updateField();
      }
      else if (e.keyCode === e.KEY_ESCAPE)
      {
         this.onInplaceCancel();
      }
   }

   /**
    * Cancels inplace editing
    */
   this.onInplaceCancel = function()
   {
      this.inplaceEditing = false;
      this.inplaceDlg.hide();
      dojo.html.show(this.divElem);
   }

   /**
    * Opens the field for inplace editing.
    * @param {String} value the initial textbox value.
    */
   this.onInplaceEdit = function (value)
   {
      this.inplaceEditing = true;
      this.maybeCreateInplaceDlg();
      this.inplaceTextBox.value = value;

      var dn = this.inplaceDlg.domNode;
      
      // place the editor over the editing element
      var elemPos = dojo.html.getAbsolutePosition(this.divElem);
      var dlgPadding = 0;
      dn.style.left = (elemPos.left - dlgPadding) + "px";
      dn.style.top = (elemPos.top - dlgPadding) + "px";

      var width = dojo.html.getBorderBox(this.divElem).width;
      this.inplaceTextBox.style.width = width + "px";

      // to disable automatic dialog placement at the center of the page
      this.inplaceDlg.placeModalDialog = function () {};

      this.inplaceDlg.show();

      if (!this.inplaceDlgHeight)
      {
         this.inplaceDlgHeight =
             dojo.html.getBorderBox(this.inplaceDlg.domNode).height + 10;
      }
      this.inplaceDlg.resizeTo(width, this.inplaceDlgHeight);
      this.inplaceTextBox.focus();

      dojo.html.hide(this.divElem);
   }

   /**
    * Updates the fields and refreshes the page. 
    * If the renderer is POPUP the update takes place in popup window, we
    * just refresh the page. 
    * If the renderer is MODAL dialog box then we submit the form and refresh 
    * the page if the submission succeeds.  
    */
   this.updateField = function()
   {
      if(this.renderer == this.FIELD_RENDERER_MODAL)
      {
         var response = ps.io.Actions.submitForm(document.EditForm);
         if(!response.isSuccess())
         {
            ps.io.Actions.maybeReportActionError(response);
            return false;
         }
         var value = response.getValue();
         //Check for the cmsErrors first and warn the user about it.
         if(dojo.lang.has(value, "cmsError"))
         {
            alert(value.cmsError);
            return false;         
         }
         else if(dojo.lang.has(value, "validationError"))
         {
            if(!confirm(value.validationError + this.FIELD_VALIDATION_CONFIRM_MSG_PART2))
               return false;
            this.fieldModalDlg.hide();
            ps.aa.controller.editAll(value.ceCachedPageUrl);
            return false;
         }
         else
         {
            this.initialCheckSum = ps_getAllFieldChecksums(document.EditForm,true);
         }
      }
      else if(this.renderer == this.FIELD_RENDERER_INPLACE_TEXT)
      {
         var response = ps.io.Actions.setContentEditorFieldValue(this.objectId,this.inplaceTextBox.value);
         if(!response.isSuccess())
         {
            ps.io.Actions.maybeReportActionError(response);
            return false;
         }
         var value = response.getValue();
         //Check for the cmsErrors first and warn the user about it.
         if(dojo.lang.has(value, "cmsError"))
         {
            alert(value.cmsError);
            return false;         
         }
         else if(dojo.lang.has(value, "validationError"))
         {
            if(!confirm(value.validationError + this.FIELD_VALIDATION_CONFIRM_MSG_PART2))
               return false;
            this.onInplaceCancel();
            ps.aa.controller.editAll();
            return false;
         }
         this.onInplaceCancel();
      }
      ps.aa.controller.refreshFieldsOnPage(this.objectId.getContentId(),this.objectId.getFieldName(),this.psCeFieldWindow);
   }
   
   /**
    * Constant for defualt field height for the controls
    */
   this.DEFAULT_CONTROL_HEIGHT = 300;
   
   /**
    * Constant for default field width for the controls
    */
   this.DEFAULT_CONTROL_WIDTH = 400;
   
   /**
    * Constant for defualt field renderer
    */
   this.DEFAULT_FIELD_RENDERER = this.FIELD_RENDERER_POPUP;
   
   /**
    * Constant for field renderer modal dialog box
    */
   this.FIELD_RENDERER_MODAL = "MODAL";
   
   /**
    * Constant for field renderer popup dialog box
    */
   this.FIELD_RENDERER_POPUP = "POPUP";
   
   /**
    * Constant for field renderer none
    */
   this.FIELD_RENDERER_NONE = "NONE";

   /**
    * Constant for field renderer inplace text box
    */
   this.FIELD_RENDERER_INPLACE_TEXT = "INPLACE_TEXT";
   
   /**
    * Constant for field validation error confirmation message part2.
    */
   this.FIELD_VALIDATION_CONFIRM_MSG_PART2 = "\nClick OK to open the full content editor or Cancel to continue editing.";
   
   /**
    * Constant for form change warning when user clicks close button.
    */
   this.FORM_CHANGE_WARNING_FOR_CLOSING = "Changes have been made.\nDo you want to save before closing?"; 

   /**
    * Constant for form change warning when user clicks close button.
    */
   this.FORM_CHANGE_WARNING_FOR_FULLEDITOR = "Changes have been made.\nDo you want to save before opening full editor?";
   
   /**
    * Constant for message shown when the field renderer is none.
    */ 
    this.FIELD_RENDERER_NONE_MESSAGE = "The source of the data comes from a hidden field.\nIt can probably be modified by editing another field in the content item.\n\nClick OK to open the full editor.";

};


dojo.kwCompoundRequire({
	common: [
		"ps.aa.controller",
		"ps.aa.dnd",
		"ps.aa.Field",
		"ps.aa.Menu",
		"ps.aa.Page",
		"ps.aa.SnippetMove",
		"ps.aa.Tree"
	]
});
dojo.provide("ps.aa.*");


dojo.kwCompoundRequire({
	common: [
		"ps.content.Browse",
		"ps.content.History",
		"ps.content.SelectTemplates"
	]
});
dojo.provide("ps.content.*"); 


dojo.kwCompoundRequire({
	common: ["ps.io.Actions",
	"ps.io.Response"] // a generic dependency
});
dojo.provide("ps.io.*");


/******************************************************************************
 *
 * [ ps.widget.MenuBar2.js ]
 *
 * COPYRIGHT (c) 1999 - 2007 by Percussion Software, Inc., Woburn, MA USA.
 * All rights reserved. This material contains unpublished, copyrighted
 * work including confidential and proprietary information of Percussion.
 *
 *****************************************************************************/
 
dojo.provide("ps.widget.MenuBar2");



/**
 * Override dojo.widget.PopupMenu2.closeSubmenu() function to avoid gain
 * focus on the original window instead of the popup window.
 */
dojo.widget.defineWidget(
	"ps.widget.MenuBar2",
	dojo.widget.MenuBar2,
{
   /**
    * Override dojo.widget.PopupMenu2.closeSubmenu() function, so that 
    * we can avoid the following statement of, this.parent.domNode.focus(), 
    * which is called inside dojo.widget.PopupContainerBase.close() function.
    * The above statement will always make the current Window gain focus and
    * push any popup Window behind (the popup window is invoked by a menu item
    * from the menubar). 
    * For some reason, the above problem works for FireFox, but not IE, and it
    * is not an issue with the context menu.
    * 
    * @param {boolean} force true if force to close the sub popup.
    */
   closeSubmenu: function(force){
      // summary: close the currently displayed submenu
      if (this.currentSubmenu == null){ return; }

      // set the parent property to null to avoid a statement of
      // this.parent.domNode.focus() in the dojo.widget.PopupContainerBase.close()
      if (this.currentSubmenu.parent)
         this.currentSubmenu.parent = null;

      this.currentSubmenu.close(force);
      this.currentSubmenu = null;

      this.currentSubmenuTrigger.is_open = false;
      this.currentSubmenuTrigger._closedSubmenu(force);
      this.currentSubmenuTrigger = null;
   }

});

/******************************************************************************
 *
 * [ ps.widget.MenuBarIcon.js ]
 *
 * COPYRIGHT (c) 1999 - 2007 by Percussion Software, Inc., Woburn, MA USA.
 * All rights reserved. This material contains unpublished, copyrighted
 * work including confidential and proprietary information of Percussion.
 *
 *****************************************************************************/
 
dojo.provide("ps.widget.MenuBarIcon");





/**
 * This widget is used to display an icon at the menubar. It supports the onClick
 * event.
 */
dojo.widget.defineWidget(
	"ps.widget.MenuBarIcon",
	dojo.widget.MenuBarItem2,
{
	templateString:
      '<span class="dojoMenuItem2" dojoAttachEvent="onClick: _onClick;">'
		+ '<img src="../sys_resources/images/aa/page_1.gif" alt="Icon" title="" verticalAlign="middle"/>'
      + '</span>',

	imgDomNode : null,
	
   setImage : function(imgUrl)
   {
      if (this.imgDomNode == null)
      {
         //var nodes = this.domNode.childNodes;
         //this.imgDomNode = nodes[0];
         this.imgDomNode = dojo.dom.getFirstChildElement(this.domNode, "img");
      }
      this.imgDomNode.setAttribute("src", imgUrl);
   },

   setTitle : function(title)
   {
      if (this.imgDomNode == null)
      {
         //var nodes = this.domNode.childNodes;
         //this.imgDomNode = nodes[0];
         this.imgDomNode = dojo.dom.getFirstChildElement(this.domNode, "img");
      }
      this.imgDomNode.setAttribute("title", title);
   }

});




/******************************************************************************
 *
 * [ ps.widget.MenuBarItem2.js ]
 *
 * COPYRIGHT (c) 1999 - 2007 by Percussion Software, Inc., Woburn, MA USA.
 * All rights reserved. This material contains unpublished, copyrighted
 * work including confidential and proprietary information of Percussion.
 *
 *****************************************************************************/
 
dojo.provide("ps.widget.MenuBarItem2");



/**
 * Extends the dojo MenuBarItem2 to do nothing to fix a weird menubar item 
 * renderng order issue. Whenver we mix custome menubar items and dojo menubar 
 * items the order is messed up. However, if we use all cutome menubar items it 
 * works fine.
 */
dojo.widget.defineWidget(
	"ps.widget.MenuBarItem2",
	dojo.widget.MenuBarItem2,
{
});

/******************************************************************************
 *
 * [ ps.widget.MenuBarItemDropDown.js ]
 *
 * COPYRIGHT (c) 1999 - 2007 by Percussion Software, Inc., Woburn, MA USA.
 * All rights reserved. This material contains unpublished, copyrighted
 * work including confidential and proprietary information of Percussion.
 *
 *****************************************************************************/
 
dojo.provide("ps.widget.MenuBarItemDropDown");



/**
 * Extends the dojo MenuBarItem2 to add the the decoration to indicate it is a 
 * drop down menu. Intended to be used only if the item is a drop down menu. 
 * When rendered, it puts a little down arrow at the end of the caption.
 * If method createSubmenu is specified, calls it to create a submenu on demand.
 */
dojo.widget.defineWidget(
	"ps.widget.MenuBarItemDropDown",
	dojo.widget.MenuBarItem2,
	function ()
	{
	   var _this = this;
	   
	   // listener, creating submenu on demand
	   function onCreateSubmenu()
	   {
	      if (_this.submenuCreated)
	      {
	         return;
	      }
	      _this.submenuCreated = true;
	      if (_this.createSubmenu)
	      {
	         _this.createSubmenu();
	      }
	   }

	   dojo.event.connectBefore(this, "_onClick", onCreateSubmenu);
	   dojo.event.connectBefore(this, "_openSubmenu", onCreateSubmenu);
	},
{
   // it would be nice to modify the super class template string to add 
   // the decoration instead of repeating that from the superclass.
   templateString:
         '<span class="dojoMenuItem2" dojoAttachEvent="onMouseOver: onHover; '
         + 'onMouseOut: onUnhover; onClick: _onClick;">'
         + '${this.caption} <span><img src="'
         + dojo.uri.dojoUri("../ps/widget/images/dropdownButtonsArrow.gif")
         + '" verticalAlign="middle"/></span></span>',

    // a function, which creates submenu.
    createSubmenu: null
});

/******************************************************************************
 *
 * [ ps.widget.PopupMenu.js ]
 *
 * COPYRIGHT (c) 1999 - 2006 by Percussion Software, Inc., Woburn, MA USA.
 * All rights reserved. This material contains unpublished, copyrighted
 * work including confidential and proprietary information of Percussion.
 *
 *****************************************************************************/
 
dojo.provide("ps.widget.PopupMenu");




/**
 * Added additional features based on dojo.widget.PopupMenu2.
 * If method createMenuItems is specified, calls it to create the menu items
 * on demand.
 */
dojo.widget.defineWidget(
   "ps.widget.PopupMenu",
   dojo.widget.PopupMenu2,
{
   /**
    * Binds all specified DOM nodes to this popup menu. 
    * 
    * @param {Array} targetNodes The array of ids in {string} or {DomNode} 
    *    that need to bind to this popup menu.
    */
   bindTargetNodes: function(targetNodes)
   {
      for (var i=0; i<targetNodes.length; i++)
      {
         this.bindDomNode(targetNodes[i]);
      }
   },

   /**
    * Unbinds all specified DOM nodes to this popup menu. 
    * 
    * @param {Array} targetNodes The array of ids in {string} or {DomNode} 
    *    that need to unbind to this popup menu.
    */
   unBindTargetNodes: function(targetNodes)
   {
      for (var i=0; i<targetNodes.length; i++)
      {
         this.unBindDomNode(targetNodes[i]);
      }
   },

   /**
    * Overwrite super, so that we have a chance to activate the target object
    * before open the context menu.
    * Lazily create menu items.
    */   
   onOpen: function(/*Event*/ e)
   {
      if (this.createMenuItems && !this.itemsCreated)
      {
         this.createMenuItems();
      }
      this.itemsCreated = true;

      if (e.currentTarget != null)
      {
         ps.aa.controller.activate(e.currentTarget);
      }
      ps.widget.PopupMenu.superclass.onOpen.apply(this, arguments);
   }
});


/******************************************************************************
 *
 * [ ps.widget.PSSplitContainer.js ]
 *
 * COPYRIGHT (c) 1999 - 2007 by Percussion Software, Inc., Woburn, MA USA.
 * All rights reserved. This material contains unpublished, copyrighted
 * work including confidential and proprietary information of Percussion.
 *
 *****************************************************************************/

dojo.provide("ps.widget.PSSplitContainer");



/**
 * The SplitContainer class overriden to allow disabling of the sizer bar
 */
dojo.widget.defineWidget("ps.widget.PSSplitContainer", dojo.widget.SplitContainer,
{
    
    /**
     * Sizer enabled flag, if <code>true</code> which is the default then the
     * sizer bar will move when dragged.
     */
    sizerEnabled: true,
    
    /**
     * Flag indicating that the sizer should be visible.
     * Defaults to <code>true</code>
     */
    sizerVisible: true,    
    
    /**
     * Overridden method to control when sizing is allowed.
     * @see dojo.widget.SplitContainer#beginSizing for more detail
     */
    beginSizing: function(e, i)
    {
       if(this.sizerEnabled)
       {
          ps.widget.PSSplitContainer.superclass.beginSizing.apply(this, arguments);
       }
    },
    
    /**
     * Overriden to set the default cursor if the sizer is disabled
     */
    postCreate: function(args, fragment, parentComp)
    {
	ps.widget.PSSplitContainer.superclass.postCreate.apply(this, arguments);
	if(!this.sizerEnabled)
	{
	   this.virtualSizer.style.cursor = 'default';
	   for(i = 0; i < this.sizers.length; i++)
	   {
	      this.sizers[i].style.cursor = 'default';
	   }
	}
	if(!this.sizerVisible)
	{
	   this.virtualSizer.style.visibility = 'hidden';
	   for(i = 0; i < this.sizers.length; i++)
	   {
	      this.sizers[i].style.visibility = 'hidden';
	   }
	}
	
    }
    
});



/******************************************************************************
 *
 * [ ps.widget.Tree.js ]
 *
 * COPYRIGHT (c) 1999 - 2007 by Percussion Software, Inc., Woburn, MA USA.
 * All rights reserved. This material contains unpublished, copyrighted
 * work including confidential and proprietary information of Percussion.
 *
 *****************************************************************************/

/**
 * Comments from Dojo (dojo.widget.TreeV3):
 * Tree model does all the drawing, visual node management etc.
 * Throws events about clicks on it, so someone may catch them and process
 */

dojo.provide("ps.widget.Tree");







dojo.widget.defineWidget(
   "ps.widget.Tree",
   dojo.widget.TreeV3,
{
   /**
    * Selector helps activate the nodes (selects) them.
    */
   selector:"",
   
   /**
    * Tree Model.
    * @see ps.aa.Tree
    */
   model : null,
   
   /**
    * Flag to see if the tree is already loaded or not.
    */
   loaded : false,
   
   /**
    * Tree controller.
    */
   treeController : null,
   
   /**
    * Load custom css
    */
   templateCssPath: dojo.uri.moduleUri("ps", "widget/Tree.css"),

   /**   
    * Slot nodes, for which initialization is not completed yet.
    */
   delayedInitSlotNodes: [],
   
   /**
    * Item nodes, for which initialization is not completed yet.
    */
   delayedInitItemNodes: [],
   
   /**
    * Indicates whether browser supports Array.indexOf.
    */
   indexOfSupported: Array.indexOf,
   
   /** Creates a tree node from a model node.
    * 
    * @param {ps.aa.TreeNode} modelNode
    * 
    * @return {dojo.widget.TreeNodeV3}
    */
   createWidgetFromModelNode : function (modelNode) 
   {
      // dojo.debug("Creating widget node from model " + modelNode.toString());
      dojo.lang.assertType(modelNode, ps.aa.TreeNode);
      var title = modelNode.getLabel();
      var widgetId = modelNode.objId.getTreeNodeWidgetId();
      var widgetNode = dojo.widget.createWidget("TreeNodeV3", 
         {
            title: title, 
            tree: this.widgetId, 
            id: widgetId,
            modelId: modelNode.objId,
            tryLazyInit: true,
            isFolder: !modelNode.isLeafNode()
         });
      var _this = this;
      widgetNode.setChildren = function ()
      {
         // get model node again, because it could be changed already
         var n = _this.model.getNodeById(widgetNode.modelId);
         if (!n.isLeafNode())
         {
            for (var i = 0; i < n.childNodes.count; i++) {
               var childModel = n.childNodes.item(i);
               widgetNode.addChild(_this.createWidgetFromModelNode(childModel));
            }
         }
      }

      var oid = modelNode.objId;
      var noMove = !oid.isSnippetNode();
      var hasParentCanCheckout = modelNode.parentNode && 
            modelNode.parentNode.objId.isCheckoutByMe();
      var noAddChild = !(oid.isSlotNode() && hasParentCanCheckout) 
         || oid.isPageNode();
      var actionsDisabled = [];
      if (noAddChild) actionsDisabled.push("ADDCHILD");
      if (noMove) actionsDisabled.push("MOVE");
      widgetNode.actionsDisabled = actionsDisabled;

      //For some reason dojo does not set html id's to tree nodes
      widgetNode.domNode.setAttribute("id",widgetId);
      this._bindContextMenu(widgetNode);
      return widgetNode;
   },

   /**
    * Binds the context menu to a node widget.
    * 
    * @param {dojo.widget.TreeNodeV3}
    */
   _bindContextMenu : function(widget)
   {        
      var objId = widget.modelId;
      // it's possible the menus are not created yet during initialization
      if (objId.isSlotNode()) {
         if (ps.aa.Menu.slotCtxMenu)
         {
            ps.aa.Menu.slotCtxMenu.bindTargetNodes([widget.domNode]);
         }
         else
         {
            dojo.lang.assert(!this.indexOfSupported
                  || this.delayedInitSlotNodes.indexOf(widget.domNode) === -1,
                  "Slot node is registered more than once: " + widget.domNode);
            this.delayedInitSlotNodes.push(widget.domNode);
         }
      }
      else
      {
         if (ps.aa.Menu.itemCtxMenu)
         {
            ps.aa.Menu.itemCtxMenu.bindTargetNodes([widget.domNode]);
         }
         else
         {
            dojo.lang.assert(!this.indexOfSupported
                  || this.delayedInitItemNodes.indexOf(widget.domNode) === -1,
                  "Snippet node is registered more than once: " + widget.domNode);
            this.delayedInitItemNodes.push(widget.domNode);
         }
      }
   },

   /**
    * Unbinds the context menu from the node widget.
    * 
    * @param {dojo.widget.TreeNodeV3}
    */
   _unBindContextMenu : function(widget)
   {        
      var objId = widget.modelId;
      if (objId.isSlotNode()) {
         ps.aa.Menu.slotCtxMenu.unBindTargetNodes([widget.domNode]);
      }
      else {
         ps.aa.Menu.itemCtxMenu.unBindTargetNodes([widget.domNode]);  
      }     
   },
   
   /**
    * Loads the tree by creating node widgets based on the model.
    * 
    * @param {ps.aa.Tree} model
    */
   loadFromModel : function (model) 
   {
      this.treeController = dojo.widget.manager.getWidgetById("treeController");
      this.actionsDisabled.push('ADDCHILD');
      this.model = model;
      
      this._loadModel();
   },
   
   /**
    * Finishes functionality of {@link loadModel}, which can be executed later
    * and requires other UI subsystems to be initialized.
    * @param {ps.aa.Tree} model the tree model to use. Not null.
    */
   loadFromModelAsynch : function (model)
   {
      dojo.lang.assertType(model, ps.aa.Tree);
      if (this.delayedInitSlotNodes.length)
      {
         ps.aa.Menu.slotCtxMenu.bindTargetNodes(this.delayedInitSlotNodes);
      }
      if (this.delayedInitItemNodes.length)
      {
         ps.aa.Menu.itemCtxMenu.bindTargetNodes(this.delayedInitItemNodes);
      }
   },
   
   /**
    * Reloads the model.
    */
   _loadModel: function () 
   {
      if (this.loaded)
      {
         dojo.lang.assert(this.children);
         dojo.lang.assertType(this.children,Array);
         if (this.children.length > 0)
         {
            var child = this.children[0];
            dojo.lang.assertType(child, dojo.widget.TreeNodeV3);
            this.removeChild(child);
            child.destroy();
         }
         var treeDnd = dojo.widget.manager.getWidgetById("treeDndController");
         if (treeDnd)
         {
            treeDnd.reset();
         }
      }

      var rootModelNode = this.model.getRootNode();
      var rootWidgetNode = this.createWidgetFromModelNode(rootModelNode);
      this.addChild(rootWidgetNode);

      this.treeController.expandToLevel(this, this.expandLevel);
      this.loaded = true;
   },
   
   /**
    * Initializes the tree Drag-and-Drop functionality.
    */
   dndInit: function ()
   {
      if (dojo.widget.manager.getWidgetById("treeDndController"))
      {
         return;
      }

      var dndController = dojo.widget.createWidget("ps:TreeDndController", {
         id: "treeDndController",
         controller: "treeController"
      });
      dndController.listenTree(this);
   },
 
    /** 
    * Updates a tree node from a model node.
    * 
    * @param {ps.aa.TreeNode} modelNode
    * @param {dojo.widget.TreeNodeV3} treeNodeWidget
    * 
    * @return {dojo.widget.TreeNodeV3}
    */
   _updateWidgetFromModelNode : function (modelNode,parentWidget) 
   {

      //dojo.debug("Trying to update an existing tree " +
      //      "node widget with modelNode: " + modelNode.toString());
      
      var childWidget = this.getWidgetFromModelNode(modelNode);
      if (childWidget) {
         //dojo.debug("sync: Found an existing widget that " +
         //      "matchs this modelNode: " + modelNode.toString());
         if (!parentWidget) 
         {
            //dojo.debug("parentWidget is null so this must be the root node.");
         }
         else if (parentWidget == childWidget.parent) 
         {
            //dojo.debug("This child node had the same parent as before (OK).");
            childWidget.doDetach();
         }
         else 
         {
            /*
             * detach the child from the old parent and attach it to the
             * new parent.
             */
            //dojo.debug("Detaching child widget from old parent.");
            childWidget.doDetach();
            // The caller of this method will add the node to the parent.
         }
         
         if (childWidget.title != modelNode.getLabel()) 
         {
            //dojo.debug("Title changed from " + childWidget.title 
            // + " to " + modelNode.getLabel());
            childWidget.setTitle(modelNode.getLabel());
         }
         childWidget.modelId = modelNode.objId;
      }
      else /* did not find widget for model */ 
      {
         //dojo.debug("Did not find widget corresponding to model node");
         childWidget = this.createWidgetFromModelNode(modelNode);
      }
      return childWidget;
   },  

   /**
    * Removes the tree nodes that are no longer exist in the tree model.
    */   
   _cleanTree : function () 
   {
      //dojo.debug("Tree - Cleaning Tree - Start");

      var deadNodes = [];
      var root = this.children[0];
      var stack = [root];
      while (wNode = stack.pop()) {
         var mNode = this.model.getNodeById(wNode.modelId);
         if (mNode) 
         {
            //dojo.debug("Tree has node " + mNode.toString());
            for (var i = 0; i < wNode.children.length; i++) 
            {
               stack.push(wNode.children[i]);
            }
         }
         else 
         {
            //dojo.debug("Node is dead: " + wNode.toString());
            deadNodes.push(wNode);
         }
      }
      
      // removes all invalid nodes and its decendents
      for (var i = 0; i < deadNodes.length; i++) 
      {
         this._removeNodes(deadNodes[i]);
      }
      //dojo.debug("Tree - Cleaning Tree - End");
   },

   /**
    * Removes a node and its decendent nodes from the tree.
    * 
    * @param {dojo.widget.TreeNodeV3} node The to be removed node, which may 
    *    contain child node.
    */
   _removeNodes : function (node) 
   {
      //dojo.debug("Tree - Removing NODES: " + node.modelId.toString() + ", len=" + node.children.length);
      dojo.lang.assert(node, "Can't remove null node.");   

      // removes the child nodes first if any      
      while (node.children.length > 0) 
      {
         this._removeNodes(node.children[0]);
      }

      this._removeNode(node);
   },
      
   
   /**
    * Removes a node from the tree.
    * 
    * @param {ojo.widget.TreeNodeV3} node The to be removed node, which may not
    *    contain any child node.
    */
   _removeNode : function (node) 
   {
      //dojo.debug("Tree - Removing node: " + node.modelId.toString());
      
      dojo.lang.assert(node, "Can't remove null node.");   
      dojo.lang.assert(!node.children.length,
            "Can't remove a node with children.");   

      this._unBindContextMenu(node);
      node.destroy();
   },
      
   /**
    * Reloads the model.
    */
   _synchModel: function () 
   {
      //dojo.debug("Tree - Synchronizing Tree to Model - Start");
      
      // Clean Widgets that are no longer in the tree.
      this._cleanTree();
      if (this.children.length == 0)
      {
         this._loadModel();
         return;
      }
      
      var rootModelNode = this.model.getRootNode();
      var rootWidgetNode = this._updateWidgetFromModelNode(rootModelNode,null);
      var child = this.children[0];
      
      //dojo.debug("original root = " + child);
      //dojo.debug("new root = " + rootWidgetNode);
      
      dojo.lang.assert(child == rootWidgetNode, 
            "The root widget node should not have changed.");

      var modelAndWidget = {model:rootModelNode, widget:rootWidgetNode};
      var stack = [modelAndWidget];
      while (mw = stack.pop()) 
      {
         var w = mw.widget;
         var m = mw.model;
         if (!m.isLeafNode() && !w.tryLazyInit) 
         {            
            //dojo.debug("Number of children: " + m.childNodes.count);
            for (var i = 0; i < m.childNodes.count; i++) {
               var childModel = m.childNodes.item(i);
               var childWidget = this._updateWidgetFromModelNode(childModel,w);
               stack.push({model:childModel,widget:childWidget});
               w.addChild(childWidget,i,false);
            }
         }
         else 
         {
            //dojo.debug("Tree - leaf node, no children");
         }
         this._updateIsFolderFromModel(w, m);
      }
      this.loaded = true;
      var treeDnd = dojo.widget.manager.getWidgetById("treeDndController");
      if (treeDnd)
      {
         treeDnd.reset();
      }

      //dojo.debug("Tree - Synchronizing Tree to Model - End");
   },

    /** 
     * Insures that tree node widget folder indicator value corresponds to
     * the model.
     * 
     * @param {dojo.widget.TreeNodeV3} nodeWidget the node widget to set folder
     * status value for.
     * Assumed not null.
     * @param {ps.aa.TreeNode} modelNode the corresponding model.
     * Assumed not null.
     */
   _updateIsFolderFromModel : function (nodeWidget, modelNode) 
   {
      if (nodeWidget.tryLazyInit)
      {
         if (!modelNode.isLeafNode() !== nodeWidget.isFolder)
         {
            // model and lazy node are out of sync
            if (modelNode.isLeafNode())
            {
               nodeWidget.unsetFolder();
            }
            else
            {
               nodeWidget.setFolder();
            }
         }
      }
      else
      {
         // ignore non-lazy nodes
      }
   },

   /**
    * Get tree node widget from a tree node model id.
    * 
    * @param {ps.aa.ObjectId} objId
    */
   getWidgetFromModelId : function (objId) 
   {
       var widgetId = objId.getTreeNodeWidgetId();
       var widget = dojo.widget.manager.getWidgetById(widgetId);
       return widget;
   },
    
   /**
    * Get widget from model node.
    * @param {ps.aa.TreeNode} treeNode
    */
   getWidgetFromModelNode : function (treeNode) 
   {
       return this.getWidgetFromModelId(treeNode.objId);
   },
    
   /**
    * Selects the widget node give the corresponding model node.
    * @param {ps.aa.ObjectId} treeNodeId
    */
   activate : function (treeNodeId) 
   {
      var _this = this;
      // expand from top to trigger lazy node loading
      function expandTo(n)
      {
         dojo.lang.assert(n, "Tree model node is expected to be not null.");
         if (n.parentNode)
         {
            expandTo(n.parentNode);

            var w = _this.getWidgetFromModelId(n.parentNode.objId);
            dojo.lang.assert(w, "Can't find a widget for  " + n.parentNode);
            w.expand();
         }
      }

      var treeNode = this.model.getNodeById(treeNodeId);
      expandTo(treeNode);
      var widget = this.getWidgetFromModelId(treeNode.objId);
      var selector = dojo.widget.manager.getWidgetById(this.selector);
      selector.deselectAll();
      selector.select(widget);
   },

   /**
    * doMove is used to move snippets within a slot or to a new slot.
    * @see {dojo.widget.TreeV3#doMove}
    * @Override dojo.widget.TreeV3#doMove
    */
	doMove: function(child, newParent, index) 
	{
		//dojo.debug("Tree move: "+child+" to "+newParent+" at "+index);
      //ps.aa.SnippetMove = function (snippetId, slotId, targetSlotId, targetIndex,
      // dontUpdatePage)
      
      dojo.lang.assert(child.modelId, "Node being moved does not have a model");
      dojo.lang.assert(newParent.modelId, "Node being moved does not have a model");
      var pid = newParent.modelId;
      var cid = child.modelId;
      dojo.lang.assert(cid.isSnippetNode(), "child is not a snippet.");
      var childModelNode = this.model.getNodeById(child.modelId);
      var parentModelNode = childModelNode.parentNode;
      dojo.lang.assert(parentModelNode, "Unable to get the parent model node.");
      var sid = parentModelNode.objId;
      dojo.lang.assert(sid.isSlotNode(), "Original parent of child is not a slot.");
      dojo.lang.assert(pid.isSlotNode(), "New parent is not a slot.");
      var targetSlotId = pid;
      var snippetId = cid;
      var slotId = sid;
      
      var move = new ps.aa.SnippetMove(snippetId, slotId, targetSlotId, 
         (index + 1), false);
      var success = ps.aa.controller.moveToSlot(move);
      
      
		//var parent = child.parent;
		if (success == true) 
		{
         //dojo.debug("Tree - successful move.");
		   var snipid = move.getTargetSnippetId();
		   try
		   {
		      // could fail if the target slot requires a template change
		      // and the template selection dialog is called
            ps.aa.controller.activate(snipid);
		   }
		   catch (e) {
		      dojo.debug("Ignore on a template change request")
		      dojo.debug(e);
		   }
		   //We don't need resync the tree because the controller will.
		}
		else
		{
         dojo.debug("Tree - move failed.");
		}
	},
	
   /**
    * A listener for {@link ps.aa.Tree#onModelChanged}.
    * @see ps.aa.Tree
    */
   onModelChanged : function ()
   {
      //dojo.debug("tree on model change called.");

      if (this.loaded) {
         this._synchModel();
      }
      else {
         this._loadModel();
      }

      //dojo.debug("tree on model change SUCCESSFUL");
	 }
});


dojo.provide("dojo.widget.TreeDndControllerV3");




dojo.experimental("Tree drag'n'drop' has lots of problems/bugs, it requires dojo drag'n'drop overhaul to work, probably in 0.5");
	
dojo.widget.defineWidget(
	"dojo.widget.TreeDndControllerV3",
	[dojo.widget.HtmlWidget, dojo.widget.TreeCommon],
	function() {
		this.dragSources = {};
		this.dropTargets = {};
		this.listenedTrees = {};
	},
{
	listenTreeEvents: ["afterChangeTree","beforeTreeDestroy", "afterAddChild"],
	listenNodeFilter: function(elem) { return elem instanceof dojo.widget.Widget}, 
	
	initialize: function(args) {
		this.treeController = dojo.lang.isString(args.controller) ? dojo.widget.byId(args.controller) : args.controller;
		
		if (!this.treeController) {
			dojo.raise("treeController must be declared");
		}
		
	},

	onBeforeTreeDestroy: function(message) {
		this.unlistenTree(message.source);
	},
	
	// first Dnd registration happens in addChild
	// because I have information about parent on this stage and can use it
	// to check locking or other things
	onAfterAddChild: function(message) {
		//dojo.debug("Dnd addChild "+message.child);
		this.listenNode(message.child);		
	},


	onAfterChangeTree: function(message) {
		/* catch new nodes on afterAddChild, because I need parent */		
		if (!message.oldTree) return;
		
		//dojo.debug("HERE");
		
		if (!message.newTree || !this.listenedTrees[message.newTree.widgetId]) {			
			this.processDescendants(message.node, this.listenNodeFilter, this.unlistenNode);
		}		
		
		if (!this.listenedTrees[message.oldTree.widgetId]) {
			// we have new node
			this.processDescendants(message.node, this.listenNodeFilter, this.listenNode);	
		}
		//dojo.profile.end("onTreeChange");
	},
	
	
	/**
	 * Controller(node model) creates DndNodes because it passes itself to node for synchroneous drops processing
	 * I can't process DnD with events cause an event can't return result success/false
	*/
	listenNode: function(node) {

		//dojo.debug("listen dnd "+node);
		//dojo.debug((new Error()).stack)
		//dojo.profile.start("Dnd listenNode "+node);		
		if (!node.tree.DndMode) return;
		if (this.dragSources[node.widgetId] || this.dropTargets[node.widgetId]) return;

	
		/* I drag label, not domNode, because large domNodes are very slow to copy and large to drag */

		var source = null;
		var target = null;

	
		if (!node.actionIsDisabled(node.actions.MOVE)) {
			//dojo.debug("reg source")
			
			//dojo.profile.start("Dnd source "+node);		
			var source = this.makeDragSource(node);
			//dojo.profile.end("Dnd source "+node);		

			this.dragSources[node.widgetId] = source;
		}

		//dojo.profile.start("Dnd target "+node);		
		//dojo.debug("reg target");
		var target = this.makeDropTarget(node);
		//dojo.profile.end("Dnd target "+node);		

		this.dropTargets[node.widgetId] = target;

		//dojo.profile.end("Dnd listenNode "+node);		


	},
	
	/**
	 * Factory method, override it to create special source
	 */
	makeDragSource: function(node) {
		return new dojo.dnd.TreeDragSourceV3(node.contentNode, this, node.tree.widgetId, node);
	},


	/**
	 * Factory method, override it to create special target
	 */
	makeDropTarget: function(node) {
		 return new dojo.dnd.TreeDropTargetV3(node.contentNode, this.treeController, node.tree.DndAcceptTypes, node);
	},

	unlistenNode: function(node) {

		if (this.dragSources[node.widgetId]) {
			dojo.dnd.dragManager.unregisterDragSource(this.dragSources[node.widgetId]);
			delete this.dragSources[node.widgetId];
		}

		if (this.dropTargets[node.widgetId]) {
			dojo.dnd.dragManager.unregisterDropTarget(this.dropTargets[node.widgetId]);
			delete this.dropTargets[node.widgetId];
		}
	}

});

/******************************************************************************
 *
 * [ ps.widget.TreeDndController.js ]
 *
 * COPYRIGHT (c) 1999 - 2007 by Percussion Software, Inc., Woburn, MA USA.
 * All rights reserved. This material contains unpublished, copyrighted
 * work including confidential and proprietary information of Percussion.
 *
 *****************************************************************************/

dojo.provide("ps.widget.TreeDndController");







dojo.widget.defineWidget(
	"ps.widget.TreeDndController",
	dojo.widget.TreeDndControllerV3,
	function() {
		this.dragSources = {};
		this.dropTargets = {};
		this.listenedTrees = {};
	},
{
   
	onBeforeTreeDestroy: function(message) {
	   //We don't want to stop listening to the tree because it will be
	   //reloaded with a new model most likely.
		//this.unlistenTree(message.source);
		dojo.debug("I would be not listening anymore but I am going to.");
	},
	
	reset : function() {
	   this.dragSources = {};
	   this.dropTargets = {};
	},
	
	/**
	 * Intercept the parent's makeDropTarget method to add listener on the drop
	 * target onDragOver call.
	 */
	makeDropTarget : function (node)
	{
	   var target = dojo.widget.TreeDndControllerV3.prototype.makeDropTarget
	         .apply(this, arguments);
	   dojo.event.connectAround(target, "onDragOver",
            this, "_onDragOver");
	   return target;
	},

   /**
    * A listener around all tree drop targets onDragOver calls.
    * Makes sure that is dropped only into allowed target.
    */
   _onDragOver : function (invocation)
   {
      var accepts = invocation.proceed();
      var targetId = invocation.object.treeNode.modelId;
      var targetSlotId = null;
      if(targetId.isSlotNode())
      {
         targetSlotId = targetId;
      }
      else if(targetId.isSnippetNode())
      {
         var snippetNode = ps.aa.controller.treeModel.getNodeById(targetId)
         targetSlotId = snippetNode.parentNode.objId;
      }
      if (accepts && targetSlotId)
      {
         var dragSource = invocation.args[0].dragObjects[0].dragSource;
         var snippetId = dragSource.treeNode.modelId;
         var snippetNode = ps.aa.controller.treeModel.getNodeById(snippetId)
         var slotId = snippetNode.parentNode.objId;
         return slotId.belongsToTheSameItem(targetSlotId);
      }
      else
      {
         return false;
      }
      dojo.lang.assert(false, "Should not reach here");
   }
});

/******************************************************************************
 *
 * [ ps.widget.TreeIcon.js ]
 *
 * COPYRIGHT (c) 1999 - 2007 by Percussion Software, Inc., Woburn, MA USA.
 * All rights reserved. This material contains unpublished, copyrighted
 * work including confidential and proprietary information of Percussion.
 *
 *****************************************************************************/

dojo.provide("ps.widget.TreeIcon");






dojo.widget.defineWidget(
   "ps.widget.TreeIcon",
   dojo.widget.TreeDocIconExtension,
{
   templateCssPath: dojo.uri.moduleUri("ps", "widget/TreeIcon.css"),
   
   
   /**
    * Gets the nominal node type to be used as part of 
    * CSS class selector. The CSS class is used to display the icon.
    * @Override
    *
    * @param {dojo.widget.TreeNodeV3} node
    * @return {String}
    * @see {#_getNodeType}
    */
   getnodeDocType: function(node) 
   {
      //dojo.debug("getnodeDocType called with Node: " + node);
      dojo.lang.assert(node);
      dojo.lang.assertType(node,dojo.widget.TreeNodeV3);
      var oid = node.modelId;
      dojo.lang.assert(oid, "node does not have model id attached to it.");
      var nodeDocType = this._getNodeType(oid);
      //dojo.debug("TreeIcon - doc type is: " + nodeDocType);
      return nodeDocType;
    },
    

   /**
    * Gets the node type for css class selector based
    * on the ObjectId.
    * 
    * @param {ps.aa.ObjectId} objId
    * @return {String} node type.
    */
   _getNodeType : function(objId)
   {   
      dojo.lang.assertType(objId,ps.aa.ObjectId);
      var objClass;
      if(objId.isPageNode())
      {
         objClass = ps.aa.PAGE_CLASS;
      }
      else if(objId.isSnippetNode())
      {
         objClass = ps.aa.SNIPPET_CLASS;
      }
      else if(objId.isSlotNode())
      {
         objClass = ps.aa.SLOT_CLASS;
      }
      else if(objId.isFieldNode())
      {
         objClass = ps.aa.FIELD_CLASS;
      }
      var myName = ps.aa.ObjectId.ImageNames[objClass] + objId.getCheckoutStatus();
      var initial = myName.substring(0,1);
      var rest = myName.substring(1,myName.length);
      var klass = initial.toUpperCase() + rest;
      return klass;
   }

});

/******************************************************************************
 *
 * [ ps.widget.TreeSelector.js ]
 *
 * COPYRIGHT (c) 1999 - 2007 by Percussion Software, Inc., Woburn, MA USA.
 * All rights reserved. This material contains unpublished, copyrighted
 * work including confidential and proprietary information of Percussion.
 *
 *****************************************************************************/


dojo.provide("ps.widget.TreeSelector");




dojo.widget.defineWidget(
	"ps.widget.TreeSelector",
	dojo.widget.TreeSelectorV3,
	function ()
	{
	   dojo.event.connect(this, "processNode", this, "_nodeActivated");
	},
{
   /**
    * Is called when a tree node is activated/deactivated.
    * @param node the tree node to activate. Not <code>null</code>
    */
	_nodeActivated: function (node)
	{
		dojo.lang.assert(node);
		var objId = node.modelId;
		dojo.lang.assert(objId, "widget does not have a model id");
		ps.aa.controller.activate(objId);
	}
});

dojo.provide("dojo.io.ScriptSrcIO");



//FIXME: should constantParams be JS object?
//FIXME: check dojo.io calls. Can we move the BrowserIO defined calls somewhere
//       else so that we don't depend on BrowserIO at all? The dependent calls
//       have to do with dealing with forms and making query params from JS object.
/**
 * See test_ScriptSrcIO.html for usage information.
 * Notes:
 * - The watchInFlight timer is set to 100 ms instead of 10ms (which is what BrowserIO.js uses).
 */
dojo.io.ScriptSrcTransport = new function(){
	this.preventCache = false; // if this is true, we'll always force GET requests to not cache
	this.maxUrlLength = 1000; //Used to calculate if script request should be multipart.
	this.inFlightTimer = null;

	this.DsrStatusCodes = {
		Continue: 100,
		Ok: 200,
		Error: 500
	};

	this.startWatchingInFlight = function(){
		//summary: Internal method to start the process of watching for in-flight requests.
		if(!this.inFlightTimer){
			this.inFlightTimer = setInterval("dojo.io.ScriptSrcTransport.watchInFlight();", 100);
		}
	}

	this.watchInFlight = function(){
		//summary: Internal method to watch for in-flight requests.
		var totalCount = 0;
		var doneCount = 0;
		for(var param in this._state){
			totalCount++;
			var currentState = this._state[param];
			if(currentState.isDone){
				doneCount++;
				delete this._state[param];
			}else if(!currentState.isFinishing){
				var listener = currentState.kwArgs;
				try{
					if(currentState.checkString && eval("typeof(" + currentState.checkString + ") != 'undefined'")){
						currentState.isFinishing = true;
						this._finish(currentState, "load");
						doneCount++;
						delete this._state[param];
					}else if(listener.timeoutSeconds && listener.timeout){
						if(currentState.startTime + (listener.timeoutSeconds * 1000) < (new Date()).getTime()){
							currentState.isFinishing = true;
							this._finish(currentState, "timeout");
							doneCount++;
							delete this._state[param];
						}
					}else if(!listener.timeoutSeconds){
						//Increment the done count if no timeout is specified, so
						//that we turn off the timer if all that is left in the state
						//list are things we can't clean up because they fail without
						//getting a callback.
						doneCount++;
					}
				}catch(e){
					currentState.isFinishing = true;
					this._finish(currentState, "error", {status: this.DsrStatusCodes.Error, response: e});
				}
			}
		}
	
		if(doneCount >= totalCount){
			clearInterval(this.inFlightTimer);
			this.inFlightTimer = null;
		}
	}

	this.canHandle = function(/*dojo.io.Request*/kwArgs){
		//summary: Tells dojo.io.bind() if this is a good transport to
		//use for the particular type of request. This type of transport can only
		//handle responses that are JavaScript or JSON that is passed to a JavaScript
		//callback. It can only do asynchronous binds, is limited to GET HTTP method
		//requests, and cannot handle formNodes. However, it has the advantage of being
		//able to do cross-domain requests.

		return dojo.lang.inArray(["text/javascript", "text/json", "application/json"], (kwArgs["mimetype"].toLowerCase()))
			&& (kwArgs["method"].toLowerCase() == "get")
			&& !(kwArgs["formNode"] && dojo.io.formHasFile(kwArgs["formNode"]))
			&& (!kwArgs["sync"] || kwArgs["sync"] == false)
			&& !kwArgs["file"]
			&& !kwArgs["multipart"];
	}

	this.removeScripts = function(){
		//summary: Removes any script tags from the DOM that may have been added by ScriptSrcTransport.
		//description: Be careful though, by removing them from the script, you may invalidate some
		//script objects that were defined by the js file that was pulled in as the
		//src of the script tag. Test carefully if you decide to call this method.
		//In MSIE 6 (and probably 5.x), if you remove the script element while 
		//part of the response script is still executing, the browser might crash.
		var scripts = document.getElementsByTagName("script");
		for(var i = 0; scripts && i < scripts.length; i++){
			var scriptTag = scripts[i];
			if(scriptTag.className == "ScriptSrcTransport"){
				var parent = scriptTag.parentNode;
				parent.removeChild(scriptTag);
				i--; //Set the index back one since we removed an item.
			}
		}
	}

	this.bind = function(/*dojo.io.Request*/kwArgs){
		//summary: function that sends the request to the server.
		//description: See the Dojo Book page on this transport for a full
		//description of supported kwArgs properties and usage:
		//http://manual.dojotoolkit.org/WikiHome/DojoDotBook/Book25

		//START duplication from BrowserIO.js (some changes made)
		var url = kwArgs.url;
		var query = "";
		
		if(kwArgs["formNode"]){
			var ta = kwArgs.formNode.getAttribute("action");
			if((ta)&&(!kwArgs["url"])){ url = ta; }
			var tp = kwArgs.formNode.getAttribute("method");
			if((tp)&&(!kwArgs["method"])){ kwArgs.method = tp; }
			query += dojo.io.encodeForm(kwArgs.formNode, kwArgs.encoding, kwArgs["formFilter"]);
		}

		if(url.indexOf("#") > -1) {
			dojo.debug("Warning: dojo.io.bind: stripping hash values from url:", url);
			url = url.split("#")[0];
		}

		//Break off the domain/path of the URL.
		var urlParts = url.split("?");
		if(urlParts && urlParts.length == 2){
			url = urlParts[0];
			query += (query ? "&" : "") + urlParts[1];
		}

		if(kwArgs["backButton"] || kwArgs["back"] || kwArgs["changeUrl"]){
			dojo.undo.browser.addToHistory(kwArgs);
		}

		//Create an ID for the request.
		var id = kwArgs["apiId"] ? kwArgs["apiId"] : "id" + this._counter++;

		//Fill out any other content pieces.
		var content = kwArgs["content"];
		var jsonpName = kwArgs.jsonParamName;
		if(kwArgs.sendTransport || jsonpName) {
			if (!content){
				content = {};
			}
			if(kwArgs.sendTransport){
				content["dojo.transport"] = "scriptsrc";
			}

			if(jsonpName){
				content[jsonpName] = "dojo.io.ScriptSrcTransport._state." + id + ".jsonpCall";
			}
		}

		if(kwArgs.postContent){
			query = kwArgs.postContent;
		}else if(content){
			query += ((query) ? "&" : "") + dojo.io.argsFromMap(content, kwArgs.encoding, jsonpName);
		}
		//END duplication from BrowserIO.js

		//START DSR

		//If an apiId is specified, then we want to make sure useRequestId is true.
		if(kwArgs["apiId"]){
			kwArgs["useRequestId"] = true;
		}

		//Set up the state for this request.
		var state = {
			"id": id,
			"idParam": "_dsrid=" + id,
			"url": url,
			"query": query,
			"kwArgs": kwArgs,
			"startTime": (new Date()).getTime(),
			"isFinishing": false
		};

		if(!url){
			//Error. An URL is needed.
			this._finish(state, "error", {status: this.DsrStatusCodes.Error, statusText: "url.none"});
			return;
		}

		//If this is a jsonp request, intercept the jsonp callback
		if(content && content[jsonpName]){
			state.jsonp = content[jsonpName];
			state.jsonpCall = function(data){
				if(data["Error"]||data["error"]){
					if(dojo["json"] && dojo["json"]["serialize"]){
						dojo.debug(dojo.json.serialize(data));
					}
					dojo.io.ScriptSrcTransport._finish(this, "error", data);
				}else{
					dojo.io.ScriptSrcTransport._finish(this, "load", data);
				}
			};
		}

		//Only store the request state on the state tracking object if a callback
		//is expected or if polling on a checkString will be done.
		if(kwArgs["useRequestId"] || kwArgs["checkString"] || state["jsonp"]){
			this._state[id] = state;
		}

		//A checkstring is a string that if evaled will not be undefined once the
		//script src loads. Used as an alternative to depending on a callback from
		//the script file. If this is set, then multipart is not assumed to be used,
		//since multipart requires a specific callback. With checkString we will be doing
		//polling.
		if(kwArgs["checkString"]){
			state.checkString = kwArgs["checkString"];
		}

		//Constant params are parameters that should always be sent with each
		//part of a multipart URL.
		state.constantParams = (kwArgs["constantParams"] == null ? "" : kwArgs["constantParams"]);
	
		if(kwArgs["preventCache"] ||
			(this.preventCache == true && kwArgs["preventCache"] != false)){
			state.nocacheParam = "dojo.preventCache=" + new Date().valueOf();
		}else{
			state.nocacheParam = "";
		}

		//Get total length URL, if we were to do it as one URL.
		//Add some padding, extra & separators.
		var urlLength = state.url.length + state.query.length + state.constantParams.length 
				+ state.nocacheParam.length + this._extraPaddingLength;

		if(kwArgs["useRequestId"]){
			urlLength += state.idParam.length;
		}
		
		if(!kwArgs["checkString"] && kwArgs["useRequestId"] 
			&& !state["jsonp"] && !kwArgs["forceSingleRequest"]
			&& urlLength > this.maxUrlLength){
			if(url > this.maxUrlLength){
				//Error. The URL domain and path are too long. We can't
				//segment that, so return an error.
				this._finish(state, "error", {status: this.DsrStatusCodes.Error, statusText: "url.tooBig"});
				return;
			}else{
				//Start the multiple requests.
				this._multiAttach(state, 1);
			}
		}else{
			//Send one URL.
			var queryParams = [state.constantParams, state.nocacheParam, state.query];
			if(kwArgs["useRequestId"] && !state["jsonp"]){
				queryParams.unshift(state.idParam);
			}
			var finalUrl = this._buildUrl(state.url, queryParams);

			//Track the final URL in case we need to use that instead of api ID when receiving
			//the load callback.
			state.finalUrl = finalUrl;
			
			this._attach(state.id, finalUrl);
		}
		//END DSR

		this.startWatchingInFlight();
	}
	
	//Private properties/methods
	this._counter = 1;
	this._state = {};
	this._extraPaddingLength = 16;

	//Is there a dojo function for this already?
	this._buildUrl = function(url, nameValueArray){
		var finalUrl = url;
		var joiner = "?";
		for(var i = 0; i < nameValueArray.length; i++){
			if(nameValueArray[i]){
				finalUrl += joiner + nameValueArray[i];
				joiner = "&";
			}
		}

		return finalUrl;
	}

	this._attach = function(id, url){
		//Attach the script to the DOM.
		var element = document.createElement("script");
		element.type = "text/javascript";
		element.src = url;
		element.id = id;
		element.className = "ScriptSrcTransport";
		document.getElementsByTagName("head")[0].appendChild(element);
	}

	this._multiAttach = function(state, part){
		//Check to make sure we still have a query to send up. This is mostly
		//a protection from a goof on the server side when it sends a part OK
		//response instead of a final response.
		if(state.query == null){
			this._finish(state, "error", {status: this.DsrStatusCodes.Error, statusText: "query.null"});
			return;
		}

		if(!state.constantParams){
			state.constantParams = "";
		}

		//How much of the query can we take?
		//Add a padding constant to account for _part and a couple extra amperstands.
		//Also add space for id since we'll need it now.
		var queryMax = this.maxUrlLength - state.idParam.length
					 - state.constantParams.length - state.url.length
					 - state.nocacheParam.length - this._extraPaddingLength;
		
		//Figure out if this is the last part.
		var isDone = state.query.length < queryMax;
	
		//Break up the query string if necessary.
		var currentQuery;
		if(isDone){
			currentQuery = state.query;
			state.query = null;
		}else{
			//Find the & or = nearest the max url length.
			var ampEnd = state.query.lastIndexOf("&", queryMax - 1);
			var eqEnd = state.query.lastIndexOf("=", queryMax - 1);

			//See if & is closer, or if = is right at the edge,
			//which means we should put it on the next URL.
			if(ampEnd > eqEnd || eqEnd == queryMax - 1){
				//& is nearer the end. So just chop off from there.
				currentQuery = state.query.substring(0, ampEnd);
				state.query = state.query.substring(ampEnd + 1, state.query.length) //strip off amperstand with the + 1.
			}else{
				//= is nearer the end. Take the max amount possible. 
				currentQuery = state.query.substring(0, queryMax);
			 
				//Find the last query name in the currentQuery so we can prepend it to
				//ampEnd. Could be -1 (not there), so account for that.
				var queryName = currentQuery.substring((ampEnd == -1 ? 0 : ampEnd + 1), eqEnd);
				state.query = queryName + "=" + state.query.substring(queryMax, state.query.length);
			}
		}
		
		//Now send a part of the script
		var queryParams = [currentQuery, state.idParam, state.constantParams, state.nocacheParam];
		if(!isDone){
			queryParams.push("_part=" + part);
		}

		var url = this._buildUrl(state.url, queryParams);

		this._attach(state.id + "_" + part, url);
	}

	this._finish = function(state, callback, event){
		if(callback != "partOk" && !state.kwArgs[callback] && !state.kwArgs["handle"]){
			//Ignore "partOk" because that is an internal callback.
			if(callback == "error"){
				state.isDone = true;
				throw event;
			}
		}else{
			switch(callback){
				case "load":
					var response = event ? event.response : null;
					if(!response){
						response = event;
					}
					state.kwArgs[(typeof state.kwArgs.load == "function") ? "load" : "handle"]("load", response, event, state.kwArgs);
					state.isDone = true;
					break;
				case "partOk":
					var part = parseInt(event.response.part, 10) + 1;
					//Update the constant params, if any.
					if(event.response.constantParams){
						state.constantParams = event.response.constantParams;
					}
					this._multiAttach(state, part);
					state.isDone = false;
					break;
				case "error":
					state.kwArgs[(typeof state.kwArgs.error == "function") ? "error" : "handle"]("error", event.response, event, state.kwArgs);
					state.isDone = true;
					break;
				default:
					state.kwArgs[(typeof state.kwArgs[callback] == "function") ? callback : "handle"](callback, event, event, state.kwArgs);
					state.isDone = true;
			}
		}
	}

	dojo.io.transports.addTransport("ScriptSrcTransport");
}

//Define callback handler.
window.onscriptload = function(event){
	var state = null;
	var transport = dojo.io.ScriptSrcTransport;
	
	//Find the matching state object for event ID.
	if(transport._state[event.id]){
		state = transport._state[event.id];
	}else{
		//The ID did not match directly to an entry in the state list.
		//Try searching the state objects for a matching original URL.
		var tempState;
		for(var param in transport._state){
			tempState = transport._state[param];
			if(tempState.finalUrl && tempState.finalUrl == event.id){
				state = tempState;
				break;
			}
		}

		//If no matching original URL is found, then use the URL that was actually used
		//in the SCRIPT SRC attribute.
		if(state == null){
			var scripts = document.getElementsByTagName("script");
			for(var i = 0; scripts && i < scripts.length; i++){
				var scriptTag = scripts[i];
				if(scriptTag.getAttribute("class") == "ScriptSrcTransport"
					&& scriptTag.src == event.id){
					state = transport._state[scriptTag.id];
					break;
				}
			}
		}
		
		//If state is still null, then throw an error.
		if(state == null){
			throw "No matching state for onscriptload event.id: " + event.id;
		}
	}

	var callbackName = "error";
	switch(event.status){
		case dojo.io.ScriptSrcTransport.DsrStatusCodes.Continue:
			//A part of a multipart request.
			callbackName = "partOk";
			break;
		case dojo.io.ScriptSrcTransport.DsrStatusCodes.Ok:
			//Successful reponse.
			callbackName = "load";
			break;
	}

	transport._finish(state, callbackName, event);
};

/**
* This file contains an Image Gallery widget built upon the 
* Dojo Ajax toolkit.  For a sample usage, see http://www.skynet.ie/~sos/photos.php
*
* @author  Copyright 2007 Shane O Sullivan (shaneosullivan1@gmail.com)
* @license Licensed under the Academic Free License 3.0 http://www.opensource.org/licenses/afl-3.0.php
* 
* Version: 0.2
*/

dojo.provide("sos.widget.ImageGallery");




dojo.declare(
"sos.widget.ImageGallery", 
dojo.widget.HtmlWidget,
{
  ns: "sos",
  widgetType: "ImageGallery",
  imageStore: [],
  
  imageHeight: 375,
  imageWidth: 500,
  
  defaultTitle: "No Title",
  
  images: [],
  thumbs: [],
  
  thumbCounter: 0,
  imageCounter: 0,
  
  numberThumbs: 5,
  thumbIndex: 0,
  
  dataFn: "",
  
  slideshowInterval: 3,
  
  twoConnectionsUsedForMain: false,
  
  templateString: "<div dojoAttachPoint='outerNode' class='image-gallery-wrapper'>" + 
          "<div dojoAttachPoint='thumbsNode' class='image-gallery-thumbs-wrapper'>" +
          "<table><tr dojoAttachPoint='thumbsTableRow'></tr></table></div>" + 
          "<div dojoAttachPoint='largeNode' class='image-gallery-image-wrapper'></div>" + 
          "<div dojoAttachPoint='slideshowNode' class='image-gallery-slideshow'><a href='#'>Start Slideshow</a></div>" + 
          "<div dojoAttachPoint='hiddenNode' class='image-gallery-hidden'></div>" + 
          "</div>",
  templateCssPath: dojo.uri.moduleUri("sos", "widget/templates/ImageGallery.css"),
  
  tempImgPath: dojo.uri.moduleUri("sos", "widget/templates/images/1pixel.gif"),
  
  tmpImage: null,
  
  postCreate: function()
  {
    var img = document.createElement("img");
    img.setAttribute("width", this.imageWidth);
    img.setAttribute("height", this.imageHeight);
    img.setAttribute("src", this.tempImgPath);
  
    var thisWidget = this;
  
    dojo.event.browser.addListener(this.slideshowNode.firstChild,"onclick",function(evt){
      thisWidget.toggleSlideshow();
      dojo.event.browser.stopEvent(evt);
      return false;
    });

    this.largeNode.appendChild(img);
    this.tmpImage = img;
  
    if(this.dataFn != "" && typeof(dj_global[this.dataFn]) == "function") {
      var data = dj_global[this.dataFn]();
      if(data) {
        this.setData(data);
      }
    } else 
    {
      this.init();
    }
  },
  
  init: function()
  {
    if(this.isInitialized || this.imageStore.length < 1){
      return;
    }
    
    if(!this.thumbCells) 
    {
      dojo.html.setStyle(this.hiddenNode, "position:absolute: left:-10000px;");
      this.thumbCells = [];
      this.thumbIndex = 0;
      this.numberThumbs = Number(this.numberThumbs);    
    
      for(var i = 0; i < this.numberThumbs + 2; i++){
        var cell = document.createElement("td");
        cell.setAttribute("id","img_cell_"+i);
        cell.setAttribute("align","center");    
      
        this.thumbCells[this.thumbCells.length] = cell;
      
        if(i > 0 && i < this.numberThumbs + 1) 
        {
          dojo.html.setClass(cell, "image-thumb-placeholder");        
        } else 
        {
          dojo.html.addClass(cell, "image-thumb-nav");
          if(i == 0) 
          {
            dojo.html.addClass(cell, "image-thumb-prev");
          } else 
          {
            dojo.html.addClass(cell, "image-thumb-next");      
          }
        }
        cell.innerHTML = "<img src='"+this.tempImgPath+"' class='image-gallery-thumb'/>";
        this.thumbsTableRow.appendChild(cell);
      }	  
	  
      var thisWidget = this;
      
      dojo.event.browser.addListener(this.thumbCells[0], "onclick", function(evt){
        thisWidget.showThumbs(thisWidget.thumbIndex - thisWidget.numberThumbs);
      });
      dojo.event.browser.addListener(this.thumbCells[this.numberThumbs + 1], "onclick", function(evt){
        thisWidget.showThumbs(thisWidget.thumbIndex + thisWidget.numberThumbs);
      });
    
    //calculate the correct width for the widget
      var width = 100 * this.numberThumbs + 90;
      dojo.html.insertCssText(".image-gallery-wrapper{text-align:center;width:"+width+"px;}");        
    }
    this.isInitialized = true;
     
    this.updateNavControls();
   
    this.loadNextThumbnail();
    this.showImage(0);
  },
  
  setData: function(data) {
    this.imageStore = data;
    this.init()
  },
  
  reset: function() {
    this.imageStore = [];
  
    while(this.largeNode.firstChild){
        this.largeNode.removeChild(this.largeNode.firstChild);
    }
    this.largeNode.appendChild(this.tmpImage);

    while(this.hiddenNode.firstChild) {
      this.hiddenNode.removeChild(this.hiddenNode.firstChild);
    }
    var img;
    for(var pos = 0; pos < this.images.length; pos++) {
      img = this.images[pos];
      if(img) {
        dojo.event.browser.clean(img);
        if(img.parentNode){
          img.parentNode.removeChild(img);    
        }
      }
    }
    for(var pos = 0; pos < this.thumbs.length; pos++) {
      img = this.thumbs[pos];
      if(img) {
        dojo.event.browser.clean(img);
        if(img.parentNode){
          img.parentNode.removeChild(img);    
        }  
      }
    }

    this.images = [];
    this.thumbs = [];
    this.isInitialized = false;
    this.thumbCounter = 0;
    this.twoConnectionsUsedForMain = false;
    this.imageCounter = 0;
    this.thumbIndex = 0;
  },
  
  showThumbs: function(idx){
    var thisWidget = this;
    var idx = arguments.length == 0 ? this.thumbIndex : arguments[0];
    
    idx = Math.max(idx, 0);
    idx = Math.min(idx, this.imageStore.length);
  
    if(idx == this.imageStore.length) {
      return;
    }
    
    var imgId;
    var existingNodes = [];
    var imagesToPlace = [];
    
    for(var i = 0; i < this.numberThumbs; i++) {
      imgId = "img_"+(i + idx);
      
      if(this.thumbCells[i + 1].firstChild) {
        if(this.thumbCells[i + 1].firstChild.getAttribute("id") == imgId) {
          continue;
        }
        existingNodes[existingNodes.length] = this.thumbCells[i + 1].firstChild;
      }
      imagesToPlace[i] = imgId;
    }
    var page = this.page;
    var showNodes = function() {
      //if the user has moved onto another page, do nothing
      if(page != thisWidget.page)
      {
      return;
      }
    
      for(var i = 0; i < thisWidget.numberThumbs; i++) 
	  {
        if(imagesToPlace[i]) 
		{
          while(thisWidget.thumbCells[i + 1].firstChild) 
          {
            thisWidget.hiddenNode.appendChild(thisWidget.thumbCells[i + 1].firstChild);
          }
      
          var node = dojo.byId(imagesToPlace[i]);
          if(node)
		  {
            if(node.parentNode != thisWidget.thumbCells[i + 1])
            {
              thisWidget.thumbCells[i + 1].appendChild(node);        
            }
            if(dojo.html.getOpacity(node) != 100)
            {
              dojo.html.setOpacity(node, 100);
            }
          } else 
		  {
            var loadPos = imagesToPlace[i].split("_")[1];
            dojo.debug("No thumb '"+imagesToPlace[i]+"' loading from "+(loadPos));
            thisWidget.loadNextThumbnail(imagesToPlace[i].split("_")[1]);
          }
        }
      }
      thisWidget.thumbIndex = idx;
      thisWidget.updateNavControls();
    };
  
    if(existingNodes.length > 0) {
      dojo.lfx.html.fadeOut(existingNodes, 300, null, showNodes).play();
    } else {
      showNodes();
    }
  },
  
  updateNavControls: function() {
    var firstCell = this.thumbsTableRow.cells[0];
    if(this.thumbIndex < 1) {
      dojo.html.removeClass(firstCell,"image-thumb-prev");
    } else if(!dojo.html.hasClass(firstCell,"image-thumb-prev")) {
      dojo.html.addClass(firstCell,"image-thumb-prev");
    }
  
    var lastCell = this.thumbsTableRow.cells[this.thumbsTableRow.cells.length -1];
  
    if(this.thumbIndex + this.numberThumbs >= this.imageStore.length) {
      dojo.html.removeClass(lastCell,"image-thumb-next");
    } else if(!dojo.html.hasClass(lastCell,"image-thumb-next")) {
      dojo.html.addClass(lastCell,"image-thumb-next");
    }
  },
  
  loadNextThumbnail: function()
  { 
    var initPos =  arguments.length == 0 ? -1 : arguments[0];
    var pos = arguments.length == 0 ? this.thumbCounter++ : arguments[0];
    while(pos < this.thumbs.length && this.thumbs[pos]) {
      pos ++;
    }
    
    if(this.thumbCounter >= this.imageStore.length){
      if(this.imageStore.length > 0) {
        if(!this.twoConnectionsUsedForMain) {
          //if all the thumbnails have been loaded, then use the second connection to 
          //the image server to load primary images
          this['twoConnectionsUsedForMain'] = true;
          this.loadNextImage();
        } 
      }
      //return;
    }
    if(pos >= this.imageStore.length) {
      return;
    }
  
    var url = this.imageStore[pos]["thumb"];
    var img = document.createElement("img");
    var imgContainer = document.createElement("div");
    imgContainer.setAttribute("id","img_"+pos);
    imgContainer.appendChild(img);
  
    this.thumbs[pos] = imgContainer;
    
    var loadingDiv = document.createElement("div");
    loadingDiv.innerHTML = "<!-- -->";
    
    loadingDiv.setAttribute("id","loadingDiv_"+pos);
    dojo.html.setClass(loadingDiv,"image-gallery-notifier");
    
    if(this.images.length > pos && this.images[pos]) {
      dojo.html.addClass(loadingDiv, "image-gallery-loaded");
    }
    
    imgContainer.appendChild(loadingDiv);
    this.hiddenNode.appendChild(imgContainer);
        
    var thisWidget = this;
    var page = this.page;
    dojo.event.browser.addListener(img, "onload", function(){
      if(page != thisWidget.page)
      {
        return;
      }
      if(pos >= thisWidget.thumbIndex && pos <thisWidget.thumbIndex + thisWidget.numberThumbs) {
        thisWidget.showThumbs();
      }
      thisWidget.loadNextThumbnail();
      return false;
    });
    dojo.event.browser.addListener(img, "onclick", function(){
      if(page != thisWidget.page)
      {
        return;
      }
      thisWidget.showImage(pos);
      return false;
    });
    
    dojo.html.setClass(img, "image-gallery-thumb");
    img.setAttribute("src", url);
  
    if(this.imageStore[pos]["title"])
    {
      img.setAttribute("title",this.imageStore[pos]["title"]);
    }
  
    this.showThumbs();
  },
  
  loadNextImage: function()
  {
    while(this.images.length >= this.imageCounter && this.images[this.imageCounter]){
      this.imageCounter++;
    }
    
    this.loadImage(this.imageCounter);
  },
  
  loadImage: function(pos, callbackFn)
  {
    if(this.images[pos] || pos >= this.imageStore.length )
    {
      return;
    }
    
    var thumbNotifier = dojo.byId("loadingDiv_"+pos);
    if(thumbNotifier && !dojo.html.hasClass(thumbNotifier, "image-gallery-loading")){
      dojo.html.addClass(thumbNotifier, "image-gallery-loading");
    }
        
    var url = this.imageStore[pos]["large"];
    var img = document.createElement("img");
    var div = document.createElement("div");
    if(!this.imageStore[pos]["link"])
    {
      div.appendChild(img);
    } else
	{
      var a = document.createElement("a");
      a.setAttribute("href",this.imageStore[pos]["link"]);
      a.setAttribute("target","_blank");
      div.appendChild(a);
      a.appendChild(img);
    }
    div.setAttribute("id",this.widgetId + "_imageDiv"+pos);
    div.setAttribute("width",this.imageWidth);
    div.setAttribute("height",this.imageHeight);
    img.setAttribute("width",this.imageWidth);
    img.setAttribute("height",this.imageHeight);
    
    var thisWidget = this;
    var page = this.page;
    dojo.event.browser.addListener(img, "onload", function(){
      //If the user has changed the page, do nothing when an image loads
      if(page != thisWidget.page)
      {
        return;
      }
      var divId = "loadingDiv_"+pos;
      var thumbNotifier = dojo.byId(divId);
      if(thumbNotifier) {
        dojo.html.addClass(thumbNotifier, "image-gallery-loaded");
      } 
      thisWidget.loadNextImage();
    });
    if(callbackFn){
      dojo.event.browser.addListener(img, "onload", callbackFn);
    }
    this.hiddenNode.appendChild(div);
  
    var titleDiv = document.createElement("div");
    dojo.html.addClass(titleDiv, "image-gallery-title");
    div.appendChild(titleDiv);
    
    this.images[pos] = div;
    
    img.setAttribute("src", url);
  
    var title = this.imageStore[pos]["title"];
    if(title)
    {
      img.setAttribute("title",title);
      titleDiv.innerHTML = title;
    } else{
      titleDiv.innerHTML = this.defaultTitle;
    }
  },
  
  destroy: function(){
    if(this._slideId) {
    this.cancelSlideshow();
  }
  },
  
  showNextImage: function(inTimer) {
    if(Number(this.imageIndex) + 1 >= this.imageStore.length) {
      if(this._slideId)
	  {
        this.cancelSlideshow();
      }
      return false;
    }
    var thisWidget = this;
    this.showImage(Number(this.imageIndex + 1), function(){
      if(inTimer)
      {
        thisWidget.startTimer();
      }
    });
    return true;
  },
  
  toggleSlideshow: function() {
    if(this._slideId) {
      this.cancelSlideshow();
    } else {
      this.slideshowNode.firstChild.innerHTML= "Stop Slideshow";
      var success = this.showNextImage(true);
      if(!success) {
        this.cancelSlideshow();
      }
    }
  },
  
  cancelSlideshow: function(){
    if(this._slideId) {
      clearTimeout(this._slideId);
    }     
    this._slideId = null;
    this.slideshowNode.firstChild.innerHTML= "Start Slideshow";
  },
  
  startTimer: function() {
    this._slideId = setTimeout("dojo.widget.byId('"+
      this.widgetId + 
      "').showNextImage(true);", this.slideshowInterval * 1000);
  },
  
  showImage: function(index, /*optional*/callback)
  {  
    if(!callback && this._slideId)
	{
      this.toggleSlideshow();
    }
    var thisWidget = this;
    var current = this.largeNode.getElementsByTagName("div");
    this.imageIndex = Number(index);
        
    var showOrLoadIt = function() {
      if(thisWidget.images[index])
	  {
        while(thisWidget.largeNode.firstChild)
	    {
          thisWidget.largeNode.removeChild(thisWidget.largeNode.firstChild);
        }
        thisWidget.images[index].style.opacity = 0;
        thisWidget.largeNode.appendChild(thisWidget.images[index]);      
        dojo.lfx.html.fadeIn(thisWidget.images[index], 300, null, callback).play();  
      }
      else 
	  {
        thisWidget.loadImage(index, function(){
          thisWidget.showImage(index);
        });
      }
    };
  
  var thumbNotifier = dojo.byId("loadingDiv_" + index);
    if(thumbNotifier && !dojo.html.hasClass(thumbNotifier, "image-gallery-loading")){
      dojo.html.addClass(thumbNotifier, "image-gallery-loading");
    }
    
    if(current && current.length > 0){
      dojo.lfx.html.fadeOut(current[0], 300, null, function(){
        thisWidget.hiddenNode.appendChild(current[0]);
        showOrLoadIt();
      }).play();

    }else {
      showOrLoadIt();
    }
  } 
}
);

dojo.provide("sos.widget.FlickrImageGallery");


dojo.declare("sos.widget.FlickrImageGallery", sos.widget.ImageGallery, {
  widgetType: "FlickrImageGallery",
  flickrUserId: "",
  flickrApiKey: "",
  flickrSetId: "",
  page: 1,
  perPage: 50,
  numPageLinks: 8,
  useSetMenus: false,
  
  postCreate: function(){
    sos.widget.ImageGallery.prototype.postCreate.call(this);
    if(this.flickrUserId != "" && this.flickrApiKey !="") {
      this.loadFlickrPublicPhotos(this.flickrUserId, this.flickrApiKey)
    }
  
    this.pagingDiv = document.createElement('div');
    this.outerNode.insertBefore(this.pagingDiv, this.slideshowNode);
  
    dojo.html.setClass(this.pagingDiv, "image-gallery-pager");
      
    if(!this.maxPages){
      dojo.html.hide(this.pagingDiv);
    }
	if(this.useSetMenus != false) {
	  this.initSetMenus();
	}
  },
  
  generatePagingLinks: function() {
    if(!this.maxPages) {
      return;
    }
  
    while(this.pagingDiv.firstChild){
      this.pagingDiv.firstChild.parentNode.removeChild(this.pagingDiv.firstChild);
    }
  
    var maxLinks = this.numPageLinks -1;
  
    var first = Math.max(1,Math.min(this.page, this.maxPages));
	var diff = first % this.numPageLinks;
	
    first = first - (diff == 0 ? this.numPageLinks : diff) + 1;
	
    var html = ["<ul id='" + this.widgetId + "_pageLinks'>","<li>Pages: </li>"];
  
    var prefix = "<li><a href='#' onclick='dojo.widget.byId(\"" + this.widgetId 
                         + "\").setPage(";
    var postfix = "</a></li>";
  
    if(first > 1)
    {
      var pageNum = first - 1;
      html[html.length] = prefix + pageNum+"); return false;' " 
                         + "title='Page" + pageNum + "'"
               + ">&lt;&lt;" + postfix;
    }

    var button;
    for(var i = first; i<= this.maxPages && i <= first + maxLinks; i++) {
      html[html.length] = prefix + i + "); return false;' " 
              + "title='Page " + i +"'"
              + ((i == this.page) ? " class='current-page'" : "")
                          + ">" + i + postfix;
    }
  
    if(this.page + maxLinks <= this.maxPages)
	{
      var pageNum = Math.min(first + maxLinks + 1, this.maxPages);
      html[html.length] = prefix + pageNum
               + ");  return false;' " 
               + " title='Page " + pageNum +"'"
               + ">&gt;&gt;" + postfix;
    }
	
    html[html.length] = "</ul>"	
	
    this.pagingDiv.innerHTML = html.join('\n');
	
    if(this._setMenu) {
      this.createSetButton();
	}
  },
  
  createSetButton: function() {
  	var listNode = dojo.byId(this.widgetId + "_pageLinks");
	if(!listNode) {
		return;
	}
	var li = document.createElement("li");
	li.innerHTML = "<a href='#' id='" + this.widgetId + "_menuLink'>Sets</a>";
	
	listNode.appendChild(li);
	
    var thisWidget = this;
	dojo.event.browser.addListener(li.firstChild, "onclick", function(e){
	  thisWidget._setMenu.onOpen(e);return false;
    });
  },
  
  addFlickrData: function(flickrData)
  {
    if(flickrData['stat'] != "ok")
    {
      alert("Flickr data is not valid, stat = " + flickrData['stat']);
      return;
    }
	var baseKey = 'photos';
	if(flickrData['photos'])
	{
      baseKey = 'photos'
	} else if(flickrData['photoset'])
	{
	  baseKey = "photoset";
	} else if(flickrData['photosets'])
	{
	  this.initSetMenus(flickrData);
	  return;
	}
  
    var oldPages = this.maxPages;
    if(flickrData[baseKey] && flickrData[baseKey]['pages'])
    {
      this.maxPages = Number(flickrData[baseKey]['pages']);
    }
  
    this.generatePagingLinks();      
    this.reset();	
	
	var defaultOwner = flickrData[baseKey]['owner'];
    
    if(flickrData[baseKey] && flickrData[baseKey]['photo']){
      flickrData = flickrData[baseKey]['photo'];
    }
    var newData = [];
    for(var i = 0; i< flickrData.length; i++)
    {
      var owner = flickrData[i]['owner'] || defaultOwner;
      var baseUrl = "http://farm"+flickrData[i]['farm']+".static.flickr.com/"+flickrData[i]['server'] +
        "/"+flickrData[i]['id']+"_"+flickrData[i]['secret'];
      var title = flickrData[i]['title'];
      var link = "http://www.flickr.com/photos/" + owner + "/"+flickrData[i]["id"];
      newData[newData.length] = {"thumb": baseUrl+"_t.jpg", "large": baseUrl+".jpg", "title":title,"link":link};
    }
    this.setData(newData);
  
    if(!this.maxPages){
      dojo.html.hide(this.pagingDiv);
    } else {
      dojo.html.show(this.pagingDiv);
    }
    
    this.init();
  },
  
  loadFlickrPublicPhotos: function(userId, apiKey, setId, page, perPage) {
  	var method = "flickr.people.getPublicPhotos";
    if(arguments.length == 0) 
    {
      if(this.flickrApiKey == "" || this.flickrUserId == "") {
        dojo.debug("FlickrImageGallery: no userId or apiKey specified. Cannot load Flickr images.");
        return;
      }
    }
	if(!userId) {
	  userId = this.flickrUserId;
	}
	if(!apiKey) {
      apiKey = this.flickrApiKey;		
	}
    if(!page) {
      page = this.page;
    }
    if(!perPage){
      perPage = this.perPage;
    }
    if(!setId) {
      var setId = this.flickrSetId;
	 }
    var extraArgs = "";
    if(setId && setId != "")
    {
      method = "flickr.photosets.getPhotos";
      extraArgs += "&photoset_id=" + setId;
    }
  
    var thisWidget = this;
    dj_global['jsonFlickrApi'] = function(data){
      thisWidget.addFlickrData(data);
    };
  
    
    
	
    var url = "http://www.flickr.com/services/rest/?method="+ method + "&format=json&api_key="
      + apiKey +"&user_id=" + userId+"&page=" + page + "&per_page=" + perPage + extraArgs;	
  
    dojo.io.bind({
      url: url,
      transport: "ScriptSrcTransport",
      mimetype: "application/json"
    });
  },
  
  initSetMenus: function(data) {
  	if(arguments.length == 0) {
	  url = "http://www.flickr.com/services/rest/?method=flickr.photosets.getList&format=json&api_key="
        + this.flickrApiKey +"&user_id=" + this.flickrUserId;
	  var thisWidget = this;
	  dj_global['jsonFlickrApi'] = function(data){
        thisWidget.addFlickrData(data);
      };
		
	  dojo.io.bind({
        url: url,
        transport: "ScriptSrcTransport",
        mimetype: "application/json"
      });
	  return;
	}
	
  	if(data['stat'] != 'ok' || !data['photosets'])
	{
		alert("Error: Invalid Flickr Set data.");
		return;
	}
	data = data['photosets']['photoset'];
	
	
	
	var menu = dojo.widget.byId(this.widgetId + "_menu");
	if(menu) {
		menu.destroy();
	}
	
	var thisWidget = this;
    function makeMenu(items, isTop, id){
      var menu2 = dojo.widget.createWidget("PopupMenu2", 
	    {
		  contextMenuForWindow: isTop, 
		  widgetId:id
		});
	  menu2.addChild(dojo.widget.createWidget("MenuItem2", {
	  	caption: "All Photos",
		onClick: function() {
          thisWidget.flickrSetId = null;
          thisWidget.loadFlickrPublicPhotos();
		}
	  }));
      menu2.addChild(dojo.widget.createWidget("MenuSeparator2"));
      dojo.lang.forEach(items, function(itemJson){	   
	    var item = dojo.widget.createWidget("MenuItem2",  itemJson);
	    menu2.addChild(item);
      });
      return menu2;
    }
	
	var menuItems = [];
	
	function genFn(setIdToLoad) {
		return function() {
		  thisWidget.loadFlickrPublicPhotos(null,null, setIdToLoad);
		  return true;
		};
	}
	
	for(var count = 0; count < data.length; count ++) {
      var setId = data[count].id;
      menuItems[menuItems.length] = {
          caption: data[count]["title"]["_content"],
          onClick: genFn(setId)
	  };
	}
	//this.largeNode.setAttribute("oncontextmenu","return false;");
	this._setMenu = makeMenu(menuItems, false, this.widgetId + "_menu");
	this.createSetButton(); 
  },
  nextPage: function() {
    this.setPage(this.page +1 );
  },
  prevPage: function() {
    this.setPage(this.page -1 );
  },
  setPage: function(num) {
    if(num < 0 || (this.maxPages && num > this.maxPages) || num == this.page){
    return;
  }
  this.page = num;
  this.loadFlickrPublicPhotos();
  }
});

if(typeof(imageGalleryLoaded) == "function"){
  imageGalleryLoaded();
}

dojo.provide("dojo.style");

dojo.kwCompoundRequire({
	browser: ["dojo.html.style"]
});
dojo.deprecated("dojo.style", "replaced by dojo.html.style", "0.5");
dojo.lang.mixin(dojo.style, dojo.html);

dojo.provide("ps.widget.PSImageGallery");


dojo.widget.defineWidget(    
   // widget name and class    
   "ps.widget.PSImageGallery",         
   // superclass    
   sos.widget.ImageGallery,        
   // properties and methods    
   {        
      templateString: "<div dojoAttachPoint='outerNode' class='image-gallery-wrapper'>" + 
         "<div dojoAttachPoint='largeNode' class='image-gallery-image-wrapper'></div>" + 
         "<div dojoAttachPoint='thumbsNode' class='image-gallery-thumbs-wrapper'>" +
         "<table><tr dojoAttachPoint='thumbsTableRow'></tr></table></div>" + 
         "<div dojoAttachPoint='slideshowNode' class='image-gallery-slideshow'><a href='#'>Start Slideshow</a></div>" + 
         "<div dojoAttachPoint='hiddenNode' class='image-gallery-hidden'></div>" + 
         "</div>",
      numberThumbs: 4,
      imageHeight: 300,
      imageWidth: 400,
      

      /**
       * Hides the slide show link that is part of sos.widget.ImageGallery
       */
      postCreate: function()
      {
         sos.widget.ImageGallery.prototype.postCreate.call(this);
         dojo.style.hide(this.slideshowNode);
      },

      /**
       * Creates input data for Image gallery widget. Creates a data objects by 
       * looping through thumbUrls array,  gets the corresponding full image 
       * url and title from supplied fullUrls and titles at the same index.
       * @param thumbUrls array of thumbnail image urls, must be an Array object
       * @param fullUrls array of full image urls, must be an Array object
       * @param titles optional titles if provided must be an Array object.
       */
      setImages: function(thumbUrls,fullUrls, titles)
      {
         dojo.lang.assertType(thumbUrls,Array);
         dojo.lang.assertType(fullUrls,Array);
         if(titles)
            dojo.lang.assertType(titles,Array);
         var imageData = [];
         for(var i=0;i<thumbUrls.length;i++)
         {
            imageData[imageData.length] = {"thumb": thumbUrls[i], "large": fullUrls[i], "title":titles[i]};
         }
         this.setData(imageData);
      }
   }
);


dojo.kwCompoundRequire({
   common: [
      "ps.widget.Autoscroller",
      "ps.widget.ContentPaneProgress",
      "ps.widget.MenuBar2",
      "ps.widget.MenuBarIcon",
      "ps.widget.MenuBarItem2",
      "ps.widget.MenuBarItemDropDown",
      "ps.widget.PopupMenu",
      "ps.widget.PSSplitContainer",
      "ps.widget.ScrollableNodes",
      "ps.widget.Tree",
      "ps.widget.TreeDndController",
      "ps.widget.TreeIcon",
      "ps.widget.TreeSelector",
      "ps.widget.PSImageGallery"
   ]
});
dojo.provide("ps.widget.*");

