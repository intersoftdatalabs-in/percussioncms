/*
 *     Percussion CMS
 *     Copyright (C) 1999-2020 Percussion Software, Inc.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU Affero General Public License for more details.
 *
 *     Mailing Address:
 *
 *      Percussion Software, Inc.
 *      PO Box 767
 *      Burlington, MA 01803, USA
 *      +01-781-438-9900
 *      support@percussion.com
 *      https://www.percussion.com
 *
 *     You should have received a copy of the GNU Affero General Public License along with this program.  If not, see <https://www.gnu.org/licenses/>
 */

package com.percussion.data;

import com.percussion.debug.PSDebugLogHandler;
import com.percussion.debug.PSTraceMessageFactory;
import com.percussion.design.catalog.PSCatalogException;
import com.percussion.design.objectstore.PSDataSet;
import com.percussion.design.objectstore.PSNotFoundException;
import com.percussion.design.objectstore.PSPipe;
import com.percussion.design.objectstore.PSRequestor;
import com.percussion.design.objectstore.PSResultPager;
import com.percussion.design.objectstore.PSSystemValidationException;
import com.percussion.error.PSBackEndQueryProcessingError;
import com.percussion.error.PSErrorException;
import com.percussion.error.PSException;
import com.percussion.error.PSHtmlProcessingError;
import com.percussion.error.PSIllegalArgumentException;
import com.percussion.error.PSXmlProcessingError;
import com.percussion.extension.PSExtensionException;
import com.percussion.log.PSLogError;
import com.percussion.security.PSAuthenticationFailedException;
import com.percussion.security.PSAuthorizationException;
import com.percussion.server.IPSInternalRequest;
import com.percussion.server.IPSServerErrors;
import com.percussion.server.PSApplicationHandler;
import com.percussion.server.PSConsole;
import com.percussion.server.PSInvalidRequestTypeException;
import com.percussion.server.PSRequest;
import com.percussion.server.PSRequestStatistics;
import com.percussion.server.PSUserSession;
import org.w3c.dom.Document;

import java.io.ByteArrayOutputStream;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Stack;


/**
 * The PSQueryHandler class is used internally by the Rhythmyx server to process
 * queries. Once an application handler determines a request which is
 * for a query, it hands the request off to the query handler. The query handler
 * must then prepare the request for the given back-end and prepare the
 * resulting data for returning to the requestor.
 *
 * @see        com.percussion.server.PSApplicationHandler
 *
 * @author     Tas Giakouminakis
 * @version    1.0
 * @since      1.0
 */
public class PSQueryHandler extends PSDataHandler implements IPSInternalResultHandler
{
   /**
    * Construct a query handler to manage the querying for the specified
    * data set.
    * <p>
    * The steps performed during construction:
    * <ol>
    * <li>call the query optimizer to build the execution plan</li>
    * <li>go through the execution plan, and for each PSStatement object,
    * add its column mapper to the proper place</li>
    * <li>set the result set converter to be used (m_converter)</li>
    * </ol>
    * The information used from the
    * {@link com.percussion.design.objectstore.PSDataSet PSDataSet}
    * object:
    * <ul>
    * <li>the type of transaction support</li>
    * <li>the pipes defining the data associated with this data set</li>
    * <li>the page data tank describing the XML document being used for this
    * data set</li>
    * <li>the definition of the results being generated by this data set</li>
    * <li>the extensions which act upon the entire data set</li>
    * </ul>
    *
    * @param      app      the application containing the data set
    *
    * @param      ds       the data set containing the query pipe(s) this
    *                      object will handle
    *
    * @throws  PSInvalidRequestTypeException    if the request type is not valid
    *
    * @throws  PSIllegalArgumentException       if any argument object is wrong
    *
    * @throws  SQLException                     if any SQL related error occurs
    *
    * @throws  PSNotFoundException              if any piece of data is not found
    *
    * @throws  PSCatalogException               if the data belongs to the wrong catalog
    *
    * @exception PSSystemValidationException            if the execution plan has error
    */
   public PSQueryHandler(PSApplicationHandler app, PSDataSet ds)
      throws PSInvalidRequestTypeException, java.sql.SQLException,
            PSIllegalArgumentException, PSNotFoundException,
            PSCatalogException, PSSystemValidationException, PSExtensionException
   {
      super(app, ds);

      /* verify a query pipe exists */
      PSPipe pipe = ds.getPipe();
      if (!(pipe instanceof com.percussion.design.objectstore.PSQueryPipe)) {
         Object[] params = { ds.getName(), app.getName() };
         throw new PSInvalidRequestTypeException(
                     IPSServerErrors.APP_NO_QUERY_PIPES_IN_DATASET, params);
      }

      /* call the query optimizer to build the execution plan */
      try {
         m_execPlanQuery = PSQueryOptimizer.createExecutionPlan(app, ds);
      } catch (RuntimeException e) {
         // for unknown exceptions, it's useful to log the stack trace
         Object[] args = { app.getName(),
            com.percussion.error.PSException.getStackTraceAsString(e) };
         throw new PSSystemValidationException(
            IPSServerErrors.APPLICATION_INIT_EXCEPTION, args,
            app.getApplicationDefinition(), ds);
      }

      /* set the result set converter we'll be using (m_converter) */
      PSRequestor requestor = ds.getRequestor();
      try {
         if (requestor.isDirectDataStream())
            m_converter = new PSResultSetMimeConverter(app, ds);
         else
            m_converter = new PSResultSetHtmlConverter(app, ds);
      } catch (RuntimeException e) {
         // for unknown exceptions, it's useful to log the stack trace
         Object[] args = { app.getName(),
            com.percussion.error.PSException.getStackTraceAsString(e) };
         throw new PSSystemValidationException(
            IPSServerErrors.APPLICATION_INIT_EXCEPTION, args,
            app.getApplicationDefinition(), ds);
      }
   }

   /**
    * Return a reference to the pager for the query.  This is used
    * to tune the Statement and ResultSet.
    *
    * @return May be <code>null</code> if the dataset associated with this
    *    handler doesn't have a pager.
    */
   public PSResultPager getPager()
   {
      return getDataSet().getResultPager();
   }

   /**
    * Process a query request using the input context information and data.
    * Execute the request, running any pre-processing extensions.
    *
    * @param   request  The request context.
    *
    * @return  The execution data, which can be used to retrieve a
    *    result set.
    *
    * @throws  PSErrorException if a lower level call throws
    *    this
    *
    * @throws  PSIllegalArgumentException if a lower level call throws
    *    this
    *
    * @throws  PSDataExtractionException if an error occurs extracting
    *    a data value
    *
    * @throws  SQLException   if a sql error occurs
    *
    */
   public PSExecutionData executeQueryRequest(PSRequest request)
      throws SQLException, PSIllegalArgumentException,
         PSErrorException, PSDataExtractionException
   {
      PSExecutionData execData = null;
      int curExec = -1;
      boolean success = false;

      try {

         execData = new PSExecutionData(m_appHandler, this, request);

         // run any pre-processing extensions
         runPreProcessingExtensions(execData);

         // validate the request data
         validate(execData);

         PSRequestStatistics stats = request.getStatistics();

         // trace request processing
         PSDebugLogHandler dh = (PSDebugLogHandler)request.getLogHandler();
         boolean isTraceEnabled = dh.isTraceEnabled(
            PSTraceMessageFactory.RESOURCE_HANDLER_FLAG);

         /* run the execution plan (IPSExecutionStep[]) */
         for (curExec = 0; curExec < m_execPlanQuery.length; curExec++)
            m_execPlanQuery[curExec].execute(execData);

         success = true;
      } finally
      {
         if (!success && execData != null)
            execData.release();
      }

      return execData;

   }

   /**
    * This filter is used during document construction. It is passed to the
    * converter, which will pass all rows in the result set through it. Only
    * those rows that are accepted will be included in the result document.
    *
    * @param filter May be <code>null</code>. If <code>null</code>, no
    *    filtering will occur.
    */
   public void setRowFilter(IPSResultSetDataFilter filter)
   {
      m_rowFilter = filter;
   }

   /**
    * See {@link #getRowFilter()} for details.
    *
    * @return The filter set by {@link #setRowFilter(IPSResultSetDataFilter)
    *    setRowFilter}. Default is <code>null</code>.
    */
   public IPSResultSetDataFilter getRowFilter()
   {
      return m_rowFilter;
   }

   public boolean isBinary(PSRequest req)
   {
      return m_converter instanceof PSResultSetMimeConverter;
   }
   
   /* ************ IPSRequestHandler Interface Implementation ************ */

   /**
    * Process a query request using the input context information and data.
    * The results will be written to the specified output stream.
    * <p>
    * The following steps are performed to handle the request:
    * <ol>
    * <li>fill query statement(s) with selection variables.</li>
    * <li>run the execution plan (IPSExecutionStep[])</li>
    * <li>convert the data to the appropriate output format (XML or HTML).
    * This is done by calling the result set converter (m_converter) with
    * the request infomation. The converter will then attempt to generate the
    * appropriate output. If this cannot be done, an exception will be
    * shown.</li>
    * </ol>
    *
    * @param   request      the request object containing all context
    *                        data associated with the request
    */
   public void processRequest(PSRequest request)
   {
      PSExecutionData execData = null;
      int curExec = -1;

      try {
         /* Execute the query */
         execData = executeQueryRequest(request);

         /* convert the data to the appropriate output format (XML, HTML
          * or TXT). This is done by calling the result set converter with
          * the request info. The converter will then attempt to generate
          * the appropriate output. If this cannot be done, an exception
          * will be thrown.
          */
         m_converter.generateResults(execData);
      } catch (com.percussion.error.PSErrorException err) {
         // these are pre-formatted error we've thrown
         m_appHandler.reportError(request, err.getLogError());
      } catch (Throwable t) {
         /* catch anything that comes our way */

         String source = "";
         if ((curExec > 0) && (curExec < m_execPlanQuery.length))
            source = m_execPlanQuery[curExec].toString();

         String sessId = "";
         PSUserSession sess = request.getUserSession();
         if (sess != null)
            sessId = sess.getId();

         int errorCode;
         Object[] errorArgs;

         if (t instanceof PSException) {
            PSException e = (PSException)t;
            errorCode = e.getErrorCode();
            errorArgs = e.getErrorArguments();
         }
         else {
            errorCode = IPSServerErrors.RAW_DUMP;
            errorArgs = new Object[] { getExceptionText(t) };
         }

         PSLogError err = null;

         if (t instanceof com.percussion.data.PSConversionException)
         {
            int pageType = request.getRequestPageType();
            if (pageType == PSRequest.PAGE_TYPE_HTML)
            {
               // TODO can't get stylesheet so passing "" for now
               err = new PSHtmlProcessingError(m_appHandler.getId(),
                                                      sessId,
                                                      errorCode,
                                                      errorArgs,
                                                      "");
            } else if ((pageType == PSRequest.PAGE_TYPE_XML) ||
                        (pageType == PSRequest.PAGE_TYPE_TEXT))
            {
               // TODO can't get xml element so passing null for now
               err = new PSXmlProcessingError(m_appHandler.getId(),
                                                      sessId,
                                                      errorCode,
                                                      errorArgs,
                                                      null);
            } else {
               // Processing error for now...
               err = new PSBackEndQueryProcessingError(m_appHandler.getId(),
                                                      sessId,
                                                      errorCode,
                                                      errorArgs,
                                                      source);
            }
         } else {
            err = new PSBackEndQueryProcessingError(m_appHandler.getId(),
                                                      sessId,
                                                      errorCode,
                                                      errorArgs,
                                                      source);
         }

         m_appHandler.reportError(request, err);
      }

      /* release all connection related resources */
      if (execData != null)
         execData.release();
   }

   /* ********* IPSInternalRequestHandler Interface Implementation ********* */

   // see IPSInternalRequestHandler interface for description
   public PSExecutionData makeInternalRequest(PSRequest request)
      throws PSInternalRequestCallException, PSAuthorizationException,
      PSAuthenticationFailedException
   {
      if (request == null)
         throw new IllegalArgumentException("Request must be specified.");

      PSRequest clonedReq = request.cloneRequest();
      checkInternalRequestAuthorization(clonedReq);

      PSExecutionData execData = null;
      try
      {
         execData = executeQueryRequest(clonedReq);
      }
      catch (PSException e)
      {
         reportError(request, e);
         throw new PSInternalRequestCallException(e.getErrorCode(),
            e.getErrorArguments(), e);
      }
      catch (Exception e)
      {
         reportError(request, e);
         throw new PSInternalRequestCallException(
            IPSDataErrors.INTERNAL_REQUEST_CALL_EXCEPTION, 
            getExceptionText(e), e);
      }

      return execData;
   }


   // see IPSInternalRequestHandler interface for description
   public Document getResultDocument(PSRequest request)
      throws PSInternalRequestCallException, PSAuthorizationException,
      PSAuthenticationFailedException
   {
      if (request == null)
         throw new IllegalArgumentException("Request must be specified.");

      PSRequest clonedReq = request.cloneRequest();
      checkInternalRequestAuthorization(clonedReq);

      PSExecutionData execData = null;
      try
      {
         execData = executeQueryRequest(clonedReq);
         if (m_converter instanceof PSResultSetMimeConverter)
         {
            throw new PSInternalRequestCallException(
               IPSDataErrors.INVALID_INTERNAL_RESULT_CALL, "getResultDoc");
         } else {
            try {
               return
                     ((PSResultSetXmlConverter)m_converter).createXmlDocument(
                        execData, m_rowFilter, true);
            } catch (PSConversionException e)
            {
               throw new PSInternalRequestCallException(e.getErrorCode(),
                  e.getErrorArguments());
            }
         }
      }
      catch (PSException e)
      {
         throw new PSInternalRequestCallException(e.getErrorCode(),
            e.getErrorArguments());
      }
      catch (SQLException e)
      {
         throw new PSInternalRequestCallException(
            IPSDataErrors.INTERNAL_REQUEST_CALL_EXCEPTION, getExceptionText(e));
      }
      finally
      {
         if (execData != null)
            execData.release();
      }
   }

   /**
    * Returns <code>IPSInternalRequest.REQUEST_TYPE_QUERY</code>.
    *
    * see {@link IPSInternalRequestHandler#getRequestType()} for details.
    */
   public int getRequestType()
   {
      return IPSInternalRequest.REQUEST_TYPE_QUERY;
   }

   //see IPSInternalResultHandler interface for description
   public ByteArrayOutputStream getMergedResult(PSExecutionData data)
      throws PSInternalRequestCallException, PSAuthorizationException,
      PSAuthenticationFailedException
   {
      if (data == null)
         throw new IllegalArgumentException("Executeion data cannot be null.");

      ByteArrayOutputStream out = null;

      /*we assume that security has already been checked when the execution
         data was requested */
      try
      {
         if (m_converter instanceof PSResultSetMimeConverter)
         {
            throw new PSInternalRequestCallException(
               IPSDataErrors.INVALID_INTERNAL_RESULT_CALL, "getResultDoc");
         }
         else
         {
            try
            {
               Document resultDoc =
                  ((PSResultSetXmlConverter)m_converter).createXmlDocument(
                     data, m_rowFilter, false);

               out = new ByteArrayOutputStream();

               // merge the doc w/ the stylesheet
               PSStyleSheetMerger.merge(data.getRequest(), resultDoc, out);

               return out;
            }
            catch (PSConversionException e)
            {
               throw new PSInternalRequestCallException(e.getErrorCode(),
                  e.getErrorArguments());
            }
         }
      }
      catch (PSException e)
      {
         throw new PSInternalRequestCallException(e.getErrorCode(),
            e.getErrorArguments());
      }
   }
   
   /**
    * A special version of the <code>getMergedResult</code> method that
    * will run the namespace cleanup on the merged result if the 
    * stylesheet's namespace cleanup flag is set. 
    * See {@link IPSInternalResultHandler#getMergedResult(PSExecutionData)} for more 
    * details. 
    * @param invokeNamespaceCleanup flag indicating that namespace cleanup should
    * run if the flag is set on the stylesheet.
    */
   public ByteArrayOutputStream getMergedResult(PSExecutionData data,
      boolean invokeNamespaceCleanup)
      throws PSInternalRequestCallException, PSAuthorizationException,
      PSAuthenticationFailedException
   {
      ByteArrayOutputStream result = getMergedResult(data);
      if(invokeNamespaceCleanup)
      {
         PSResultSetXmlConverter converter = 
            ((PSResultSetXmlConverter)m_converter);
         int index = converter.getResultPageIndex(data);
         String encoding = converter.getEncodingForRequestPage(index);
         if(encoding == null)
            encoding = converter.getRequestorCharacterEncoding();
         if(converter.isNamespaceCleanupAllowedForResultPage(index))
         {
            try
            {
               String mergedResults = result.toString(encoding);
               mergedResults = 
                  PSStylesheetCleanupUtils.namespaceCleanup(
                     mergedResults, PSStylesheetCleanupFilter.getInstance());
               byte[] mergedAsBytes = mergedResults.getBytes(encoding);
               ByteArrayOutputStream os = new ByteArrayOutputStream();
               os.write(mergedAsBytes);
               result = os;
            }
            catch (Exception e)
            {
               Object[] args = new Object[]{e.getClass().getName(),
                  e.getLocalizedMessage()};
               PSConsole.printWarnMsg("QueryHandler",
                  IPSServerErrors.NORUN_NAMESPACE_CLEANUP_WARNING, args);
            }          
         }
      }
      return result;
   }

   /* ********* IPSInternalResultHandler Interface Implementation ********* */

   // See IPSInternalResultHandler interface for description
   public Document getResultDoc(PSExecutionData data)
      throws PSInternalRequestCallException
   {
      if (m_converter instanceof PSResultSetMimeConverter)
      {
         throw new PSInternalRequestCallException(
            IPSDataErrors.INVALID_INTERNAL_RESULT_CALL, "getResultDoc");
      } else {
         try {
            if (data != null)
               return
                  ((PSResultSetXmlConverter)m_converter).createXmlDocument(
                     data, m_rowFilter, true);
            else
               throw new IllegalArgumentException("Execution data must not be null.");
         } catch (PSConversionException e)
         {
            throw new PSInternalRequestCallException(e.getErrorCode(),
               e.getErrorArguments());
         }
      }
   }

   // See IPSInternalResultHandler interface for description
   public PSMimeContentResult getMimeContent(PSExecutionData data,
      boolean setResponse)
      throws PSInternalRequestCallException
   {
      if (data == null)
         throw new IllegalArgumentException(
            "Execution data must not be null.");

      if (m_converter instanceof PSResultSetMimeConverter)
      {

         PSResultSetMimeConverter c = (PSResultSetMimeConverter) m_converter;
         try
         {
            ((PSResultSetMimeConverter) m_converter).processMimeContent(
               data, setResponse);

            if (setResponse)
               return null;

            return data.getMimeContentResult();
         }
         catch (PSConversionException e)
         {
            throw new PSInternalRequestCallException(e.getErrorCode(),
               e.getErrorArguments());
         }
      }
      else
      {
         throw new PSInternalRequestCallException(
            IPSDataErrors.INVALID_INTERNAL_RESULT_CALL, "getInputStream");
      }
   }

   /**
    * Get the result set based on the execution data created when the
    * internal request was made.  Since there is no conversion necessary,
    * none of the resultset converters need be called.  The caller of this
    * method is not responsible for closing the result set!
    *
    * @return the result set, or <code>null</code> if the result set stack
    *    is empty or the execution data has not been supplied.
    *
    * @throws PSInternalRequestCallException If there are multiple result
    *    sets to return.
    */
   public ResultSet getResultSet(PSExecutionData data)
      throws PSInternalRequestCallException
   {
      ResultSet rs = null;

      if (data != null)
      {
         /* if there's more than one result set on the stack, we're
          * in trouble!!! we must have missed a join.
          */
         Stack stack = data.getResultSetStack();

         if (stack.size() > 1)
         {
            throw new PSInternalRequestCallException(
               IPSDataErrors.CANNOT_RETURN_MULTIPLE_RESULT_SETS,
               new Integer(stack.size()));
         } else
         {
            rs = (ResultSet) stack.pop();
         }
      } else
         throw new IllegalArgumentException("Execution data must not be null.");

      return rs;
   }

   /**
    * Shutdown the request handler, freeing any associated resources.
    */
   public void shutdown()
   {
      /* nothing to do here */
   }

   /**
    * This array contains the query execution plan. It contains
    * the steps that must be performed, in the appropriate order. It may
    * contain SELECT statements (PSQueryStatement), joins (PSQueryJoiner),
    * and extension runners (???).
    */
   private IPSExecutionStep[]       m_execPlanQuery;

   private IPSResultSetConverter    m_converter;

   /**
    * The pager used by this query; may be <code>null</code>
    */
   private PSResultPager m_pager = null;
   /**
    * See {@link #setRowFilter(IPSResultSetDataFilter)} for details. Defaults
    * to <code>null</code>.
    */
   private IPSResultSetDataFilter m_rowFilter = null;
}
