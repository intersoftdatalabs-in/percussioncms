/*
 *     Percussion CMS
 *     Copyright (C) 1999-2020 Percussion Software, Inc.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU Affero General Public License for more details.
 *
 *     Mailing Address:
 *
 *      Percussion Software, Inc.
 *      PO Box 767
 *      Burlington, MA 01803, USA
 *      +01-781-438-9900
 *      support@percussion.com
 *      https://www.percussion.com
 *
 *     You should have received a copy of the GNU Affero General Public License along with this program.  If not, see <https://www.gnu.org/licenses/>
 */

package com.percussion.design.objectstore;

import com.percussion.conn.IPSConnectionErrors;
import com.percussion.conn.PSDesignerConnection;
import com.percussion.conn.PSServerException;
import com.percussion.design.objectstore.server.PSXmlObjectStoreHandler;
import com.percussion.error.PSException;
import com.percussion.extension.IPSExtensionDef;
import com.percussion.extension.IPSExtensionDefFactory;
import com.percussion.extension.PSExtensionDefFactory;
import com.percussion.extension.PSExtensionException;
import com.percussion.extension.PSExtensionRef;
import com.percussion.security.PSAuthenticationFailedException;
import com.percussion.security.PSAuthorizationException;
import com.percussion.server.PSConsole;
import com.percussion.server.config.PSServerConfigException;
import com.percussion.services.datasource.PSHibernateDialectConfig;
import com.percussion.services.security.data.PSCatalogerConfig;
import com.percussion.tablefactory.PSJdbcTableSchemaCollection;
import com.percussion.util.PSCollection;
import com.percussion.utils.container.IPSJndiDatasource;
import com.percussion.utils.container.jboss.PSJBossJndiDatasource;
import com.percussion.utils.jdbc.PSConnectionDetail;
import com.percussion.utils.jdbc.PSDatasourceResolver;
import com.percussion.utils.spring.IPSBeanConfig;
import com.percussion.utils.xml.PSInvalidXmlException;
import com.percussion.xml.PSXmlDocumentBuilder;
import com.percussion.xml.PSXmlTreeWalker;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.List;
import java.util.Properties;
import java.util.Vector;

import org.apache.commons.lang.StringUtils;
import org.w3c.dom.Document;
import org.w3c.dom.Element;

/**
 * The PSObjectStore class allows a client, such as the E2 designer, to
 * access the objects within an object store. The E2 server checks the
 * application ACLs to verify that the client actually has designer access
 * to the application before permitting any actions against it.
 *
 * @author      Tas Giakouminakis
 * @version    1.0
 * @since      1.0
 */
public class PSObjectStore
{

   /**
    * Constructs a PSObjectStore object, creating the client-end of a
    * connection to the object store.
    *
    * @param conn the connection object for the desired E2 server
    * @param uniqueId a unique id generated by the client that will be
    * used as an application lock identifier. We will default to using the
    * user's session id if this value is <code>null</code> or empty.                                         
    */
   public PSObjectStore(PSDesignerConnection conn, String uniqueId)
   {
      
      if (conn == null)
         throw new IllegalArgumentException("conn obj null");

      m_conn   = conn;
      m_uid    = conn.getUserName();
      m_uniqueClientId = uniqueId;
   }
   
   /**
    * Constructs a PSObjectStore object, creating the client-end of a
    * connection to the object store.
    *
    * @param conn the connection object for the desired E2 server                                           
    */
   public PSObjectStore(PSDesignerConnection conn)
   {
      this(conn, null);      
   }

   /**
    * No-parameter constructor. For testing only.
    */
   public PSObjectStore() {}

   /**
    * Constructs a new application object containing default settings.
    * It contains no page or pipe objects upon initial creation. The user
    * making this request is added to the ACL with full access. The specified
    * name will be used for the application. May throw a PSNonUniqueException
    * if an application by the same name already exists.
    *
    * @param     name                     a unique name to assign the
    *                                     application
    *
    * @return                              the newly created object
    *
    * @throws PSServerException         if the server is not responding
    *
    * @throws PSAuthorizationException if the user is not permitted to
    *                                     create applications on the server
    *
    * @throws PSNonUniqueException      if an application by the same name
    *                                     already exists (might not throw this)
    *
    * @see        PSApplication
    */
   public PSApplication createApplication(java.lang.String name)
      throws PSServerException, PSAuthorizationException,
      PSAuthenticationFailedException,
      PSNonUniqueException
   {
      PSApplication app = new PSApplication(name);

      /* create a default ACL with:
       *  - Default entry with no access
       *  - user entry with full access
       */
      PSAcl acl = new PSAcl();

      PSCollection entries = acl.getEntries();

      PSAclEntry ace = new PSAclEntry(   PSAclEntry.DEFAULT_USER_NAME,
         PSAclEntry.ACE_TYPE_USER);
      ace.setAccessLevel(PSAclEntry.AACE_NO_ACCESS);
      entries.add(ace);

      ace = new PSAclEntry(m_uid, PSAclEntry.ACE_TYPE_USER);
      ace.setAccessLevel(   PSAclEntry.AACE_DATA_CREATE |
         PSAclEntry.AACE_DATA_DELETE |
         PSAclEntry.AACE_DATA_UPDATE |
         PSAclEntry.AACE_DATA_QUERY |
         PSAclEntry.AACE_DESIGN_DELETE |
         PSAclEntry.AACE_DESIGN_READ |
         PSAclEntry.AACE_DESIGN_UPDATE |
         PSAclEntry.AACE_DESIGN_MODIFY_ACL);
      entries.add(ace);

      app.setAcl(acl);

      return app;
   }

   /**
    * Gets the System Fields definition for content editor either for editing or
    * reading based on the value passed to <code>lock</code> parameter. The
    * caller must have admin privileges to lock the file, but only designer
    * privileges to read it.
    *
    * @param lock A flag to indicate how the system definition fields are
    * going to be used. If it is <code>true</code> it is for editing, otherwise
    * it is for reading only.  If the definition is not locked, it cannot be
    * saved. The lock is valid for 30 minutes unless it is renewed or released.
    *
    * @param overrideSameUser If <code>true</code>, and <code>lock</code>
    * is <code>true</code>, and the definition is already locked by the
    * requesting user in a different session, will automatically steal the lock
    * from the other session. If <code>false</code>, and <code>lock</code> is
    * <code>true</code>, and the definition is already locked by the requesting
    * user in a different session (or any other user), will throw a
    * PSServerException with a nested PSLockedException. If
    * <code>lock</code> is <code>false</code>, this parameter is ignored.
    *
    * @return Definition of system for content editor resources which is
    * defined in 'rxconfig\Server\ContentEditors\ContentEditorSystemDef.xml'
    * under rhythmyx root, never <code>null</code>
    *
    * @throws PSServerException If the server is not responding or any error
    * occurs in processing the request.
    * @throws PSAuthorizationException If the user is not permitted to lock
    * the definition on the server.
    * @throws PSAuthenticationFailedException If the user's session timed out
    * and they could not be authenticated with the same credentials.
    * @throws PSLockedException If another user already owns the definition lock
    * and the lock flag was specified and the override flag wasn't.
    */
   public PSContentEditorSystemDef getContentEditorSystemDef ( boolean lock,
         boolean overrideSameUser)
      throws PSServerException, PSAuthorizationException,
         PSAuthenticationFailedException, PSLockedException
   {
      if (lock) throw new IllegalArgumentException(
            "Locking is currently not supported." );

      if (ms_systemDef == null)
      {
         // build request
         Document request = PSXmlDocumentBuilder.createXmlDocument();
         Element root = PSXmlDocumentBuilder.createRoot(request,
               "PSXContentEditorSystemDefinitionLoad");

         try
         {
            Document respDoc = makeRequest(
                  "design-objectstore-cesystemdef-load", request);
            ms_systemDef = new PSContentEditorSystemDef(respDoc);
         }
         catch (PSUnknownDocTypeException e)
         {
            throw new PSServerException(e);
         }
         catch (PSUnknownNodeTypeException e)
         {
            throw new PSServerException(e);
         }
      }

      return ms_systemDef;
   }

   /**
    * Gets the shared definition for Content Editors either for editing or
    * reading based on the value passed to <code>lock</code> parameter. The
    * caller must have admin privileges to lock the file, but only designer
    * privileges to read it.
    *
    * @param lock A flag to indicate how the system definition fields are
    * going to be used. If it is <code>true</code> it is for editing, otherwise
    * it is for reading only.  If the definition is not locked, it cannot be
    * saved. The lock is valid for 30 minutes unless it is renewed or released.
    *
    * @param overrideSameUser If <code>true</code>, and <code>lock</code>
    * is <code>true</code>, and the definition is already locked by the
    * requesting user in a different session, will automatically steal the lock
    * from the other session. If <code>false</code>, and <code>lock</code> is
    * <code>true</code>, and the definition is already locked by the requesting
    * user in a different session (or any other user), will throw a
    * PSServerException with a nested PSLockedException. If
    * <code>lock</code> is <code>false</code>, this parameter is ignored.
    *
    * @return Definition of all shared groups for content editor resources which
    * are defined in xml files in directory
    * 'rxconfig\Server\ContentEditors\shared' under rhythmyx root, never
    * <code>null</code>.
    *
    * @throws PSServerException If the server is not responding or any error
    * occurs in processing the request.
    * @throws PSAuthorizationException If the user is not permitted to lock
    * the definition on the server.
    * @throws PSAuthenticationFailedException If the user's session timed out
    * and they could not be authenticated with the same credentials.
    * @throws PSLockedException If another user already owns the definition lock
    * and the lock flag was specified and the override flag wasn't.
    */
   public PSContentEditorSharedDef getContentEditorSharedDef ( boolean lock,
         boolean overrideSameUser )
      throws PSServerException, PSAuthorizationException,
         PSAuthenticationFailedException, PSLockedException
   {
      if (lock) throw new IllegalArgumentException(
            "Locking is currently not supported." );

      if (ms_sharedDef == null)
      {
         // build request
         Document request = PSXmlDocumentBuilder.createXmlDocument();
         Element root = PSXmlDocumentBuilder.createRoot(request,
               "PSXContentEditorSharedDefinitionLoad");

         try
         {
            Document respDoc = makeRequest(
                  "design-objectstore-ceshareddef-load", request);
            ms_sharedDef = new PSContentEditorSharedDef(respDoc);
         }
         catch (PSUnknownDocTypeException e)
         {
            throw new PSServerException(e);
         }
         catch (PSUnknownNodeTypeException e)
         {
            throw new PSServerException(e);
         }
      }

      return ms_sharedDef;
   }
   
   /**
    * Get the connection detail for the specified datasource
    * 
    * @param datasource The name of the datasource configuration for which
    * detail is to be obtained, may be <code>null</code> or empty to indicate
    * the default datasource.
    *  
    * @return The detail, never <code>null</code>.
    * @throws PSAuthorizationException If the user does not have the required
    * access level.
    * @throws PSAuthenticationFailedException If the user's session timed out
    * and they could not be authenticated with the same credentials.
    * @throws PSServerException if there are any other errors.
    */
   public PSConnectionDetail getConnectionDetail(String datasource) 
      throws PSServerException, PSAuthorizationException, 
         PSAuthenticationFailedException
   {
      // build request
      Document request = PSXmlDocumentBuilder.createXmlDocument();
      Element root = PSXmlDocumentBuilder.createRoot(request,
            "PSXGetConnectionDetails");
      if (datasource != null)
         root.setAttribute("dsName", datasource);

      Document respDoc = makeRequest(
            "design-objectstore-datasource-conndetail", request);
      Element respRoot = respDoc.getDocumentElement();
      if (respRoot == null)
      {
         throw new PSServerException(
               IPSObjectStoreErrors.MALFORMED_RESPONSE_DOCUMENT, null);
      }
      return new PSConnectionDetail(respRoot.getAttribute("datasource"),
            respRoot.getAttribute("driver"), respRoot.getAttribute("database"),
            respRoot.getAttribute("origin"), respRoot.getAttribute("jdbcUrl"));
   }

   /**
    * Provides all roles and related subjects, possibly for editing. If you
    * want to change the roles, you must supply <code>true</code> for the
    * <code>lock</code> flag.
    * <p>Note, the server config and the role config share the same lock. If
    * you are editing just the roles, then the lock should be managed with
    * this method. If you are editing both, then the lock should be managed
    * with the server configuration methods. In other words, if you already
    * have a lock on the server config, all of the flags for this method are
    * ignored.
    *
    * @param lock A flag to indicate that the role list is being obtained for
    *    editing. If the collection is not locked, it cannot be saved. The
    *    lock is valid for 30 minutes unless it is renewed or released.
    *
    * @param overrideSameUser If <CODE>true</CODE>, and <CODE>lock</CODE>
    * is <CODE>true</CODE>, and the config is already locked by the requesting
    * user in a different session, will automatically steal the lock from the
    * other session. If <CODE>false</CODE>, and <CODE>lockConfig</CODE> is
    * <CODE>true</CODE>, and the config is already locked by the requesting
    * user in a different session (or any other user), will throw a
    * PSServerException with a nested PSLockedException. If
    * <CODE>lock</CODE> is <CODE>false</CODE>, this parameter is ignored.
    *
    * @param overrideDifferentUser If <code>lock</code> is <code>true</code>,
    *    and the role config is currently locked by another admin, if this
    *    flag is <code>true
    *    </code>, then the current lock will be released and this requestor
    *    will obtain the lock. This mechanism is provided to allow a scheduled
    *    program to complete its updates even though someone may have left
    *    an administration session open. If this is going to be used, the
    *    method should always first be called with this flag set to <code>
    *    false</code>, then resent with <code>true</code> if needed, logging
    *    the override.
    *
    * @return A valid configuration containing 0 or more {@link PSRole}
    *    objects and their related PSSubjects.
    *
    * @throws PSServerException If the server is not responding
    *
    * @throws PSAuthorizationException If the user is not permitted to lock
    *    server/role configurations on the server.
    *
    * @throws PSAuthenticationFailedException If the user's session timed out
    *    and they could not be authenticated with the same credentials.
    *
    * @throws PSLockedException If another user already owns the server/role
    *    configuration lock and the lock flag was specified and the override
    *    flag wasn't.
    */
   public PSRoleConfiguration getRoleConfiguration( boolean lock,
         boolean overrideSameUser, boolean overrideDifferentUser )
      throws PSServerException,
         PSAuthorizationException,
         PSAuthenticationFailedException,
         PSLockedException
   {
      /* format the request as an XML document */
      Document sendDoc = PSXmlDocumentBuilder.createXmlDocument();
      Element root = PSXmlDocumentBuilder.
            createRoot(sendDoc, "PSXDesignServerRolesLoad");
      root.setAttribute("mode", lock ? "edit" : "read");
      root.setAttribute("overrideSameUser", (overrideSameUser) ? "yes" : "no");
      root.setAttribute("overrideDifferentUser",
            (overrideDifferentUser) ? "yes" : "no");

      /* send the request to the server */

      try
      {
         Document respDoc = makeRequest(
               "design-objectstore-serverroles-load", sendDoc);
         /* convert the response to a config object */
         PSRoleConfiguration config = new PSRoleConfiguration();

         Element respRoot = respDoc.getDocumentElement();
         PSXmlTreeWalker tree = new PSXmlTreeWalker(respDoc);
         if (tree.getNextElement(
            PSRoleConfiguration.ms_NodeType, true, true) != null) {
            /* need to promote PSXServerConfiguration to the root */
            PSXmlDocumentBuilder.replaceRoot(respDoc,
               (Element)tree.getCurrent());

            try {
               config.fromXml(respDoc);
            } catch (PSUnknownDocTypeException e) {
               throw new PSServerException(e);
            } catch (PSUnknownNodeTypeException e) {
               throw new PSServerException(e);
            }
         }
         else {
            throw new PSServerException(
               IPSObjectStoreErrors.MALFORMED_RESPONSE_DOCUMENT,
               respRoot.getNodeName());
         }

         return config;
      }
      catch (PSServerException e)
      {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null) {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException)throwExc;
            else if (throwExc instanceof PSLockedException)
               throw (PSLockedException)throwExc;
         }
         throw e;
      }
   }

   /**
    * Adds new table definitions to the backend database using
    * the specified database and table schema definitions.
    * <p>
    * Format of the request:
    * <code><pre>
    * &lt;PSXDesignTableDefinitionsSave>
    *    &lt;PSXTableLocator>...&lt;/PSXTableLocator>
    *    &lt;tables>
    *       &lt;table>...&lt;/table>
    *    &lt;/tables>
    *    &lt;tables>
    *       &lt!-- empty data definitions for each table -->
    *       &lt;table name="" />
    *    &lt;/tables>
    * &lt;/PSXDesignTableDefinitionsSave>
    * </pre></code>
    *
    * @author James Schultz
    * @param dbms identifies which database to use and how to connect (driver
    * and credential information); cannot be <code>null</code>.
    * @param defs an array of table definitions which may specify new tables or
    * existing tables with new columns. This cannot be <code>null</code> or
    * empty. The each element in the array cannot be <code>null</code>.
    *
    * @return either success document or error document.
    * The structure of success document is:
    * <pre><code>
    *  &lt;!--
    *    Either 'success' or 'error' element for each table schema processed.
    *  --&gt;
    *  &lt;!ELEMENT PSXDesignTableDefinitionsSaveResults (success*, error*)&gt;
    *
    *  &lt;!ELEMENT success  (#PCDATA)&gt;
    *  &lt;!ATTLIST success
    *       tableName CDATA #REQUIRED
    *       create(y|n) "y"&gt;
    *
    *  &lt;!ELEMENT error (#PCDATA)&gt;
    *  &lt;!ATTLIST error
    *       tableName CDATA #REQUIRED
    *       create(y|n) "y" &gt;
    * </code></pre>
    * The structure of error document is:
    * <code><pre>
    * &lt;PSXDesignTableDefinitionsSaveResults>
    *    &lt;error>error message&lt;/error>
    * &lt;/PSXDesignTableDefinitionsSaveResults>
    * </pre></code>
    *
    * @throws PSServerException If the server is not responding or an error
    * occurs processing the request
    * @throws PSAuthorizationException If the user is not permitted to do this
    * action
    * @throws PSAuthenticationFailedException If the user's session is timed out
    * and they could not be authenticated with the same credentials.
    */
   public Document saveTableDefinitions(PSTableLocator dbms,
                                    PSJdbcTableSchemaCollection defs)
      throws PSServerException, PSAuthorizationException,
         PSAuthenticationFailedException
   {
      // validate parameters
      if (null == dbms) throw new IllegalArgumentException(
            "PSTableLocator cannot be null");
      if (null == defs || 0 == defs.size()) throw new IllegalArgumentException(
            "PSJdbcTableSchemaCollection cannot be null or empty");

         // build request
         Document request = PSXmlDocumentBuilder.createXmlDocument();
         Element root = PSXmlDocumentBuilder.createRoot(request,
               "PSXDesignTableDefinitionsSave");
         root.appendChild( dbms.toXml( request ) );
         root.appendChild( defs.toXml( request ) );

      return makeRequest("design-objectstore-tabledefinitions-save",
            request);
   }


   /**
    * Used to send the modified roles back to the server. The passed in
    * collection should be all of the roles obtained with the {@link
    * #getRoleConfiguration} method with any changes.
    *
    * @param config A valid collection of roles. It must be the same collection
    *    that was obtained with the <code>getRoleConfiguration</code> method,
    *    with any modifications.
    *
    * @param releaseLock If <code>true</code>, the lock on the roles will be
    *    released. Since the server config and role config share the same
    *    lock, If you are editing the server config at the same time as
    *    the role config, only release when saving the last config object
    *    (which could be the server config or the role config, it doesn't
    *    matter).
    *
    * @throws PSServerException If the server is not responding
    *
    * @throws PSAuthorizationException If the user is not permitted to lock
    *    server/role configurations on the server.
    *
    * @throws PSAuthenticationFailedException If the user's session timed out
    *    and they could not be authenticated with the same credentials.
    *
    * @throws PSLockedException If another user has acquired the server/role
    *    configuration lock. This usually occurs if the server configuration
    *    was not previously locked or the lock was lost due to a timeout.
    */
   public void saveRoleConfiguration( PSRoleConfiguration config,
         boolean releaseLock )
      throws PSServerException,
         PSAuthorizationException,
         PSAuthenticationFailedException,
         PSLockedException
   {
      /* format the request as an XML document
       * this is tricky due to the DOM rules, so we must let the config
       * build its XML doc, then we'll move the root node down a level
       */
      Document sendDoc = config.toXml();
      Element newRoot = sendDoc.createElement("PSXDesignServerRolesSave");
      newRoot.setAttribute("releaseLock", releaseLock ? "yes" : "no");

      PSXmlDocumentBuilder.swapRoot(sendDoc, newRoot);

      /* send the request to the server */
      try
      {
         makeRequest("design-objectstore-serverroles-save", sendDoc);
      }
      catch (PSServerException e)
      {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null) {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException)throwExc;
            else if (throwExc instanceof PSLockedException)
               throw (PSLockedException)throwExc;
         }
         throw e;
      }
   }

   /**
    * Gets the rx configuration that is identified by supplied name either in
    * edit or read mode based on the lock parameter value.
    *
    * @param name the name of rx configuration, may not be <code>null</code> and
    * must be one of the rx configurations.
    * @param lock A flag to indicate that the configuration is being obtained
    * for editing or not. Supply <code>true</code> to edit the configuration. If
    * the configuration is not locked, it cannot be saved. The lock is valid
    * until it is released by the same user or stolen by another user.
    * @param overrideSameUser supply <code>true</code> to override the lock if
    * the config is already locked by the requesting user in a different
    * session. If lock is <code>false</code> this parameter is ignored.
    * @param overrideDifferentUser supply <code>true</code> to override the lock
    * if the config is already locked by different user. If lock is <code>false
    * </code> this parameter is ignored.
    *
    * @throws PSServerConfigException if the config with supplied name does not
    * exist or if the configuration is not allowed to edit and user requested
    * the config to edit.
    * @throws PSLockedException if the config is locked and override flags are
    * not <code>true</code>
    * @throws PSAuthenticationFailedException if the requesting user is not
    * authenticated.
    * @throws PSAuthorizationException if the requesting user is not authorized.
    * @throws PSServerException if any error occurs.
    * @throws PSUnknownNodeTypeException if the response document is not a valid
    * configuration document.
    */
   public IPSConfig getRxConfiguration(String name, boolean lock,
      boolean overrideSameUser, boolean overrideDifferentUser)
      throws PSServerException, PSAuthenticationFailedException,
         PSAuthorizationException, PSLockedException, PSServerConfigException,
         PSUnknownNodeTypeException
   {
      if(name == null || name.trim().length() == 0)
         throw new IllegalArgumentException(
            "name may not be null or empty.");

      //format the request as an XML document
      Document sendDoc = PSXmlDocumentBuilder.createXmlDocument();
      Element root = PSXmlDocumentBuilder.
            createRoot(sendDoc, "PSXDesignRxConfigLoad");
      root.setAttribute("name", name);
      root.setAttribute("lock", lock ? "yes" : "no");
      root.setAttribute("overrideSameUser", (overrideSameUser) ? "yes" : "no");
      root.setAttribute("overrideDifferentUser",
            (overrideDifferentUser) ? "yes" : "no");

      /* send the request to the server */
      try
      {
         Document respDoc = makeRequest(
               "design-objectstore-rxconfig-load", sendDoc);
         return PSConfigurationFactory.getConfiguration(name, respDoc);
      }
      catch (PSServerException e)
      {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null) {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException)throwExc;
            else if (throwExc instanceof PSLockedException)
               throw (PSLockedException)throwExc;
            else if(throwExc instanceof PSServerConfigException)
               throw (PSServerConfigException)throwExc;
         }
         throw e;
      }
   }

   /**
    * Saves the specified rx configuration to server. To save the configuration
    * must be locked. This method can be called just to update the lock status
    * also.
    *
    * @param rxConfigName The name of the configuration, may not be <code>
    * null</code> or empty and must be one of the existing configurations.
    * @param rxConfig The configuration to be saved, supply <code>null</code> to
    * not to save the configuration and update the lock status alone.
    * @param releaseLock Supply <code>true</code> to release the lock on the
    * supplied configuration, otherwise <code>false</code>.
    *
    * @throws PSServerConfigException if the config with supplied name does not
    * exist
    * @throws PSNotLockedException if the config is not locked for save.
    * @throws PSAuthorizationException if the requesting user is not authorized.
    * @throws PSServerException if any error occurs.
    */
   public void saveRxConfiguration(String rxConfigName, IPSConfig rxConfig,
      boolean releaseLock)
      throws PSServerException, PSAuthenticationFailedException,
         PSAuthorizationException, PSNotLockedException, PSServerConfigException
   {
      if(rxConfigName == null || rxConfigName.trim().length() == 0)
         throw new IllegalArgumentException(
            "rxConfigName may not be null or empty.");

      //format the request as an XML document
      Document sendDoc = PSXmlDocumentBuilder.createXmlDocument();
      Element root = PSXmlDocumentBuilder.
            createRoot(sendDoc, "PSXDesignRxConfigSave");
      root.setAttribute("name", rxConfigName);
      root.setAttribute("releaseLock", releaseLock ? "yes" : "no");
      if(rxConfig != null)
      {
         PSXmlDocumentBuilder.addElement(sendDoc, root, "CONFIGURATION",
            rxConfig.getConfigString());
      }

      /* send the request to the server */
      try
      {
         makeRequest("design-objectstore-rxconfig-save", sendDoc);
      }
      catch (PSServerException e)
      {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null) {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException)throwExc;
            else if (throwExc instanceof PSNotLockedException)
               throw (PSNotLockedException)throwExc;
            else if(throwExc instanceof PSServerConfigException)
               throw (PSServerConfigException)throwExc;
         }
         throw e;
      }
   }


   /**
    * Constructs a new application object containing default settings.
    * It contains no page or pipe objects upon initial creation. The user
    * making this request is added to the ACL with full access. A unique
    * name is assigned to the application, which can be changed.
    *
    * @return                              the newly created object
    *
    * @throws PSServerException         if the server is not responding
    *
    * @throws PSAuthorizationException if the user is not permitted to
    *                                     create applications on the server
    *
    * @see        PSApplication
    */
   public PSApplication createApplication()
      throws PSServerException, PSAuthorizationException,
      PSAuthenticationFailedException
   {
      while (true) {
         try {
            return createApplication("App_" +
               String.valueOf((new Date()).getTime()));
         } catch (PSNonUniqueException e) {
            /* try again with the current time, we'll eventually get it */
         } catch (IllegalArgumentException e) {
            /* this can really never happen as it implies a null name
             * or a name that's too long, neither of which can happen
             */
            throw new PSServerException(0, e.getLocalizedMessage());
         }
      }
   }

   /**
    * Extend the write lock on an application. Write locks are granted for a
    * maximum of 30 minutes. If the designer needs more time to complete the
    * task, an additional 30 minute extension can be requested.
    *
    * @param     app                      the loaded application for which
    *                                     to extend the lock
    *
    * @throws PSServerException         if the server is not responding
    *
    * @throws PSAuthorizationException if the user is not permitted to
    *                                     create applications on the server
    *
    * @throws PSLockedException         if another user has acquired the
    *                                     application lock. This usually
    *                                     occurs if the application was not
    *                                     previously locked or the lock was
    *                                     lost due to a timeout.
    *
    * @see        PSApplication
    */
   public void extendApplicationLock(PSApplication app)
      throws PSServerException, PSAuthorizationException,
      PSAuthenticationFailedException,
      PSLockedException
   {
      extendApplicationLock(app, 30);
   }

   public void extendApplicationLock(PSApplication app,
                                     boolean overrideSameUser)
      throws PSServerException, PSAuthorizationException,
      PSAuthenticationFailedException,
      PSLockedException
   {
      extendApplicationLock(app, 30, overrideSameUser);
   }

   /**
    * Extend the write lock on an application. Write locks are granted for a
    * maximum of 30 minutes. If the designer needs more time to complete the
    * task, an additional 30 minute extension can be requested.
    *
    * @param     app                      the loaded application for which
    *                                     to extend the lock
    *
    * @param      minutes                  the number of minutes to extend.
    * The server will make sure this is <= 30 minutes. If <CODE>minutes</CODE>
    * is 0, it will try to release the lock rather than extend it.
    *
    * @throws PSServerException         if the server is not responding
    *
    * @throws PSAuthorizationException if the user is not permitted to
    *                                     create applications on the server
    *
    * @throws PSLockedException         if another user has acquired the
    *                                     application lock. This usually
    *                                     occurs if the application was not
    *                                     previously locked or the lock was
    *                                     lost due to a timeout.
    *
    * @see        PSApplication
    */
   public void extendApplicationLock(PSApplication app, int minutes)
      throws PSServerException, PSAuthorizationException,
      PSAuthenticationFailedException,
      PSLockedException
   {
      extendApplicationLock(app, minutes, false);
   }

   /**
    * Extend the write lock on an application. Write locks are granted for a
    * maximum of 30 minutes. If the designer needs more time to complete the
    * task, an additional 30 minute extension can be requested.
    *
    * @param     app                      the loaded application for which
    *                                     to extend the lock
    *
    * @param      minutes                  the number of minutes to extend.
    *
    * @param   overrideSameUser      If <CODE>true</CODE>, will allow the lock
    * to be stolen if it is locked by the same user under a different session.
    * If <CODE>false</CODE>, will treat that condition the same as if it
    * were locked by anyone else.
    *
    * The server will make sure this is <= 30 minutes. If <CODE>minutes</CODE>
    * is 0, it will try to release the lock rather than extend it.
    *
    * @throws PSServerException         if the server is not responding
    *
    * @throws PSAuthorizationException if the user is not permitted to
    *                                     create applications on the server
    *
    * @throws PSLockedException         if another user has acquired the
    *                                     application lock. This usually
    *                                     occurs if the application was not
    *                                     previously locked or the lock was
    *                                     lost due to a timeout.
    *
    * @see        PSApplication
    */
   public void extendApplicationLock(PSApplication app,
                                     int minutes,
                                     boolean overrideSameUser)
      throws PSServerException, PSAuthorizationException,
      PSAuthenticationFailedException, PSLockedException
   {
      /* format the request as an XML document */
      Document sendDoc = PSXmlDocumentBuilder.createXmlDocument();

      Element root = PSXmlDocumentBuilder.createRoot(   sendDoc,
         "PSXDesignAppLock");

      // setting this means that the lock should be released
      root.setAttribute("lockMins", "" + minutes);
      root.setAttribute("overrideSameUser", (overrideSameUser) ? "yes" : "no");

      PSXmlDocumentBuilder.addElement(   sendDoc, root, "applid",
         String.valueOf(app.getId()));

      /* send the request to the server */
      try
      {
         makeRequest("design-objectstore-app-lock", sendDoc);
      }
      catch (PSServerException e)
      {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null) {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException)throwExc;
            else if (throwExc instanceof PSLockedException)
               throw (PSLockedException)throwExc;
         }
         throw e;
      }
   }


   /**
    * Releases the application lock.
    *
    * @author   chadloder
    *
    * @version 1.21 1999/07/13
    *
    * @param   app The application.
    *
    * @throws PSServerException         if the server is not responding
    *
    * @throws PSAuthorizationException if the user is not permitted to
    *                                     create applications on the server
    *
    * @throws PSLockedException         if another user has acquired the
    *                                     application lock. This usually
    *                                     occurs if the application was not
    *                                     previously locked or the lock was
    *                                     lost due to a timeout.
    *
    * @see        PSApplication
    *
    */
   public void releaseApplicationLock(PSApplication app)
      throws PSServerException, PSAuthorizationException,
      PSAuthenticationFailedException,
      PSLockedException
   {
      extendApplicationLock(app, 0, true);
   }

   /**
    * Constructs an application object for the specified application. The
    * application is loaded from the object store when this method is called.
    * If the application is being loaded for editing, be sure to lock the
    * application.
    *
    * @param     appName                  the name of the application to load
    *
    * @param     lockApp                  if <code>true</code>, a 30 minute
    *                                     write lock will be granted on the
    *                                     application. Others will be
    *                                     permitted to read the app, but
    *                                     no one else can request a write
    *                                     lock. To lock the app for extended
    *                                     periods of time, call
    *                                     extendApplicationLock.
    *
    * @return                              the application object
    *
    * @throws PSServerException         if the server is not responding
    *
    * @throws PSAuthorizationException if user does not have designer
    *                                     access to the application
    *
    * @throws PSLockedException         if lockApp is <code>true</code> but
    *                                     another user already has the
    *                                     application locked
    *
    * @throws PSNotFoundException      if an application by that name
    *                                     does not exist
    *
    * @see        PSApplication
    */
   public PSApplication getApplication(String appName,
      boolean lockApp)
      throws PSServerException, PSAuthorizationException,
      PSAuthenticationFailedException,
      PSLockedException, PSNotFoundException
   {
      return getApplication(appName, lockApp, false);
   }

   /**
    * Constructs an application object for the specified application. The
    * application is loaded from the object store when this method is called.
    * If the application is being loaded for editing, be sure to lock the
    * application.
    *
    * @param     appName                  the name of the application to load
    *
    * @param     lockApp                  if <code>true</code>, a 30 minute
    *                                     write lock will be granted on the
    *                                     application. Others will be
    *                                     permitted to read the app, but
    *                                     no one else can request a write
    *                                     lock. To lock the app for extended
    *                                     periods of time, call
    *                                     extendApplicationLock.
    *
    * @param   overrideSameUser      If <CODE>true</CODE>, will allow the lock
    * to be stolen if it is locked by the same user under a different session.
    * If <CODE>false</CODE>, will treat that condition the same as if it
    * were locked by anyone else. This parameter is ignored if
    * <CODE>lockApp</CODE> is false.
    *
    * @return                              the application object
    *
    * @throws PSServerException         if the server is not responding
    *
    * @throws PSAuthorizationException if user does not have designer
    *                                     access to the application
    *
    * @throws PSLockedException         if lockApp is <code>true</code> but
    *                                     another user already has the
    *                                     application locked
    *
    * @throws PSNotFoundException      if an application by that name
    *                                     does not exist
    *
    * @see        PSApplication
    */
   public PSApplication getApplication(String appName, boolean lockApp,
      boolean overrideSameUser)
      throws PSServerException, PSAuthorizationException,
      PSAuthenticationFailedException, PSLockedException, PSNotFoundException
   {
      /* format the request as an XML document */
      Document sendDoc = PSXmlDocumentBuilder.createXmlDocument();

      Element root = PSXmlDocumentBuilder.createRoot(   sendDoc,
         "PSXDesignAppLoad");
      root.setAttribute("mode", lockApp ? "edit" : "read");
      root.setAttribute("overrideSameUser", (overrideSameUser) ? "yes" : "no");

      PSXmlDocumentBuilder.addElement(   sendDoc, root, "name", appName);

      /* send the request to the server */

      try
      {
         /* convert the response to an application object */
         Document respDoc = makeRequest("design-objectstore-app-load",
               sendDoc);
         PSApplication app = new PSApplication();

         root = respDoc.getDocumentElement();
         PSXmlTreeWalker tree = new PSXmlTreeWalker(respDoc);
         if (tree.getNextElement(PSApplication.ms_NodeType, true, true)
             != null)
         {
            /* need to promote PSXApplication to the root */
            PSXmlDocumentBuilder.replaceRoot(respDoc,
               (Element)tree.getCurrent());

            try {
               app.fromXml(respDoc);
            } catch (PSUnknownDocTypeException e) {
               throw new PSServerException(e);
            } catch (PSUnknownNodeTypeException e) {
               throw new PSServerException(e);
            }
         }
         else {
            throw new PSServerException(
               IPSObjectStoreErrors.MALFORMED_RESPONSE_DOCUMENT,
               new Object[] { PSApplication.ms_NodeType, null } );
         }
         return app;
      }
      catch (PSServerException e)
      {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null) {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException)throwExc;
            else if (throwExc instanceof PSLockedException)
               throw (PSLockedException)throwExc;
            else if (throwExc instanceof PSNotFoundException)
               throw (PSNotFoundException)throwExc;
         }
         throw e;
      }
   }

   /**
    * Get the log messages generated by an application during the specified
    * interval.
    * <p>
    * Returned messages are formatted as:
    * <pre><code>
    *    DateTime  LogType.SubCode   LogText
    *    ...
    *    DateTime  LogType.SubCode   LogText
    * <pre><code>
    *
    * @param     appName                  the name of the application to get
    *                                     the log entries for
    *
    * @param     startTime                the earliest time to retrieve log
    *                                     entries from. Use <code>null</code>
    *                                     to ignore start time
    *
    * @param     endTime                  the latest time to retrieve log
    *                                     entries from. Use <code>null</code>
    *                                     to ignore end time
    *
    * @return                              the log stream
    *
    * @throws PSServerException         if the server is not responding
    *
    * @throws PSAuthorizationException if user does not have designer
    *                                     access to the application
    *
    * @throws PSNotFoundException      if an application by that name
    *                                     does not exist
    *
    * @see        PSApplication
    */
   public java.io.InputStream getApplicationLog(java.lang.String appName,
      java.util.Date startTime,
      java.util.Date endTime)
      throws PSServerException, PSAuthorizationException,
      PSAuthenticationFailedException,
      PSNotFoundException
   {
      Object[] args = { appName, startTime, endTime };
      throw new PSNotFoundException(
         IPSObjectStoreErrors.GET_APP_LOG_NO_DATA, args);
   }

   /**
    * Get the log messages generated by an application during the specified
    * interval.
    * <p>
    * Returned messages are formatted as:
    * <pre><code>
    *    DateTime  LogType.SubCode   LogText
    *    ...
    *    DateTime  LogType.SubCode   LogText
    * <pre><code>
    *
    * @param     app                      the application to get
    *                                     the log entries for
    *
    * @param     startTime                the earliest time to retrieve log
    *                                     entries from. Use <code>null</code>
    *                                     to ignore start time
    *
    * @param     endTime                  the latest time to retrieve log
    *                                     entries from. Use <code>null</code>
    *                                     to ignore end time
    *
    * @return                              the log stream
    *
    * @throws PSServerException         if the server is not responding
    *
    * @throws PSAuthorizationException if user does not have designer
    *                                     access to the application
    *
    * @throws PSNotFoundException      if an application by that name
    *                                     does not exist
    *
    * @see        PSApplication
    */
   public java.io.InputStream getApplicationLog(PSApplication app,
      java.util.Date startTime,
      java.util.Date endTime)
      throws PSServerException, PSAuthorizationException,
      PSAuthenticationFailedException,
      PSNotFoundException
   {
      String     sTemp = app.getName();

      return getApplicationLog(sTemp, startTime, endTime);
   }

   /**
    * Convenience method for retrieving non-hidden applications.
    * @see #getApplicationSummaries(Properties, boolean)
    */
   public Enumeration getApplicationSummaries(Properties info)
      throws PSAuthenticationFailedException, PSServerException
   {
      return getApplicationSummaries(info, false);
   }
   
   /**
    * Convenience method to get all application summaries, calls
    * {@link #getApplicationSummaries(Properties, boolean, String)
    * getApplicationSummaries(info, showHiddenApps, null)}
    */
   public Enumeration getApplicationSummaries(Properties info,
      boolean showHiddenApps)
      throws PSAuthenticationFailedException, PSServerException
   {
      return getApplicationSummaries(info, showHiddenApps, null);
   }

   /**
    * Creates an enumeration containing the requested properties of each
    * application for which the user has designer access.
    * <p>
    * The application properties which can be retrieved are: <table border="1">
    * <tr>
    * <th>Key</th>
    * <th>Value</th>
    * </tr>
    * <tr>
    * <td>name</td>
    * <td>the application name</td>
    * </tr>
    * <tr>
    * <td>description</td>
    * <td>the application's description</td>
    * </tr>
    * <tr>
    * <td>isEnabled</td>
    * <td>is the application currently enabled</td>
    * </tr>
    * <tr>
    * <td>isActive</td>
    * <td>is the application currently active</td>
    * </tr>
    * <tr>
    * <td>createdBy</td>
    * <td>the name of the user who created the application</td>
    * </tr>
    * <tr>
    * <td>createdOn</td>
    * <td>the date the application was created</td>
    * </tr>
    * <tr>
    * <td>lockerName</td>
    * <td>the name of the locker, null if not locked</td>
    * </tr>
    * <tr>
    * <td>lockerSession</td>
    * <td>the session id of the locker, null if not locked</td>
    * </tr>
    * </table>
    * 
    * @param info the names of the application properties to be retrieved
    * 
    * @param showHiddenApps is this request supposed to show hidden
    * applications? <code>true</code> to show them <code>false</code>
    * otherwise.
    * 
    * @param appName The name of an app if a single summary is to be returned,
    * may be <code>null</code> or empty to get all app summaries. 
    * 
    * @return an enumeration of Properties objects containing the requested
    * application properties and their associated values
    * 
    * @throws PSServerException if the server is not responding
    * 
    * @throws PSAuthenticationFailedException if authentication failed at
    * connect time
    */
   public Enumeration getApplicationSummaries(Properties info,
      boolean showHiddenApps, String appName)
      throws PSAuthenticationFailedException, PSServerException
   {
      /* format the request as an XML document */
      Document sendDoc = PSXmlDocumentBuilder.createXmlDocument();

      Element root = PSXmlDocumentBuilder.createRoot(   sendDoc,
         "PSXDesignAppList");

      root.setAttribute("showHidden", showHiddenApps ? "yes" : "no");
      if (!StringUtils.isBlank(appName))
         root.setAttribute("appName", appName);

      for (Enumeration e = info.keys(); e.hasMoreElements(); )
         PSXmlDocumentBuilder.addElement(   sendDoc, root, "columnName",
         (String)e.nextElement());

      /* send the request to the server */
      Document respDoc = null;
      try
      {
         respDoc = makeRequest("design-objectstore-app-list", sendDoc);
      }
      catch (PSAuthorizationException e) {
         /* this is ok, just return an empty list */
         return (new Vector()).elements();
      }
      /* walk through the results */
      Vector<Properties> retList = new Vector<>();
      Properties         curProps;
      String            curKey, curVal;
      PSXmlTreeWalker   tree = new PSXmlTreeWalker(respDoc);
      while (tree.getNextElement("PSXApplicationSummary", true, true) != null)
      {
         curProps = new Properties();

         for (Enumeration e = info.keys(); e.hasMoreElements(); ) {
            curKey = (String)e.nextElement();
            curVal = tree.getElementData(curKey, false);
            if (curVal == null)
               curVal = "";

            curProps.put(curKey, curVal);
         }

         retList.addElement(curProps);
      }

      return retList.elements();
   }

   /**
    * Remove the specified application from the object store. This
    * permanently deletes the application, which cannot be recovered.
    *
    * @param     app                      the application to remove
    *
    * @throws PSServerException         if the server is not responding
    *
    * @throws PSAuthorizationException if user does not have delete access
    *                                     to the application
    *
    * @throws PSLockedException         if another user has the application
    *                                     locked
    *
    * @see        PSApplication
    */
   public void removeApplication(PSApplication app)
      throws PSServerException, PSAuthorizationException,
      PSAuthenticationFailedException,
      PSLockedException
   {
      removeApplication("applid", String.valueOf(app.getId()));
   }

   /**
    * Remove the specified application from the object store. This
    * permanently deletes the application, which cannot be recovered.
    *
    * @param     appName                  the name of the application to
    *                                     remove
    *
    * @throws PSServerException         if the server is not responding
    *
    * @throws PSAuthorizationException if user does not have delete access
    *                                     to the application
    *
    * @throws PSLockedException         if another user has the application
    *                                     locked
    *
    * @see        PSApplication
    */
   public void removeApplication(java.lang.String appName)
      throws PSServerException, PSAuthorizationException,
      PSAuthenticationFailedException, PSLockedException
   {
      removeApplication("name", appName);
   }

   private void removeApplication(   java.lang.String appTagName,
      java.lang.String appTagValue)
      throws PSServerException, PSAuthorizationException,
      PSAuthenticationFailedException, PSLockedException
   {
      /* format the request as an XML document */
      Document sendDoc = PSXmlDocumentBuilder.createXmlDocument();

      Element root = PSXmlDocumentBuilder.createRoot(   sendDoc,
         "PSXDesignAppRemove");

      PSXmlDocumentBuilder.addElement(sendDoc, root, appTagName, appTagValue);

      /* send the request to the server */
      try
      {
         makeRequest("design-objectstore-app-remove", sendDoc);
      }
      catch (PSServerException e)
      {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null) {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException)throwExc;
            else if (throwExc instanceof PSLockedException)
               throw (PSLockedException)throwExc;
         }
         throw e;
      }
   }


   /**
    * Rename the specified application defined in this object store.  If the
    * current app name and app root are the same, the app root will also be
    * renamed to match the new app name
    *
    * @param     curName                  the current name of the application
    *
    * @param     newName                  the new name to set
    *
    * @throws PSServerException         if the server is not responding
    *
    * @throws PSAuthorizationException if user does not have update
    *                                     access to the application
    *
    * @throws PSLockedException         if another user has the application
    *                                     locked
    *
    * @throws PSNonUniqueException      if an application named newName
    *                                     already exists
    *
    * @throws PSNotFoundException      if an application named curName
    *                                     does not exist
    *
    * @see        PSApplication
    */
   public void renameApplication( java.lang.String curName,
      java.lang.String newName)
      throws PSServerException, PSAuthorizationException,
      PSAuthenticationFailedException,
      PSLockedException, PSNonUniqueException, PSNotFoundException
   {
      renameApplication("oldName", curName, newName);
   }

   /**
    * Rename the specified application defined in this object store.  If the
    * current app name and app root are the same, the app root will also be
    * renamed to match the new app name
    *
    * @param     app                      the application to rename
    *
    * @param     newName                  the new name to set
    *
    * @throws PSServerException         if the server is not responding
    *
    * @throws PSAuthorizationException if user does not have update
    *                                     access to the application
    *
    * @throws PSLockedException         if another user has the application
    *                                     locked
    *
    * @throws PSNonUniqueException      if an application named newName
    *                                     already exists
    *
    * @throws PSNotFoundException      if an application named curName
    *                                     does not exist
    *
    * @see        PSApplication
    */
   public void renameApplication( PSApplication app,
      java.lang.String newName)
      throws PSServerException, PSAuthorizationException,
      PSAuthenticationFailedException, PSLockedException,
      PSNonUniqueException, PSNotFoundException
   {
      renameApplication("applid", String.valueOf(app.getId()), newName);
   }

   private void renameApplication(   java.lang.String oldTagName,
      java.lang.String oldTagValue,
      java.lang.String newName)
      throws PSServerException, PSAuthorizationException,
      PSLockedException, PSNonUniqueException,
      PSAuthenticationFailedException, PSNotFoundException
   {
      /* format the request as an XML document */
      Document sendDoc = PSXmlDocumentBuilder.createXmlDocument();

      Element root = PSXmlDocumentBuilder.createRoot(   sendDoc,
         "PSXDesignAppRename");

      PSXmlDocumentBuilder.addElement(sendDoc, root, oldTagName, oldTagValue);
      PSXmlDocumentBuilder.addElement(sendDoc, root, "newName", newName);

      /* send the request to the server */
      try
      {
         makeRequest("design-objectstore-app-rename", sendDoc);
      }
      catch (PSServerException e)
      {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null) {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException)throwExc;
            else if (throwExc instanceof PSLockedException)
               throw (PSLockedException)throwExc;
            else if (throwExc instanceof PSNonUniqueException)
               throw (PSNonUniqueException)throwExc;
            else if (throwExc instanceof PSNotFoundException)
               throw (PSNotFoundException)throwExc;
         }
         throw e;
      }
   }

   /**
    * Saves the specified application to the object store. If the application
    * was newly created, or it references a different object store, it will
    * be created in this object store. If the application represents an
    * existing application in this object store, it will be updated. This
    * behavior can also be overriden by using the createNewApp parameter.
    *
    * @param     app          the application to save
    *
    * @param     releaseLock   if <code>true</code>, the application lock will
    *                         be released. Use this when no further changes
    *                         to the application will be made. If false, the
    *                         application lock will be extended an additional
    *                         30 minutes.
    *
    * @param     validate      if <code>true</code>, the application logic
    *                         will be validated. This means all objects must
    *                         contain all required settings. If false,
    *                         validation will not be done. <em>NOTE:</em>
    *                         if the application is enabled, validation will
    *                         be performed regardless of how this parameter
    *                         is set.
    *
    * @param     createNewApp if <code>true</code>, a new application will be
    *                         created in the object store. This is most
    *                         useful when copying an application. Be sure to
    *                         change the name of the application before
    *                         attempting to perform this operation.
    *
    * @throws PSServerException         if the server is not responding
    *
    * @throws PSAuthorizationException if creating a new application, the
    *                                     user does not have create access on
    *                                     the server. If updating an existing
    *                                     application, the user does not have
    *                                     update access on the application.
    *
    * @throws PSNotLockedException      when updating an existing
    *                                     application and a lock is not
    *                                     currently held (the timeout already
    *                                     expired or getApplication was not
    *                                     used to lock the application)
    *
    * @throws PSNonUniqueException      if creating an application and an
    *                                     application by the same name
    *                                     already exists
    *
    * @throws PSSystemValidationException    if validate is <code>true</code>
    *                                     and a validation error is
    *                                     encountered
    *
    * @see        PSApplication
    */
   public void saveApplication( PSApplication app,
      boolean releaseLock,
      boolean validate,
      boolean createNewApp)
      throws PSServerException, PSAuthorizationException,
      PSAuthenticationFailedException,
      PSNotLockedException, PSNonUniqueException,
           PSSystemValidationException, PSVersionConflictException
   {
      /* format the request as an XML document
       * this is tricky due to the DOM rules, so we must let the app
       * build its XML doc, then we'll move the root node down a level
       */
      Document sendDoc = app.toXml();
      Element newRoot = sendDoc.createElement("PSXDesignAppSave");

      PSXmlDocumentBuilder.swapRoot(sendDoc, newRoot);

      newRoot.setAttribute("releaseLock",      releaseLock      ? "yes" : "no");
      newRoot.setAttribute("validate",         validate         ? "yes" : "no");
      newRoot.setAttribute("createNewApp",   createNewApp   ? "yes" : "no");


      try
      {
         Document respDoc = makeRequest("design-objectstore-app-save",
               sendDoc);

         // the server may have assigned an ID to us, so let's set it on
         // the in-memory app that we have open
         PSXmlTreeWalker respWalker = new PSXmlTreeWalker(respDoc);
         Element appEl = respWalker.getNextElement("PSXApplication");
         if (appEl != null)
         {
            String appId = appEl.getAttribute("id");
            if (appId != null)
            {
               try
               {
                  app.setId(Integer.parseInt(appId));
               }
               catch (NumberFormatException e)
               {
                  throw new PSServerException(
                     IPSObjectStoreErrors.MALFORMED_RESPONSE_DOCUMENT,
                     respDoc.getDocumentElement().getNodeName());
               }
               Element historyEl =
                     respWalker.getNextElement("PSXRevisionHistory");
               if (historyEl != null)
               {
                  PSRevisionHistory history = new PSRevisionHistory();
                  try
                  {
                     history.fromXml(historyEl, app, null);
                     PSRevisionEntry entry = history.getLatestRevision();
                     if (entry != null)
                        app.setRevision(entry);
                  }
                  catch (PSUnknownNodeTypeException e)
                  {
                     PSConsole.printMsg("Design", e);
                  }
               }
            }
         }

         // did this generate an error attempting to run the app?
         Element errorNode = respWalker.getNextElement("PSXError");
         PSException psxException
            = PSDesignerConnection.createExceptionFromXml(errorNode);
         if (psxException != null) {
            if (psxException instanceof PSAuthorizationException)
               throw (PSAuthorizationException)psxException;
            else if (psxException instanceof PSServerException)
               throw (PSServerException)psxException;
            else {
               throw new PSServerException(
                  psxException.getClass().getName(),
                  psxException.getErrorCode(),
                  psxException.getErrorArguments());
            }
         }
      }
      catch (PSServerException e)
      {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null) {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException)throwExc;
            else if (throwExc instanceof PSNonUniqueException)
               throw (PSNonUniqueException)throwExc;
            else if (throwExc instanceof PSNotLockedException)
               throw (PSNotLockedException)throwExc;
            else if (throwExc instanceof PSSystemValidationException)
               throw (PSSystemValidationException)throwExc;
            else if (throwExc instanceof PSVersionConflictException)
               throw (PSVersionConflictException)throwExc;
         }
         throw e;
      }
   }

   /**
    * Save an arbitrary application file under the application directory.
    *
    * @author   chadloder
    *
    * @version 1.17 1999/05/12
    *
    * @param   app   The application to which this file belongs.
    *
    * @param   appFile   The file to save.
    *
    * @param   overwriteIfExists   if <CODE>true</CODE>, the file will be
    * overwritten if it exists. If <CODE>false</CODE>, if the file exists
    * already, then it will not be overwritten and no error will be reported.
    *
    * @param   releaseLock   if <code>true</code>, the application lock will
    * be released. Use this when no further changes to the application will
    * be made. If false, the application lock will be extended an additional
    * 30 minutes.
    *
    * @throws PSServerException         if the server is not responding
    *
    * @throws PSAuthorizationException If the user does not have
    *                                     update access on the application.
    *
    * @throws PSNotLockedException      If a lock is not
    *                                     currently held (the timeout already
    *                                     expired or getApplication was not
    *                                     used to lock the application)
    *
    * @throws PSSystemValidationException    if validate is <code>true</code>
    *                                     and a validation error is
    *                                     encountered
    *
    * @see        PSApplication
    */
   public void saveApplicationFile(
      PSApplication app,
      PSApplicationFile appFile,
      boolean overwriteIfExists,
      boolean releaseLock)
         throws PSServerException,
         PSAuthorizationException,
         PSAuthenticationFailedException,
         PSNotLockedException,
           PSSystemValidationException
   {
      Document saveFileDoc = PSXmlDocumentBuilder.createXmlDocument();
      Element root = PSXmlDocumentBuilder.createRoot(
         saveFileDoc, "PSXDesignAppFileSave");
      appFile.toXml(saveFileDoc);

      root.setAttribute("application", app.getName());
      root.setAttribute("releaseLock",   releaseLock   ? "yes" : "no");
      root.setAttribute("overWrite", overwriteIfExists ? "yes" : "no");

      /* send the request to the server */
      try
      {
         makeRequest("design-objectstore-app-file-save", saveFileDoc);
      }
      catch (PSServerException e)
      {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null) {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException)throwExc;
            else if (throwExc instanceof PSNotLockedException)
               throw (PSNotLockedException)throwExc;
            else if (throwExc instanceof PSSystemValidationException)
               throw (PSSystemValidationException)throwExc;
         }
         throw e;
      }
   }
   
   /**
    * Save an arbitrary application file under the application directory.
    *
    * @author   chadloder
    *
    * @version 1.17 1999/05/12
    *
    * @param   app   The application to which this file belongs.
    *
    * @param   appFile   The file to save.
    *
    * @param   overwriteIfExists   if <CODE>true</CODE>, the file will be
    * overwritten if it exists. If <CODE>false</CODE>, if the file exists
    * already, then it will not be overwritten and no error will be reported.
    *
    * @param   releaseLock   if <code>true</code>, the application lock will
    * be released. Use this when no further changes to the application will
    * be made. If false, the application lock will be extended an additional
    * 30 minutes.
    * 
    * @param ignoreLockFlag This flag will be appended to the application name 
    * to signal to the server that application locking should be ignored. It 
    * will then be stripped by the server before further use.
    *
    * @throws PSServerException         if the server is not responding
    *
    * @throws PSAuthorizationException If the user does not have
    *                                     update access on the application.
    *
    * @throws PSNotLockedException      If a lock is not
    *                                     currently held (the timeout already
    *                                     expired or getApplication was not
    *                                     used to lock the application)
    *
    * @throws PSSystemValidationException    if validate is <code>true</code>
    *                                     and a validation error is
    *                                     encountered
    *
    * @see        PSApplication
    */
   public void saveApplicationFile(
      PSApplication app,
      PSApplicationFile appFile,
      boolean overwriteIfExists,
      boolean releaseLock,
      boolean dontLockApp)
         throws PSServerException,
         PSAuthorizationException,
         PSAuthenticationFailedException,
         PSNotLockedException,
           PSSystemValidationException
   {
      Document saveFileDoc = PSXmlDocumentBuilder.createXmlDocument();
      Element root = PSXmlDocumentBuilder.createRoot(
         saveFileDoc, "PSXDesignAppFileSave");
      appFile.toXml(saveFileDoc);

      root.setAttribute("application", app.getName());
      root.setAttribute("releaseLock",   releaseLock   ? "yes" : "no");
      root.setAttribute("overWrite", overwriteIfExists ? "yes" : "no");
      root.setAttribute("dontLockApp", dontLockApp ? "yes" : "no");

      /* send the request to the server */
      try
      {
         makeRequest("design-objectstore-app-file-save", saveFileDoc);
      }
      catch (PSServerException e)
      {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null) {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException)throwExc;
            else if (throwExc instanceof PSNotLockedException)
               throw (PSNotLockedException)throwExc;
            else if (throwExc instanceof PSSystemValidationException)
               throw (PSSystemValidationException)throwExc;
         }
         throw e;
      }
   }

   /**
    * Installs the given extension definition along with all of its required
    * resources.
    *
    * @param factory The extension def factory that knows how to convert the
    * def to the appropriate serialized content for transport.
    *
    * @param def The extension definition. The extension name in this
    * definition will determine the handler, context, and extension names.
    * The designer must use a systematic context-naming
    * convention for application-specific extensions vs. global extensions.
    * This naming convention is as follows:
    * for application-specific extensions, the context must be of the
    * form "appExtensions/<appName>". For global extensions, the context
    * must be of the form "globalExtensions/".
    *
    * Must not be <CODE>null</CODE>.
    *
    * @param resources An Iterator over 0 or more non-<CODE>null</CODE>
    * PSExtensionFile objects which hold the contents of the required
    * named resources associated with this extension definition.
    *
    * @param overwriteIfExists <CODE>true</CODE> if and only if the
    * extension should be overwritten if it already exists (update).
    *
    * @TODO Exception documentation.
    */
   public void saveExtension(
      IPSExtensionDefFactory factory,
      IPSExtensionDef def,
      Iterator resources,
      boolean overwriteIfExists
      )
      throws PSServerException,
         PSAuthorizationException,
         PSAuthenticationFailedException,
         PSNotLockedException,
           PSSystemValidationException,
         PSExtensionException,
         PSNotFoundException
   {
      Document saveExtDoc = PSXmlDocumentBuilder.createXmlDocument();
      Element root = PSXmlDocumentBuilder.createRoot(
         saveExtDoc, "PSXDesignExtSave");

      factory.toXml(root, def);

      // TODO: this is extremely inefficient - we should not have to base64
      // every single resource
      while (resources.hasNext())
      {
         PSExtensionFile file = (PSExtensionFile)resources.next();
         file.toXml(saveExtDoc); // closes resource
      }

      root.setAttribute("overWrite", overwriteIfExists ? "yes" : "no");


      /* send the request to the server */
      try
      {
         makeRequest("design-objectstore-extension-save", saveExtDoc);
      }
      catch (PSServerException e)
      {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null)
         {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException)throwExc;
            else if (throwExc instanceof PSLockedException)
               throw (PSNotLockedException)throwExc;
            else if (throwExc instanceof PSSystemValidationException)
               throw (PSSystemValidationException)throwExc;
            else if (throwExc instanceof PSNotLockedException)
               throw (PSNotLockedException)throwExc;
            else if (throwExc instanceof PSExtensionException)
               throw (PSExtensionException)throwExc;
            else if (throwExc instanceof PSNotFoundException)
               throw (PSNotFoundException)throwExc;
         }
         throw e; // else - throw the containing exception
      }
   }

   /**
    * Permanently disables and removes the named extension and all of its
    * supporting files.
    *
    * @param ref The fully qualified extension name. Must not be
    * <CODE>null</CODE>. See saveExtension for a description of extension
    * naming conventions.
    *
    * @TODO: Exception documentation
    */
   public void removeExtension(
      PSExtensionRef ref
      )
      throws PSServerException,
         PSAuthorizationException,
         PSAuthenticationFailedException,
         PSNotLockedException,
           PSSystemValidationException,
         PSExtensionException,
         PSNotFoundException
   {
      Document removeExtDoc = PSXmlDocumentBuilder.createXmlDocument();
      Element root = PSXmlDocumentBuilder.createRoot(
         removeExtDoc, "PSXDesignExtRemove");

      root.setAttribute("name", ref.toString());

      /* send the request to the server */
      try
      {
         makeRequest("design-objectstore-extension-remove", removeExtDoc);
      }
      catch (PSServerException e)
      {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null)
         {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException)throwExc;
            else if (throwExc instanceof PSLockedException)
               throw (PSNotLockedException)throwExc;
            else if (throwExc instanceof PSSystemValidationException)
               throw (PSSystemValidationException)throwExc;
            else if (throwExc instanceof PSNotLockedException)
               throw (PSNotLockedException)throwExc;
            else if (throwExc instanceof PSExtensionException)
               throw (PSExtensionException)throwExc;
            else if (throwExc instanceof PSNotFoundException)
               throw (PSNotFoundException)throwExc;
         }
         throw e; // else - throw the containing exception
      }
   }

   /**
    * Loads the extension definition for the named extension. The extension
    * def contains all relevant information about the extension. There is
    * <STRONG>no way</STRONG> to retrieve the content of the extension's
    * resources at this time.
    *
    * @param ref The fully qualified extension name. Must not be
    * <CODE>null</CODE>. See saveExtension for a description of extension
    * naming conventions.
    *
    * @return The extension definition for the named extension.
    *
    * @TODO: Exception documentation
    */
   public IPSExtensionDef loadExtensionDef(
      PSExtensionRef ref
      )
      throws PSServerException,
         PSAuthorizationException,
         PSAuthenticationFailedException,
         PSNotLockedException,
           PSSystemValidationException,
         PSExtensionException,
         PSNotFoundException
   {
      Document removeExtDoc = PSXmlDocumentBuilder.createXmlDocument();
      Element root = PSXmlDocumentBuilder.createRoot(
         removeExtDoc, "PSXDesignExtLoad");

      root.setAttribute("name", ref.toString());

      /* send the request to the server */
      try
      {
         PSExtensionDefFactory fact = new PSExtensionDefFactory();
         Document respDoc = makeRequest(
               "design-objectstore-extension-load", removeExtDoc);
         PSXmlTreeWalker walker = new PSXmlTreeWalker(respDoc);
         Element extEl = walker.getNextElement("Extension",
            PSXmlTreeWalker.GET_NEXT_ALLOW_CHILDREN);

         IPSExtensionDef def = fact.fromXml(extEl);
         return def;
      }
      catch (PSServerException e)
      {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null)
         {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException)throwExc;
            else if (throwExc instanceof PSLockedException)
               throw (PSNotLockedException)throwExc;
            else if (throwExc instanceof PSSystemValidationException)
               throw (PSSystemValidationException)throwExc;
            else if (throwExc instanceof PSNotLockedException)
               throw (PSNotLockedException)throwExc;
            else if (throwExc instanceof PSExtensionException)
               throw (PSExtensionException)throwExc;
            else if (throwExc instanceof PSNotFoundException)
               throw (PSNotFoundException)throwExc;
         }
         throw e; // else - throw the containing exception
      }
   }

   /**
    * Removes a file from the application directory.
    *
    * @author   chadloder
    *
    * @version 1.17 1999/05/12
    *
    *
    * @param   app   The application to which the file belongs.
    *
    * @param   appFileName   The application file name, relative to the
    * application directory.
    *
    * @param   releaseLock   if <code>true</code>, the application lock will
    * be released. Use this when no further changes to the application will
    * be made. If false, the application lock will be extended an additional
    * 30 minutes.
    *
    * @throws   PSServerException
    * @throws   PSAuthorizationException
    * @throws   PSNotLockedException
    * @throws PSSystemValidationException
    *
    */
   public void removeApplicationFile(
      PSApplication app,
      PSApplicationFile removeFile,
      boolean releaseLock)
         throws PSServerException,
         PSAuthorizationException,
         PSAuthenticationFailedException,
         PSNotLockedException,
           PSSystemValidationException
   {
      Document removeFileDoc = PSXmlDocumentBuilder.createXmlDocument();
      Element root = PSXmlDocumentBuilder.createRoot(
         removeFileDoc, "PSXDesignAppFileRemove");
      removeFile.toXml(removeFileDoc);

      root.setAttribute("application", app.getName());
      root.setAttribute("releaseLock",   releaseLock   ? "yes" : "no");

      /* send the request to the server */
      try
      {
         makeRequest("design-objectstore-app-file-remove", removeFileDoc);
      }
      catch (PSServerException e)
      {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null) {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException)throwExc;
            else if (throwExc instanceof PSLockedException)
               throw (PSNotLockedException)throwExc;
            else if (throwExc instanceof PSSystemValidationException)
               throw (PSSystemValidationException)throwExc;
         }
         throw e;
      }
   }
   
   /**
    * Removes a file from the application directory.
    *
    * @author   chadloder
    *
    * @version 1.17 1999/05/12
    *
    *
    * @param   app   The application to which the file belongs.
    *
    * @param   appFileName   The application file name, relative to the
    * application directory.
    *
    * @param   releaseLock   if <code>true</code>, the application lock will
    * be released. Use this when no further changes to the application will
    * be made. If false, the application lock will be extended an additional
    * 30 minutes.
    *
    * @throws   PSServerException
    * @throws   PSAuthorizationException
    * @throws   PSNotLockedException
    * @throws PSSystemValidationException
    *
    */
   public void removeApplicationFile(
      PSApplication app,
      PSApplicationFile removeFile,
      boolean releaseLock,
      boolean dontLockApp)
         throws PSServerException,
         PSAuthorizationException,
         PSAuthenticationFailedException,
         PSNotLockedException,
           PSSystemValidationException
   {
      Document removeFileDoc = PSXmlDocumentBuilder.createXmlDocument();
      Element root = PSXmlDocumentBuilder.createRoot(
         removeFileDoc, "PSXDesignAppFileRemove");
      removeFile.toXml(removeFileDoc);

      root.setAttribute("application", app.getName());
      root.setAttribute("releaseLock",   releaseLock   ? "yes" : "no");
      root.setAttribute("dontLockApp",   dontLockApp   ? "yes" : "no");

      /* send the request to the server */
      try
      {
         makeRequest("design-objectstore-app-file-remove", removeFileDoc);
      }
      catch (PSServerException e)
      {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null) {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException)throwExc;
            else if (throwExc instanceof PSLockedException)
               throw (PSNotLockedException)throwExc;
            else if (throwExc instanceof PSSystemValidationException)
               throw (PSSystemValidationException)throwExc;
         }
         throw e;
      }
   }
   
   /**
    * Moves the specified application file to the new location specified
    * if the file name is not already in use.
    *
    * @param   app   The application to which the file belongs. 
    * Cannot be <code>null</code>.
    *
    * @param   appFile   The application file name, relative to the
    * application directory. Cannot be <code>null</code>
    *
    * @param targetApp the application to move the file to. 
    * Cannot be <code>null</code>. Can be the same as app.
    * 
    * @param targetAppFile the new file name.
    * Cannot be <code>null</code>. Relative to the targetApp application
    * directory.
    *
    * @param   releaseLock   if <code>true</code>, the application lock will
    * be released. Use this when no further changes to the application will
    * be made. If false, the application lock will be extended an additional
    * 30 minutes.
    * @throws   PSServerException upon any other error
    * @throws   PSAuthorizationException if the user does not have authorization
    * to perform the operation.
    * @throws   PSNotLockedException if the appication was and could not be locked
    *
    */
   public void moveApplicationFile(
      PSApplication app,
      PSApplicationFile appFile,
      PSApplication targetApp,
      PSApplicationFile targetAppFile,
      boolean releaseLock)
         throws PSServerException,
         PSAuthorizationException,
         PSAuthenticationFailedException,
         PSNotLockedException,
           PSSystemValidationException
   {
      if(app == null || targetApp == null)
         throw new IllegalArgumentException("Application cannot be null.");
      if(appFile == null || targetApp == null)
         throw new IllegalArgumentException(
            "The application file cannot be null.");
      Document renameFileDoc = PSXmlDocumentBuilder.createXmlDocument();
      Element root = PSXmlDocumentBuilder.createRoot(
         renameFileDoc, "PSXDesignAppFileRename");

      {
         final Element fromFile =
            PSXmlDocumentBuilder.addEmptyElement(renameFileDoc, root, "from");
         fromFile.appendChild(appFile.toXml(renameFileDoc));
      }

      {
         final Element toFile =
            PSXmlDocumentBuilder.addEmptyElement(renameFileDoc, root, "to");
         toFile.appendChild(targetAppFile.toXml(renameFileDoc));
      }

      root.setAttribute("application", app.getName());
      root.setAttribute("targetApplication", targetApp.getName());
      root.setAttribute("releaseLock",   releaseLock   ? "yes" : "no");

      /* send the request to the server */
      try
      {
         makeRequest("design-objectstore-app-file-rename", renameFileDoc);
      }
      catch (PSServerException e)
      {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null) {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException)throwExc;
            else if (throwExc instanceof PSLockedException)
               throw (PSNotLockedException)throwExc;
            else if (throwExc instanceof PSSystemValidationException)
               throw (PSSystemValidationException)throwExc;
         }
         throw e;
      }
   }
   
   /**
    * Moves the specified application file to the new location specified
    * if the file name is not already in use.
    *
    * @param   app   The application to which the file belongs. 
    * Cannot be <code>null</code>.
    *
    * @param   appFile   The application file name, relative to the
    * application directory. Cannot be <code>null</code>
    *
    * @param targetApp the application to move the file to. 
    * Cannot be <code>null</code>. Can be the same as app.
    * 
    * @param targetAppFile the new file name.
    * Cannot be <code>null</code>. Relative to the targetApp application
    * directory.
    *
    * @param   releaseLock   if <code>true</code>, the application lock will
    * be released. Use this when no further changes to the application will
    * be made. If false, the application lock will be extended an additional
    * 30 minutes.
    * @throws   PSServerException upon any other error
    * @throws   PSAuthorizationException if the user does not have authorization
    * to perform the operation.
    * @throws   PSNotLockedException if the appication was and could not be locked
    *
    */
   public void moveApplicationFile(
      PSApplication app,
      PSApplicationFile appFile,
      PSApplication targetApp,
      PSApplicationFile targetAppFile,
      boolean releaseLock,
      boolean dontLockApp)
         throws PSServerException,
         PSAuthorizationException,
         PSAuthenticationFailedException,
         PSNotLockedException,
           PSSystemValidationException
   {
      if(app == null || targetApp == null)
         throw new IllegalArgumentException("Application cannot be null.");
      if(appFile == null || targetApp == null)
         throw new IllegalArgumentException(
            "The application file cannot be null.");
      Document renameFileDoc = PSXmlDocumentBuilder.createXmlDocument();
      Element root = PSXmlDocumentBuilder.createRoot(
         renameFileDoc, "PSXDesignAppFileRename");

      {
         final Element fromFile =
            PSXmlDocumentBuilder.addEmptyElement(renameFileDoc, root, "from");
         fromFile.appendChild(appFile.toXml(renameFileDoc));
      }

      {
         final Element toFile =
            PSXmlDocumentBuilder.addEmptyElement(renameFileDoc, root, "to");
         toFile.appendChild(targetAppFile.toXml(renameFileDoc));
      }

      root.setAttribute("application", app.getName());
      root.setAttribute("targetApplication", targetApp.getName());
      root.setAttribute("releaseLock",   releaseLock   ? "yes" : "no");
      root.setAttribute("dontLockApp",   dontLockApp   ? "yes" : "no");

      /* send the request to the server */
      try
      {
         makeRequest("design-objectstore-app-file-rename", renameFileDoc);
      }
      catch (PSServerException e)
      {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null) {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException)throwExc;
            else if (throwExc instanceof PSLockedException)
               throw (PSNotLockedException)throwExc;
            else if (throwExc instanceof PSSystemValidationException)
               throw (PSSystemValidationException)throwExc;
         }
         throw e;
      }
   }

   /**
    * Renames the specified application file to the new name specified
    * if the file name is not already in use.
    *
    * @param   app   The application to which the file belongs. 
    * Cannot be <code>null</code>.
    *
    * @param   appFile   The application file name, relative to the
    * application directory. Cannot be <code>null</code>
    * 
    * @param newName the new name for the application file, cannot be <code>null</code>
    * or empty.
    *
    * @param   releaseLock   if <code>true</code>, the application lock will
    * be released. Use this when no further changes to the application will
    * be made. If false, the application lock will be extended an additional
    * 30 minutes.
    *
    * @throws   PSServerException upon any other error
    * @throws   PSAuthorizationException if the user does not have authorization
    * to perform the operation.
    * @throws   PSNotLockedException if the appication was and could not be locked
    * @throws PSSystemValidationException
    *
    */
   public void renameApplicationFile(
      PSApplication app,
      PSApplicationFile appFile,
      String newName,
      boolean releaseLock)
         throws PSServerException,
         PSAuthorizationException,
         PSAuthenticationFailedException,
         PSNotLockedException,
           PSSystemValidationException
   {
      if(newName == null || newName.trim().length() == 0)
         throw new IllegalArgumentException(
            "New name cannot be null or empty.");
      final File parentDir = appFile.getFileName().getParentFile();
      final File newFile = new File(parentDir, newName);
      final PSApplicationFile targetAppFile = new PSApplicationFile(newFile);
      moveApplicationFile(app, appFile, app, targetAppFile, releaseLock);
   }
   
   /**
    * Renames the specified application file to the new name specified
    * if the file name is not already in use.
    *
    * @param   app   The application to which the file belongs. 
    * Cannot be <code>null</code>.
    *
    * @param   appFile   The application file name, relative to the
    * application directory. Cannot be <code>null</code>
    * 
    * @param newName the new name for the application file, cannot be <code>null</code>
    * or empty.
    *
    * @param   releaseLock   if <code>true</code>, the application lock will
    * be released. Use this when no further changes to the application will
    * be made. If false, the application lock will be extended an additional
    * 30 minutes.
    *
    * @throws   PSServerException upon any other error
    * @throws   PSAuthorizationException if the user does not have authorization
    * to perform the operation.
    * @throws   PSNotLockedException if the appication was and could not be locked
    * @throws PSSystemValidationException
    *
    */
   public void renameApplicationFile(
      PSApplication app,
      PSApplicationFile appFile,
      String newName,
      boolean releaseLock,
      boolean dontLockApp)
         throws PSServerException,
         PSAuthorizationException,
         PSAuthenticationFailedException,
         PSNotLockedException,
           PSSystemValidationException
   {
      if(newName == null || newName.trim().length() == 0)
         throw new IllegalArgumentException(
            "New name cannot be null or empty.");
      final File parentDir = appFile.getFileName().getParentFile();
      final File newFile = new File(parentDir, newName);
      final PSApplicationFile targetAppFile = new PSApplicationFile(newFile);
      moveApplicationFile(app, appFile, app, targetAppFile, releaseLock, dontLockApp);
   }
   
   /**
    * Gets a list of files below an application root.
    * 
    * @param appRoot The application root, may not be <code>null</code> or 
    * empty.
    * 
    * @return A list of application file paths, relative to the application 
    * root, never <code>null</code>, may be empty.
    * 
    * @throws PSAuthorizationException If the user is not authorized to read
    * the application design.
    * @throws PSAuthenticationFailedException If the user is not authenticated.
    * @throws PSServerException If there are any other errors.
    */
   public List<String> getApplicationFiles(String appRoot) 
      throws PSServerException, PSAuthorizationException, 
      PSAuthenticationFailedException
   {
      if (StringUtils.isBlank(appRoot))
         throw new IllegalArgumentException("appRoot may not be null or empty");
      
      Document removeFileDoc = PSXmlDocumentBuilder.createXmlDocument();
      Element root = PSXmlDocumentBuilder.createRoot(
         removeFileDoc, "PSXDesignAppListFiles");

      root.setAttribute("appRoot", appRoot);
      root.setAttribute("includeDirs", "false");
      root.setAttribute("recurse", "true");
      

      /* send the request to the server */
      try
      {
         Document respDoc = makeRequest(
               "design-objectstore-app-list-files", removeFileDoc);
         
         // walk doc and get files
         List<String> files = new ArrayList<>();
         PSXmlTreeWalker tree = new PSXmlTreeWalker(respDoc);
         Element fileEl = tree.getNextElement(PSApplicationFile.ms_nodeType, 
            tree.GET_NEXT_ALLOW_CHILDREN);
         while (fileEl != null)
         {
            String path = fileEl.getAttribute("fileName");
            if (StringUtils.isNotEmpty(path))
               files.add(path);
            fileEl = tree.getNextElement(
               PSApplicationFile.ms_nodeType, tree.GET_NEXT_ALLOW_SIBLINGS);            
         }
         
         return files;
      }
      catch (PSServerException e)
      {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null)
         {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException) throwExc;
         }
         throw e;
      }      
   }
   
   /***
    * Returns all application files and folders under the folder specified
    * by the <code>PSApplicationFile</code> passed in. If no 
    * <code>PSApplicationFile</code> is passed in then we default to 
    * the applications associated root.
    * 
    * @param app the application to catalog, cannot be <code>null</code>.
    * 
    * @param appFile the application file, if <code>null</code> or not
    * a folder then we default to use the applications associated root.
    * 
    * @return a collection of <code>PSApplicationFile</code> objects
    * that represent all the folders and files under the specified application
    * root. Files are returned without content.
    * Note: We will not recurse down into the folders.
    * 
    * @throws PSAuthorizationException If the user is not authorized to read
    * the application design.
    * 
    * @throws PSAuthenticationFailedException If the user is not authenticated.
    * 
    * @throws PSServerException upon any other error
    */
   public Collection<PSApplicationFile> getApplicationFiles(
      PSApplication app, PSApplicationFile appFile) 
   throws PSServerException, PSAuthorizationException, 
   PSAuthenticationFailedException
{
   
   if(app == null)
      throw new IllegalArgumentException("The application cannot be null.");
   File appRootFile = null;
   String appRoot = null;
   if(appFile != null && appFile.isFolder())
   {
      appRootFile = new File(app.getRequestRoot(),
            appFile.getFileName().getPath());
      appRoot = (new PSApplicationFile(appRootFile, true)).getPath();
   }
   else
      appRoot = app.getRequestRoot();
   Document getFileDoc = PSXmlDocumentBuilder.createXmlDocument();
   Element root = PSXmlDocumentBuilder.createRoot(
      getFileDoc, "PSXDesignAppListFiles");

   root.setAttribute("appRoot", appRoot);
   root.setAttribute("includeDirs", "true");
   root.setAttribute("recurse", "false");
   

   /* send the request to the server */
   try
   {
      Document respDoc = makeRequest(
            "design-objectstore-app-list-files", getFileDoc);

      // walk doc and get files
      Collection<PSApplicationFile> files = new ArrayList<>();
      PSXmlTreeWalker tree = new PSXmlTreeWalker(respDoc);
      Element fileEl = tree.getNextElement(PSApplicationFile.ms_nodeType, 
            tree.GET_NEXT_ALLOW_CHILDREN);
      while (fileEl != null)
      {
         PSApplicationFile aFile = new PSApplicationFile();
         aFile.fromXml(fileEl, null, null);
         assert aFile.isNull();
         files.add(aFile);
         fileEl = tree.getNextElement(
               PSApplicationFile.ms_nodeType, tree.GET_NEXT_ALLOW_SIBLINGS);            
      }

      return files;
   }
   catch (PSUnknownNodeTypeException e)
   {
      throw new PSServerException(e);
   }
   catch (PSServerException e)
   {
      PSException throwExc = e.getOriginatingException();
      if (throwExc != null)
      {
         if (throwExc instanceof PSAuthorizationException)
            throw (PSAuthorizationException) throwExc;
      }
      throw e;
   }      
}


   /**
    * Loads the contents of the specified application file unless the application file
    * specified is a folder.
    * @param   app the application
    * @param   loadFile The file. Will not be modified.
    *
    * @return   PSApplicationFile loaded with its file contents or 
    * <code>null</code> if the application file is a folder.
    */
   public PSApplicationFile loadApplicationFile(
      PSApplication app,
      PSApplicationFile loadFile)
         throws PSServerException,
         PSAuthorizationException,
         PSAuthenticationFailedException,
         PSNotLockedException,
           PSSystemValidationException
   {
      if(loadFile.isFolder())
         return null;
      Document loadFileDoc   = PSXmlDocumentBuilder.createXmlDocument();
      Element root = PSXmlDocumentBuilder.createRoot(
         loadFileDoc, "PSXDesignAppFileLoad");

      root.setAttribute("application", app.getName());

      loadFile.toXml(loadFileDoc);

      /* send the request to the server */
      PSApplicationFile appFile = null; // the loaded file
      try
      {
         Document respDoc = makeRequest(
               "design-objectstore-app-file-load", loadFileDoc);
         PSXmlTreeWalker walker = new PSXmlTreeWalker(respDoc);
         Element fileEl = walker.getNextElement(PSApplicationFile.ms_nodeType);
         appFile = new PSApplicationFile();
         appFile.fromXml(fileEl, null, null);
      } catch (PSUnknownNodeTypeException e) {
         throw new PSServerException(e);
      } catch (PSServerException e) {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null) {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException)throwExc;
            else if (throwExc instanceof PSNotLockedException)
               throw (PSNotLockedException)throwExc;
            else if (throwExc instanceof PSSystemValidationException)
               throw (PSSystemValidationException)throwExc;
         }
         throw e;
      }

      return appFile;
   }

   /**
    * Constructs a user configuration object for the currently logged in
    * user. The configuration information previously saved for the user
    * will be loaded from the server. If configuration information does not
    * exist on the server, a new, empty object will be returned.
    *
    * @return     the user configuration object
    *
    * @throws PSServerException         if the server is not responding
    *
    * @throws PSAuthorizationException if user does not have designer
    *                                     access to the server
    *
    * @see        PSUserConfiguration
    */
   public PSUserConfiguration getUserConfiguration()
      throws PSServerException, PSAuthorizationException,
      PSAuthenticationFailedException
   {
      /* format the request as an XML document */
      Document sendDoc = PSXmlDocumentBuilder.createXmlDocument();
      Element root = PSXmlDocumentBuilder.createRoot(
         sendDoc, "PSXDesignUserConfigLoad");
      PSXmlDocumentBuilder.addElement(
         sendDoc, root, "name", m_conn.getUserName());

      /* send the request to the server */
      try
      {
         Document respDoc = null;

         try
         {
            respDoc = makeRequest("design-objectstore-userconfig-load",
                  sendDoc);
         }
         catch (PSServerException e)
         {
            if ((e.getErrorCode() != IPSConnectionErrors.SERVER_GENERATED_EXCEPTION)
                  || !"com.percussion.design.objectstore.PSNotFoundException"
                        .equals(e.getErrorArguments()[0]))
            { // if this is not found, we'll create a new config
               throw e;
            }
         }

         /* convert the response to an configuration object */
         PSUserConfiguration config = new PSUserConfiguration(m_uid);

         /* respDoc will be null if we are creating the config */
         if(respDoc != null){
            root = respDoc.getDocumentElement();
            PSXmlTreeWalker tree = new PSXmlTreeWalker(respDoc);
            if (tree.getNextElement(
               PSUserConfiguration.ms_NodeType, true, true) != null) {
               /* need to promote PSXUserConfiguration to the root */
               PSXmlDocumentBuilder.replaceRoot(respDoc,
                  (Element)tree.getCurrent());

               try {
                  config.fromXml(respDoc);
               } catch (PSUnknownDocTypeException e) {
                  throw new PSServerException(e);
               }
            }
            else {
               throw new PSServerException(
                  IPSObjectStoreErrors.MALFORMED_RESPONSE_DOCUMENT,
                  root.getNodeName());
            }
         }

         return config;
      }
      catch (PSServerException e)
      {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null) {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException)throwExc;
         }
         throw e;
      }
   }

   /**
    * Retrieves the character encoding map document from the installation root
    * directory.
    *
    * @return the character encoding map document
    *
    * @throws PSServerException         if the server is not responding
    *
    * @throws PSAuthorizationException  if user does not have designer
    *                                    access to the server
    *
    * @throws PSAuthenticationFailedException if the user is not
    *                                         authenticated to perform this
    *                                         command
    */
   public Document getCharacterSetMap()
      throws PSServerException, PSAuthorizationException,
      PSAuthenticationFailedException
   {
      /* format the request as an XML document */
      Document sendDoc = PSXmlDocumentBuilder.createXmlDocument();
      Element root = PSXmlDocumentBuilder.createRoot(
         sendDoc, PSXmlObjectStoreHandler.ms_RootCharacterSetMapLoad);

      /* send the request to the server */
      try
      {
         return makeRequest("design-objectstore-characterset-map-load",
               sendDoc);
      }
      catch (PSServerException e)
      {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null) {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException)throwExc;
         }
         throw e;
      }
   }

   /**
    * Remove the user configuration information for the currently logged
    * in user from the object store. This permanently deletes all the
    * user configuration information, which cannot be recovered.
    *
    * @throws PSServerException         if the server is not responding
    *
    * @throws PSAuthorizationException if user does not have designer
    *                                     access to the server
    *
    * @see        PSUserConfiguration
    */
   public void removeUserConfiguration()
      throws PSServerException, PSAuthorizationException,
      PSAuthenticationFailedException
   {
      /* format the request as an XML document */
      Document sendDoc = PSXmlDocumentBuilder.createXmlDocument();
      Element root = PSXmlDocumentBuilder.createRoot(
         sendDoc, "PSXDesignUserConfigRemove");
      PSXmlDocumentBuilder.addElement(
         sendDoc, root, "name", m_conn.getUserName());

      /* send the request to the server */
      try
      {
         makeRequest("design-objectstore-userconfig-remove", sendDoc);
      }
      catch (PSServerException e)
      {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null) {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException)throwExc;
         }
         throw e;
      }
   }

   /**
    * Saves the user configuration information for the currently logged in
    * user to the object store.
    *
    * @param     config       the user configuration information to save
    *
    * @throws PSServerException         if the server is not responding
    *
    * @throws PSAuthorizationException if user does not have designer
    *                                     access to the server
    *
    * @see        PSUserConfiguration
    */
   public void saveUserConfiguration(PSUserConfiguration config)
      throws PSServerException, PSAuthorizationException,
      PSAuthenticationFailedException
   {
      /* format the request as an XML document
       * this is tricky due to the DOM rules, so we must let the config
       * build its XML doc, then we'll move the root node down a level
       */
      Document sendDoc = config.toXml();
      Element newRoot = sendDoc.createElement("PSXDesignUserConfigSave");

      PSXmlDocumentBuilder.swapRoot(sendDoc, newRoot);

      /* send the request to the server */
      try
      {
         makeRequest("design-objectstore-userconfig-save", sendDoc);
      }
      catch (PSServerException e)
      {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null) {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException)throwExc;
         }
         throw e;
      }
   }

   /**
    * Constructs a server configuration object for the connected server.
    * <P>
    * The server configuration can be accessed by designers and
    * administrators. Designers will not, however, get all information.
    * They are also unable to save changes to the server's configuration.
    *
    * @return     the server configuration object
    *
    * @throws PSServerException         if the server is not responding
    *
    * @throws PSAuthorizationException if the user does not have
    *                                     designer or admin access to the
    *                                       server
    *
    * @see        PSServerConfiguration
    */
   public PSServerConfiguration getServerConfiguration()
      throws PSServerException, PSAuthorizationException,
      PSAuthenticationFailedException
   {
      try
      {
         return getServerConfiguration(false, false);
      }
      catch (PSLockedException e)
      {
         throw new PSServerException(e); // this should not happen
      }
   }

   /**
    * Constructs a server configuration object for the connected server.
    * <P>
    * The server configuration can be accessed by designers and
    * administrators. Designers will not, however, get all information.
    * They are also unable to save changes to the server's configuration.
    *
    * @param lockConfig If <CODE>true</CODE>, locks the server config
    * for editing for 30 minutes.
    *
    * @return     the server configuration object
    *
    * @throws PSServerException         if the server is not responding
    *
    * @throws PSAuthorizationException if the user does not have
    *                                     designer or admin access to the
    *                                       server
    *
    * @see        PSServerConfiguration
    */
   public PSServerConfiguration getServerConfiguration(
      boolean lockConfig
      )
      throws PSServerException, PSAuthorizationException,
      PSAuthenticationFailedException,
      PSLockedException
   {
      return getServerConfiguration(lockConfig, false);
   }

   /**
    * Constructs a server configuration object for the connected server.
    * <P>
    * The server configuration can be accessed by designers and
    * administrators. Designers will not, however, get all information.
    * They are also unable to save changes to the server's configuration.
    *
    * @param lockConfig If <CODE>true</CODE>, locks the server config
    * for editing for 30 minutes.
    *
    * @param overrideSameUser If <CODE>true</CODE>, and <CODE>lockConfig</CODE>
    * is <CODE>true</CODE>, and the config is already locked by the requesting
    * user in a different session, will automatically steal the lock from the
    * other session. If <CODE>false</CODE>, and <CODE>lockConfig</CODE> is
    * <CODE>true</CODE>, and the config is already locked by the requesting
    * user in a different session (or any other user), will throw a
    * PSServerException with a nested PSLockedException. If
    * <CODE>lockConfig</CODE> is <CODE>false</CODE>, this parameter is ignored.
    *
    * @return     the server configuration object
    *
    * @throws PSServerException         if the server is not responding
    *
    * @throws PSAuthorizationException if the user does not have
    *                                     designer or admin access to the
    *                                       server
    *
    * @see        PSServerConfiguration
    */
   public PSServerConfiguration getServerConfiguration(
      boolean lockConfig, boolean overrideSameUser)
      throws PSServerException, PSAuthorizationException,
      PSAuthenticationFailedException, PSLockedException
   {
      /* format the request as an XML document */
      Document sendDoc = PSXmlDocumentBuilder.createXmlDocument();
      Element root = PSXmlDocumentBuilder.
            createRoot(sendDoc, "PSXDesignServerConfigLoad");
      root.setAttribute("mode", lockConfig ? "edit" : "read");
      root.setAttribute("overrideSameUser", (overrideSameUser) ? "yes" : "no");

      /* send the request to the server */
      try
      {
         Document respDoc = makeRequest(
               "design-objectstore-serverconfig-load", sendDoc);

         /* convert the response to a config object */
         PSServerConfiguration config = new PSServerConfiguration();

         Element respRoot = respDoc.getDocumentElement();
         PSXmlTreeWalker tree = new PSXmlTreeWalker(respDoc);
         if (tree.getNextElement(
            PSServerConfiguration.ms_NodeType, true, true) != null) {
            /* need to promote PSXServerConfiguration to the root */
            PSXmlDocumentBuilder.replaceRoot(respDoc,
               (Element)tree.getCurrent());

            try {
               config.fromXml(respDoc);
            } catch (PSUnknownDocTypeException e) {
               throw new PSServerException(e);
            } catch (PSUnknownNodeTypeException e) {
               throw new PSServerException(e);
            }
         }
         else {
            throw new PSServerException(
               IPSObjectStoreErrors.MALFORMED_RESPONSE_DOCUMENT,
               respRoot.getNodeName());
         }

         return config;
      }
      catch (PSServerException e)
      {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null) {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException)throwExc;
            else if (throwExc instanceof PSLockedException)
               throw (PSLockedException)throwExc;
         }
         throw e;
      }
   }

   /**
    * Saves the server configuration information to the connected server.
    *
    * @param     config       the server configuration information to save
    *
    * @throws PSServerException         if the server is not responding
    *
    * @throws PSAuthorizationException if server does not have admin
    *                                     access to the server
    *
    * @throws PSLockedException        if another user has acquired the
    *                                  server configuration lock. This usually
    *                                  occurs if the server configuration was
    *                                  not previously locked or the lock was
    *                                  lost due to a timeout.
    * @see        PSServerConfiguration
    */
   public void saveServerConfiguration(PSServerConfiguration config)
      throws PSServerException, PSAuthorizationException,
      PSAuthenticationFailedException,
      PSLockedException
   {
      saveServerConfiguration(config, false);
   }

   /**
    * Saves the server configuration information to the connected server.
    *
    * @param     config       the server configuration information to save
    *
    * @param releaseLock If <code>true</code>, the lock on the config will be
    *    released. Since the server config and role config share the same
    *    lock, If you are editing the server config at the same time as
    *    the role config, only release when saving the last config object
    *    (which could be the server config or the role config, it doesn't
    *    matter).
    *
    * @throws PSServerException         if the server is not responding
    *
    * @throws PSAuthorizationException if server does not have admin
    *                                     access to the server
    *
    * @throws PSLockedException        if another user has acquired the
    *                                  server configuration lock. This usually
    *                                  occurs if the server configuration was
    *                                  not previously locked or the lock was
    *                                  lost due to a timeout.
    * @see        PSServerConfiguration
    */
   public void saveServerConfiguration(PSServerConfiguration config,
      boolean releaseLock)
      throws PSServerException, PSAuthorizationException,
      PSAuthenticationFailedException,
      PSLockedException
   {
      /* format the request as an XML document
       * this is tricky due to the DOM rules, so we must let the config
       * build its XML doc, then we'll move the root node down a level
       */
      Document sendDoc = config.toXml();
      Element newRoot = sendDoc.createElement("PSXDesignServerConfigSave");
      newRoot.setAttribute("releaseLock",   releaseLock   ? "yes" : "no");

      PSXmlDocumentBuilder.swapRoot(sendDoc, newRoot);

      /* send the request to the server */
      try
      {
         makeRequest("design-objectstore-serverconfig-save", sendDoc);
      }
      catch (PSServerException e)
      {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null) {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException)throwExc;
            else if (throwExc instanceof PSLockedException)
               throw (PSLockedException)throwExc;
         }
         throw e;
      }
   }

   /**
    * Extend the write lock on a server configuration. Write locks are granted
    * for a maximum of 30 minutes. If the designer needs more time to complete
    * the task, an additional 30 minute extension can be requested.
    *
    * @param     config                   the serverConfiguration for which
    *                                     to extend the lock
    *
    * @throws PSServerException         if the server is not responding
    *
    * @throws PSAuthorizationException if the user is not permitted to
    *                                   lock server configurations on the server
    *
    * @throws PSLockedException        if another user has acquired the
    *                                  server configuration lock. This usually
    *                                  occurs if the server configuration was
    *                                  not previously locked or the lock was
    *                                  lost due to a timeout.
    *
    * @see        PSServerConfiguration
    */
   public void extendServerConfigurationLock(PSServerConfiguration config)
      throws PSServerException, PSAuthorizationException,
      PSAuthenticationFailedException,
      PSLockedException
   {
      extendServerConfigurationLock(config, 30);
   }

   /**
    * Extend the write lock on a server configuration. Write locks are granted
    * for a maximum of 30 minutes. If the designer needs more time to complete
    * the task, an additional 30 minute extension can be requested.
    *
    * @param     config               the loaded server configuration for which
    *                                     to extend the lock
    *
    * @param      minutes                  the number of minutes to extend.
    * The server will make sure this is <= 30 minutes. If <CODE>minutes</CODE>
    * is 0, it will try to release the lock rather than extend it.
    *
    * @throws PSServerException         if the server is not responding
    *
    * @throws PSAuthorizationException if the user is not permitted to lock
    *                                  server configurations on the server
    *
    * @throws PSLockedException        if another user has acquired the
    *                                  server configuration lock. This usually
    *                                  occurs if the server configuration was
    *                                  not previously locked or the lock was
    *                                  lost due to a timeout.
    *
    * @see        PSServerConfiguration
    */
   public void extendServerConfigurationLock(PSServerConfiguration config,
                                             int minutes)
      throws PSServerException, PSAuthorizationException,
      PSAuthenticationFailedException,
      PSLockedException
   {
      extendServerConfigurationLock(config, minutes, false);
   }

   /**
    * Extend the write lock on a server configuration. Write locks are granted
    * for a maximum of 30 minutes. If the designer needs more time to complete
    * the task, an additional 30 minute extension can be requested.
    *
    * @param   config   the loaded server configuration for which
    * to extend the lock
    *
    * @param   minutes   the number of minutes to extend.
    * The server will make sure this is <= 30 minutes. If <CODE>minutes</CODE>
    * is 0, it will try to release the lock rather than extend it.
    *
    * @param overrideSameUser If <CODE>true</CODE>, and <CODE>lockConfig</CODE>
    * is <CODE>true</CODE>, and the config is already locked by the requesting
    * user in a different session, will automatically steal the lock from the
    * other session. If <CODE>false</CODE>, and <CODE>lockConfig</CODE> is
    * <CODE>true</CODE>, and the config is already locked by the requesting
    * user in a different session (or any other user), will throw a
    * PSServerException with a nested PSLockedException. If
    * <CODE>lockConfig</CODE> is <CODE>false</CODE>, this parameter is ignored.
    *
    * @throws PSServerException         if the server is not responding
    *
    * @throws PSAuthorizationException if the user is not permitted to lock
    *                                  server configurations on the server
    *
    * @throws PSLockedException        if another user has acquired the
    *                                  server configuration lock. This usually
    *                                  occurs if the server configuration was
    *                                  not previously locked or the lock was
    *                                  lost due to a timeout.
    *
    * @see        PSServerConfiguration
    */
   public void extendServerConfigurationLock(
      PSServerConfiguration config,
      int minutes,
      boolean overrideSameUser
      )
      throws PSServerException, PSAuthorizationException,
      PSAuthenticationFailedException,
      PSLockedException
   {
      /* format the request as an XML document */
      Document sendDoc = PSXmlDocumentBuilder.createXmlDocument();

      Element root = PSXmlDocumentBuilder.createRoot(   sendDoc,
         "PSXDesignServerConfigLock");

      // setting this means that the lock should be released
      root.setAttribute("lockMins", "" + minutes);
      root.setAttribute("overrideSameUser", (overrideSameUser) ? "yes" : "no");

      /* send the request to the server */
      try
      {
         makeRequest("design-objectstore-serverconfig-lock", sendDoc);
      }
      catch (PSServerException e)
      {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null) {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException)throwExc;
            else if (throwExc instanceof PSLockedException)
               throw (PSLockedException)throwExc;
         }
         throw e;
      }
   }


   /**
    * Releases the server configuration lock.
    *
    * @author   chadloder
    *
    * @version 1.21 1999/07/13
    *
    * @param   config                   The server configuration.
    *
    * @throws PSServerException         if the server is not responding
    *
    * @throws PSAuthorizationException  if the user is not permitted to
    *                                   create server configurations on the
    *                                   server
    *
    * @throws PSLockedException         if another user has acquired the
    *                                   server configuration lock. This usually
    *                                   occurs if the server configuration was
    *                                   not previously locked or the lock was
    *                                   lost due to a timeout.
    *
    * @see        PSServerConfiguration
    *
    */
   public void releaseServerConfigurationLock(PSServerConfiguration config)
      throws PSServerException, PSAuthorizationException,
      PSAuthenticationFailedException,
      PSLockedException
   {
      extendServerConfigurationLock(config, 0, true);
   }

   /**
    * Requests a PSSupportedFeatureSet object from the server.
    *
    * @return the set of features supported by the server.  May be
    * <code>null</code> if the server does not yet support this type of request.
    *
    * @throws PSServerException         if the server is not responding
    *
    * @throws PSAuthorizationException if the user does not have
    *                                     designer or admin access to the
    *                                        server
    * @throws PSAuthenticationFailedException if the user is not
    * authenticated to perform this
    *
    * @roseuid 39F9D483007D
    */
   public PSFeatureSet getSupportedFeatureSet()
      throws PSServerException,
         PSAuthorizationException,
         PSAuthenticationFailedException
   {
      Document sendDoc = PSXmlDocumentBuilder.createXmlDocument();
      Element root = PSXmlDocumentBuilder.
            createRoot(sendDoc, "PSXSupportedFeatureSetLoad");

      /* send the request to the server */
      try
      {
         Document respDoc = makeRequest(
               "design-objectstore-featureset-load", sendDoc);

         /* convert the response to a featureset object */
         PSFeatureSet featureSet = null;

         Element respRoot = respDoc.getDocumentElement();
         PSXmlTreeWalker tree = new PSXmlTreeWalker(respDoc);
         if (tree.getNextElement(
            PSFeatureSet.ms_nodeName, true, true) != null) {
            /* need to promote PSXServerConfiguration to the root */
            PSXmlDocumentBuilder.replaceRoot(respDoc,
               (Element)tree.getCurrent());

            try {
               featureSet = new PSFeatureSet();
               featureSet.fromXml(respDoc);
            } catch (PSUnknownDocTypeException e) {
               throw new PSServerException(e);
            } catch (PSUnknownNodeTypeException e) {
               throw new PSServerException(e);
            }
         }
         else {
            throw new PSServerException(
               IPSObjectStoreErrors.MALFORMED_RESPONSE_DOCUMENT,
               respRoot.getNodeName());
         }

         return featureSet;
      }
      catch (PSServerException e)
      {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null) {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException)throwExc;
         }
         throw e;
      }
   }
   
   /**
    * Gets the list of JNDI datasource configurations from the server.
    * 
    * @param lockConfig <code>true</code> to ensure the server config is locked,
    * <code>false</code> to get the datasources effectively read-only.
    * 
    * @return The list, never <code>null</code>, may be empty.
    * 
    * @throws PSAuthenticationFailedException If the user cannot be 
    * authenticated by the server.
    * @throws PSAuthorizationException If the user is not authorized to perform
    * the operation. 
    * @throws PSServerException If there are any other errors. 
    */
   public List<IPSJndiDatasource> getJndiDatasources(boolean lockConfig) 
      throws PSAuthorizationException, PSAuthenticationFailedException, 
      PSServerException
   {
      Document sendDoc = PSXmlDocumentBuilder.createXmlDocument();
      Element root = PSXmlDocumentBuilder.createRoot(sendDoc,
         "PSXGetJndiDatasourcesRequest");
      root.setAttribute("locked", lockConfig ? "yes" : "no");

      /* send the request to the server */
      try
      {
         Document respDoc = makeRequest(
               "design-objectstore-jndidatasources-load", sendDoc);

         Element respRoot = respDoc.getDocumentElement();
         if (!respRoot.getNodeName().equals("PSXGetJndiDatasourcesResults"))
         {
            throw new PSServerException(
               IPSObjectStoreErrors.MALFORMED_RESPONSE_DOCUMENT, 
               respRoot.getNodeName());
         }
         
         PSXmlTreeWalker tree = new PSXmlTreeWalker(respDoc);

         try {
            Element dsEl = tree.getNextElement(
                  PSJBossJndiDatasource.DATASOURCE_NODE_NAME,
               PSXmlTreeWalker.GET_NEXT_ALLOW_CHILDREN);
            
            List<IPSJndiDatasource> dsList = new ArrayList<>();
            while (dsEl != null)
            {
               dsList.add(new PSJBossJndiDatasource(dsEl));
               dsEl = tree.getNextElement(PSJBossJndiDatasource.DATASOURCE_NODE_NAME,
                  PSXmlTreeWalker.GET_NEXT_ALLOW_SIBLINGS);
            }
            
            return dsList;
         }
         catch (PSInvalidXmlException e)
         {
            throw new PSServerException(e);
         }
     
      }
      catch (PSServerException e)
      {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null)
         {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException) throwExc;
         }
         throw e;
      }
   }

   /**
    * Saves the list of JNDI datasource configurations to the server.  The 
    * caller must have server config locked.
    * 
    * @param datasources The list of datasources to save, may not be 
    * <code>null</code> or empty.
    * 
    * @throws PSAuthenticationFailedException If the user cannot be 
    * authenticated by the server.
    * @throws PSAuthorizationException If the user is not authorized to perform
    * the operation. 
    * @throws PSServerException If there are any other errors.
    */
   public void saveJndiDatasources(List<IPSJndiDatasource> datasources) 
      throws PSServerException, PSAuthorizationException, 
      PSAuthenticationFailedException
   {
      Document sendDoc = PSXmlDocumentBuilder.createXmlDocument();
      Element root = PSXmlDocumentBuilder.createRoot(sendDoc,
         "PSXSaveJndiDatasourcesRequest");
      
      if (datasources == null || datasources.isEmpty())
         throw new IllegalArgumentException(
            "datasources may not be null or empty");

      for (IPSJndiDatasource datasource : datasources)
      {
          PSJBossJndiDatasource jbossDs = new PSJBossJndiDatasource(datasource);
         root.appendChild(jbossDs.toXml(sendDoc));
      }
      
      /* send the request to the server */
      try
      {
         Document respDoc = makeRequest(
               "design-objectstore-jndidatasources-save", sendDoc);

         Element respRoot = respDoc.getDocumentElement();
         if (!respRoot.getNodeName().equals("PSXSaveJndiDatasourcesResults"))
         {
            throw new PSServerException(
               IPSObjectStoreErrors.MALFORMED_RESPONSE_DOCUMENT, 
               respRoot.getNodeName());
         }
      }
      catch (PSServerException e)
      {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null)
         {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException) throwExc;
         }
         throw e;
      }
   }

   /**
    * Gets the datasource resolver containing the list of datasource 
    * configurations from the server.
    * 
    * @param lockConfig <code>true</code> to ensure the server config is locked,
    * <code>false</code> to get the datasources effectively read-only.
    * 
    * @return The resolver, never <code>null</code>.
    * 
    * @throws PSAuthenticationFailedException If the user cannot be 
    * authenticated by the server.
    * @throws PSAuthorizationException If the user is not authorized to perform
    * the operation. 
    * @throws PSServerException If there are any other errors. 
    */
   public PSDatasourceResolver getDatasourceConfigs(boolean lockConfig) 
      throws PSServerException, PSAuthorizationException, 
      PSAuthenticationFailedException
   {
      Document sendDoc = PSXmlDocumentBuilder.createXmlDocument();
      Element root = PSXmlDocumentBuilder.createRoot(sendDoc,
         "PSXGetDatasourceConfigsRequest");
      root.setAttribute("locked", lockConfig ? "yes" : "no");

      /* send the request to the server */
      try
      {
         Document respDoc = makeRequest(
               "design-objectstore-datasourceconfigs-load", sendDoc);

         Element respRoot = respDoc.getDocumentElement();
         if (!respRoot.getNodeName().equals("PSXGetDatasourceConfigsResults"))
         {
            throw new PSServerException(
               IPSObjectStoreErrors.MALFORMED_RESPONSE_DOCUMENT, 
               respRoot.getNodeName());
         }
         
         PSXmlTreeWalker tree = new PSXmlTreeWalker(respDoc);

         try
         {
            Element dsEl = tree.getNextElement(
               PSDatasourceResolver.BEAN_NODE_NAME, 
               PSXmlTreeWalker.GET_NEXT_ALLOW_CHILDREN);
            
            if (dsEl == null)
               throw new PSServerException(
                  IPSObjectStoreErrors.MALFORMED_RESPONSE_DOCUMENT, 
                  respRoot.getNodeName());
            
            PSDatasourceResolver resolver = new PSDatasourceResolver();
            resolver.fromXml(dsEl);
            
            return resolver;
         }
         catch (PSInvalidXmlException e)
         {
            throw new PSServerException(e);
         }
      }
      catch (PSServerException e)
      {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null)
         {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException) throwExc;
         }
         throw e;
      }
   }

   /**
    * Saves the resolver containing the datsource configs to the server. The
    * caller must have server config locked.
    * 
    * @param configs The resolver to save, may not be <code>null</code> or
    * empty.
    * 
    * @throws PSAuthenticationFailedException If the user cannot be
    * authenticated by the server.
    * @throws PSAuthorizationException If the user is not authorized to perform
    * the operation.
    * @throws PSServerException If there are any other errors.
    */
   public void saveDatsourceConfigs(PSDatasourceResolver configs)
      throws PSAuthorizationException, PSAuthenticationFailedException,
      PSServerException
   {
      Document sendDoc = PSXmlDocumentBuilder.createXmlDocument();
      Element root = PSXmlDocumentBuilder.createRoot(sendDoc,
         "PSXSaveDatasourceConfigsRequest");
      
      if (configs == null)
         throw new IllegalArgumentException("configs may not be null");

      root.appendChild(configs.toXml(sendDoc));

      
      /* send the request to the server */
      try
      {
         Document respDoc = makeRequest(
               "design-objectstore-datasourceconfigs-save", sendDoc);

         Element respRoot = respDoc.getDocumentElement();
         if (!respRoot.getNodeName().equals("PSXSaveDatasourceConfigsResults"))
         {
            throw new PSServerException(
               IPSObjectStoreErrors.MALFORMED_RESPONSE_DOCUMENT, 
               respRoot.getNodeName());
         }
      }
      catch (PSServerException e)
      {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null)
         {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException) throwExc;
         }
         throw e;
      }
   }

   /**
    * Gets the Hibernate dialect configuration from the server.
    * 
    * @param lockConfig <code>true</code> to ensure the server config is locked,
    * <code>false</code> to get the config effectively read-only.
    * 
    * @return The config, never <code>null</code>.
    * 
    * @throws PSAuthenticationFailedException If the user cannot be 
    * authenticated by the server.
    * @throws PSAuthorizationException If the user is not authorized to perform
    * the operation. 
    * @throws PSServerException If there are any other errors.
    */
   public PSHibernateDialectConfig getHibernateDialectConfig(boolean lockConfig)
      throws PSAuthorizationException, PSAuthenticationFailedException,
      PSServerException
   {
      Document sendDoc = PSXmlDocumentBuilder.createXmlDocument();
      Element root = PSXmlDocumentBuilder.createRoot(sendDoc,
      "PSXGetHibernateDialectsRequest");
      root.setAttribute("locked", lockConfig ? "yes" : "no");

      /* send the request to the server */
      try
      {
         Document respDoc = makeRequest(
               "design-objectstore-hibernatedialects-load", sendDoc);

         Element respRoot = respDoc.getDocumentElement();
         if (!respRoot.getNodeName().equals("PSXGetHibernateDialectsResults"))
         {
            throw new PSServerException(
               IPSObjectStoreErrors.MALFORMED_RESPONSE_DOCUMENT, 
               respRoot.getNodeName());
         }
         
         PSXmlTreeWalker tree = new PSXmlTreeWalker(respDoc);
   
         try
         {
            Element cfgEl = tree.getNextElement(
               PSDatasourceResolver.BEAN_NODE_NAME, 
               tree.GET_NEXT_ALLOW_CHILDREN);
            
            if (cfgEl == null)
               throw new PSServerException(
                  IPSObjectStoreErrors.MALFORMED_RESPONSE_DOCUMENT, 
                  respRoot.getNodeName());
            
            PSHibernateDialectConfig config = new PSHibernateDialectConfig();
            config.fromXml(cfgEl);
            
            return config;
         }
         catch (PSInvalidXmlException e)
         {
            throw new PSServerException(e);
         }
      }
      catch (PSServerException e)
      {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null)
         {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException) throwExc;
         }
         throw e;
      }   
   }

   /**
    * Saves the Hibernate dialect configuration to the server. The caller must
    * have server config locked.
    * 
    * @param config The config to save, may not be <code>null</code> or
    * empty.
    * 
    * @throws PSAuthenticationFailedException If the user cannot be
    * authenticated by the server.
    * @throws PSAuthorizationException If the user is not authorized to perform
    * the operation.
    * @throws PSServerException If there are any other errors.
    */
   public void saveHibernateDialectConfig(PSHibernateDialectConfig config)
      throws PSAuthorizationException, PSAuthenticationFailedException,
      PSServerException
   {
      Document sendDoc = PSXmlDocumentBuilder.createXmlDocument();
      Element root = PSXmlDocumentBuilder.createRoot(sendDoc,
         "PSXSaveHibernateDialectsRequest");
      
      if (config == null)
         throw new IllegalArgumentException("config may not be null");

      root.appendChild(config.toXml(sendDoc));

      
      /* send the request to the server */
      try
      {
         Document respDoc = makeRequest(
               "design-objectstore-hibernatedialects-save", sendDoc);

         Element respRoot = respDoc.getDocumentElement();
         if (!respRoot.getNodeName().equals("PSXSaveHibernateDialectsResults"))
         {
            throw new PSServerException(
               IPSObjectStoreErrors.MALFORMED_RESPONSE_DOCUMENT, 
               respRoot.getNodeName());
         }
      }
      catch (PSServerException e)
      {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null)
         {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException) throwExc;
         }
         throw e;
      }
   }

   /**
    * Gets the list of cataloger configurations from the server.
    * 
    * @param lockConfig <code>true</code> to ensure the server config is locked,
    * <code>false</code> to get the datasources effectively read-only.
    * 
    * @return The list of configs, never <code>null</code>, may be empty.
    * 
    * @throws PSAuthenticationFailedException If the user cannot be 
    * authenticated by the server.
    * @throws PSAuthorizationException If the user is not authorized to perform
    * the operation. 
    * @throws PSServerException If there are any other errors. 
    */
   public List<PSCatalogerConfig> getCatalogerConfigs(boolean lockConfig)
      throws PSServerException, PSAuthorizationException,
      PSAuthenticationFailedException
   {
      Document sendDoc = PSXmlDocumentBuilder.createXmlDocument();
      Element root = PSXmlDocumentBuilder.createRoot(sendDoc,
         "PSXGetCatalogerConfigsRequest");
      root.setAttribute("locked", lockConfig ? "yes" : "no");

      /* send the request to the server */
      try
      {
         Document respDoc = makeRequest(
               "design-objectstore-catalogerconfigs-load", sendDoc);

         Element respRoot = respDoc.getDocumentElement();
         if (!respRoot.getNodeName().equals("PSXGetCatalogerConfigsResults"))
         {
            throw new PSServerException(
               IPSObjectStoreErrors.MALFORMED_RESPONSE_DOCUMENT, 
               respRoot.getNodeName());
         }
         
         PSXmlTreeWalker tree = new PSXmlTreeWalker(respDoc);

         try
         {
            List<PSCatalogerConfig> configs = 
               new ArrayList<>();
            Element configEl;            
            Element subEl = tree.getNextElement("subjectConfigs", 
               tree.GET_NEXT_ALLOW_CHILDREN);
            if (subEl != null)
            {
               configEl = tree.getNextElement(IPSBeanConfig.BEAN_NODE_NAME,
                  tree.GET_NEXT_ALLOW_CHILDREN);
               while (configEl != null)
               {
                  configs.add(new PSCatalogerConfig(configEl, 
                     PSCatalogerConfig.ConfigTypes.SUBJECT));
                  configEl = tree.getNextElement(IPSBeanConfig.BEAN_NODE_NAME,
                     tree.GET_NEXT_ALLOW_SIBLINGS);
               }
            }
            tree.setCurrent(respRoot);
            Element roleEl = tree.getNextElement("roleConfigs", 
               tree.GET_NEXT_ALLOW_CHILDREN);
            if (roleEl != null)
            {
               configEl = tree.getNextElement(IPSBeanConfig.BEAN_NODE_NAME,
                  tree.GET_NEXT_ALLOW_CHILDREN);
               while (configEl != null)
               {
                  configs.add(new PSCatalogerConfig(configEl, 
                     PSCatalogerConfig.ConfigTypes.ROLE));
                  configEl = tree.getNextElement(IPSBeanConfig.BEAN_NODE_NAME,
                     tree.GET_NEXT_ALLOW_SIBLINGS);
               }
            }
            
            return configs;
         }
         catch (PSInvalidXmlException e)
         {
            throw new PSServerException(e);
         }
      }
      catch (PSServerException e)
      {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null)
         {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException) throwExc;
         }
         throw e;
      }
   }

   /**
    * Saves the cataloger configs to the server. The caller must have server
    * config locked.
    * 
    * @param configs The configs to save, may not be <code>null</code> or
    * empty.
    * 
    * @throws PSAuthenticationFailedException If the user cannot be
    * authenticated by the server.
    * @throws PSAuthorizationException If the user is not authorized to perform
    * the operation.
    * @throws PSServerException If there are any other errors.
    */
   public void saveCatalogerConfigs(List<PSCatalogerConfig> configs)
      throws PSAuthorizationException, PSAuthenticationFailedException,
      PSServerException
   {
      if (configs == null)
         throw new IllegalArgumentException("configs may not be null");
      
      Document sendDoc = PSXmlDocumentBuilder.createXmlDocument();
      Element root = PSXmlDocumentBuilder.createRoot(sendDoc,
         "PSXSaveCatalogerConfigsRequest");
      Element subEl = PSXmlDocumentBuilder.addEmptyElement(sendDoc, root, 
         "subjectConfigs");
      Element roleEl = PSXmlDocumentBuilder.addEmptyElement(sendDoc, root, 
         "roleConfigs");      

      for (PSCatalogerConfig config : configs)
      {
         Element catEl = config.toXml(sendDoc);
         if (config.getConfigType().equals(
            PSCatalogerConfig.ConfigTypes.SUBJECT))
         {
            subEl.appendChild(catEl);
         }
         else
         {
            roleEl.appendChild(catEl);
         }
      }
      
      /* send the request to the server */
      try
      {
         Document respDoc = makeRequest(
               "design-objectstore-catalogerconfigs-save", sendDoc);

         Element respRoot = respDoc.getDocumentElement();
         if (!respRoot.getNodeName().equals("PSXSaveCatalogerConfigsResults"))
         {
            throw new PSServerException(
               IPSObjectStoreErrors.MALFORMED_RESPONSE_DOCUMENT, 
               respRoot.getNodeName());
         }
      }
      catch (PSServerException e)
      {
         PSException throwExc = e.getOriginatingException();
         if (throwExc != null)
         {
            if (throwExc instanceof PSAuthorizationException)
               throw (PSAuthorizationException) throwExc;
         }
         throw e;
      }
   }
   
   /**
    * A unique id set by the client that will be used as an
    * application lock identifier. If set to <code>null</code>, then
    * we default to using the user's session id.
    * @param id the unique id, may be <code>null</code> or empty.
    */
   public void setClientGeneratedSessionId(String id)
   {
      m_uniqueClientId = id;
   }
   
   /**
    * Makes the request via the document connection and will also add the
    * unique client generated id if it exists.
    * 
    * @param requestType the request never <code>null</code> or empty
    * @param reqDoc the request document, assumed not <code>null</code>.
    * @return the resulting document
    * @throws PSAuthorizationException if the user does not have
    * designer or admin access to the server
    * @throws PSAuthenticationFailedException if the user is not
    *  authenticated to perform this
    */
   private Document makeRequest(String requestType, Document reqDoc)
         throws PSServerException, PSAuthenticationFailedException,
         PSAuthorizationException
   {
      if (StringUtils.isBlank(requestType))
         throw new IllegalArgumentException("request may not be null or empty");
      if (reqDoc == null)
         throw new IllegalArgumentException("input document may not be null");

      try
      {
         synchronized (m_conn)
         {
            m_conn.setRequestType(requestType);
            if(m_uniqueClientId != null && m_uniqueClientId.trim().length() > 0)
            {
               // Add the client generated session id to the request doc
               Element root = reqDoc.getDocumentElement();
               root.setAttribute("uniqueId", m_uniqueClientId);
            }
            return m_conn.execute(reqDoc);

         }
      }
      catch (IOException e)
      {
         throw new PSServerException(e);
      }
   }

   private String                  m_uid;
   private PSDesignerConnection   m_conn;
   
   /**
    * This is a unique id set by the client that will be used as an
    * application lock identifier. If set to <code>null</code>, then
    * we default to using the user's session id.
    */
   private String m_uniqueClientId;

   /**
    * The system definition cache, initialized once in the first call to
    * #getContentEditorSystemDef(boolean, boolean), never <code>null</code>
    * after that.
    */
   private volatile static PSContentEditorSystemDef ms_systemDef = null;

   /**
    * The shared definition cache, initialized once in the first call to
    * #getContentEditorSharedDef(boolean, boolean), never <code>null</code>
    * after that.
    */
   private volatile static PSContentEditorSharedDef ms_sharedDef = null;
   
}
