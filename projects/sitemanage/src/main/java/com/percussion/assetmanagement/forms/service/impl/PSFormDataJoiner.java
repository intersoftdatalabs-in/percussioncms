/*
 *     Percussion CMS
 *     Copyright (C) 1999-2020 Percussion Software, Inc.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU Affero General Public License for more details.
 *
 *     Mailing Address:
 *
 *      Percussion Software, Inc.
 *      PO Box 767
 *      Burlington, MA 01803, USA
 *      +01-781-438-9900
 *      support@percussion.com
 *      https://www.percussion.com
 *
 *     You should have received a copy of the GNU Affero General Public License along with this program.  If not, see <https://www.gnu.org/licenses/>
 */

package com.percussion.assetmanagement.forms.service.impl;

import org.apache.commons.lang.StringUtils;
import org.supercsv.io.CsvMapReader;
import org.supercsv.io.CsvMapWriter;
import org.supercsv.io.ICsvMapReader;
import org.supercsv.io.ICsvMapWriter;
import org.supercsv.prefs.CsvPreference;

import java.io.IOException;
import java.io.StringReader;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;

/**
 * Merges the content of 0 or more CSV files, (each with a header and 0 or more rows of data)
 * into a single CSV file, with a single header and a row for every row of data in the source
 * data. Handles the case where different files have different headers by putting empty data
 * for each row's cell if that row did not originally have that field's data. The output
 * rows are in the same order as the input rows.
 * 
 * @author miltonpividori
 *
 */
public class PSFormDataJoiner
{
    
    private static final String FORM_NAME_FIELD = "Form name";
    private static final String CREATE_DATE_FIELD = "Create date";
    
    /**
     * Adds all columns in a form header into a Set of column names.
     * 
     * @param columnNames A Set object where form headers will be added. Assumed
     * not <code>null</code>.
     * @param formHeader Array with form's header (column names). Assumed no
     * <code>null</code>.
     */
    private void addColumnNames(Set<CaselessString> columnNames, String[] formHeader)
    {
        for (String header : formHeader)
        {
            if (!FORM_NAME_FIELD.equals(header) &&
                    !CREATE_DATE_FIELD.equals(header))
                columnNames.add(new CaselessString(header));
        }
    }
    
    /**
     * Prepares the final header to be finally written to a CSV file.
     * 
     * @param columnsHeader The header with all the fields of every form, except
     * the 'form name' and 'create date'. Assumed not <code>null</code>.
     * @return A CaselessString list with all the header columns given in the
     * argument, plus the 'form name' and 'create date' fields. Never
     * <code>null<code>, never empty.
     */
    private List<CaselessString> prepareHeader(SortedSet<CaselessString> columnsHeader)
    {
        List<CaselessString> finalHeader = new ArrayList<>(columnsHeader);
        
        // Add "form name" and "create date" fields at the beginning
        // of the header list
        finalHeader.add(0, new CaselessString(CREATE_DATE_FIELD));
        finalHeader.add(0, new CaselessString(FORM_NAME_FIELD));
        
        return finalHeader;
    }
    
    /**
     * Takes a Map generated by SuperCSV and returns a new one, but with all
     * its keys normalized (using CaselessString class).
     * 
     * @param csvRow a Map generated with SuperCSV. It represents a row, with
     * the header columns as keys. Assumed not <code>null</code>.
     * @return a new Map with the same information, but using a CaselessString
     * object as the key. Never <code>null</code>, never empty.
     */
    private Map<CaselessString,String> processCsvRow(Map<String,String> csvRow)
    {
        Map<CaselessString,String> processedRow = new HashMap<>();
        
        for (String key : csvRow.keySet())
            processedRow.put(new CaselessString(key), csvRow.get(key));
        
        return processedRow;
    }
    
    /**
     * Takes the raw data of the forms and parses it.
     * 
     * @param data Raw data of forms. Assumed not <code>null</code>.
     * @return Parsing result. It has the final header in alpha order
     * and the data as a list of maps. Never <code>null</code>, maybe
     * empty.
     */
    private ParsingResult parseCSVData(String[] data)
    {
        SortedSet<CaselessString> finalHeaderSet = new TreeSet<>();
        
        // Stores current data in the first for-loop
        List<Map<CaselessString,String>> currentDataList = new ArrayList<>();
        Map<String, String> currentCsvData;
        
        ICsvMapReader reader = null;
        String[] formHeader;
        
        
        try
        {
            // First get all columns and store csv data in 'currentDataList'
            for (int i=0; i<data.length; i++)
            {
                if (data[i] == null || data[i].isEmpty())
                    continue;
                
                reader = new CsvMapReader(new StringReader(data[i]), CsvPreference.EXCEL_PREFERENCE);
                    formHeader = reader.getHeader(true);
                addColumnNames(finalHeaderSet, formHeader);
                
                while ((currentCsvData = reader.read(formHeader)) != null)
                {
                    // TODO SuperCSV returns a Map<String,String>. The key has to be
                    // caseless. Right now I am re-creating the Map that SuperCSV
                    // returns. Maybe it has an important impact on performance,
                    // but I need a way to get the value of a row's field ignoring
                    // the case.
                    currentDataList.add(processCsvRow(currentCsvData));
                }
                
                reader.close();
            }
        }
        catch (IOException e)
        {
            //should never happen since using string
            throw new RuntimeException("Unexpected IOException on String");
        }
        
        // check if there is data
        if (currentDataList.isEmpty())
            return new ParsingResult();
        
        // add every row with all columns
        Map<String,String> aFinalCsvRow;
        List<Map<String,String>> finalCsvRowList = new ArrayList<>();
        
        // Final header is based on 'finalHeaderSet'. It has the "form name" and
        // "create date" at the beginning.
        List<CaselessString> finalHeader = this.prepareHeader(finalHeaderSet);
        
        for (Map<CaselessString,String> aCsvRow : currentDataList)
        {
            aFinalCsvRow = new HashMap<>();
            
            for (CaselessString aHeader : finalHeader)
            {
                // if this row has no data for aHeader, add a blank value
                if (aCsvRow.containsKey(aHeader))
                    aFinalCsvRow.put(aHeader.toString(), aCsvRow.get(aHeader));
                else
                    aFinalCsvRow.put(aHeader.toString(), StringUtils.EMPTY);
            }
            
            finalCsvRowList.add(aFinalCsvRow);
        }
        
        return new ParsingResult(finalHeader, finalCsvRowList);
    }

    /**
     * Writes a CSV file with given the header and data.
     * 
     * @param parsingResult Result of parsing raw form data. Assumed
     * not <code>null</code>.
     * @return CSV produced according with the parsing result. It's produced according
     * to Excel rules. Never <code>null</code>, maybe empty.
     */
    private String writeCSV(ParsingResult parsingResult)
    {
        if (parsingResult.isEmpty())
            return StringUtils.EMPTY;
        
        StringWriter finalResult = new StringWriter();
        ICsvMapWriter csvWriter = new CsvMapWriter(finalResult, CsvPreference.EXCEL_PREFERENCE);
        
        try
        {
            // write header
            csvWriter.writeHeader(parsingResult.getHeader());

            // write data
            for (Map<String,String> aRow : parsingResult.getData())
                csvWriter.write(aRow, parsingResult.getHeader());
            
            csvWriter.close();
        }
        catch (IOException e)
        {
            //should never happen since using string
            throw new RuntimeException("Unexpected IOException on String");
        }
                
        return finalResult.toString();
    }
    
    /**
     * Joins an array with forms data in CSV format (each cell escaped according to
     * Excel rules) and returns a merged CSV.
     * 
     * @param data Array with forms data in CSV format. Each element in the array
     * has a header and 0 or more rows of a single form. Assumed not <code>null</code>.
     * @return A CSV with all forms data merged. It has the columns
     * of all forms given in the 'data' argument. The first 2 columns are
     * maintained, all other columns are in ascending alpha order.
     * Never <code>null</code>, may be empty.
     */
    public String joinFormData(String[] data)
    {
        if (data == null || data.length == 0)
            return StringUtils.EMPTY;
        
        // Do nothing if there is only a single file
        if (data.length == 1)
            return data[0];
        
        ParsingResult parsingResult = parseCSVData(data);
        
        return writeCSV(parsingResult);
    }
    
    /**
     * A caseless representation of a String object.
     * 
     * @author miltonpividori
     *
     */
    final class CaselessString implements Comparable<CaselessString>
    {
        /**
         * Original string.
         */
        private final String string;
        
        /**
         * Normalized string used for comparisons.
         */
        private final String normalizedString;
        
        public CaselessString(String string)
        {
            this.string = string;
            normalizedString = string.toUpperCase();
        }

        /* (non-Javadoc)
         * @see java.lang.Object#equals(java.lang.Object)
         */
        @Override
        public boolean equals(Object obj)
        {
            if (!(obj instanceof CaselessString))
                return false;
            
            return ((CaselessString) obj).normalizedString.equals(normalizedString);
        }

        /* (non-Javadoc)
         * @see java.lang.Object#hashCode()
         */
        @Override
        public int hashCode()
        {
            return normalizedString.hashCode();
        }

        /* (non-Javadoc)
         * @see java.lang.String#compareTo()
         */
        @Override
        public int compareTo(CaselessString o)
        {
            return normalizedString.compareTo(o.normalizedString);
        }
        
        /* (non-Javadoc)
         * @see java.lang.Object#toString()
         */
        @Override
        public String toString()
        {
            return string;
        }
    }
    
    /**
     * Represents the parsing result of the forms data. It has the
     * final header and the data.
     * 
     * @author miltonpividori
     *
     */
    class ParsingResult
    {
        private String[] header;
        private List<Map<String,String>> data;
        
        /**
         * Creates an empty ParsingResult.
         */
        public ParsingResult()
        {
            
        }
        
        /**
         * Creates a ParsingResult with the given header and data.
         * 
         * @param header Header of the parsing result.
         * @param data Data list of parsing result. It's a list of Maps. Each key/value pair
         * represents a CSV row, with the field as the key and its value as the Map's value.
         */
        public ParsingResult(List<CaselessString> header, List<Map<String,String>> data)
        {
            this.header = new String[header.size()];
            for (int i=0; i<header.size(); i++)
                this.header[i] = header.get(i).toString();
            
            this.data = data;
        }
        
        /**
         * @return the header
         */
        public String[] getHeader()
        {
            return header;
        }

        /**
         * @return Data list of parsing result. It's a list of Maps. Each key/value pair
         * represents a CSV row, with the field as the key and its value as the Map's value.
         */
        public List<Map<String, String>> getData()
        {
            return data;
        }
        
        /**
         * Checks if the ParsingResult is empty.
         * 
         * @return Returns true if the ParsingResult object has
         * no header and no data. False otherwise.
         */
        public boolean isEmpty()
        {
            return header == null && data == null;
        }
    }
}
