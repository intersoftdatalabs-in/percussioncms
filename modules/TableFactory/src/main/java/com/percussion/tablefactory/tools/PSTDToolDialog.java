/*
 * Copyright 1999-2023 Percussion Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.percussion.tablefactory.tools;

import com.percussion.tablefactory.PSJdbcDataTypeMap;
import com.percussion.tablefactory.PSJdbcDbmsDef;
import com.percussion.tablefactory.PSJdbcTableFactory;
import com.percussion.tablefactory.PSJdbcTableSchema;
import com.percussion.xml.PSXmlDocumentBuilder;
import com.percussion.xml.PSXmlTreeWalker;
import com.percussion.xml.PSXmlUtil;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.filechooser.FileFilter;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.TableColumn;
import javax.swing.table.TableModel;
import javax.xml.XMLConstants;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMResult;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamSource;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.net.URL;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.Properties;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.Vector;

/**
 * This class creates and displays the dialog box for table definition builder.
 * This dialog box has two tabbed panes, one for configuring database parameters
 * and testing database connection based on these parameters and other for
 * obtaining the catalog of tables from the database and creating the table
 * definition xml of the selected tables.
 */

public class PSTDToolDialog extends JPanel
{

   private static final Logger log = LogManager.getLogger(PSTDToolDialog.class);

    /**
    * Generated by Eclipse, used for serialization
    */
   private static final long serialVersionUID = 3762532330161322293L;

   /**
     * Creates and displays the dialog box.
     *
     * @param frame the parent frame object, never <code>null</code>
     *
     * @throws IllegalArgumentException if frame is <code>null</code>
     */
   public PSTDToolDialog(JFrame frame)
   {
      if (frame == null)
         throw new IllegalArgumentException("frame may not be null");

      m_frame = frame;
      loadResourceBundle();
      loadDefaultProperties();
      loadServerProperties(true);
      m_timer = new Timer(ONE_SECOND, new TimerListener());

      //create the components
      JPanel dbmsBuilderPanel = createDBMSBuilderDialogBox();
      if (dbmsBuilderPanel == null)
         System.exit(0);
      JPanel connectionPanel = createConnectionDialogBox();
      //lay them out
      Border padding = BorderFactory.createEmptyBorder(20,20,10,20);
      connectionPanel.setBorder(padding);
      dbmsBuilderPanel.setBorder(padding);

      JTabbedPane tabbedPane = new JTabbedPane();
      tabbedPane.addTab(m_resourceProps.getProperty(KEY_CONN_PANE),
         null, connectionPanel,
         m_resourceProps.getProperty(KEY_CONN_TIP));

      tabbedPane.addTab(m_resourceProps.getProperty(KEY_TABLE_BUILDER_PANE),
         null, dbmsBuilderPanel,
         m_resourceProps.getProperty(KEY_TABLE_BUILDER_TIP));

      setLayout(new BorderLayout());
      add(tabbedPane, BorderLayout.CENTER);
   }

   /**
    * Creates the connection parameters tabbed pane.
    * Tries to establish a connection to the database when "Test"
    * button is clicked.
    *
    * @return the tabbed pane displaying connection parameters,
    * never <code>null</code>
    */
   private JPanel createConnectionDialogBox()
   {
      int index = 0;
      //create the controls
      JLabel dbServerLabel = new JLabel(
         m_resourceProps.getProperty(KEY_DB_SERVER_LBL));
      JLabel dbTypeLabel = new JLabel(
         m_resourceProps.getProperty(KEY_DB_TYPE_LBL));
      JLabel driverLabel = new JLabel(
         m_resourceProps.getProperty(KEY_DRIVER_LBL));
      JLabel driverClassLabel = new JLabel(
         m_resourceProps.getProperty(KEY_DRIVER_CLASS_LBL));
      JLabel dbNameLabel = new JLabel(
         m_resourceProps.getProperty(KEY_DB_NAME_LBL));
      JLabel dbSchemaLabel = new JLabel(
         m_resourceProps.getProperty(KEY_DB_SCHEMA_LBL));
      JLabel userIDLabel = new JLabel(
         m_resourceProps.getProperty(KEY_USER_ID_LBL));
      JLabel pwdLabel = new JLabel(
         m_resourceProps.getProperty(KEY_PWD_LBL));

      m_dbServerField = new JTextField(m_serverProps.getProperty(
         PSJdbcDbmsDef.DB_SERVER_PROPERTY, ""));

      m_dbTypesList = parseString(
         m_resourceProps.getProperty(KEY_DATABASE_LIST));
      String dbType = m_serverProps.getProperty(
         PSJdbcDbmsDef.DB_BACKEND_PROPERTY, "");
      if(dbType != null && !dbType.trim().isEmpty())
      {
         index = m_dbTypesList.indexOf(dbType);
         if (index != -1) m_dbTypesList.removeElementAt(index);
         m_dbTypesList.insertElementAt(dbType, 0);
      }
      m_dbTypeCombo = new JComboBox(m_dbTypesList);
      m_dbTypeCombo.setEditable(true);

      m_driverList = parseString(m_resourceProps.getProperty(KEY_DRIVERS_LIST));
      String driverType = m_serverProps.getProperty(
         PSJdbcDbmsDef.DB_DRIVER_NAME_PROPERTY, "");
      if(!(driverType == null) && (driverType.trim().length() == 0))
      {
         index = m_driverList.indexOf(driverType);
         if (index != -1) m_driverList.removeElementAt(index);
         m_driverList.insertElementAt(driverType, 0);
      }
      m_driverCombo = new JComboBox(m_driverList);
      m_driverCombo.setEditable(true);

      m_driverClassList = parseString(
         m_resourceProps.getProperty(KEY_DRIVER_CLASSES_LIST));
      String driverClass = m_serverProps.getProperty(
         PSJdbcDbmsDef.DB_DRIVER_CLASS_NAME_PROPERTY, "");
      if(!(driverClass == null) && (driverClass.trim().length() == 0))
      {
         index = m_driverClassList.indexOf(driverClass);
         if (index != -1) m_driverClassList.removeElementAt(index);
         m_driverClassList.insertElementAt(driverClass, 0);
      }
      m_driverClassCombo = new JComboBox(m_driverClassList);
      m_driverClassCombo.setEditable(true);

      m_dbNameField = new JTextField(m_serverProps.getProperty(
         PSJdbcDbmsDef.DB_NAME_PROPERTY, ""));
      m_dbSchemaField = new JTextField(m_serverProps.getProperty(
         PSJdbcDbmsDef.DB_SCHEMA_PROPERTY, ""));
      m_userIDField = new JTextField(m_serverProps.getProperty(
         PSJdbcDbmsDef.UID_PROPERTY, ""));
      m_pwdField = new JPasswordField(m_serverProps.getProperty(
         PSJdbcDbmsDef.PWD_PROPERTY, ""));

      JButton testButton = new JButton(
          m_resourceProps.getProperty(KEY_TEST_BUTTON));

      //layout the controls
      JPanel contentPane = new JPanel();
      GridBagLayout gridbag = new GridBagLayout();
      GridBagConstraints c = new GridBagConstraints();
      contentPane.setLayout(gridbag);
      c.fill = GridBagConstraints.HORIZONTAL;
      c.insets = new Insets(5,5,0,0);

      //database server
      c.gridx = 0;
      c.gridy = 0;
      gridbag.setConstraints(dbServerLabel, c);
      contentPane.add(dbServerLabel);

      c.gridx = 1;
      c.gridy = 0;
      gridbag.setConstraints(m_dbServerField, c);
      contentPane.add(m_dbServerField);

      //database type
      c.gridx = 0;
      c.gridy = 1;
      gridbag.setConstraints(dbTypeLabel, c);
      contentPane.add(dbTypeLabel);

      c.gridx = 1;
      c.gridy = 1;
      gridbag.setConstraints(m_dbTypeCombo, c);
      contentPane.add(m_dbTypeCombo);

      //driver
      c.gridx = 0;
      c.gridy = 2;
      gridbag.setConstraints(driverLabel, c);
      contentPane.add(driverLabel);

      c.gridx = 1;
      c.gridy = 2;
      gridbag.setConstraints(m_driverCombo, c);
      contentPane.add(m_driverCombo);

      //driver class
      c.gridx = 0;
      c.gridy = 3;
      gridbag.setConstraints(driverClassLabel, c);
      contentPane.add(driverClassLabel);

      c.gridx = 1;
      c.gridy = 3;
      gridbag.setConstraints(m_driverClassCombo, c);
      contentPane.add(m_driverClassCombo);

      //database name
      c.gridx = 0;
      c.gridy = 4;
      gridbag.setConstraints(dbNameLabel, c);
      contentPane.add(dbNameLabel);

      c.gridx = 1;
      c.gridy = 4;
      gridbag.setConstraints(m_dbNameField, c);
      contentPane.add(m_dbNameField);

      //database schema
      c.gridx = 0;
      c.gridy = 5;
      gridbag.setConstraints(dbSchemaLabel, c);
      contentPane.add(dbSchemaLabel);

      c.gridx = 1;
      c.gridy = 5;
      gridbag.setConstraints(m_dbSchemaField, c);
      contentPane.add(m_dbSchemaField);

      //user ID
      c.gridx = 0;
      c.gridy = 6;
      gridbag.setConstraints(userIDLabel, c);
      contentPane.add(userIDLabel);

      c.gridx = 1;
      c.gridy = 6;
      gridbag.setConstraints(m_userIDField, c);
      contentPane.add(m_userIDField);

      //password
      c.gridx = 0;
      c.gridy = 7;
      gridbag.setConstraints(pwdLabel, c);
      contentPane.add(pwdLabel);

      c.gridx = 1;
      c.gridy = 7;
      gridbag.setConstraints(m_pwdField, c);
      contentPane.add(m_pwdField);

      //test button
      c.anchor = GridBagConstraints.SOUTH;
      c.insets = new Insets(5,15,0,0);
      c.weightx = 1.0;
      c.gridx = 2;
      c.gridy = 7;
      gridbag.setConstraints(testButton, c);
      contentPane.add(testButton);

      /**
       * Add an ActionListener for the "Test" button.
       */
      testButton.addActionListener(new ActionListener()
      {
         /**
          * Tries to obtain a connection to the database based on the
          * parameters specified by the user on the connection tab of
          * the dialog box.
          * @param e the event triggered by clicking the "Test" button.
          */
         public void actionPerformed(@SuppressWarnings("unused") ActionEvent e)
         {
            /**
             * getConnection method displays error message to the user if it
             * fails to obtain the database connection.
             */
            Connection conn = getConnection(true);
            if (conn == null)
               return;
            try
            {
               conn.close();
            }
            catch (SQLException ignore)
            {
               /* no-op */
            }
         }
      });

      return contentPane;
   }

   /**
    * Creates the database table definition tabbed pane.
    * Tries to establish a connection to the database and obtain the
    * list of tables depending upon the connection parameters entered
    * in the other tabbed pane when "Catalog" button is pressed.
    * Creates an XML file containing the table schema definition of the
    * selected tables. This XML file conforms to "sys_Tabledef.dtd" dtd.
    *
    * @return the tabbed pane displaying tables, may return <code>null</code>
    * if invalid number of columns are configured in the resource file
    */
   private JPanel createDBMSBuilderDialogBox()
   {
      //create the controls
      DataTableModel dataModel = new DataTableModel();
      int colCount = dataModel.getColumnCount();
      if (colCount != COLUMN_COUNT)
      {
         String []args = new String[] {String.valueOf(colCount)};
         String err = createMessage(KEY_MSG_INVALID_COL, args);
         showMessage(false, err);
         return null;
      }
      final JTable table = new JTable(dataModel);
      table.setPreferredScrollableViewportSize(new Dimension(300, 100));

      TableColumn column = null;
      column = table.getColumnModel().getColumn(0);
      column.setPreferredWidth(50);
      column = table.getColumnModel().getColumn(1);
      column.setPreferredWidth(250);

      //Create the scroll pane and add the table to it.
      JScrollPane scrollPane = new JScrollPane(table);

      JButton catalogButton = new JButton(
         m_resourceProps.getProperty(KEY_CATALOG_BUTTON));
      JButton noneSelButton = new JButton(
         m_resourceProps.getProperty(KEY_NONE_BUTTON));
      JButton allSelButton = new JButton(
         m_resourceProps.getProperty(KEY_ALL_BUTTON));
      JButton saveButton = new JButton(
         m_resourceProps.getProperty(KEY_SAVE_BUTTON));

      JCheckBox allowSchemaChangesBox = new JCheckBox(
         m_resourceProps.getProperty(KEY_ALLOW_SCHEMA_CHANGES_LBL));
      JPanel bottomPane = new JPanel();
      bottomPane.setLayout(new BorderLayout());
      bottomPane.add(allowSchemaChangesBox, BorderLayout.WEST);

      //layout the controls
      JPanel buttonPane = new JPanel();
      buttonPane.setLayout(new BoxLayout(buttonPane, BoxLayout.Y_AXIS));
      buttonPane.add(Box.createRigidArea(new Dimension(0, 20)));
      buttonPane.add(catalogButton);
      buttonPane.add(Box.createRigidArea(new Dimension(0, 20)));
      buttonPane.add(noneSelButton);
      buttonPane.add(Box.createRigidArea(new Dimension(0, 5)));
      buttonPane.add(allSelButton);
      buttonPane.add(Box.createRigidArea(new Dimension(0, 20)));
      buttonPane.add(saveButton);

      JPanel topPane = new JPanel();
      topPane.setLayout(new BoxLayout(topPane, BoxLayout.X_AXIS));
      topPane.add(scrollPane);
      topPane.add(Box.createRigidArea(new Dimension(20, 0)));
      topPane.add(buttonPane);

      JPanel contentPane = new JPanel();
      contentPane.setLayout(new BoxLayout(contentPane, BoxLayout.Y_AXIS));
      contentPane.add(topPane);
      contentPane.add(bottomPane);

      /**
       * Add an ActionListener for the "Allow Schema Changes" checkbox.
       */
      allowSchemaChangesBox.addItemListener(new ItemListener()
      {
         /**
          * Sets the value of the class variable
          * <code>m_bAllowSchemaChanges</code> depending upon the state
          * of the checkbox.
          */
         public void itemStateChanged(ItemEvent e)
         {
            if (e.getStateChange() == ItemEvent.DESELECTED)
               m_bAllowSchemaChanges = false;
            else
               m_bAllowSchemaChanges = true;
         }
      });

      /**
       * Add an ActionListener for the "Catalog" button.
       */
      catalogButton.addActionListener(new ActionListener()
      {
         /**
          * Tries to obtain a connection to the database based on the
          * parameters specified by the user on the connection tab of
          * the dialog box. Then fetches the catalog of tables from the
          * database and populates the table on the "DBMS Builder" tab
          * with this list of tables.
          *
          * @param e the event triggered by clicking the "Catalog" button.
          */
         public void actionPerformed(@SuppressWarnings("unused") ActionEvent e)
         {
            TableModel model = table.getModel();
            ((DataTableModel)model).deleteAllRows();

            /**
             * getConnection method displays error message to the user if it
             * fails to obtain the database connection.
             */
            Connection conn = getConnection(false);
            if (conn == null)
               return;

            ResultSet rs = null;
            String errMsg = "";
            boolean showErrMsg = false;
            try
            {
               setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
               DatabaseMetaData dbmd = conn.getMetaData();

               String driver = m_serverProps.getProperty(
                  PSJdbcDbmsDef.DB_DRIVER_NAME_PROPERTY);
               if (driver.equalsIgnoreCase("oracle:thin"))
               {
                  // for oracle always pass the schema name, user always has
                  // to enter schema name for Oracle
                  String schema = m_serverProps.getProperty(
                     PSJdbcDbmsDef.DB_SCHEMA_PROPERTY);
                  rs = dbmd.getTables(null, schema, "%", new String[] {"TABLE"});
               }
               else
               {
                  // for sqlserver,db2 don't pass the schema name
                  rs = dbmd.getTables(null, null, "%", new String[] {"TABLE"});
               }

               int i=0;
               while (rs.next())
               {
                  model.setValueAt(false, i, CHECKBOXES_COL);
                  model.setValueAt(rs.getString("TABLE_NAME"), i,
                     TABLENAMES_COL);
                  i++;
               }
            }
            catch (SQLException sqle)
            {
               showErrMsg = true;
               errMsg = sqle.getMessage();
            }
            finally
            {
               setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
               try
               {
                  if (rs != null)
                     rs.close();
                  if (conn != null)
                     conn.close();
               }
               catch (SQLException se)
               {
               }
               if (showErrMsg)
               {
                  showMessage(false, errMsg);
               }
            }
         }
      });

      /**
       * Add an ActionListener for the "None" button. This button deselects
       * all the checkboxes in the table displayed on "DBMS Builder" tab.
       */
      noneSelButton.addActionListener(new ActionListener()
      {
         /**
          * Deselects all the checkboxes in the table displayed on
          * "DBMS Builder" tab.
          *
          * @param e the event triggered by clicking the "None" button.
          */
         public void actionPerformed(@SuppressWarnings("unused") ActionEvent e)
         {
            TableModel model = table.getModel();
            for (int i=0; i < model.getRowCount(); i++)
            {
               model.setValueAt(false, i, CHECKBOXES_COL);
            }
         }
      });

      /**
       * Add an ActionListener for the "All" button. This button selects
       * all the checkboxes in the table displayed on "DBMS Builder" tab.
       */
      allSelButton.addActionListener(new ActionListener()
      {
         /**
          * Selects all the checkboxes in the table displayed on
          * "DBMS Builder" tab.
          *
          * @param e the event triggered by clicking the "All" button.
          */
         public void actionPerformed(@SuppressWarnings("unused") ActionEvent e)
         {
            TableModel model = table.getModel();
            for (int i=0; i < model.getRowCount(); i++)
            {
               model.setValueAt(true, i, CHECKBOXES_COL);
            }
         }
      });

      /**
       * Add an ActionListener for the "Save" button. This button saves
       * the tableschema of the selected tables in an xml file.
       */
      saveButton.addActionListener(new ActionListener()
      {
         /**
          * Shows a "File Save As" dialog box to obtain the xml file in
          * which the user wants to save the table schema definitions.
          * Then generates the table schema xml of the selected tables and
          * writes it to the xml file.
          *
          * @param e the event triggered by clicking the "Save" button.
          */
         public void actionPerformed(@SuppressWarnings("unused") ActionEvent e)
         {
            TableModel model = table.getModel();
            List tables = ((DataTableModel)model).getSelectedTables();
            m_tablesIterator = tables.iterator();
            m_lengthOfTask = tables.size();
            if (m_lengthOfTask == 0)
            {
               String errMsg = createMessage(KEY_MSG_NO_TABLES_SELECTED, null);
               showMessage(false, errMsg);
               return;
            }
            String xmlExt = m_resourceProps.getProperty(KEY_XML_FILE_EXTENSION);
            String xmlFileDesc =
               m_resourceProps.getProperty(KEY_XML_FILE_DESC);
            PSFileFilter filter = new PSFileFilter(xmlExt, xmlFileDesc);

            JFileChooser fc = null;
            String parentDir = m_serverProps.getProperty(SAVE_TO_DIR);
            if ((parentDir == null) || (parentDir.trim().length() == 0))
            {
               fc = new JFileChooser();
            }
            else
            {
               fc = new JFileChooser(parentDir);
            }
            fc.setFileFilter(filter);
            if (fc.showSaveDialog(PSTDToolDialog.this) !=
               JFileChooser.APPROVE_OPTION)
               return;

            File f = fc.getSelectedFile();
            String fileName = f.getName();
            if ((fileName == null) || (fileName.trim().length() == 0))
            {
               String errMsg = createMessage(KEY_MSG_INVALID_FILE_NAME, null);
               showMessage(false, errMsg);
               return;
            }

            String matchExt = "." + xmlExt;
            int len = fileName.length();
            if (len <= 4)
            {
               fileName += matchExt;
            }
            else
            {
               String ext = fileName.substring(len - 4);
               if (!ext.equalsIgnoreCase(matchExt))
               {
                  fileName += matchExt;
               }
            }
            m_serverProps.setProperty(SAVE_TO_DIR, f.getParent());
            saveServerProperties();
            m_xmlFile = f.getParent() + File.separator + fileName;

            m_skipXmlPrint = false;
            m_progressMonitor = new ProgressMonitor(PSTDToolDialog.this,
               m_resourceProps.getProperty(KEY_PROGRESS_BAR_NOTE),
               "", 0, m_lengthOfTask);
            m_progressMonitor.setProgress(0);
            m_progressMonitor.setMillisToDecideToPopup(ONE_SECOND);
            go();
            m_timer.start();
         }
      });

      return contentPane;
   }

    /**
     * The actual long running task.  This runs in a SwingWorker thread.
     */
   protected class ActualTask
   {
      ActualTask ()
      {
         createTableSchemaXml();
      }
   }

   /**
    * A convenience implementation of FileFilter that filters out
    * all files except for those type extensions that it knows about.
    *
    * Extensions are of the type ".foo", which is typically found on
    * Windows and Unix boxes, but not on Macinthosh. Case is ignored.
    *
    * Example - create a new filter that filerts out all files
    * but gif and jpg image files:
    *
    *     JFileChooser chooser = new JFileChooser();
    *     PSFileFilter filter = new PSFileFilter(
    *                   new String{"gif", "jpg"}, "JPEG & GIF Images")
    *     chooser.addChoosableFileFilter(filter);
    *     chooser.showOpenDialog(this);
    *
    */
   protected class PSFileFilter extends FileFilter
   {
      private Map<String, FileFilter> filters;
      private String description;
      private String fullDescription;
      private boolean useExtensionsInDescription = true;

    /**
     * Creates a file filter. If no filters are added, then all
     * files are accepted.
     *
     * @see #addExtension
     */
      public PSFileFilter()
      {
         this.filters = new HashMap<String, FileFilter>();
      }

    /**
     * Creates a file filter that accepts files with the given extension.
     * Example: new ExampleFileFilter("jpg");
     *
     * @see #addExtension
     */
      public PSFileFilter(String extension)
      {
         this(extension, null);
      }

    /**
     * Creates a file filter that accepts the given file type.
     * Example: new ExampleFileFilter("jpg", "JPEG Image Images");
     *
     * Note that the "." before the extension is not needed. If
     * provided, it will be ignored.
     *
     * @see #addExtension
     */
      public PSFileFilter(String extension, String description)
      {
         this();
         if(extension != null) addExtension(extension);
         if(description != null) setDescription(description);
      }

    /**
     * Creates a file filter from the given string array.
     * Example: new ExampleFileFilter(String {"gif", "jpg"});
     *
     * Note that the "." before the extension is not needed adn
     * will be ignored.
     *
     * @see #addExtension
     */
      public PSFileFilter(String[] filters)
      {
         this(filters, null);
      }

    /**
     * Creates a file filter from the given string array and description.
     * Example: new ExampleFileFilter(String {"gif", "jpg"},
     * "Gif and JPG Images");
     * Note that the "." before the extension is not needed and will be ignored.
     *
     * @see #addExtension
     */
      public PSFileFilter(String[] filters, String description)
      {
         this();
         for (int i = 0; i < filters.length; i++)
         {
            // add filters one by one
            addExtension(filters[i]);
         }
         if(description!=null) setDescription(description);
      }

    /**
     * Return true if this file should be shown in the directory pane,
     * false if it shouldn't.
     *
     * Files that begin with "." are ignored.
     *
     * @see #getExtension
     */
      @Override
      public boolean accept(File f)
      {
         if (f != null)
         {
            if(f.isDirectory())
            {
               return true;
            }
            String extension = getExtension(f);
            if(extension != null && filters.get(getExtension(f)) != null)
            {
               return true;
            }
         }
         return false;
      }

    /**
     * Return the extension portion of the file's name .
     *
     * @see #getExtension
     * @see FileFilter#accept
     */
      public String getExtension(File f)
      {
         if (f != null)
         {
            String filename = f.getName();
            int i = filename.lastIndexOf('.');
            if (i>0 && i<filename.length()-1)
            {
               return filename.substring(i+1).toLowerCase();
            }
         }
         return null;
      }

    /**
     * Adds a filetype "dot" extension to filter against.
     *
     * For example: the following code will create a filter that filters
     * out all files except those that end in ".jpg" and ".tif":
     *
     *   ExampleFileFilter filter = new ExampleFileFilter();
     *   filter.addExtension("jpg");
     *   filter.addExtension("tif");
     *
     * Note that the "." before the extension is not needed and will be ignored.
     */
      public void addExtension(String extension)
       {
         if(filters == null)
         {
            filters = new HashMap<String, FileFilter>();
         }
         filters.put(extension.toLowerCase(), this);
         fullDescription = null;
      }


    /**
     * Returns the human readable description of this filter. For
     * example: "JPEG and GIF Image Files (*.jpg, *.gif)"
     *
     * @see #setExtensionListInDescription(boolean)
     * @see #isExtensionListInDescription()
     * @see FileFilter#getDescription
     */
      @Override
      public String getDescription()
      {
         if(fullDescription == null)
         {
            if(description == null || isExtensionListInDescription())
            {
               fullDescription = description==null ? "(" : description + " (";
               // build the description from the extension list
               Enumeration extensions = Collections.enumeration(filters.keySet()); 
               if(extensions != null)
               {
                  fullDescription += "." + (String) extensions.nextElement();
                  while (extensions.hasMoreElements())
                  {
                     fullDescription += ", " +
                     (String) extensions.nextElement();
                  }
               }
               fullDescription += ")";
            }
            else
            {
               fullDescription = description;
            }
         }
         return fullDescription;
      }

    /**
     * Sets the human readable description of this filter. For
     * example: filter.setDescription("Gif and JPG Images");
     *
     * @see #setExtensionListInDescription(boolean)
     * @see #isExtensionListInDescription()
     */
      public void setDescription(String description)
      {
         this.description = description;
         fullDescription = null;
      }

    /**
     * Determines whether the extension list (.jpg, .gif, etc) should
     * show up in the human readable description.
     *
     * Only relevent if a description was provided in the constructor
     * or using setDescription();
     *
     * @see #getDescription()
     * @see #setDescription(String)
     * @see #isExtensionListInDescription()
     */
      public void setExtensionListInDescription(boolean b)
      {
         useExtensionsInDescription = b;
         fullDescription = null;
      }

    /**
     * Returns whether the extension list (.jpg, .gif, etc) should
     * show up in the human readable description.
     *
     * Only relevent if a description was provided in the constructor
     * or using setDescription();
     *
     * @see #getDescription()
     * @see #setDescription(String)
     * @see #setExtensionListInDescription(boolean)
     */
      public boolean isExtensionListInDescription()
      {
         return useExtensionsInDescription;
      }
   }

    /**
     * The actionPerformed method in this class
     * is called each time the Timer "goes off".
     */
   protected class TimerListener implements ActionListener
   {
      public void actionPerformed(@SuppressWarnings("unused") ActionEvent evt)
      {
         if (m_progressMonitor.isCanceled() || done())
         {
            m_progressMonitor.close();
            stop();
            Toolkit.getDefaultToolkit().beep();
            m_timer.stop();
         }
         else
         {
            m_progressMonitor.setNote(getMessage());
            m_progressMonitor.setProgress(getCurrent());
         }
      }
   }

   /**
    * Implements the "TableModel" interface by inheriting from
    * "AbstractTableModel". Implemenets the  methods the JTable
    * will use to interrogate a tabular data model.
    */
   protected class DataTableModel extends AbstractTableModel
   {
      /**
       * 
       */
      private static final long serialVersionUID = 3833747672556517428L;

      /**
       * Returns the number of columns in the model.
       *
       * @return the number of columns in the model
       */
      public int getColumnCount()
      {
         return m_columnNames.size();
      }

      /**
       * Returns the number of rows in the model.
       *
       * @return the number of rows in the model
       */
      public int getRowCount()
      {
         int size = m_checkBoxes.size();
         if (m_tableNames.size() == size)
            return size;
         return 0;
      }

      /**
       * Returns the name of the specified column.
       *
       * @param col the index of the column
       *
       * @return the name of the column, may be <code>null</code> if col
       * is greater than or equal to the number of columns in the table
       */
      @Override
      public String getColumnName(int col)
      {
         if (col >= m_columnNames.size())
            return null;
         return (String)m_columnNames.elementAt(col);
      }

      /**
       * Returns the value for the cell at the specified row and column.
       *
       * @param row the row whose value is to be queried
       * @param col the column whose value is to be queried
       *
       * @return the value Object at the specified cell, may be
       * <code>null</code> if this row and column does not exist in the table
       */
      public Object getValueAt(int row, int col)
      {
         switch(col)
         {
            case CHECKBOXES_COL:
               if (row < m_checkBoxes.size())
                  return m_checkBoxes.get(row);
               else
                  return null;

            case TABLENAMES_COL:
               if (row < m_tableNames.size())
                  return m_tableNames.get(row);
               else
                  return null;
         }
         return null;
      }

      /**
       * Returns the most specific superclass for all the cell values in
       * the column.
       *
       * @param c the index of the column
       *
       * @return the common ancestor class of the object values in the model,
       * returns <code>null</code> if this column does not exist
       */
      @SuppressWarnings("unchecked")
      @Override
      public Class getColumnClass(int c)
      {
         switch(c)
         {
            case CHECKBOXES_COL:
               return Boolean.class;

            case TABLENAMES_COL:
               return String.class;
         }
         return null;
      }

      /**
       * Returns true if the cell at the specified row and column is editable.
       *
       * @param row the row whose value to be queried
       * @param col the column whose value to be queried
       *
       * @return true if the cell is editable
       */
      @Override
      public boolean isCellEditable(@SuppressWarnings("unused") int row, int col)
      {
         switch(col)
         {
            case CHECKBOXES_COL:
               return true;

            case TABLENAMES_COL:
               return false;

            default:
               return false;
         }
      }

      /**
       * Sets the value in the cell at columnIndex and rowIndex to value.
       *
       * @param value the new value, may not be <code>null</code>
       * @param row the row whose value is to be changed
       * @param col the column whose value is to be changed
       *
       * @throws IllegalArgumentException if value is <code>null</code>
       */
      @Override
      public void setValueAt(Object value, int row, int col)
      {
         if (value == null)
            throw new IllegalArgumentException("value may not be null");

         switch(col)
         {
            case CHECKBOXES_COL:
               if (row >= m_checkBoxes.size())
               {
                  m_checkBoxes.add((Boolean) value);
                  fireTableRowsInserted(0,1);
               }
               else
               {
                  m_checkBoxes.set(row, (Boolean) value);
                  fireTableCellUpdated(row, col);
               }
               break;

            case TABLENAMES_COL:
               if (row >= m_tableNames.size())
               {
                  m_tableNames.add((String) value);
                  fireTableRowsInserted(0,1);
               }
               else
               {
                  m_tableNames.set(row, (String) value);
                  fireTableCellUpdated(row, col);
               }
               break;
         }
      }

      /**
       * Deletes all the rows in the table.
       */
      public void deleteAllRows()
      {
         int lastRow = m_tableNames.size();
         if(lastRow > 0)
         {
            m_checkBoxes.clear();
            m_tableNames.clear();
            fireTableRowsDeleted(0, lastRow-1);
         }
      }

      /**
       * Returns the <code>List</code> of tables which has been selected
       * by the user.
       *
       * @return a <code>List</code> of selected tables, never
       * <code>null</code>, may be empty if no table has been selected
       */
      public List<String> getSelectedTables()
      {
         final List<String> tables = new ArrayList<String>();
         int size = getRowCount();
         for (int i = 0; i < size; i++)
         {
            if (m_checkBoxes.get(i))
            {
               tables.add(m_tableNames.get(i));
            }
         }
         return tables;
      }

      /**
       * List of column names, never <code>null</code> or empty.
       */
      Vector m_columnNames = PSTDToolDialog.parseString(
         m_resourceProps.getProperty(KEY_COL_NAME_HDR));

      /**
       * <code>List</code> of <code>boolean</code> values. The value of an
       * element in this <code>List</code> is <code>true</code> if the user
       * has selected the corresponding table. This list is never
       * <code>null</code> but may be empty if the table on the
       * "DBMS Builder" tab is empty.
       */
      final List<Boolean> m_checkBoxes = new ArrayList<Boolean>();

      /**
       * <code>List</code> of tablenames obtained from the database, based on
       * the connection parameters entered by the user on the "connection" tab.
       * This list is never <code>null</code> but may be empty if the table
       * on the "DBMS Builder" tab is empty.
       */
      final List<String> m_tableNames = new ArrayList<String>();

   }

   /**
    * Create a formatted message for messages taking an array of
    * arguments. Be sure to store the arguments in the correct order in
    * the array, where {0} in the string is array element 0, etc.
    *
    * @param key The error string to load, never<code>null</code> or empty
    *
    * @param arrayArgs  The array of arguments to use as the arguments
    *    in the error message, may be <code>null</code> or empty.
    *
    * @return The formatted message, never <code>null</code>. If the appropriate
    *    message cannot be created, a message is constructed from the msgCode
    *    and args and is returned.
    *
    * @throws IllegalArgumentException if key is <code>null</code> or empty
    */
   String createMessage(String key, String[] arrayArgs)
   {
      if ((key == null) || (key.trim().length() == 0))
         throw new IllegalArgumentException("key may not be null or empty");

      if (arrayArgs == null)
         arrayArgs = new String[0];

      String msg = m_resourceProps.getProperty(key);

      if (msg != null)
      {
         try
         {
            msg = MessageFormat.format(msg, (Object[]) arrayArgs);
         }
         catch (IllegalArgumentException e)
         {
            // some problem with formatting
            msg = null;
         }
      }

      if (msg == null)
      {
         String sArgs = "";
         String sep = "";

         for (int i = 0; i < arrayArgs.length; i++) {
            sArgs += sep + arrayArgs[i].toString();
            sep = "; ";
         }

         msg = key + ": " + sArgs;
      }

      return msg;
   }

   /**
    * displays success or error message in a message box
    *
    * @param successMsg if <code>true</code> then a success message is
    * displayed else an error message is displayed
    * @param msg the message to display, never<code>null</code>
    *
    * @throws IllegalArgumentException if errMsg is <code>null</code> or empty
    */

   void showMessage(boolean successMsg, String msg)
   {
      if ((msg == null) || (msg.trim().length() == 0))
         throw new IllegalArgumentException("msg may not be null or empty");

      String msgTitle;
      int msgType = 0;
      if (successMsg)
      {
         msgTitle = m_resourceProps.getProperty(KEY_SUCCESS_MSG_TITLE);
         msgType = JOptionPane.INFORMATION_MESSAGE;
      }
      else
      {
         msgTitle = m_resourceProps.getProperty(KEY_ERR_MSG_TITLE);
         msgType = JOptionPane.ERROR_MESSAGE;
      }
      JOptionPane.showMessageDialog(m_frame, msg, msgTitle, msgType);
   }


   /**
    * Utility method to load the ResourceBundle associated with this class
    */
   private void loadResourceBundle()
   {
      try
      {
         m_resBundle = ResourceBundle.getBundle(
               getResourceName(), Locale.getDefault());
      }
      catch(MissingResourceException mre)
      {
         /* no-op */
      }
   }

   /**
    * Gets resource file name for this class.
    *
    * @return resource file name, never <code>null</code> or empty.
    **/
   private String getResourceName()
   {
      return getClass().getName() + "Resources";
   }

   /**
    * parses the string str into an array of strings separated by comma
    * and inserts them into the vector which is returned. The reason for
    * returning a <code>Vector</code> instead of the <code>List</code>
    * interface is that the <code>JComboBox</code> has a contructor which
    * takes a <code>Vector</code> and populates the ComboBox with the list
    * of <code>String</code> in this <code>Vector</code>
    *
    * @param str string containing list of strings separated by comma, may not
    * be <code>null</code> or empty
    *
    * @return vector in which the array of strings will be inserted, never
    * <code>null</code>, may be empty
    *
    * @throws IllegalArgumentException if str is <code>null</code> or empty
    */
   static Vector<String> parseString(String str)
   {
      if ((str == null) || (str.trim().length() == 0))
         throw new IllegalArgumentException("str may not be null or empty");

      final Vector<String> vec = new Vector<String>();
      StringTokenizer st = new StringTokenizer(str, ",");
      while (st.hasMoreTokens())
      {
         vec.add(st.nextToken());
      }
      return vec;
   }
   /**
    * Writes the connection parameters to the "conn.properties" file.
    */
   void saveServerProperties()
   {
      try
      {
         m_serverProps.store(new FileOutputStream(CONN_PROPERTIES_FILE), null);
      }
      catch(IOException ioe)
      {
         /**
          * If we fail to save the server properties then the user has to
          * type the values for the connection parameteres the next time he
          * runs this dialog box.
          */
      }
   }

   /**
    * Loads the resource properties file "PSTDToolDialogResources.properties"
    * into memory.
    */
   private void loadDefaultProperties()
   {
      // load default property if the value was null or empty in
      // the resource bundle
      loadDefaultProperty(KEY_CONN_PANE, DEF_CONN_PANE);
      loadDefaultProperty(KEY_CONN_TIP, DEF_CONN_TIP);
      loadDefaultProperty(KEY_TABLE_BUILDER_PANE, DEF_TABLE_BUILDER_PANE);
      loadDefaultProperty(KEY_TABLE_BUILDER_TIP, DEF_TABLE_BUILDER_TIP);

      loadDefaultProperty(KEY_TEST_BUTTON, DEF_TEST_BUTTON);
      loadDefaultProperty(KEY_CATALOG_BUTTON, DEF_CATALOG_BUTTON);
      loadDefaultProperty(KEY_NONE_BUTTON, DEF_NONE_BUTTON);
      loadDefaultProperty(KEY_ALL_BUTTON, DEF_ALL_BUTTON);
      loadDefaultProperty(KEY_SAVE_BUTTON, DEF_SAVE_BUTTON);

      loadDefaultProperty(KEY_DB_SERVER_LBL, DEF_DB_SERVER_LBL);
      loadDefaultProperty(KEY_DB_TYPE_LBL, DEF_DB_TYPE_LBL);
      loadDefaultProperty(KEY_DRIVER_LBL, DEF_DRIVER_LBL);
      loadDefaultProperty(KEY_DRIVER_CLASS_LBL, DEF_DRIVER_CLASS_LBL);
      loadDefaultProperty(KEY_DB_NAME_LBL, DEF_DB_NAME_LBL);
      loadDefaultProperty(KEY_DB_SCHEMA_LBL, DEF_DB_SCHEMA_LBL);
      loadDefaultProperty(KEY_USER_ID_LBL, DEF_USER_ID_LBL);
      loadDefaultProperty(KEY_PWD_LBL, DEF_PWD_LBL);
      loadDefaultProperty(KEY_ALLOW_SCHEMA_CHANGES_LBL,
         DEF_ALLOW_SCHEMA_CHANGES_LBL);

      loadDefaultProperty(KEY_COL_NAME_HDR, DEF_COL_NAME_HDR);
      loadDefaultProperty(KEY_PROGRESS_BAR_NOTE, DEF_PROGRESS_BAR_NOTE);
      loadDefaultProperty(KEY_PROGRESS_BAR_MSG, DEF_PROGRESS_BAR_MSG);

      loadDefaultProperty(KEY_DRIVERS_LIST, DEF_DRIVERS_LIST);
      loadDefaultProperty(KEY_DRIVER_CLASSES_LIST, DEF_DRIVER_CLASSES_LIST);
      loadDefaultProperty(KEY_DATABASE_LIST, DEF_DATABASE_LIST);

      loadDefaultProperty(KEY_ERR_MSG_TITLE, DEF_ERR_MSG_TITLE);
      loadDefaultProperty(KEY_SUCCESS_MSG_TITLE, DEF_SUCCESS_MSG_TITLE);
      loadDefaultProperty(KEY_XML_FILE_EXTENSION, DEF_XML_FILE_EXTENSION);
      loadDefaultProperty(KEY_XML_FILE_DESC, DEF_XML_FILE_DESC);
      loadDefaultProperty(KEY_DB_SERVER_ERR_MSG, DEF_DB_SERVER_ERR_MSG);
      loadDefaultProperty(KEY_DRIVER_ERR_MSG, DEF_DRIVER_ERR_MSG);
      loadDefaultProperty(KEY_DRIVER_CLASS_ERR_MSG, DEF_DRIVER_CLASS_ERR_MSG);
      loadDefaultProperty(KEY_XML_SUCCESS_MSG, DEF_XML_SUCCESS_MSG);

      //error or success messages
      loadDefaultProperty(KEY_MSG_CLASS_NOT_FOUND, DEF_MSG_CLASS_NOT_FOUND);
      loadDefaultProperty(KEY_MSG_NO_TABLES_SELECTED,
         DEF_MSG_NO_TABLES_SELECTED);
      loadDefaultProperty(KEY_MSG_XSL_NOT_FOUND, DEF_MSG_XSL_NOT_FOUND);
      loadDefaultProperty(KEY_MSG_INVALID_FILE_NAME, DEF_MSG_INVALID_FILE_NAME);
      loadDefaultProperty(KEY_MSG_CONN_SUCCESS, DEF_MSG_CONN_SUCCESS);
      loadDefaultProperty(KEY_MSG_CONN_FAILED, DEF_MSG_CONN_FAILED);
      loadDefaultProperty(KEY_MSG_INVALID_COL, DEF_MSG_INVALID_COL);
      loadDefaultProperty(KEY_MSG_NO_SCHEMA, DEF_MSG_NO_SCHEMA);
      loadDefaultProperty(KEY_MSG_INVALID_SCHEMA, DEF_MSG_INVALID_SCHEMA);
      loadDefaultProperty(KEY_MSG_EMPTY_SCHEMA, DEF_MSG_EMPTY_SCHEMA);
      loadDefaultProperty(KEY_MSG_FAIL_SCHEMA, DEF_MSG_FAIL_SCHEMA);
   }

   /**
    * Checks to see if the value corresponding to the param key exists
    * in the resource property and is non empty. If not then sets the
    * value of property key equal to defaultValue.
    *
    * @param key the property whose value will be checked to see if it
    * is non-null and non-empty, assumed never <code>null</code> or empty
    * @param defaultValue the value to set for this key if the present value
    * in the resource property is null or empty,
    * assumed never <code>null</code> or empty
    */
   private void loadDefaultProperty(String key, String defaultValue)
   {
      String val = null;
      if (m_resBundle != null)
      {
         try
         {
            val = m_resBundle.getString(key);
         }
         catch (MissingResourceException mre)
         {
            val = null;
         }
      }
      if ((val == null) || (val.trim().length() == 0))
      {
         val = defaultValue;
      }
      m_resourceProps.setProperty(key, val);
   }

   /**
    * Loads the connection properties from the connection parameters
    * tabbed pane or from the "conn.properties" file.
    *
    * @param loadFromFile if true then loads the properties from the
    * "conn.properties" file, else loads from the connection parameters
    * tabbed pane.
    *
    * @return <code>true</code> if the database server, driver and driver
    * class are non empty
    */
   private boolean loadServerProperties(boolean loadFromFile)
   {
      if (!loadFromFile)
      {
         String dbServer = m_dbServerField.getText();
         String driver = (String) m_driverCombo.getSelectedItem();
         String driverClass = (String) m_driverClassCombo.getSelectedItem();
         String dbSchema = m_dbSchemaField.getText();

         if((dbServer == null) || (dbServer.trim().length() == 0))
         {
            showMessage(false,
               m_resourceProps.getProperty(KEY_DB_SERVER_ERR_MSG));
            return false;
         }
         if((driver == null) || (driver.trim().length() == 0))
         {
            showMessage(false,
               m_resourceProps.getProperty(KEY_DRIVER_ERR_MSG));
            return false;
         }
         if((driverClass == null) || (driverClass.trim().length() == 0))
         {
            showMessage(false,
               m_resourceProps.getProperty(KEY_DRIVER_CLASS_ERR_MSG));
            return false;
         }
         if(driver.equalsIgnoreCase("oracle:thin") &&
            ((dbSchema == null) || (dbSchema.trim().length() == 0)))
         {
            showMessage(false,
               m_resourceProps.getProperty(KEY_MSG_NO_SCHEMA));
            return false;
         }

         // For some drivers, make sure the server name is prepended with '//'
         if (ms_driversNeedingSlashes.contains(driverClass)
               && ! dbServer.startsWith("//"))
         {
            dbServer = "//" + dbServer;
         }

         m_serverProps.setProperty(PSJdbcDbmsDef.DB_BACKEND_PROPERTY,
            (String)m_dbTypeCombo.getSelectedItem());
         m_serverProps.setProperty(PSJdbcDbmsDef.DB_DRIVER_NAME_PROPERTY,
            driver);
         m_serverProps.setProperty(PSJdbcDbmsDef.DB_DRIVER_CLASS_NAME_PROPERTY,
            driverClass);
         m_serverProps.setProperty(PSJdbcDbmsDef.DB_SERVER_PROPERTY,
            dbServer);
         m_serverProps.setProperty(PSJdbcDbmsDef.DB_NAME_PROPERTY,
            m_dbNameField.getText());
         m_serverProps.setProperty(PSJdbcDbmsDef.UID_PROPERTY,
            m_userIDField.getText());
         char pw[] = m_pwdField.getPassword();
         m_serverProps.setProperty(PSJdbcDbmsDef.PWD_PROPERTY,
            pw == null ? "" : new String(pw));
         m_serverProps.setProperty(PSJdbcDbmsDef.DB_SCHEMA_PROPERTY,
            m_dbSchemaField.getText());
      }
      else
      {
         try
         {
            m_serverProps.load(new FileInputStream(CONN_PROPERTIES_FILE));
         }
         catch(IOException ioe)
         {
            return false;
         }
      }

      return true;
   }

   /**
    * Tries to obtain a connection from the database depending upon the
    * connection parameters entered in the tabbed pane. Displays messagebox
    * if connection to the database fails.
    *
    * @param bShowSuccessMsg if true, shows connection successful messagebox
    * if a connection to the database is obtained successfully.
    *
    * @return the connection from the database, may be <code>null</code>
    */
   Connection getConnection(boolean bShowSuccessMsg)
   {
      Connection conn = null;
      boolean successMsgIcon = true;

      /**
       * loadServerProperties method displays error message to the user if
       * it any of the three required properties for establishing a
       * database connection - DB Server name, Driver name or Driver Class
       * name are missing or empty and then returns <code>false<code>.
       * Since a message has already been displayed to the user we do not show
       * it again here.
       */
      if (!loadServerProperties(false))
         return null;
      saveServerProperties();
      
      String []args = new String[]{m_serverProps.getProperty(
            PSJdbcDbmsDef.DB_SERVER_PROPERTY)};
      String message = createMessage(KEY_MSG_CONN_SUCCESS, args);
      
      PSJdbcDbmsDef dbmsDef = null;
      String strExMsg = "";
      boolean bConnSuccess = false;
      try
      {
         String driverClass = m_serverProps.getProperty(
               PSJdbcDbmsDef.DB_DRIVER_CLASS_NAME_PROPERTY);
         Class.forName(driverClass);
         dbmsDef = new PSJdbcDbmsDef(m_serverProps);
         setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
         conn = dbmsDef.getConnection();
         if (conn != null)
         {
            bConnSuccess = true;
            String driver = m_serverProps.getProperty(
               PSJdbcDbmsDef.DB_DRIVER_NAME_PROPERTY);

            if (driver.equalsIgnoreCase("oracle:thin"))
            {
               // If backend database is Oracle, verify that the schema
               // entered by the user exists
               String schema = m_serverProps.getProperty(
                  PSJdbcDbmsDef.DB_SCHEMA_PROPERTY);
               boolean schemaExists = false;
               DatabaseMetaData dbmd = conn.getMetaData();
               ResultSet rs = dbmd.getSchemas();
               if (rs != null)
               {
                  while (rs.next())
                  {
                     //schema names are case-sensitive for Oracle
                     if (schema.equals(rs.getString(1)))
                     {
                        schemaExists = true;
                        break;
                     }
                  }
                  try
                  {
                     rs.close();
                     rs = null;
                  }
                  catch (Exception e)
                  {
                  }
               }
               if (!schemaExists)
               {
                  args = new String[] {schema};
                  String invSchemaMsg = createMessage(KEY_MSG_INVALID_SCHEMA, args);
                  message += "\n" + invSchemaMsg;
                  successMsgIcon = false;
                  bShowSuccessMsg = true;
                  try
                  {
                     if (conn != null)
                     {
                        conn.close();
                        conn = null;
                     }
                  }
                  catch (Exception e)
                  {
                  }
               }
               else
               {
                  // schema exists check if it has any tables
                  boolean schemaHasTables = false;
                  rs = dbmd.getTables(null, schema, "%", new String[] {"TABLE"});
                  if (rs != null)
                  {
                     if (rs.next())
                        schemaHasTables = true;

                     try
                     {
                        rs.close();
                        rs = null;
                     }
                     catch (Exception e)
                     {
                     }
                  }
                  if (!schemaHasTables)
                  {
                     args = new String[] {schema};
                     String invSchemaMsg = createMessage(KEY_MSG_EMPTY_SCHEMA, args);
                     message += "\n" + invSchemaMsg;
                     successMsgIcon = false;
                     bShowSuccessMsg = true;
                     try
                     {
                        if (conn != null)
                        {
                           conn.close();
                           conn = null;
                        }
                     }
                     catch (Exception e)
                     {
                     }
                  }
               }
            }
            if (!bShowSuccessMsg)
               return conn;
         }
      }
      catch (ClassNotFoundException cnfe)
      {
         String []errArgs = new String[] {cnfe.getMessage()};
         strExMsg = createMessage(KEY_MSG_CLASS_NOT_FOUND, errArgs);
      }
      catch (Exception ex)
      {
         strExMsg = ex.getMessage();
      }
      setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
      if (bConnSuccess)
      {
         showMessage(successMsgIcon, message);
      }
      else
      {
         args = new String[] {
            m_serverProps.getProperty(PSJdbcDbmsDef.DB_SERVER_PROPERTY),
            strExMsg};
         message = createMessage(KEY_MSG_CONN_FAILED, args);
         showMessage(false, message);
      }
      return conn;
   }

   /**
    * Creates an XML file containing the table schema definitions of the
    * selected tables. This XML file conforms to the "sys_Tabledef.dtd" dtd.
    */
   void createTableSchemaXml()
   {
      String strMsg = "";
      Connection conn = null;

      if (!m_tablesIterator.hasNext())
         return;

      try
      {
         /**
         * <code>getConnection<code> method displays error message to the user
         * if it fails to obtain the database connection.
         */
         conn = getConnection(false);
         if (conn == null)
            return;

         setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));

         String backEndDB = m_serverProps.getProperty(
            PSJdbcDbmsDef.DB_BACKEND_PROPERTY, "");
         PSJdbcDbmsDef dbmsDef = new PSJdbcDbmsDef(m_serverProps);
         PSJdbcDataTypeMap dataTypeMap = new PSJdbcDataTypeMap(
               dbmsDef.getBackEndDB(), dbmsDef.getDriver(), null);

         // reset the backend database
         m_serverProps.setProperty(PSJdbcDbmsDef.DB_BACKEND_PROPERTY, backEndDB);

         Document doc = PSXmlDocumentBuilder.createXmlDocument();

         String []args = new String[2];

         // create all tabledef nodes into a map by table names
         final Map<String, Element> tabledefNodes =
               new HashMap<String, Element>();
         while (m_tablesIterator.hasNext() && (m_current < m_lengthOfTask))
         {
            String tableName = (String)m_tablesIterator.next();
            m_current++;

            args[0] = new String(String.valueOf(m_current));
            args[1] = new String(String.valueOf(m_lengthOfTask));
            m_statMessage = createMessage(KEY_PROGRESS_BAR_MSG, args);

            PSJdbcTableSchema tableSchema = PSJdbcTableFactory.catalogTable(
               conn, dbmsDef, dataTypeMap, tableName, false);

            if (tableSchema == null)
            {
               m_progressMonitor.close();
               stop();
               m_timer.stop();
               String []errArgs = new String[] {tableName};
               String errMsg =  createMessage(KEY_MSG_FAIL_SCHEMA, errArgs);
               throw new Exception(errMsg);
            }

            tableSchema.setAllowSchemaChanges(m_bAllowSchemaChanges);
            Element node = tableSchema.toXml(doc);
            tabledefNodes.put(node.getAttribute("name"), node);
         }
         
         // order the table names, parent tables first, children later
         List<String> orderedTableNames = new ArrayList<String>();
         Iterator<String> tableNames = tabledefNodes.keySet().iterator();
         while (tableNames.hasNext())
         {
            String tableName = tableNames.next();
            orderTableNames(tableName, tabledefNodes, orderedTableNames);
         }

         // produce the output document in the correct order
         Element root = PSXmlDocumentBuilder.createRoot(doc, XML_ROOT_ELEMENT);
         tableNames = orderedTableNames.iterator();
         while (tableNames.hasNext())
         {
            String tableName = tableNames.next();
            
            // the same name may be in the list multiple time, use the first only
            Element node = tabledefNodes.remove(tableName);
            if (node != null)
               root.appendChild(node);
         }

         if (!m_skipXmlPrint)
         {
            //print the file
            PSXmlDocumentBuilder.write(doc, new FileOutputStream(m_xmlFile));
            //now transform the xml file to conform to the "sys_Tabledef.dtd"
            transformDocument(m_xmlFile);
            strMsg = m_resourceProps.getProperty(KEY_XML_SUCCESS_MSG);
            showMessage(true, strMsg);
         }
      }
      catch (NoClassDefFoundError cle)
      {
         String []args = new String[] {cle.getMessage()};
         strMsg = createMessage(KEY_MSG_CLASS_NOT_FOUND, args);
         showMessage(false, strMsg);
      }
      catch (Exception ex)
      {
         strMsg = ex.getMessage();
         System.out.println("Error : " + strMsg);
         log.error(ex.getMessage());
         log.debug(ex.getMessage(), ex);
         showMessage(false, strMsg);
      }
      finally
      {
         setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
         if (conn != null)
         {
            try
            {
               conn.close();
            }
            catch (SQLException sqle)
            {
            }
         }
      }
   }
   
   /**
    * Recursivly process the specified table name for references and insert
    * the parent table names to the top and child table names to the end of 
    * the ordered name table.
    * 
    * @param tableName the name of the table for which to process the 
    *    references, assumed not <code>null</code> or empty.
    * @param tabledefNodes a map with all nodes to process, assumed not 
    *    <code>null</code> or empty.
    * @param orderedTableNames a list with all table names in the order as
    *    they should produce the output document, assumed not <code>null</code>, 
    *    may be empty. The returned list may contain duplicates in which
    *    case the first found must be used for the produced output order.
    */
   private void orderTableNames(String tableName, Map tabledefNodes, 
      List<String> orderedTableNames)
   {
      Element node = (Element) tabledefNodes.get(tableName);
      List references = getReferencedTables(node);
      if (!references.isEmpty())
      {
         for (int i=0; i< references.size(); i++)
         {
            String referencedTableName = (String) references.get(i);
            if (tabledefNodes.get(referencedTableName) != null)
               orderTableNames(referencedTableName, tabledefNodes, 
                  orderedTableNames);
         }
      }
      
      if (references.isEmpty())
      {
         // insert parents to the very top
         orderedTableNames.add(0, tableName);
      }
      else
      {
         // append children to the very end
         orderedTableNames.add(tableName);
      }
   }
   
   /**
    * Get all referenced <code>externalTable</code> names from all 
    * <code>foreignkey</code> nodes found in the supplied node.
    * 
    * @param node the node in which to search for referenced external tables,
    *    assumed not <code>null</code>.
    * @return a list with all external table names referenced in the 
    *    supplied node, never <code>null</code>, may be empty.
    */
   private List getReferencedTables(Element node)
   {
      final List<String> references = new ArrayList<String>();
      
      NodeList foreignKeys = node.getElementsByTagName("foreignkey");
      if (foreignKeys != null)
      {
         for (int i=0; i<foreignKeys.getLength(); i++)
         {
            Element foreignKey = (Element) foreignKeys.item(i);
            
            NodeList externalTables = foreignKey.getElementsByTagName(
               "externalTable");
            if (externalTables != null)
            {
               for (int j=0; j<externalTables.getLength(); j++)
               {
                  String externalTableName = PSXmlTreeWalker.getElementData(
                     externalTables.item(j));
                  references.add(externalTableName);
               }
            }
         }
      }
      
      return references;
   }

   /**
    * Transforms XML file based on the "TableDefBuilder.xsl" XSL file
    * using saxon's TransformerFactory and Transformer classes.
    *
    * @param xmlFile the XML file to be transformed, assumed never
    * <code>null</null> or empty
    */
   private void transformDocument(String xmlFile)
      throws TransformerConfigurationException, TransformerException, 
      FileNotFoundException, SAXException, IOException 
   {
      Document doc = 
         PSXmlDocumentBuilder.createXmlDocument(new FileInputStream(xmlFile),
            false);

      String xslFileName = TABLE_BUILDER_XSL_FILE;

      // locate and load the XSL File
      URL xslUrl = this.getClass().getResource(xslFileName);
      if(xslUrl == null)
      {
         String []args = new String[] {xslFileName};
         String errMsg =  createMessage(KEY_MSG_XSL_NOT_FOUND, args);
         throw new FileNotFoundException(errMsg);
      }

      TransformerFactory tFactory = TransformerFactory.newInstance();
      tFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
      Transformer transformer = null;
      transformer = tFactory.newTransformer(
         new StreamSource(xslUrl.toString()));
      DOMResult domResult = new DOMResult();
      DOMSource domSource = new DOMSource(doc);
      transformer.transform(domSource, domResult);
      PrintXMLDoc(domResult.getNode(), xmlFile);
   }

     /**
     * Prints the XML Node to a file
     * @param node the node to print to file, may be <code>null</code>
     * @xmlFile the file to which the node should be printed, assumed never
     * <code>null</null> or empty
     * @throws IOException
     */
   private void PrintXMLDoc(Node node, String xmlFile)
      throws IOException
   {
      FileWriter writer = null;
      /**
       * use a try-finally block to make sure the writer gets closed.
       * Not using a catch block since we want to propagate the exception
       * all the way up to the <code>createTableSchemaXml<code> method
       * which catches the exception and displays error message to the user.
       */
      try
      {
         writer = new FileWriter(xmlFile);
         String output = PSXmlUtil.toString(node);
         writer.write(output);
         writer.flush();
      }
      finally
      {
         if (writer != null)
         {
            try
            {
               writer.close();
            }
            catch (IOException ioe)
            {
               /* no-op */
            }
         }
      }
   }

   /**
     * Called to start the task.
     */
   void go()
   {
      m_current = 0;
      final SwingWorker worker = new SwingWorker()
      {
         @Override
         public Object construct()
         {
            return new ActualTask();
         }
      };
      worker.start();
   }

    /**
     * Called from timer listener to find out how much task has been done.
     */
   int getCurrent()
   {
      return m_current;
   }

    /**
     * Called from timer listener to stop the processing of task.
     * Called when user presses cancel on the Progress Bar dialog.
     */
   void stop()
   {
      setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
      if (m_current != m_lengthOfTask)
         m_skipXmlPrint = true;
      m_current = m_lengthOfTask;
   }

    /**
     * Called from timer listener to find out if the task has been completed.
     *
     * @return <code>true</code> if the task has been completed which means
     * that either the table schema xml has already been generated for all
     * the selected tables or the user cancelled the operation by pressing
     * the cancel button on the progress monitor.
     */
   boolean done()
   {
      return m_current >= m_lengthOfTask;
   }

    /**
     * Called from timer listener.
     * Returns the note to be displayed in the Progress Bar dialog.
     * @return the note to be displayed in the Progress Bar dialog,
     * never <code>null</code> or empty
     */
   String getMessage()
   {
      return m_statMessage;
   }

    /**
     * The main method of the PSTDToolDialog.
     *
     * @param args the arguments passed while running this tool, may be
     * <code>null</code> or empty. Does not accept any parameters.
     */
   public static void main(String[] args)
   {
      JFrame frame = new JFrame(m_frameTitle);

      Container contentPane = frame.getContentPane();
      contentPane.setLayout(new GridLayout(1, 1));
      contentPane.add(new PSTDToolDialog(frame));

      frame.addWindowListener(new WindowAdapter()
      {
         @Override
         public void windowClosing(@SuppressWarnings("unused") WindowEvent e)
         {
            System.exit(0);
         }
      });

      frame.pack();
      frame.setVisible(true);
   }

   /**
    * progress monitor control for displaying the number of tables whose
    * table schema has been created, initially <code>null</code>, initialized
    * in the <code>actionPerformed</code> method of the "Save" button.
    */
   ProgressMonitor m_progressMonitor;

   /**
    * timer control for updating the message displayed on the progress
    * monitor, initially <code>null</code>, initialized in the constructor
    * of <code>PSTDToolDialog</code>.
    */
   Timer m_timer;

   /**
    * the current table being processed
    */
   private int m_current = 0;

   /**
    * number of tables to be processed
    */
   int m_lengthOfTask = 0;

   /**
    * message displayed on the progress monitor,
    * never <code>null</code> or empty
    */
   private String m_statMessage = "";

   /**
    * iterator over the list of selected tables,
    * initially <code>null</code>, initialized in the
    * <code>actionPerformed</code> method of the "Save" button.
    * May be empty if no table is selected on the "DBMS Builder" tab.
    */
   Iterator m_tablesIterator;

   /**
    * the xml file in which to save the table schema definition,
    * initially <code>null</code>, intialized in the
    * <code>actionPerformed</code> method of the "Save" button.
    */
   String m_xmlFile;

   /**
    * variable to keep track of user cancelling the operation on the
    * progress monitor
    */
   boolean m_skipXmlPrint = false;

   /**
    * The resource bundle containing GUI resources and messages displayed
    * to the user, may be <code>null</code> if resource file is not found,
    * initially <code>null</code>, initialized in the
    * <code>loadResourceBundle</code> method.
    */
   private ResourceBundle m_resBundle;

   /**
    * stores the resource properties, never <code>null</code>
    */
   Properties m_resourceProps = new Properties();

   /**
    * stores the servers connection properties, never <code>null</code>
    */
   Properties m_serverProps = new Properties();

   /**
    * stores the value of the allowSchemaChanges attribute of tableDef element
    */
   boolean m_bAllowSchemaChanges = false;

   /**
    * the frame of this dialog box, initially <code>null</code>,
    * initialized in the constructor of <code>PSTDToolDialog</code>.
    */
   private JFrame m_frame;

   /**
    * Text field for database server, initially <code>null</code>,
    * initialized in the <code>createConnectionDialogBox</code> method.
    */
   private JTextField m_dbServerField;

   /**
    * Combobox for database type, initially <code>null</code>,
    * initialized in the <code>createConnectionDialogBox</code> method.
    */
   private JComboBox m_dbTypeCombo;

   /**
    * Combobox for driver type, initially <code>null</code>,
    * initialized in the <code>createConnectionDialogBox</code> method.
    */
   private JComboBox m_driverCombo;

   /**
    * Combobox for driver class, initially <code>null</code>,
    * initialized in the <code>createConnectionDialogBox</code> method.
    */
   private JComboBox m_driverClassCombo;

   /**
    * Textfield for database name, initially <code>null</code>,
    * initialized in the <code>createConnectionDialogBox</code> method.
    */
   private JTextField m_dbNameField;

   /**
    * Textfield for database schema, initially <code>null</code>,
    * initialized in the <code>createConnectionDialogBox</code> method.
    */
   private JTextField m_dbSchemaField;

   /**
    * Textfield for user id, initially <code>null</code>,
    * initialized in the <code>createConnectionDialogBox</code> method.
    */
   private JTextField m_userIDField;

   /**
    * Textfield for password, initially <code>null</code>,
    * initialized in the <code>createConnectionDialogBox</code> method.
    */
   private JPasswordField m_pwdField;

   /**
    * constant for number of milliseconds in a second
    */
   private static final int ONE_SECOND = 1000;

   /**
    * constant for number of columns
    */
   private static final int COLUMN_COUNT = 2;

   /**
    * constant for checkboxes column
    */
   private static final int CHECKBOXES_COL = 0;

   /**
    * constant for table names column
    */
   private static final int TABLENAMES_COL = 1;

   /**
    * key in the resource properties file for the string containing the
    * column headers
    */
   private static final String KEY_COL_NAME_HDR = "COL_NAME_HDR";

   /**
    * default value for the string containing the column headers
    */
   private static final String DEF_COL_NAME_HDR = "Select,Table Name";

   /**
    * key for saving the directory in which the xml file is saved
    * in the connection properties file
    */
   private static final String SAVE_TO_DIR = "FILE_DIR";

   /**
    * frame title,
    * never <code>null</code> or empty
    */
   private static String m_frameTitle = "Table Definition Builder";

   /**
    * connection properties file
    */
   private static final String CONN_PROPERTIES_FILE = "conn.properties";

   /**
    * stylesheet file
    */
   private static final String TABLE_BUILDER_XSL_FILE = "TableDefBuilder.xsl";

   /**
    * key in the resource properties file for the string displayed
    * on the connection tabbed pane
    */
   private static final String KEY_CONN_PANE = "CONN_PANE";

   /**
    * default value for string displayed on the connection tabbed pane
    */
   private static final String DEF_CONN_PANE = "Connection";

   /**
    * key in the resource properties file for the tool tip for the
    * connection tabbed pane
    */
   private static final String KEY_CONN_TIP = "CONN_TIP";

   /**
    * default tool tip for the connection tabbed pane
    */
   private static final String DEF_CONN_TIP = "Database connection parameters";

   /**
    * key in the resource properties file for the string displayed on the
    * table def builder tabbed pane
    */
   private static final String KEY_TABLE_BUILDER_PANE = "TABLE_BUILDER_PANE";

   /**
    * default value for string displayed on the table def builder tabbed pane
    */
   private static final String DEF_TABLE_BUILDER_PANE = "DBMS Builder";

   /**
    * key in the resource properties file for the tool tip for the table def
    * builder tabbed pane
    */
   private static final String KEY_TABLE_BUILDER_TIP = "TABLE_BUILDER_TIP";

   /**
    * default tool tip for the table def builder tabbed pane
    */
   private static final String DEF_TABLE_BUILDER_TIP =
      "Database definition of tables";

   /**
    * key in the resource properties file for the string displayed
    * on the test button
    */
   private static final String KEY_TEST_BUTTON = "TEST_BUTTON";

   /**
    * default value for the string displayed on the test button
    */
   private static final String DEF_TEST_BUTTON = "Test";

   /**
    * key in the resource properties file for the string displayed
    * on the catalog button
    */
   private static final String KEY_CATALOG_BUTTON = "CATALOG_BUTTON";

   /**
    * default value for the string displayed on the catalog button
    */
   private static final String DEF_CATALOG_BUTTON = "Catalog";

   /**
    * key in the resource properties file for the string displayed
    * on the button for deselecting the tables
    */
   private static final String KEY_NONE_BUTTON = "NONE_BUTTON";

   /**
    * default value for the string displayed on the button
    * for deselecting the tables
    */
   private static final String DEF_NONE_BUTTON = "None";

   /**
    * key in the resource properties file for the string displayed
    * on the button for seleting the tables
    */
   private static final String KEY_ALL_BUTTON = "ALL_BUTTON";

   /**
    * default value for the string displayed on the button
    * for selecting the tables
    */
   private static final String DEF_ALL_BUTTON = "All";

   /**
    * key in the resource properties file for the string displayed
    * on the button for creating and saving the selected table schemas
    */
   private static final String KEY_SAVE_BUTTON = "SAVE_BUTTON";

   /**
    * default value for the string displayed on the save button
    */
   private static final String DEF_SAVE_BUTTON = "Save";

   /**
    * key in the resource properties file for the database server label
    */
   private static final String KEY_DB_SERVER_LBL = "DB_SERVER_LBL";

   /**
    * default value for the database Server label
    */
   private static final String DEF_DB_SERVER_LBL = "Database Server";

   /**
    * key in the resource properties file for the database type label
    */
   private static final String KEY_DB_TYPE_LBL = "DB_TYPE_LBL";

   /**
    * default value for the database type label
    */
   private static final String DEF_DB_TYPE_LBL = "Database Type";

   /**
    * key in the resource properties file for the driver label
    */
   private static final String KEY_DRIVER_LBL = "DRIVER_LBL";

   /**
    * default value for the driver label
    */
   private static final String DEF_DRIVER_LBL = "Driver";

   /**
    * key in the resource properties file for the driver class label
    */
   private static final String KEY_DRIVER_CLASS_LBL = "DRIVER_CLASS_LBL";

   /**
    * default value for the driver class label
    */
   private static final String DEF_DRIVER_CLASS_LBL = "Driver Class";

   /**
    * key in the resource properties file for the database name label
    */
   private static final String KEY_DB_NAME_LBL = "DB_NAME_LBL";

   /**
    * default value for the database name label
    */
   private static final String DEF_DB_NAME_LBL = "Database Name";

   /**
    * key in the resource properties file for the database schema label
    */
   private static final String KEY_DB_SCHEMA_LBL = "DB_SCHEMA_LBL";

   /**
    * default value for the database schema label
    */
   private static final String DEF_DB_SCHEMA_LBL = "Database Schema";

   /**
    * key in the resource properties file for the user ID label
    */
   private static final String KEY_USER_ID_LBL = "USER_ID_LBL";

   /**
    * default value for the user id label
    */
   private static final String DEF_USER_ID_LBL = "User ID";

   /**
    * key in the resource properties file for the password label
    */
   private static final String KEY_PWD_LBL = "PWD_LBL";

   /**
    * default value for the password label
    */
   private static final String DEF_PWD_LBL = "Password";

   /**
    * key in the resource properties file for the Allow Schema Changes label
    */
   private static final String KEY_ALLOW_SCHEMA_CHANGES_LBL =
      "ALLOW_SCHEMA_CHANGES_LBL";

   /**
    * default value for the Allow Schema Changes label
    */
   private static final String DEF_ALLOW_SCHEMA_CHANGES_LBL =
      "Allow Schema Changes";

   /**
    * key in the resource properties file for the string displayed
    * on the progress bar
    */
   private static final String KEY_PROGRESS_BAR_NOTE = "PROGRESS_BAR_NOTE";

   /**
    * default value for the string displayed on the progress bar
    */
   private static final String DEF_PROGRESS_BAR_NOTE = "Creating XML File";

   /**
    * key in the resource properties file for the string displayed
    * on the progress bar informing the user about the progress of the task
    */
   private static final String KEY_PROGRESS_BAR_MSG = "PROGRESS_BAR_MSG";

   /**
    * default value for the for the string displayed on the progress bar
    * informing the user about the progress of the task
    */
   private static final String DEF_PROGRESS_BAR_MSG =
      "Completed {0} out of {1}.";

   /**
    * list of drivers,
    * never <code>null</code> or empty
    */
   private Vector<String> m_driverList;

   /**
    * key in the resource properties file for the string containing the
    * list of drivers
    */
   private static final String KEY_DRIVERS_LIST = "DRIVERS_LIST";

   /**
    * default string from which the list of drivers will be obtained if
    * the list of drivers does not exist in the resource properties file
    */
   private static final String DEF_DRIVERS_LIST =
      "oracle:thin,sqlserver,inetdae7,idb,db2,odbc";

   private static final Set<String> ms_driversNeedingSlashes =
         new HashSet<String>();

   static {
      ms_driversNeedingSlashes.add("net.sourceforge.jtds.jdbc.Driver");
      ms_driversNeedingSlashes.add("com.microsoft.jdbc.sqlserver.SQLServerDriver");
      ms_driversNeedingSlashes.add("com.ibm.db2.jcc.DB2Driver");
   }
   
   /**
    * list of driver classes,
    * never <code>null</code> or empty
    */
   private Vector<String> m_driverClassList;

   /**
    * key in the resource properties file for the string containing the
    * list of driver classes
    */
   private static final String KEY_DRIVER_CLASSES_LIST = "DRIVER_CLASSES_LIST";

   /**
    * default string from which the list of driver classes will be obtained if
    * the list of driver classes does not exist in the resource properties file
    */
   private static final String DEF_DRIVER_CLASSES_LIST =
      "oracle.jdbc.OracleDriver," +
      "com.microsoft.jdbc.sqlserver.SQLServerDriver," +
      "com.inet.tds.TdsDriver" +
      "com.ibm.db2.jcc.DB2Driver";

   /**
    * list of database types,
    * never <code>null</code> or empty
    */
   private Vector<String> m_dbTypesList;

   /**
    * key in the resource properties file for the string containing the
    * list of database types
    */
   private static final String KEY_DATABASE_LIST = "DATABASE_LIST";

   /**
    * default string from which the list of database types will be obtained if
    * the list of database types does not exist in the resource properties file
    */
   private static final String DEF_DATABASE_LIST = "ORACLE,MSSQL,DB2";

   /**
    * key in the resource properties file for the error messagebox's title
    */
   private static final String KEY_ERR_MSG_TITLE = "ERR_MSG_TITLE";

   /**
    * default error messagebox's title
    */
   private static final String DEF_ERR_MSG_TITLE = "Error";

   /**
    * key in the resource properties file for the success messagebox's title
    */
   private static final String KEY_SUCCESS_MSG_TITLE = "SUCCESS_MSG_TITLE";

   /**
    * default success messagebox's title
    */
   private static final String DEF_SUCCESS_MSG_TITLE = "Success";

   /**
    * key in the resource properties file for the file extension filtered
    * by the file filter
    */
   private static final String KEY_XML_FILE_EXTENSION = "XML_FILE_EXTENSION";

   /**
    * default xml file extension
    */
   private static final String DEF_XML_FILE_EXTENSION = "xml";

   /**
    * key in the resource properties file for the description of the file
    * extension filtered by the file filter
    */
   private static final String KEY_XML_FILE_DESC = "XML_FILE_DESC";

   /**
    * default description of the file extension filtered by the file filter
    */
   private static final String DEF_XML_FILE_DESC = "XML Files";

   /**
    * key in the resource properties file for the message for
    * invalid database server entered by the user
    */
   private static final String KEY_DB_SERVER_ERR_MSG = "DB_SERVER_ERR_MSG";

   /**
    * key in the resource properties file for the message for
    * invalid database schema when using oracle entered by the user
    */
   private static final String KEY_MSG_NO_SCHEMA = "MSG_NO_SCHEMA";

   /**
    * key in the resource properties file for the message for
    * invalid database schema when using oracle entered by the user
    * The schema name entered by the user does not exist in the database.
    */
   private static final String KEY_MSG_INVALID_SCHEMA = "MSG_INVALID_SCHEMA";

   /**
    * key in the resource properties file for the message for
    * database schema which does not contain any tables.
    */
   private static final String KEY_MSG_EMPTY_SCHEMA = "MSG_EMPTY_SCHEMA";

   /**
    * default message for invalid database server entered by the user
    */
   private static final String DEF_DB_SERVER_ERR_MSG =
      "Please enter a valid value for database server.";

   /**
    * key in the resource properties file for the message for invalid driver
    * entered by the user
    */
   private static final String KEY_DRIVER_ERR_MSG = "DRIVER_ERR_MSG";

   /**
    * default message for invalid driver entered by the user
    */
   private static final String DEF_DRIVER_ERR_MSG =
      "Please enter a valid value for driver.";

   /**
    * key in the resource properties file for the message for invalid driver
    * class entered by the user
    */
   private static final String KEY_DRIVER_CLASS_ERR_MSG = "DRIVER_CLASS_ERR_MSG";

   /**
    * default message for invalid driver class entered by the user
    */
   private static final String DEF_DRIVER_CLASS_ERR_MSG =
      "Please enter a valid value for driver class.";

   /**
    * key in the resource properties file for the message for
    * successfully creating the table schema definition xml file
    */
   private static final String KEY_XML_SUCCESS_MSG = "XML_SUCCESS_MSG";

   /**
    * default message for successfully creating the table schema definition
    * xml file
    */
   private static final String DEF_XML_SUCCESS_MSG =
      "Successfully created xml file.";

   /**
    * default value for the table data definition xml root element
    */
   private static final String XML_ROOT_ELEMENT = "tabledataset";

   /**
    * key in the resource properties file for error message displayed when
    * a class could not be loaded since it is not in the classpath
    */
   private static final String KEY_MSG_CLASS_NOT_FOUND = "MSG_CLASS_NOT_FOUND";

   /**
    * default value for error message displayed when a class could not be
    * loaded since it is not in the classpath
    */
   private static final String DEF_MSG_CLASS_NOT_FOUND =
      "Class \"{0}\" not found.";

   /**
    * key in the resource properties file for error message displayed when
    * no table is selected and the user presses save button
    */
   private static final String KEY_MSG_NO_TABLES_SELECTED =
      "MSG_NO_TABLES_SELECTED";

   /**
    * default value for error message displayed when no table is selected
    * and the user presses save button
    */
   private static final String DEF_MSG_NO_TABLES_SELECTED =
      "Please select one or more tables.";

   /**
    * key in the resource properties file for error message displayed when
    * the stylesheet "TableDefBuilder.xsl" is not found
    */
   private static final String KEY_MSG_XSL_NOT_FOUND = "MSG_XSL_NOT_FOUND";

   /**
    * default value for error message displayed when the stylesheet
    * "TableDefBuilder.xsl" is not found
    */
   private static final String DEF_MSG_XSL_NOT_FOUND =
      "Could not load stylesheet file: {0}";

   /**
    * key in the resource properties file for error message displayed when
    * user enters invalid file name for the Xml file in which the table
    * schema definition is to be saved
    */
   private static final String KEY_MSG_INVALID_FILE_NAME =
      "MSG_INVALID_FILE_NAME";

   /**
    * default value for error message displayed when user enters invalid
    * file name for the Xml file in which the table schema definition is
    * to be saved
    */
   private static final String DEF_MSG_INVALID_FILE_NAME =
      "Please enter valid file name.";

   /**
    * key in the resource properties file for the message displayed when
    * connection to the database server succeeds
    */
   private static final String KEY_MSG_CONN_SUCCESS = "MSG_CONN_SUCCESS";

   /**
    * default value for error message displayed when the connection to the
    * database server succeeds
    */
   private static final String DEF_MSG_CONN_SUCCESS =
      "Connection to {0} successful.";

   /**
    * default value for error message displayed when no database schema was
    * provided.
    */
   private static final String DEF_MSG_NO_SCHEMA =
      "For Oracle databases you must specify a valid schema.";

   /**
    * default value for error message displayed when invalid database schema was
    * provided. The schema entered by the user does not exist in the database.
    */
   private static final String DEF_MSG_INVALID_SCHEMA =
      "Schema \"{0}\" does not exist.\n(Note : Schema names are case-sensitive for Oracle.)";

   /**
    * default value for error message displayed when the user enters
    * database schema which does not contain any tables.
    */
   private static final String DEF_MSG_EMPTY_SCHEMA =
      "Schema \"{0}\" does not contain any tables.";

   /**
    * key in the resource properties file for the message displayed when
    * connection to the database server fails
    */
   private static final String KEY_MSG_CONN_FAILED = "MSG_CONN_FAILED";

   /**
    * default value for error message displayed when the connection to the
    * database server fails
    */
   private static final String DEF_MSG_CONN_FAILED =
      "Connection to {0} failed.\n{1}.";

   /**
    * key in the resource properties file for the message displayed when
    * invalid number of columns are configured in the resource file
    */
   private static final String KEY_MSG_INVALID_COL = "MSG_INVALID_COL";

   /**
    * default value for error message displayed when invalid number of
    * columns are configured in the resource file
    */
   private static final String DEF_MSG_INVALID_COL =
      "Invalid number of columns \"{0}\" configured in the resource file.";

   /**
    * key in the resource properties file for error message displayed when
    * failure to catalog the table occurs
    */
   private static final String KEY_MSG_FAIL_SCHEMA = "MSG_MSG_FAIL_SCHEMA";

   /**
    * default value for error message displayed when the
    * failure to catalog the table occurs
    */
   private static final String DEF_MSG_FAIL_SCHEMA =
      "Failed to catalog table \"{0}\".";

}


