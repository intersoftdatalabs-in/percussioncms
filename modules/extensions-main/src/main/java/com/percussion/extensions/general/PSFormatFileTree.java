/*
 * Copyright 1999-2023 Percussion Software, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.percussion.extensions.general;

import com.percussion.error.PSExceptionUtils;
import com.percussion.extension.IPSResultDocumentProcessor;
import com.percussion.extension.PSDefaultExtension;
import com.percussion.extension.PSExtensionProcessingException;
import com.percussion.extension.PSParameterMismatchException;
import com.percussion.server.IPSRequestContext;
import com.percussion.xml.PSXmlDocumentBuilder;
import com.percussion.xml.PSXmlTreeWalker;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.Text;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.util.LinkedList;
import java.util.StringTokenizer;

/**
 * This class is a Rhythmyx ResultDocumentProcessor extension. It is used to
 * reformat a list of file path names contained in an XML result tree into a
 * true tree structure. This will be used to display file lists in the Rhythmyx
 * Content Manager User Interface. See details in
 * {@link PSFormatFileTree#processResultDocument processResultDocument}. This
 * extension may have no value outside of the Content Manager UI.
 * 
 * @author David Benua
 *  
 */

public class PSFormatFileTree extends PSDefaultExtension
                implements IPSResultDocumentProcessor
        {

            private static final Logger log = LogManager.getLogger(PSFormatFileTree.class);

   /**
    * This function reformats a file list. The file list has the basic format
    * <code>
    *   <filelist>
    *     <file fullpath="c:\dir1\dir2\file.htm">
    *         <status>published</status>...
    *     </file>
    *   </filelist>
    * </code>
    * <p>
    * This creates a directory tree
    * <code>
    * <filetree>
    *    <path name="dir1" level="1">
    *       <path name="dir2" level="2">
    *         <file fullpath="c:\dir1\dir2\file.htm" filename="file.htm">
    *              <status>....</status>
    *         </file>
    *       </path>
    *    <path>
    * </filetree>
    * </code>
    * </p>
    *
    * @param  params the parameters specified in the calling resource
    * <table border="1">
    *   <tr><th>Param #</th><th>Description</th><th>Required?</th><th>default value</th><tr>
    *   <tr>
    *     <td>1</td>
    *     <td>name of the &lt;filelist&gt;</td>
    *     <td>yes</td>
    *     <td>""</td>
    *   </tr>
    *   <tr>
    *     <td>2</td>
    *     <td>name of the XML element that contains the output file tree</td>
    *     <td>no</td>
    *     <td>&lt;fileTree&gt;</td>
    *   </tr>
    *   <tr>
    *     <td>3</td>
    *     <td>name of the XML element for each file</td>
    *     <td>no</td>
    *     <td>&lt;file&lt</td>
    *   </tr>
    *   <tr>
    *     <td>4</td>
    *     <td>name of the fullpath XML attribute</td>
    *     <td>no</td>
    *     <td>fullpath</td>
    *   </tr>
    * </table>
    *
    *
    * @param request the current request context
    *
    * @param resultDoc  the result document generated by the calling resource
    *
    * @return the modified result document
    *
    * @throws PSParameterMismatchException when the &lt;filelist&gt; is not
    * specified
    **/
  public org.w3c.dom.Document processResultDocument(Object[] params,
         IPSRequestContext request, org.w3c.dom.Document resultDoc)
         throws PSParameterMismatchException, PSExtensionProcessingException
   {

      if (params.length < 1 || null == params[0]
            || params[0].toString().trim().length() == 0)
      {
         throw new PSParameterMismatchException(1, 0);
      }
      ParamTracker pt = new ParamTracker(request, params[0].toString().trim());

      if (params.length >= 2 && null != params[1]
            && params[1].toString().trim().length() > 0)
      {
         pt.setFileTreeName(params[1].toString().trim());
      }

      if (params.length >= 3 && null != params[2]
            && params[2].toString().trim().length() > 0)
      {
         pt.setFileElementName(params[2].toString().trim());
      }

      if (params.length >= 4 && null != params[3]
            && params[3].toString().trim().length() > 0)
      {
         pt.setFilePathName(params[3].toString().trim());
      }

      ProcessResultDoc(resultDoc, pt);
      modifyLinks(resultDoc);
      return resultDoc;
   }

  /**
    * This method modifies all &lt;link&gt; elements in the document in that for
    * each element it concatenates the base Url that is taken as the "baseurl"
    * attribute of the element with the element value and replaces the element
    * value.
    * 
    * @param resultDoc result document to midify the link elements, assumed not
    *           <code>null</code>.
    */
   private void modifyLinks(Document resultDoc)
   {
      NodeList nl = resultDoc.getElementsByTagName("link");
      for (int i = 0; i < nl.getLength(); i++)
      {
         Element linkElem = (Element) nl.item(i);
         Node value = linkElem.getFirstChild();
         if (value != null && value.getNodeType() == Node.TEXT_NODE)
         {
            String baseUrl = linkElem.getAttribute("baseurl");
            if (baseUrl.endsWith("/"))
               baseUrl = baseUrl.substring(0, baseUrl.length() - 1);
            String url = ((Text) value).getData();
            if (url == null)
               url = "";
            if (!url.startsWith("/"))
               url = "/" + url;
            url = baseUrl + url;
            ((Text) value).setData(url);
         }
      }
   }

   /**
    * This function is required by the IPSResultDocumentProcessor interface.
    * PSFormatFileTree will never modify the stylesheet.
    * 
    * @return false
    *  
    */
  public boolean canModifyStyleSheet() {
        return false;
        }



  private static final String PATH_ELEMENT_NAME= "path";
  private static final String STD_DELIMITERS = "\\/";

  /**
   * ProcessResultDoc handles the entire result document
   *
   * @param resultDoc
   *
   * @param pt parameter tracker contains parameters for this request.
   **/
  private void ProcessResultDoc(Document resultDoc, ParamTracker pt)
     {
     LinkedList feList = BuildNodeList(resultDoc, pt);
     Element parentNode = resultDoc.createElement(pt.getFileTreeName());
     resultDoc.getDocumentElement().appendChild(parentNode);

     if(feList.size() > 0) {
        ProcessNodeList(feList,parentNode,0,pt);
        }

     }
  /**
   * BuildNodeList scans the result document looking for filelist nodes
   *
   * @param resultDoc the org.w3c.dom.Document to scan for &lt;filelist&gt;
   * nodes
   *
   * @param pt the parameter tracking block, contains instance parameters
   *
   * @return a java.util.LinkedList of FileElement objects
   **/
  private LinkedList BuildNodeList(Document resultDoc, ParamTracker pt)
    {
    LinkedList nodeList = new LinkedList();
    PSXmlTreeWalker filelistWalker = new PSXmlTreeWalker(resultDoc);
    String inputList = pt.getInputListName();
    if(!filelistWalker.getCurrent().getNodeName().equals(inputList))
       {
       Element filelistElement = filelistWalker.getNextElement(inputList);
       if(null==filelistElement) {
          pt.printTraceMessage("The <" + inputList + "> node was not found");
          return nodeList;
          }
       }
    Element fileElement = filelistWalker.getNextElement(pt.getFileElementName(),
          PSXmlTreeWalker.GET_NEXT_ALLOW_CHILDREN);
    while(null != fileElement)
       {
       FileElement fe = new FileElement(fileElement, pt.getFilePathName());
       nodeList.add(fe);
       fileElement = filelistWalker.getNextElement(pt.getFileElementName(),
          PSXmlTreeWalker.GET_NEXT_ALLOW_SIBLINGS);
       }
    pt.printTraceMessage("BuildNodeList: nodes=" +
                        String.valueOf(nodeList.size()));
    return nodeList;
    }

  /**
    * ProcessNodeList scans the node list looking for common &lt;path&gt;
    * nodes.
    * <p>
    * As each node is scanned, the following possible cases are examined:
    * <ul>
    * <li>A file name is encountered, and a &lt;file&gt; element is written
    * <li>A directory name is encountered that is the first name, or is the
    * same as the previous directory name.  In this case, the element is added
    * to the pending list.
    * <li>A directory name is encountered which is different from the previous one.
    * In this case, the previously pending nodes are processed, and then a new
    * list is started.
    * </ul>
    * <p>
    * After the entire nodes list has processed, any nodes in the pending list
    * handled by calling ProcessNodeList recursively.
    *
    *
    * @param nodeList a List of Nodes to process
    *
    * @param parentNode the org.w3c.dom.Node which is the parent for the
    * &lt;path&gt; nodes.
    *
    * @param level the of the parent.  For the &lt;filetree&gt; this will be 0.
    * For the first &lt;path&gt; node, the level is 1.
    * @param pt paramm tracker object, assumed not <code>null</code>.
    *
    **/
    private void ProcessNodeList(LinkedList nodeList, Element parentNode,
           int level, ParamTracker pt)
       {
       LinkedList childList = new LinkedList();
       Document ownerDoc = parentNode.getOwnerDocument();
       String pathName;
       String prevPathName = null;
       Element currNode = null;

       //check to make sure that the nodelist is not empty.
       if(nodeList.size() == 0) {
          return;
          }
       FileElement fe = (FileElement)nodeList.removeFirst();
       while(fe != null) {
          pathName = fe.getNextPathName();
          if(!fe.hasPathElements()) {
             // then this is a file not a directory
             if(childList.size() > 0) {
                 // then there are pending nodes to process.
                 ProcessNodeList(childList,currNode,level+1,pt);
                 childList.clear();
                 }
             //make a <file> element with added attributes
             Element cn = fe.copyElementTree(parentNode);
             cn.setAttribute("filename",pathName);
             cn.setAttribute("level",String.valueOf(level+1));
             pt.printTraceMessage("new <file> node: Path=" + pathName);
             }
          else { // the FileElement is a directory, not a file
             if(childList.size() == 0) {
                // then this is the first child element
                // start collecting children
                childList.addLast(fe);
                prevPathName = pathName;
                currNode= ownerDoc.createElement(PATH_ELEMENT_NAME);
                parentNode.appendChild(currNode);
                currNode.setAttribute("name",pathName);
                currNode.setAttribute("level",String.valueOf(level+1));
                pt.printTraceMessage("new <path> node: name=" + pathName);
                }
             else {
                // there are already children here
                if(pathName.equals(prevPathName)) {
                   //the name is the same, so add to the list
                   childList.addLast(fe);
                   }
                else {
                   // the name is different
                   ProcessNodeList(childList,currNode,level+1,pt);
                   childList.clear();
                         childList.addLast(fe);
                   prevPathName = pathName;
                   currNode = ownerDoc.createElement(PATH_ELEMENT_NAME);
                   parentNode.appendChild(currNode);
                   currNode.setAttribute("name",pathName);
                   currNode.setAttribute("level",String.valueOf(level+1));
                   pt.printTraceMessage("new <path> node: name=" + pathName);
                   }
                }
             }

        fe = (nodeList.size() > 0)?(FileElement)nodeList.removeFirst():null;
        }
        if(childList.size() > 0) {
           // there are outstanding items to process
           ProcessNodeList(childList,currNode,level+1,pt);
           }
     }
  /**
   * This is a dummy main() for use in debugging only
   * @param args
   **/
  public static void main(String[] args) {
    PSFormatFileTree pSFT = new PSFormatFileTree();

    ParamTracker pt = pSFT.new ParamTracker();

    String XMLFileName = args[0];
    pSFT.invokedStandalone = true;
    try(FileInputStream fs = new FileInputStream(XMLFileName)){
       Document TestDoc = PSXmlDocumentBuilder.createXmlDocument(fs, false);

       pSFT.ProcessResultDoc(TestDoc, pt);
        try(FileOutputStream fo = new FileOutputStream(args[1])) {
            PSXmlDocumentBuilder.write(TestDoc, fo);
        }

       }
    catch (Exception e){
        log.error(PSExceptionUtils.getMessageForLog(e));
        log.debug(PSExceptionUtils.getDebugMessageForLog(e));
    }

  }
  private boolean invokedStandalone = false;


  /**
   * The FileElement inner class represents each &lt;file&gt; element, complete
   * with pathname and XML element. The element will be copied into the
   * &lt;filelist&gt;.  T
   * <br>
   * The pathname uses a StringTokenizer to return each subsequent directory
   * name.
   *
   **/
  private class FileElement {
       private StringTokenizer m_st;
       private Element m_element;

       /**
       * @param el the element to copy
       *
       * @param fp the file pathname (default "fullpath")
       *
       **/
       FileElement(Element el, String fp)
         {
         m_element = el;
         m_st = new StringTokenizer(el.getAttribute(fp),STD_DELIMITERS);
         }

       /**
        * determines if the path name has any more elements
        *
        * @return true if there are more tokens in the pathname
        *
        **/
       boolean hasPathElements()
         {
         return m_st.hasMoreTokens();
         }

       /**
        * gets the next token from the pathname
        *
        * @return the next token
        **/
       String getNextPathName()
         {
         return (m_st.hasMoreTokens())?m_st.nextToken():null;
         }

       /**
        * copy the element into the destination tree
        *
        * @param parent the parent element where the original element will be
        * copied.
        *
        * @return the new element
        **/
       Element copyElementTree(Element parent)
         {
            Element clone = (Element)m_element.cloneNode(true);
            parent.appendChild(clone);
            return clone;
         }

     }

     /**
      * used to hide the IPSRequestContext so that tracing can be done at
      * by internal methods while still allowing a main() method.
      *
      **/
     private class ParamTracker {
        private IPSRequestContext m_req = null;
        private String m_InputListName = "filelist";;
        private String m_fileTreeName = "filetree";
        private String m_fileElementName = "file";
        private String m_filePathName = "fullpath";

        ParamTracker()
           {

           }

        ParamTracker(IPSRequestContext req, String inputList)
           {
           m_req = req;
           m_InputListName = inputList;
           }

        void setInputListName(String inputList)
           {
           m_InputListName = inputList;
           }

        void setFileTreeName(String fileTree)
           {
           m_fileTreeName = fileTree;
           }

        void setFileElementName(String fileElement)
           {
           m_fileElementName = fileElement;
           }

        void setFilePathName(String filePath)
           {
           m_filePathName = filePath;
           }

        String getInputListName()
           {
           return m_InputListName;
           }

        String getFileTreeName()
           {
           return m_fileTreeName;
           }

        String getFileElementName()
           {
           return m_fileElementName;
           }

        String getFilePathName()
           {
           return m_filePathName;
           }
        /**
         * prints a trace message if the underlying request is not null
         *
         * @param msg
         **/
        void printTraceMessage(String msg)
           {
           if(m_req != null)
              {
              m_req.printTraceMessage(msg);
              }
           else
              {
              System.out.println(msg);
              }
           }
     }

}
